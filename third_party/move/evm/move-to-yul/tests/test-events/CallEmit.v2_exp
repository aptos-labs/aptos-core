/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "A2_M" {
    code {
        codecopy(0, dataoffset("A2_M_deployed"), datasize("A2_M_deployed"))
        return(0, datasize("A2_M_deployed"))
    }
    object "A2_M_deployed" {
        code {
            mstore(0, memoryguard(160))
            if iszero(lt(calldatasize(), 4))
            {
                let selector := $Shr(calldataload(0), 224)
                switch selector
                case 0x18e09622
                {
                    // do_event_1(uint8,address,uint256)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1, param_2 := abi_decode_tuple_$uint8_address_uint256$_$u8_address_A2_U256_U256$(4, calldatasize())
                    A2_M_do_event_1(param_0, param_1, param_2)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple__(memPos)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x72ef91b8
                {
                    // ev(uint8,address,uint16,bytes)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1, param_2, param_3 := abi_decode_tuple_$uint8_address_uint16_bytes$_$u8_address_u64_vec$u8$$(4, calldatasize())
                    A2_M_do_event_2(param_0, param_1, param_2, param_3)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple__(memPos)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x9b39a853
                {
                    // do_event_3(uint8,address,uint256)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1, param_2 := abi_decode_tuple_$uint8_address_uint256$_$u8_address_A2_U256_U256$(4, calldatasize())
                    A2_M_do_event_3(param_0, param_1, param_2)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple__(memPos)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x66325f65
                {
                    // ev(bytes1,bytes2,bytes32)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1, param_2 := abi_decode_tuple_$bytes1_bytes2_bytes32$_$vec$u8$_vec$u8$_vec$u8$$(4, calldatasize())
                    A2_M_do_event_4(param_0, param_1, param_2)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple__(memPos)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x2dd328e6
                {
                    // ev(bytes,string)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1 := abi_decode_tuple_$bytes_string$_$vec$u8$_vec$u8$$(4, calldatasize())
                    A2_M_do_event_5(param_0, param_1)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple__(memPos)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x14b66c9c
                {
                    // ev(bytes,string,uint16[3])
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1, param_2 := abi_decode_tuple_$bytes_string_uint16_3_$_$vec$u8$_vec$u8$_vec$u64$$(4, calldatasize())
                    A2_M_do_event_6(param_0, param_1, param_2)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple__(memPos)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x19b52855
                {
                    // ev(bytes[])
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0 := abi_decode_tuple_$bytes__$_$vec$vec$u8$$$(4, calldatasize())
                    A2_M_do_event_7(param_0)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple__(memPos)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x8632c0cf
                {
                    // ev(bytes[],string[3])
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1 := abi_decode_tuple_$bytes___string_3_$_$vec$vec$u8$$_vec$vec$u8$$$(4, calldatasize())
                    A2_M_do_event_8(param_0, param_1)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple__(memPos)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0xb5cfa220
                {
                    // do_transfer(address,address,uint256)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1, param_2 := abi_decode_tuple_$address_address_uint256$_$address_address_A2_U256_U256$(4, calldatasize())
                    A2_M_do_transfer(param_0, param_1, param_2)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple__(memPos)
                    return(memPos, sub(memEnd, memPos))
                }
                default {}
            }
            $Abort(97)
            function A2_M_do_event_1(from, to, amount) {
                let $t3
                // $t3 := pack 0x2::M::Event_1($t0, $t1, $t2)
                {
                    let $mem := $Malloc(65)
                    $MemoryStoreU8(add($mem, 64), from)
                    $MemoryStoreU256(add($mem, 0), to)
                    $MemoryStoreU256(add($mem, 32), amount)
                    $t3 := $mem
                }
                // Evm::emit<0x2::M::Event_1>($t3)
                A2_Evm_emit$A2_M_Event_1$($t3)
                // return ()
            }

            function A2_M_do_event_2(v1, v2, v3, v4) {
                let $t4
                // $t4 := pack 0x2::M::Event_2($t0, $t1, $t2, $t3)
                {
                    let $mem := $Malloc(73)
                    $MemoryStoreU8(add($mem, 72), v1)
                    $MemoryStoreU256(add($mem, 32), v2)
                    $MemoryStoreU64(add($mem, 64), v3)
                    $MemoryStoreU256(add($mem, 0), v4)
                    $t4 := $mem
                }
                // Evm::emit<0x2::M::Event_2>($t4)
                A2_Evm_emit$A2_M_Event_2$($t4)
                // return ()
            }

            function A2_M_do_event_3(from, to, amount) {
                let $t3
                // $t3 := pack 0x2::M::Event_3($t0, $t1, $t2)
                {
                    let $mem := $Malloc(65)
                    $MemoryStoreU8(add($mem, 64), from)
                    $MemoryStoreU256(add($mem, 0), to)
                    $MemoryStoreU256(add($mem, 32), amount)
                    $t3 := $mem
                }
                // Evm::emit<0x2::M::Event_3>($t3)
                A2_Evm_emit$A2_M_Event_3$($t3)
                // return ()
            }

            function A2_M_do_event_4(v1, v2, v3) {
                let $t3
                // $t3 := pack 0x2::M::Event_4($t0, $t1, $t2)
                {
                    let $mem := $Malloc(96)
                    $MemoryStoreU256(add($mem, 0), v1)
                    $MemoryStoreU256(add($mem, 32), v2)
                    $MemoryStoreU256(add($mem, 64), v3)
                    $t3 := $mem
                }
                // Evm::emit<0x2::M::Event_4>($t3)
                A2_Evm_emit$A2_M_Event_4$($t3)
                // return ()
            }

            function A2_M_do_event_5(bys, str) {
                let $t2
                // $t2 := pack 0x2::M::Event_5($t0, $t1)
                {
                    let $mem := $Malloc(64)
                    $MemoryStoreU256(add($mem, 0), bys)
                    $MemoryStoreU256(add($mem, 32), str)
                    $t2 := $mem
                }
                // Evm::emit<0x2::M::Event_5>($t2)
                A2_Evm_emit$A2_M_Event_5$($t2)
                // return ()
            }

            function A2_M_do_event_6(bys, str, uint16_array) {
                let $t3
                // $t3 := pack 0x2::M::Event_6($t0, $t1, $t2)
                {
                    let $mem := $Malloc(96)
                    $MemoryStoreU256(add($mem, 0), bys)
                    $MemoryStoreU256(add($mem, 32), str)
                    $MemoryStoreU256(add($mem, 64), uint16_array)
                    $t3 := $mem
                }
                // Evm::emit<0x2::M::Event_6>($t3)
                A2_Evm_emit$A2_M_Event_6$($t3)
                // return ()
            }

            function A2_M_do_event_7(bys) {
                let $t1
                // $t1 := pack 0x2::M::Event_7($t0)
                {
                    let $mem := $Malloc(32)
                    $MemoryStoreU256(add($mem, 0), bys)
                    $t1 := $mem
                }
                // Evm::emit<0x2::M::Event_7>($t1)
                A2_Evm_emit$A2_M_Event_7$($t1)
                // return ()
            }

            function A2_M_do_event_8(bys, strs) {
                let $t2
                // $t2 := pack 0x2::M::Event_8($t0, $t1)
                {
                    let $mem := $Malloc(64)
                    $MemoryStoreU256(add($mem, 0), bys)
                    $MemoryStoreU256(add($mem, 32), strs)
                    $t2 := $mem
                }
                // Evm::emit<0x2::M::Event_8>($t2)
                A2_Evm_emit$A2_M_Event_8$($t2)
                // return ()
            }

            function A2_M_do_transfer(from, to, amount) {
                let $t3
                // $t3 := pack 0x2::M::Transfer($t0, $t1, $t2)
                {
                    let $mem := $Malloc(96)
                    $MemoryStoreU256(add($mem, 0), from)
                    $MemoryStoreU256(add($mem, 32), to)
                    $MemoryStoreU256(add($mem, 64), amount)
                    $t3 := $mem
                }
                // Evm::emit<0x2::M::Transfer>($t3)
                A2_Evm_emit$A2_M_Transfer$($t3)
                // return ()
            }

            function A2_Evm_emit$A2_M_Transfer$(e) {
                let $t1 := 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
                let $t2 := $MemoryLoadU256(add(e, 0))
                let $t3 := $MemoryLoadU256(add(e, 32))
                let $t4 := $MemoryLoadU256(add(e, 64))
                {
                    let $t5 := mload(0)
                    let $t6 := abi_encode_tuple_$address_address_uint256$_$address_address_A2_U256_U256$($t5, $t2,$t3,$t4)
                    log1($t5, sub($t6, $t5), $t1)
                    mstore(0, $t6)
                }
            }
            function A2_Evm_emit$A2_M_Event_8$(e) {
                let $t1 := 0xc93e9a8cc20289a6f17bb089da7c4f35f1c7bed2d207c99c389aa67a29856919
                let $t2 := $MemoryLoadU256(add(e, 0))
                let $t3 := $MemoryLoadU256(add(e, 32))
                let $t4 := packed_hashed__$string_3_$_$vec$vec$u8$$$($t3)
                {
                    let $t5 := mload(0)
                    let $t6 := abi_encode_tuple_$bytes__$_$vec$vec$u8$$$($t5, $t2)
                    log2($t5, sub($t6, $t5), $t1,$t4)
                    mstore(0, $t6)
                }
            }
            function A2_Evm_emit$A2_M_Event_7$(e) {
                let $t1 := 0xbf5527d30da2fb3f39b16da435128c62ee89ac7b8284997e9e437fa88bab6ad9
                let $t2 := $MemoryLoadU256(add(e, 0))
                let $t3 := packed_hashed__$bytes__$_$vec$vec$u8$$$($t2)
                {
                    let $t4 := mload(0)
                    let $t5 := abi_encode_tuple__($t4)
                    log2($t4, sub($t5, $t4), $t1,$t3)
                    mstore(0, $t5)
                }
            }
            function A2_Evm_emit$A2_M_Event_6$(e) {
                let $t1 := 0x51d171607b25f521bb07d41cd58b450228834cf4490222c5a931dd370818d29a
                let $t2 := $MemoryLoadU256(add(e, 0))
                let $t3 := packed_hashed__$bytes$_$vec$u8$$($t2)
                let $t4 := $MemoryLoadU256(add(e, 32))
                let $t5 := $MemoryLoadU256(add(e, 64))
                let $t6 := packed_hashed__$uint16_3_$_$vec$u64$$($t5)
                {
                    let $t7 := mload(0)
                    let $t8 := abi_encode_tuple_$string$_$vec$u8$$($t7, $t4)
                    log3($t7, sub($t8, $t7), $t1,$t3,$t6)
                    mstore(0, $t8)
                }
            }
            function A2_Evm_emit$A2_M_Event_5$(e) {
                let $t1 := 0x2b464a26b2d3d179ea7c25de12665c6f95f5a635036da98598ae01785f5eca98
                let $t2 := $MemoryLoadU256(add(e, 0))
                let $t3 := packed_hashed__$bytes$_$vec$u8$$($t2)
                let $t4 := $MemoryLoadU256(add(e, 32))
                let $t5 := packed_hashed__$string$_$vec$u8$$($t4)
                {
                    let $t6 := mload(0)
                    let $t7 := abi_encode_tuple__($t6)
                    log3($t6, sub($t7, $t6), $t1,$t3,$t5)
                    mstore(0, $t7)
                }
            }
            function A2_Evm_emit$A2_M_Event_4$(e) {
                let $t1 := 0x4e3a2adb61a9a9a7807dfd78dc9a15809d318764f94b823392c0bc010a29453a
                let $t2 := $MemoryLoadU256(add(e, 0))
                let $t3 := $MemoryLoadU256(add(e, 32))
                let $t4 := $MemoryLoadU256(add(e, 64))
                {
                    let $t5 := mload(0)
                    let $t6 := abi_encode_tuple__($t5)
                    log4($t5, sub($t6, $t5), $t1,$t2,$t3,$t4)
                    mstore(0, $t6)
                }
            }
            function A2_Evm_emit$A2_M_Event_3$(e) {
                let $t1 := 0x46d7aa1d21879f4f2a9e4aaf35176d0ed1665d7aa48ac5221d218547d905f238
                let $t2 := $MemoryLoadU8(add(e, 64))
                let $t3 := $MemoryLoadU256(add(e, 0))
                let $t4 := $MemoryLoadU256(add(e, 32))
                {
                    let $t5 := mload(0)
                    let $t6 := abi_encode_tuple_$address$_$address$($t5, $t3)
                    log3($t5, sub($t6, $t5), $t1,$t2,$t4)
                    mstore(0, $t6)
                }
            }
            function A2_Evm_emit$A2_M_Event_2$(e) {
                let $t1 := 0xdf4ad6039dcb9f423721e54cfde43c41a053fb271f037bdb96aef91dbe2ef532
                let $t2 := $MemoryLoadU8(add(e, 72))
                let $t3 := $MemoryLoadU256(add(e, 32))
                let $t4 := $MemoryLoadU64(add(e, 64))
                let $t5 := $MemoryLoadU256(add(e, 0))
                {
                    let $t6 := mload(0)
                    let $t7 := abi_encode_tuple_$uint8_address_uint16_bytes$_$u8_address_u64_vec$u8$$($t6, $t2,$t3,$t4,$t5)
                    log1($t6, sub($t7, $t6), $t1)
                    mstore(0, $t7)
                }
            }
            function A2_Evm_emit$A2_M_Event_1$(e) {
                let $t1 := 0x46d7aa1d21879f4f2a9e4aaf35176d0ed1665d7aa48ac5221d218547d905f238
                let $t2 := $MemoryLoadU8(add(e, 64))
                let $t3 := $MemoryLoadU256(add(e, 0))
                let $t4 := $MemoryLoadU256(add(e, 32))
                {
                    let $t5 := mload(0)
                    let $t6 := abi_encode_tuple_$uint8_address_uint256$_$u8_address_A2_U256_U256$($t5, $t2,$t3,$t4)
                    log1($t5, sub($t6, $t5), $t1)
                    mstore(0, $t6)
                }
            }
            function abi_encode_tuple_$uint8_address_uint256$_$u8_address_A2_U256_U256$(headStart ,value_0, value_1, value_2) -> tail {
                tail := add(headStart, 96)
                abi_encode_uint8(value_0, add(headStart, 0))
                abi_encode_address(value_1, add(headStart, 32))
                abi_encode_uint256(value_2, add(headStart, 64))
            }
            function abi_encode_uint256(value, pos) {
                mstore(pos, cleanup_uint256(value))
            }
            function cleanup_uint256(value) -> cleaned {
                cleaned := and(value, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
            }
            function abi_encode_address(value, pos) {
                mstore(pos, cleanup_address(value))
            }
            function cleanup_address(value) -> cleaned {
                cleaned := and(value, 0xffffffffffffffffffffffffffffffffffffffff)
            }
            function abi_encode_uint8(value, pos) {
                mstore(pos, cleanup_uint8(value))
            }
            function cleanup_uint8(value) -> cleaned {
                cleaned := and(value, 0xff)
            }
            function abi_encode_tuple_$uint8_address_uint16_bytes$_$u8_address_u64_vec$u8$$(headStart ,value_0, value_1, value_2, value_3) -> tail {
                tail := add(headStart, 128)
                abi_encode_uint8(value_0, add(headStart, 0))
                abi_encode_address(value_1, add(headStart, 32))
                abi_encode_uint16(value_2, add(headStart, 64))
                mstore(add(headStart, 96), sub(tail, headStart))
                tail := abi_encode_bytes(value_3,  tail)
            }
            function abi_encode_bytes(value, pos) -> end{
                let size := $MemoryLoadU64(value)
                mstore(pos, size)
                pos := add(pos, 0x20)
                $CopyMemory(add(value, 0x20), pos, size)
                size := $RoundUp(size)
                end := add(pos, size)
            }
            function abi_encode_uint16(value, pos) {
                mstore(pos, cleanup_uint16(value))
            }
            function cleanup_uint16(value) -> cleaned {
                cleaned := and(value, 0xffff)
            }
            function abi_encode_tuple_$address$_$address$(headStart ,value_0) -> tail {
                tail := add(headStart, 32)
                abi_encode_address(value_0, add(headStart, 0))
            }
            function abi_encode_tuple__(headStart ) -> tail {
                tail := add(headStart, 0)
            }
            function packed_hashed__$string$_$vec$u8$$(value_0) -> hash {
                let pos := mload(0)
                let end := abi_encode_tuple_packed_$string$_$vec$u8$$_not_padded_inplace(pos ,value_0)
                mstore(0, end)
                hash := keccak256(pos, sub(end, pos))
            }
            function abi_encode_tuple_packed_$string$_$vec$u8$$_not_padded_inplace(pos ,value_0) -> end {
                pos := abi_encode_string_not_padded_inplace(value_0,  pos)
                end := pos
            }
            function abi_encode_string_not_padded_inplace(value, pos) -> end{
                let size := $MemoryLoadU64(value)
                $CopyMemory(add(value, 0x20), pos, size)
                end := add(pos, size)
            }
            function packed_hashed__$bytes$_$vec$u8$$(value_0) -> hash {
                let pos := mload(0)
                let end := abi_encode_tuple_packed_$bytes$_$vec$u8$$_not_padded_inplace(pos ,value_0)
                mstore(0, end)
                hash := keccak256(pos, sub(end, pos))
            }
            function abi_encode_tuple_packed_$bytes$_$vec$u8$$_not_padded_inplace(pos ,value_0) -> end {
                pos := abi_encode_bytes_not_padded_inplace(value_0,  pos)
                end := pos
            }
            function abi_encode_bytes_not_padded_inplace(value, pos) -> end{
                let size := $MemoryLoadU64(value)
                $CopyMemory(add(value, 0x20), pos, size)
                end := add(pos, size)
            }
            function abi_encode_tuple_$string$_$vec$u8$$(headStart ,value_0) -> tail {
                tail := add(headStart, 32)
                mstore(add(headStart, 0), sub(tail, headStart))
                tail := abi_encode_string(value_0,  tail)
            }
            function abi_encode_string(value, pos) -> end{
                let size := $MemoryLoadU64(value)
                mstore(pos, size)
                pos := add(pos, 0x20)
                $CopyMemory(add(value, 0x20), pos, size)
                size := $RoundUp(size)
                end := add(pos, size)
            }
            function packed_hashed__$uint16_3_$_$vec$u64$$(value_0) -> hash {
                let pos := mload(0)
                let end := abi_encode_tuple_packed_$uint16_3_$_$vec$u64$$_not_padded_inplace(pos ,value_0)
                mstore(0, end)
                hash := keccak256(pos, sub(end, pos))
            }
            function abi_encode_tuple_packed_$uint16_3_$_$vec$u64$$_not_padded_inplace(pos ,value_0) -> end {
                abi_encode_uint16_3__vec$u64$_not_padded_inplace(value_0,  pos)
                pos := add(pos, 96)
                end := pos
            }
            function abi_encode_uint16_3__vec$u64$_not_padded_inplace(value, pos)  {
                let length := $MemoryLoadU64(value)
                if iszero(eq(length, 3)) { $Abort(92) }
                let start := add(value, 32)
                let srcEnd := add(start, mul(length, 8))
                for { let src := start } lt(src, srcEnd) { src := add(src, 8) }
                {
                    let v := $MemoryLoadU64(src)
                    pos := abi_encode_uint16_with_updated_pos(v, pos)
                }
            }
            function abi_encode_uint16_with_updated_pos(value, pos) -> updated_pos{
                abi_encode_uint16(value, pos)
                updated_pos := add(pos, 32)
            }
            function packed_hashed__$bytes__$_$vec$vec$u8$$$(value_0) -> hash {
                let pos := mload(0)
                let end := abi_encode_tuple_packed_$bytes__$_$vec$vec$u8$$$_not_padded_inplace(pos ,value_0)
                mstore(0, end)
                hash := keccak256(pos, sub(end, pos))
            }
            function abi_encode_tuple_packed_$bytes__$_$vec$vec$u8$$$_not_padded_inplace(pos ,value_0) -> end {
                pos := abi_encode_bytes___vec$vec$u8$$_not_padded_inplace(value_0,  pos)
                end := pos
            }
            function abi_encode_bytes___vec$vec$u8$$_not_padded_inplace(value, pos) -> end {
                let length := $MemoryLoadU64(value)
                let start := add(value, 32)
                let srcEnd := add(start, mul(length, 32))
                for { let src := start } lt(src, srcEnd) { src := add(src, 32) }
                {
                    let v := $MemoryLoadU256(src)
                    pos := abi_encode_bytes_inplace_with_updated_pos(v, pos)
                }
                end := pos
            }
            function abi_encode_bytes_inplace_with_updated_pos(value, pos) -> updated_pos{
                updated_pos := abi_encode_bytes_inplace(value, pos)
            }
            function abi_encode_bytes_inplace(value, pos) -> end{
                let size := $MemoryLoadU64(value)
                $CopyMemory(add(value, 0x20), pos, size)
                size := $RoundUp(size)
                end := add(pos, size)
            }
            function abi_encode_tuple_$bytes__$_$vec$vec$u8$$$(headStart ,value_0) -> tail {
                tail := add(headStart, 32)
                mstore(add(headStart, 0), sub(tail, headStart))
                tail := abi_encode_bytes___vec$vec$u8$$(value_0,  tail)
            }
            function abi_encode_bytes___vec$vec$u8$$(value, pos) -> end {
                let length := $MemoryLoadU64(value)
                mstore(pos, length)
                pos := add(pos, 0x20)
                let headStart := pos
                let tail := add(pos, mul(length, 0x20))
                let start := add(value, 32)
                let srcEnd := add(start, mul(length, 32))
                for { let src := start } lt(src, srcEnd) { src := add(src, 32) }
                {
                    mstore(pos, sub(tail, headStart))
                    let v := $MemoryLoadU256(src)
                    tail := abi_encode_bytes_with_updated_pos(v, tail)
                    pos := add(pos, 0x20)
                }
                pos := tail
                end := pos
            }
            function abi_encode_bytes_with_updated_pos(value, pos) -> updated_pos{
                updated_pos := abi_encode_bytes(value, pos)
            }
            function packed_hashed__$string_3_$_$vec$vec$u8$$$(value_0) -> hash {
                let pos := mload(0)
                let end := abi_encode_tuple_packed_$string_3_$_$vec$vec$u8$$$_not_padded_inplace(pos ,value_0)
                mstore(0, end)
                hash := keccak256(pos, sub(end, pos))
            }
            function abi_encode_tuple_packed_$string_3_$_$vec$vec$u8$$$_not_padded_inplace(pos ,value_0) -> end {
                pos := abi_encode_string_3__vec$vec$u8$$_not_padded_inplace(value_0,  pos)
                end := pos
            }
            function abi_encode_string_3__vec$vec$u8$$_not_padded_inplace(value, pos) -> end {
                let length := $MemoryLoadU64(value)
                if iszero(eq(length, 3)) { $Abort(92) }
                let start := add(value, 32)
                let srcEnd := add(start, mul(length, 32))
                for { let src := start } lt(src, srcEnd) { src := add(src, 32) }
                {
                    let v := $MemoryLoadU256(src)
                    pos := abi_encode_string_inplace_with_updated_pos(v, pos)
                }
                end := pos
            }
            function abi_encode_string_inplace_with_updated_pos(value, pos) -> updated_pos{
                updated_pos := abi_encode_string_inplace(value, pos)
            }
            function abi_encode_string_inplace(value, pos) -> end{
                let size := $MemoryLoadU64(value)
                $CopyMemory(add(value, 0x20), pos, size)
                size := $RoundUp(size)
                end := add(pos, size)
            }
            function abi_encode_tuple_$address_address_uint256$_$address_address_A2_U256_U256$(headStart ,value_0, value_1, value_2) -> tail {
                tail := add(headStart, 96)
                abi_encode_address(value_0, add(headStart, 0))
                abi_encode_address(value_1, add(headStart, 32))
                abi_encode_uint256(value_2, add(headStart, 64))
            }
            function abi_decode_tuple_$address_address_uint256$_$address_address_A2_U256_U256$(headStart, dataEnd) -> value_0, value_1, value_2 {
                if slt(sub(dataEnd, headStart), 96) { $Abort(96) }
                {
                    let offset := 0
                    value_0 := abi_decode_address(add(headStart, offset), dataEnd)
                }
                {
                    let offset := 32
                    value_1 := abi_decode_address(add(headStart, offset), dataEnd)
                }
                {
                    let offset := 64
                    value_2 := abi_decode_uint256(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_uint256(offset, end) -> value {
                value := calldataload(offset)
                validator_uint256(value)
            }
            function validator_uint256(value) {
                if iszero(eq(value, cleanup_uint256(value))) { $Abort(95) }
            }
            function abi_decode_address(offset, end) -> value {
                value := calldataload(offset)
                validator_address(value)
            }
            function validator_address(value) {
                if iszero(eq(value, cleanup_address(value))) { $Abort(95) }
            }
            function abi_decode_tuple_$bytes___string_3_$_$vec$vec$u8$$_vec$vec$u8$$$(headStart, dataEnd) -> value_0, value_1 {
                if slt(sub(dataEnd, headStart), 64) { $Abort(96) }
                {
                    let offset := calldataload(add(headStart, 0))
                    if gt(offset, 0xffffffffffffffff) { $Abort(96) }
                    value_0 := abi_decode_bytes___vec$vec$u8$$(add(headStart, offset), dataEnd)
                }
                {
                    let offset := calldataload(add(headStart, 32))
                    if gt(offset, 0xffffffffffffffff) { $Abort(96) }
                    value_1 := abi_decode_string_3__vec$vec$u8$$(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_string_3__vec$vec$u8$$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := 3
                let size := 128
                array := abi_decode_available_length__string_3__vec$vec$u8$$(offset, length, size, end)
            }
            function abi_decode_available_length__string_3__vec$vec$u8$$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 32))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 32) }
                {
                    let innerOffset := calldataload(src)
                    if gt(innerOffset, 0xffffffffffffffff) { $Abort(94) }
                    let elementPos := add(offset, innerOffset)
                    let value := abi_decode_string_vec$u8$(elementPos, end)
                    $MemoryStoreU256(dst, value)
                    dst := add(dst, 32)
                }
            }
            function abi_decode_string_vec$u8$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := calldataload(offset)
                let size := add(mul(1, length), 32)
                array := abi_decode_available_length__string(add(offset, 0x20), length, size, end)
            }
            function abi_decode_available_length__string(src, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                if gt(add(src, sub(size, 32)), end) { $Abort(93) }
                $CopyFromCallDataToMemory(src, dst, length)
            }
            function abi_decode_bytes___vec$vec$u8$$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := calldataload(offset)
                let size := add(mul(32, length), 32)
                array := abi_decode_available_length__bytes___vec$vec$u8$$(add(offset, 0x20), length, size, end)
            }
            function abi_decode_available_length__bytes___vec$vec$u8$$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 32))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 32) }
                {
                    let innerOffset := calldataload(src)
                    if gt(innerOffset, 0xffffffffffffffff) { $Abort(94) }
                    let elementPos := add(offset, innerOffset)
                    let value := abi_decode_bytes_vec$u8$(elementPos, end)
                    $MemoryStoreU256(dst, value)
                    dst := add(dst, 32)
                }
            }
            function abi_decode_bytes_vec$u8$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := calldataload(offset)
                let size := add(mul(1, length), 32)
                array := abi_decode_available_length__bytes(add(offset, 0x20), length, size, end)
            }
            function abi_decode_available_length__bytes(src, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                if gt(add(src, sub(size, 32)), end) { $Abort(93) }
                $CopyFromCallDataToMemory(src, dst, length)
            }
            function abi_decode_tuple_$bytes__$_$vec$vec$u8$$$(headStart, dataEnd) -> value_0 {
                if slt(sub(dataEnd, headStart), 32) { $Abort(96) }
                {
                    let offset := calldataload(add(headStart, 0))
                    if gt(offset, 0xffffffffffffffff) { $Abort(96) }
                    value_0 := abi_decode_bytes___vec$vec$u8$$(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_tuple_$bytes_string_uint16_3_$_$vec$u8$_vec$u8$_vec$u64$$(headStart, dataEnd) -> value_0, value_1, value_2 {
                if slt(sub(dataEnd, headStart), 160) { $Abort(96) }
                {
                    let offset := calldataload(add(headStart, 0))
                    if gt(offset, 0xffffffffffffffff) { $Abort(96) }
                    value_0 := abi_decode_bytes_vec$u8$(add(headStart, offset), dataEnd)
                }
                {
                    let offset := calldataload(add(headStart, 32))
                    if gt(offset, 0xffffffffffffffff) { $Abort(96) }
                    value_1 := abi_decode_string_vec$u8$(add(headStart, offset), dataEnd)
                }
                {
                    let offset := 64
                    value_2 := abi_decode_uint16_3__vec$u64$(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_uint16_3__vec$u64$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := 3
                let size := 56
                array := abi_decode_available_length__uint16_3__vec$u64$(offset, length, size, end)
            }
            function abi_decode_available_length__uint16_3__vec$u64$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 32))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 32) }
                {
                    let elementPos := src
                    let value := abi_decode_uint16(elementPos, end)
                    $MemoryStoreU64(dst, value)
                    dst := add(dst, 8)
                }
            }
            function abi_decode_uint16(offset, end) -> value {
                value := calldataload(offset)
                validator_uint16(value)
            }
            function validator_uint16(value) {
                if iszero(eq(value, cleanup_uint16(value))) { $Abort(95) }
            }
            function abi_decode_tuple_$bytes_string$_$vec$u8$_vec$u8$$(headStart, dataEnd) -> value_0, value_1 {
                if slt(sub(dataEnd, headStart), 64) { $Abort(96) }
                {
                    let offset := calldataload(add(headStart, 0))
                    if gt(offset, 0xffffffffffffffff) { $Abort(96) }
                    value_0 := abi_decode_bytes_vec$u8$(add(headStart, offset), dataEnd)
                }
                {
                    let offset := calldataload(add(headStart, 32))
                    if gt(offset, 0xffffffffffffffff) { $Abort(96) }
                    value_1 := abi_decode_string_vec$u8$(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_tuple_$bytes1_bytes2_bytes32$_$vec$u8$_vec$u8$_vec$u8$$(headStart, dataEnd) -> value_0, value_1, value_2 {
                if slt(sub(dataEnd, headStart), 96) { $Abort(96) }
                {
                    let offset := 0
                    value_0 := abi_decode_bytes1_vec$u8$(add(headStart, offset), dataEnd)
                }
                {
                    let offset := 32
                    value_1 := abi_decode_bytes2_vec$u8$(add(headStart, offset), dataEnd)
                }
                {
                    let offset := 64
                    value_2 := abi_decode_bytes32_vec$u8$(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_bytes32_vec$u8$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := 32
                let size := 64
                array := abi_decode_available_length__bytes32(offset, length, size, end)
            }
            function abi_decode_available_length__bytes32(src, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                if gt(add(src, sub(size, 32)), end) { $Abort(93) }
                $CopyFromCallDataToMemory(src, dst, length)
            }
            function abi_decode_bytes2_vec$u8$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := 2
                let size := 34
                array := abi_decode_available_length__bytes2(offset, length, size, end)
            }
            function abi_decode_available_length__bytes2(src, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                if gt(add(src, sub(size, 32)), end) { $Abort(93) }
                $CopyFromCallDataToMemory(src, dst, length)
            }
            function abi_decode_bytes1_vec$u8$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := 1
                let size := 33
                array := abi_decode_available_length__bytes1(offset, length, size, end)
            }
            function abi_decode_available_length__bytes1(src, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                if gt(add(src, sub(size, 32)), end) { $Abort(93) }
                $CopyFromCallDataToMemory(src, dst, length)
            }
            function abi_decode_tuple_$uint8_address_uint256$_$u8_address_A2_U256_U256$(headStart, dataEnd) -> value_0, value_1, value_2 {
                if slt(sub(dataEnd, headStart), 96) { $Abort(96) }
                {
                    let offset := 0
                    value_0 := abi_decode_uint8(add(headStart, offset), dataEnd)
                }
                {
                    let offset := 32
                    value_1 := abi_decode_address(add(headStart, offset), dataEnd)
                }
                {
                    let offset := 64
                    value_2 := abi_decode_uint256(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_uint8(offset, end) -> value {
                value := calldataload(offset)
                validator_uint8(value)
            }
            function validator_uint8(value) {
                if iszero(eq(value, cleanup_uint8(value))) { $Abort(95) }
            }
            function abi_decode_tuple_$uint8_address_uint16_bytes$_$u8_address_u64_vec$u8$$(headStart, dataEnd) -> value_0, value_1, value_2, value_3 {
                if slt(sub(dataEnd, headStart), 128) { $Abort(96) }
                {
                    let offset := 0
                    value_0 := abi_decode_uint8(add(headStart, offset), dataEnd)
                }
                {
                    let offset := 32
                    value_1 := abi_decode_address(add(headStart, offset), dataEnd)
                }
                {
                    let offset := 64
                    value_2 := abi_decode_uint16(add(headStart, offset), dataEnd)
                }
                {
                    let offset := calldataload(add(headStart, 96))
                    if gt(offset, 0xffffffffffffffff) { $Abort(96) }
                    value_3 := abi_decode_bytes_vec$u8$(add(headStart, offset), dataEnd)
                }
            }
            function $Abort(code) {
                mstore(0, code)
                revert(24, 8) // TODO: store code as a string?
            }
            function $AbortBuiltin() {
                $Abort(sub(0, 1))
            }
            function $Malloc(size) -> offs {
                offs := mload(0)
                // pad to word size
                mstore(0, add(offs, shl(5, shr(5, add(size, 31)))))
            }
            function $MaskForSize(size) -> mask {
              mask := sub(shl(shl(3, size), 1), 1)
            }
            function $ToWordOffs(offs) -> word_offs, byte_offset {
              word_offs := shr(5, offs)
              byte_offset := and(offs, 0x1F)
            }
            function $MemoryLoadBytes(offs, size) -> val {
              // Lower bit where the value in the higher bytes ends
              let bit_end := shl(3, sub(32, size))
              val := shr(bit_end, mload(offs))
            }
            function $MemoryStoreBytes(offs, size, val) {
              let bit_end := shl(3, sub(32, size))
              let mask := shl(bit_end, $MaskForSize(size))
              mstore(offs, or(and(mload(offs), not(mask)), shl(bit_end, val)))
            }
            function $MemoryLoadU8(offs) -> val {
              val := $MemoryLoadBytes(offs, 1)
            }
            function $MemoryStoreU8(offs, val) {
              // Shortcut via special instruction
              mstore8(offs, val)
            }
            function $MemoryLoadU64(offs) -> val {
              val := $MemoryLoadBytes(offs, 8)
            }
            function $MemoryStoreU64(offs, val) {
              $MemoryStoreBytes(offs, 8, val)
            }
            function $MemoryLoadU256(offs) -> val {
              val := $MemoryLoadBytes(offs, 32)
            }
            function $MemoryStoreU256(offs, val) {
              $MemoryStoreBytes(offs, 32, val)
            }
            function $CopyMemory(src, dst, size) {
              let num_words, overflow_bytes := $ToWordOffs(size)
              let i := 0
              for { } lt(i, mul(num_words, 32)) { i := add(i, 32) } {
                mstore(add(dst, i), mload(add(src, i)))
              }
              if overflow_bytes {
                let mask := $MaskForSize(sub(32, overflow_bytes))
                let overflow_offs := mul(num_words, 32)
                let dst_word := and(mload(add(dst, overflow_offs)), mask)
                let src_word := and(mload(add(src, overflow_offs)), not(mask))
                mstore(add(dst, overflow_offs), or(dst_word, src_word))
              }
            }
            function $CheckMemorySize(len) -> checked_len {
                if gt(len, 0xffffffffffffffff) { $AbortBuiltin() }
                checked_len := len
            }
            function $CopyFromCallDataToMemory(src, dst, length) {
                calldatacopy(dst, src, length)
                mstore(add(dst, length), 0)
            }
            function $Shr(x, y) -> r {
                r := shr(y, x)
            }
            function $ClosestGreaterPowerOfTwo(x) -> r {
                r := or(r, shr(1, x))
                r := or(r, shr(2, r))
                r := or(r, shr(4, r))
                r := or(r, shr(8, r))
                r := or(r, shr(16, r))
                r := or(r, shr(32, r))
                r := add(x, 1)
            }
            function $RoundUp(value) -> result {
                result := and(add(value, 31), not(31))
            }
        }
    }
}


!! Succeeded compiling Yul
