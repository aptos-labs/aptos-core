/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "A2_M" {
    code {
        codecopy(0, dataoffset("A2_M_deployed"), datasize("A2_M_deployed"))
        return(0, datasize("A2_M_deployed"))
    }
    object "A2_M_deployed" {
        code {
            mstore(0, memoryguard(160))
            if iszero(lt(calldatasize(), 4))
            {
                let selector := $Shr(calldataload(0), 224)
                switch selector
                default {}
            }
            $Abort(97)
            function $Abort(code) {
                mstore(0, code)
                revert(24, 8) // TODO: store code as a string?
            }
            function $Shr(x, y) -> r {
                r := shr(y, x)
            }
        }
    }
}


!! Succeeded compiling Yul


!! Unit tests

// test of M::h1
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_M_h1" {
    code {
        mstore(0, memoryguard(160))
        A2_M_h1()
        return (0, 0)
        function A2_M_h1() {
            let $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27, $t28, $t29, $t30, $t31, $t32, $t33, $t34, $t35, $t36, $t37, $t38, $t39, $t40, $t41, $t42, $t43, $t44, $t45, $t46, $t47, $t48, $t49, $t50, $t51, $t52, $t53, $t54, $t55, $t56, $t57, $t58, $t59, $t60, $t61, $t62, $t63, $t64, $t65, $t66, $t67, $t68, $t69, $t70, $t71, $t72, $t73, $t74, $t75
            let $locals := $Malloc(96)
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // goto L2
                    $block := 5
                }
                case 3 {
                    // label L0
                    // $t14 := 96
                    $t14 := 96
                    // abort($t14)
                    $Abort($t14)
                }
                case 4 {
                    // $t3 := 0x3
                    $t3 := 0x3
                    // $t0 := Evm::sign($t3)
                    mstore($locals, A2_Evm_sign($t3))
                    // $t4 := borrow_local($t0)
                    $t4 := $MakePtr(false, $locals)
                    // $t5 := [97, 98, 99]
                    $t5 := $Malloc(add(32, $ClosestGreaterPowerOfTwo(3)))
                    $MemoryStoreU64($t5, 3)
                    $MemoryStoreU64(add($t5, 8), $ClosestGreaterPowerOfTwo(3))
                    copy_literal_string_to_memory_2053440334(add($t5, 32))
                    // $t6 := pack 0x2::M::T($t5)
                    {
                        let $mem := $Malloc(32)
                        $MemoryStoreU256(add($mem, 0), $t5)
                        $t6 := $mem
                    }
                    // move_to<0x2::M::T>($t6, $t4)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x3948ca0a, $LoadU256($t4))
                        if $AlignedStorageLoad($base_offset) {
                          $AbortBuiltin()
                        }
                        $AlignedStorageStore($base_offset, true)
                        {
                            let $dst := add($base_offset, 32)
                            let $src := $t6
                            {
                                let $linked_src_2300595445 := mload(add($src, 0))
                                let $linked_dst_2300595445 := $NewLinkedStorageBase(0x89204cf5)
                                let $size_2300595445 := $MemoryLoadU64($linked_src_2300595445)
                                let $data_size_2300595445 := mul($size_2300595445, 1)
                                $AlignedStorageStore($linked_dst_2300595445, mload($linked_src_2300595445))
                                let $data_src_2300595445 := add($linked_src_2300595445, 32)
                                let $data_dst_2300595445 := add($linked_dst_2300595445, 32)
                                for { let $offs_2300595445 := 0 } lt($offs_2300595445, $data_size_2300595445) { $offs_2300595445 := add($offs_2300595445, 32)} {
                                    $AlignedStorageStore(add($data_dst_2300595445, $offs_2300595445), mload(add($data_src_2300595445, $offs_2300595445)))
                                    $Free($linked_src_2300595445, add($data_size_2300595445, 32))
                                }
                                $AlignedStorageStore(add($dst, 0), $linked_dst_2300595445)
                            }
                            $Free($src, 32)
                        }
                    }
                    // $t7 := 0x3
                    $t7 := 0x3
                    // $t8 := borrow_global<0x2::M::T>($t7)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x3948ca0a, $t7)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t8 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t9 := borrow_field<0x2::M::T>.s($t8)
                    $t9 := $t8
                    // $t1 := read_ref($t9)
                    mstore(add($locals, 32), $LoadU256($t9))
                    if $IsStoragePtr($t9){
                        let $storage_ptr_2300595445
                        let $size_2300595445 := $StorageLoadU64(mload(add($locals, 32)))
                        let $capacity_2300595445 := $ClosestGreaterPowerOfTwo($size_2300595445)
                        $storage_ptr_2300595445 := $Malloc(add(32, mul($capacity_2300595445, 1)))
                        let $data_size_2300595445 := mul($size_2300595445, 1)
                        mstore($storage_ptr_2300595445, $AlignedStorageLoad(mload(add($locals, 32))))
                        $MemoryStoreU64(add($storage_ptr_2300595445, 8), $capacity_2300595445)
                        let $data_src_2300595445 := add(mload(add($locals, 32)), 32)
                        let $data_dst_2300595445 := add($storage_ptr_2300595445, 32)
                        for { let $offs_2300595445 := 0 } lt($offs_2300595445, $data_size_2300595445) { $offs_2300595445 := add($offs_2300595445, 32)} {
                            mstore(add($data_dst_2300595445, $offs_2300595445), $AlignedStorageLoad(add($data_src_2300595445, $offs_2300595445)))
                        }
                        mstore(add($locals, 32), $storage_ptr_2300595445)
                    }
                    // $t10 := borrow_local($t1)
                    $t10 := $MakePtr(false, add($locals, 32))
                    // $t11 := vector::length<u8>($t10)
                    $t11 := A1_vector_length$u8$($t10)
                    // $t12 := 3
                    $t12 := 3
                    // $t13 := ==($t11, $t12)
                    $t13 := $Eq($t11, $t12)
                    // if ($t13) goto L1 else goto L0
                    switch $t13
                    case 0  { $block := 3 }
                    default { $block := 2 }
                }
                case 5 {
                    // label L2
                    // $t15 := borrow_local($t1)
                    $t15 := $MakePtr(false, add($locals, 32))
                    // $t16 := 0
                    $t16 := 0
                    // $t17 := vector::borrow<u8>($t15, $t16)
                    $t17 := A1_vector_borrow$u8$($t15, $t16)
                    // $t18 := read_ref($t17)
                    $t18 := $LoadU8($t17)
                    // $t19 := 97
                    $t19 := 97
                    // $t20 := ==($t18, $t19)
                    $t20 := $Eq($t18, $t19)
                    // if ($t20) goto L4 else goto L3
                    switch $t20
                    case 0  { $block := 7 }
                    default { $block := 6 }
                }
                case 6 {
                    // label L4
                    // goto L5
                    $block := 8
                }
                case 7 {
                    // label L3
                    // $t21 := 97
                    $t21 := 97
                    // abort($t21)
                    $Abort($t21)
                }
                case 8 {
                    // label L5
                    // $t22 := borrow_local($t1)
                    $t22 := $MakePtr(false, add($locals, 32))
                    // $t23 := 1
                    $t23 := 1
                    // $t24 := vector::borrow<u8>($t22, $t23)
                    $t24 := A1_vector_borrow$u8$($t22, $t23)
                    // $t25 := read_ref($t24)
                    $t25 := $LoadU8($t24)
                    // $t26 := 98
                    $t26 := 98
                    // $t27 := ==($t25, $t26)
                    $t27 := $Eq($t25, $t26)
                    // if ($t27) goto L7 else goto L6
                    switch $t27
                    case 0  { $block := 10 }
                    default { $block := 9 }
                }
                case 9 {
                    // label L7
                    // goto L8
                    $block := 11
                }
                case 10 {
                    // label L6
                    // $t28 := 98
                    $t28 := 98
                    // abort($t28)
                    $Abort($t28)
                }
                case 11 {
                    // label L8
                    // $t29 := borrow_local($t1)
                    $t29 := $MakePtr(false, add($locals, 32))
                    // $t30 := 2
                    $t30 := 2
                    // $t31 := vector::borrow<u8>($t29, $t30)
                    $t31 := A1_vector_borrow$u8$($t29, $t30)
                    // $t32 := read_ref($t31)
                    $t32 := $LoadU8($t31)
                    // $t33 := 99
                    $t33 := 99
                    // $t34 := ==($t32, $t33)
                    $t34 := $Eq($t32, $t33)
                    // if ($t34) goto L10 else goto L9
                    switch $t34
                    case 0  { $block := 13 }
                    default { $block := 12 }
                }
                case 12 {
                    // label L10
                    // goto L11
                    $block := 14
                }
                case 13 {
                    // label L9
                    // $t35 := 99
                    $t35 := 99
                    // abort($t35)
                    $Abort($t35)
                }
                case 14 {
                    // label L11
                    // $t36 := [101, 102, 103, 104]
                    $t36 := $Malloc(add(32, $ClosestGreaterPowerOfTwo(4)))
                    $MemoryStoreU64($t36, 4)
                    $MemoryStoreU64(add($t36, 8), $ClosestGreaterPowerOfTwo(4))
                    copy_literal_string_to_memory_2788570470(add($t36, 32))
                    // $t37 := 0x3
                    $t37 := 0x3
                    // $t38 := borrow_global<0x2::M::T>($t37)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x3948ca0a, $t37)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t38 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t39 := borrow_field<0x2::M::T>.s($t38)
                    $t39 := $t38
                    // write_ref($t39, $t36)
                    if $IsStoragePtr($t39){
                        let $storage_ptr_2300595445 := $NewLinkedStorageBase(0x89204cf5)
                        let $size_2300595445 := $MemoryLoadU64($t36)
                        let $data_size_2300595445 := mul($size_2300595445, 1)
                        $AlignedStorageStore($storage_ptr_2300595445, mload($t36))
                        let $data_src_2300595445 := add($t36, 32)
                        let $data_dst_2300595445 := add($storage_ptr_2300595445, 32)
                        for { let $offs_2300595445 := 0 } lt($offs_2300595445, $data_size_2300595445) { $offs_2300595445 := add($offs_2300595445, 32)} {
                            $AlignedStorageStore(add($data_dst_2300595445, $offs_2300595445), mload(add($data_src_2300595445, $offs_2300595445)))
                        }
                        $t36 := $storage_ptr_2300595445
                    }
                    $StoreU256($t39, $t36)
                    // $t40 := 0x3
                    $t40 := 0x3
                    // $t41 := borrow_global<0x2::M::T>($t40)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x3948ca0a, $t40)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t41 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t42 := borrow_field<0x2::M::T>.s($t41)
                    $t42 := $t41
                    // $t2 := read_ref($t42)
                    mstore(add($locals, 64), $LoadU256($t42))
                    if $IsStoragePtr($t42){
                        let $storage_ptr_2300595445
                        let $size_2300595445 := $StorageLoadU64(mload(add($locals, 64)))
                        let $capacity_2300595445 := $ClosestGreaterPowerOfTwo($size_2300595445)
                        $storage_ptr_2300595445 := $Malloc(add(32, mul($capacity_2300595445, 1)))
                        let $data_size_2300595445 := mul($size_2300595445, 1)
                        mstore($storage_ptr_2300595445, $AlignedStorageLoad(mload(add($locals, 64))))
                        $MemoryStoreU64(add($storage_ptr_2300595445, 8), $capacity_2300595445)
                        let $data_src_2300595445 := add(mload(add($locals, 64)), 32)
                        let $data_dst_2300595445 := add($storage_ptr_2300595445, 32)
                        for { let $offs_2300595445 := 0 } lt($offs_2300595445, $data_size_2300595445) { $offs_2300595445 := add($offs_2300595445, 32)} {
                            mstore(add($data_dst_2300595445, $offs_2300595445), $AlignedStorageLoad(add($data_src_2300595445, $offs_2300595445)))
                        }
                        mstore(add($locals, 64), $storage_ptr_2300595445)
                    }
                    // $t43 := borrow_local($t2)
                    $t43 := $MakePtr(false, add($locals, 64))
                    // $t44 := vector::length<u8>($t43)
                    $t44 := A1_vector_length$u8$($t43)
                    // $t45 := 4
                    $t45 := 4
                    // $t46 := ==($t44, $t45)
                    $t46 := $Eq($t44, $t45)
                    // if ($t46) goto L13 else goto L12
                    switch $t46
                    case 0  { $block := 16 }
                    default { $block := 15 }
                }
                case 15 {
                    // label L13
                    // goto L14
                    $block := 17
                }
                case 16 {
                    // label L12
                    // $t47 := 100
                    $t47 := 100
                    // abort($t47)
                    $Abort($t47)
                }
                case 17 {
                    // label L14
                    // $t48 := borrow_local($t2)
                    $t48 := $MakePtr(false, add($locals, 64))
                    // $t49 := 0
                    $t49 := 0
                    // $t50 := vector::borrow<u8>($t48, $t49)
                    $t50 := A1_vector_borrow$u8$($t48, $t49)
                    // $t51 := read_ref($t50)
                    $t51 := $LoadU8($t50)
                    // $t52 := 101
                    $t52 := 101
                    // $t53 := ==($t51, $t52)
                    $t53 := $Eq($t51, $t52)
                    // if ($t53) goto L16 else goto L15
                    switch $t53
                    case 0  { $block := 19 }
                    default { $block := 18 }
                }
                case 18 {
                    // label L16
                    // goto L17
                    $block := 20
                }
                case 19 {
                    // label L15
                    // $t54 := 101
                    $t54 := 101
                    // abort($t54)
                    $Abort($t54)
                }
                case 20 {
                    // label L17
                    // $t55 := borrow_local($t2)
                    $t55 := $MakePtr(false, add($locals, 64))
                    // $t56 := 1
                    $t56 := 1
                    // $t57 := vector::borrow<u8>($t55, $t56)
                    $t57 := A1_vector_borrow$u8$($t55, $t56)
                    // $t58 := read_ref($t57)
                    $t58 := $LoadU8($t57)
                    // $t59 := 102
                    $t59 := 102
                    // $t60 := ==($t58, $t59)
                    $t60 := $Eq($t58, $t59)
                    // if ($t60) goto L19 else goto L18
                    switch $t60
                    case 0  { $block := 22 }
                    default { $block := 21 }
                }
                case 21 {
                    // label L19
                    // goto L20
                    $block := 23
                }
                case 22 {
                    // label L18
                    // $t61 := 102
                    $t61 := 102
                    // abort($t61)
                    $Abort($t61)
                }
                case 23 {
                    // label L20
                    // $t62 := borrow_local($t2)
                    $t62 := $MakePtr(false, add($locals, 64))
                    // $t63 := 2
                    $t63 := 2
                    // $t64 := vector::borrow<u8>($t62, $t63)
                    $t64 := A1_vector_borrow$u8$($t62, $t63)
                    // $t65 := read_ref($t64)
                    $t65 := $LoadU8($t64)
                    // $t66 := 103
                    $t66 := 103
                    // $t67 := ==($t65, $t66)
                    $t67 := $Eq($t65, $t66)
                    // if ($t67) goto L22 else goto L21
                    switch $t67
                    case 0  { $block := 25 }
                    default { $block := 24 }
                }
                case 24 {
                    // label L22
                    // goto L23
                    $block := 26
                }
                case 25 {
                    // label L21
                    // $t68 := 103
                    $t68 := 103
                    // abort($t68)
                    $Abort($t68)
                }
                case 26 {
                    // label L23
                    // $t69 := borrow_local($t2)
                    $t69 := $MakePtr(false, add($locals, 64))
                    // $t70 := 3
                    $t70 := 3
                    // $t71 := vector::borrow<u8>($t69, $t70)
                    $t71 := A1_vector_borrow$u8$($t69, $t70)
                    // $t72 := read_ref($t71)
                    $t72 := $LoadU8($t71)
                    // $t73 := 104
                    $t73 := 104
                    // $t74 := ==($t72, $t73)
                    $t74 := $Eq($t72, $t73)
                    // if ($t74) goto L25 else goto L24
                    switch $t74
                    case 0  { $block := 28 }
                    default { $block := 27 }
                }
                case 27 {
                    // label L25
                    // goto L26
                    $block := 29
                }
                case 28 {
                    // label L24
                    // $t75 := 104
                    $t75 := 104
                    // abort($t75)
                    $Abort($t75)
                }
                case 29 {
                    // label L26
                    // return ()
                    $Free($locals, 96)
                    leave
                }
            }
        }

        function A1_vector_borrow$u8$(v_ref, i) -> e_ptr {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            if $GtEq(i, size) { $AbortBuiltin() }
            e_ptr := $IndexPtr(v_ptr, add(32, mul(i, 1)))
        }
        function A1_vector_length$u8$(v_ref) -> len {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            len := $LoadU64(v_ptr)
        }
        function A2_Evm_sign(addr) -> signer {
          signer := addr
        }
        function copy_literal_string_to_memory_2788570470(value) {
            $MemoryStoreU8(value, 101)
            value := add(value, 1)
            $MemoryStoreU8(value, 102)
            value := add(value, 1)
            $MemoryStoreU8(value, 103)
            value := add(value, 1)
            $MemoryStoreU8(value, 104)
            value := add(value, 1)
        }
        function copy_literal_string_to_memory_2053440334(value) {
            $MemoryStoreU8(value, 97)
            value := add(value, 1)
            $MemoryStoreU8(value, 98)
            value := add(value, 1)
            $MemoryStoreU8(value, 99)
            value := add(value, 1)
        }
        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Malloc(size) -> offs {
            offs := mload(0)
            // pad to word size
            mstore(0, add(offs, shl(5, shr(5, add(size, 31)))))
        }
        function $Free(offs, size) {
        }
        function $MakePtr(is_storage, offs) -> ptr {
          ptr := or(is_storage, shl(1, offs))
        }
        function $IsStoragePtr(ptr) -> b {
          b := and(ptr, 0x1)
        }
        function $OffsetPtr(ptr) -> offs {
          offs := shr(1, ptr)
        }
        function $MaskForSize(size) -> mask {
          mask := sub(shl(shl(3, size), 1), 1)
        }
        function $ExtractBytes(word, start, size) -> bytes {
           switch size
           case 1 {
              // use the faster byte primitive
              bytes := byte(start, word)
           }
           default {
              // As we have big endian, we need to right shift the value from
              // where the highest byte starts in the word (32 - start), minus
              // the size.
              let shift_bits := shl(3, sub(sub(32, start), size))
              bytes := and(shr(shift_bits, word), $MaskForSize(size))
           }
        }
        function $InjectBytes(word, start, size, bytes) -> new_word {
           let shift_bits := shl(3, sub(sub(32, start), size))
           // Blend out the bits which we inject
           let neg_mask := not(shl(shift_bits, $MaskForSize(size)))
           word := and(word, neg_mask)
           // Overlay the bits we inject
           new_word := or(word, shl(shift_bits, bytes))
        }
        function $ToWordOffs(offs) -> word_offs, byte_offset {
          word_offs := shr(5, offs)
          byte_offset := and(offs, 0x1F)
        }
        function $OverflowBytes(byte_offset, size) -> overflow_bytes {
          let available_bytes := sub(32, byte_offset)
          switch gt(size, available_bytes)
          case 0 {
            overflow_bytes := 0
          }
          default {
            overflow_bytes := sub(size, available_bytes)
          }
        }
        function $MemoryLoadBytes(offs, size) -> val {
          // Lower bit where the value in the higher bytes ends
          let bit_end := shl(3, sub(32, size))
          val := shr(bit_end, mload(offs))
        }
        function $MemoryStoreBytes(offs, size, val) {
          let bit_end := shl(3, sub(32, size))
          let mask := shl(bit_end, $MaskForSize(size))
          mstore(offs, or(and(mload(offs), not(mask)), shl(bit_end, val)))
        }
        function $StorageLoadBytes(offs, size) -> val {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          val := $ExtractBytes(sload(key), byte_offs, size)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          if $LogicalNot(iszero(overflow_bytes)) {
            key := $StorageKey(0, add(word_offs, 1))
            let extra_bytes := $ExtractBytes(sload(key), 0, overflow_bytes)
            val := or(shl(shl(3, overflow_bytes), val), extra_bytes)
          }
        }
        function $StorageStoreBytes(offs, size, bytes) {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          switch overflow_bytes
          case 0 {
            sstore(key, $InjectBytes(sload(key), byte_offs, size, bytes))
          }
          default {
            // Shift the higher bytes to the right
            let used_bytes := sub(size, overflow_bytes)
            let higher_bytes := shr(used_bytes, bytes)
            let lower_bytes := and(bytes, $MaskForSize(overflow_bytes))
            sstore(key, $InjectBytes(sload(key), byte_offs, used_bytes, higher_bytes))
            key := $StorageKey(0, add(word_offs, 1))
            sstore(key, $InjectBytes(sload(key), 0, overflow_bytes, lower_bytes))
          }
        }
        function $StorageKey(group, word) -> key {
          mstore(32, word)
          mstore(64, shl(224, group))
          key := keccak256(32, 36)
        }
        function $MakeTypeStorageBase(category, type_hash, id) -> offs {
          offs := or(shl(252, category), or(shl(220, type_hash), shl(60, id)))
        }
        function $NewLinkedStorageBase(type_hash) -> offs {
          let key := $StorageKey(1, 1)
          let handle := sload(key)
          sstore(key, add(handle, 1))
          offs := $MakeTypeStorageBase(1, type_hash, handle)
        }
        function $IndexPtr(ptr, offs) -> new_ptr {
          new_ptr := $MakePtr($IsStoragePtr(ptr), add($OffsetPtr(ptr), offs))
        }
        function $LoadU8(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU8(offs)
          }
          default {
            val := $StorageLoadU8(offs)
          }
        }
        function $MemoryLoadU8(offs) -> val {
          val := $MemoryLoadBytes(offs, 1)
        }
        function $StorageLoadU8(offs) -> val {
          val := $StorageLoadBytes(offs, 1)
        }
        function $MemoryStoreU8(offs, val) {
          // Shortcut via special instruction
          mstore8(offs, val)
        }
        function $LoadU64(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU64(offs)
          }
          default {
            val := $StorageLoadU64(offs)
          }
        }
        function $MemoryLoadU64(offs) -> val {
          val := $MemoryLoadBytes(offs, 8)
        }
        function $StorageLoadU64(offs) -> val {
          val := $StorageLoadBytes(offs, 8)
        }
        function $MemoryStoreU64(offs, val) {
          $MemoryStoreBytes(offs, 8, val)
        }
        function $LoadU256(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU256(offs)
          }
          default {
            val := $StorageLoadU256(offs)
          }
        }
        function $MemoryLoadU256(offs) -> val {
          val := $MemoryLoadBytes(offs, 32)
        }
        function $StorageLoadU256(offs) -> val {
          val := $StorageLoadBytes(offs, 32)
        }
        function $StoreU256(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU256(offs, val)
          }
          default {
            $StorageStoreU256(offs, val)
          }
        }
        function $MemoryStoreU256(offs, val) {
          $MemoryStoreBytes(offs, 32, val)
        }
        function $StorageStoreU256(offs, val) {
          $StorageStoreBytes(offs, 32, val)
        }
        function $AlignedStorageLoad(offs) -> val {
          let word_offs := shr(5, offs)
          val := sload($StorageKey(0, word_offs))
        }
        function $AlignedStorageStore(offs, val) {
          let word_offs := shr(5, offs)
          sstore($StorageKey(0, word_offs), val)
        }
        function $GtEq(x, y) -> r {
            r := or(gt(x, y), eq(x, y))
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
        function $LogicalNot(x) -> r {
            r := iszero(x)
        }
        function $ClosestGreaterPowerOfTwo(x) -> r {
            r := or(r, shr(1, x))
            r := or(r, shr(2, r))
            r := or(r, shr(4, r))
            r := or(r, shr(8, r))
            r := or(r, shr(16, r))
            r := or(r, shr(32, r))
            r := add(x, 1)
        }
    }
}
===> Test result of M::h1: Succeed(Stopped) (used_gas=170443): []

// test of M::test_same_literals
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_M_test_same_literals" {
    code {
        mstore(0, memoryguard(160))
        A2_M_test_same_literals()
        return (0, 0)
        function A2_M_test_same_literals() {
            let $t0, $t1, $t2, $t3
            // $t0 := true
            $t0 := true
            // $t1 := [101, 114, 114, 111, 114, 95, 109, 101, 115, 115, 97, 103, 101]
            $t1 := $Malloc(add(32, $ClosestGreaterPowerOfTwo(13)))
            $MemoryStoreU64($t1, 13)
            $MemoryStoreU64(add($t1, 8), $ClosestGreaterPowerOfTwo(13))
            copy_literal_string_to_memory_3855568786(add($t1, 32))
            // Evm::require($t0, $t1)
            A2_Evm_require($t0, $t1)
            // $t2 := true
            $t2 := true
            // $t3 := [101, 114, 114, 111, 114, 95, 109, 101, 115, 115, 97, 103, 101]
            $t3 := $Malloc(add(32, $ClosestGreaterPowerOfTwo(13)))
            $MemoryStoreU64($t3, 13)
            $MemoryStoreU64(add($t3, 8), $ClosestGreaterPowerOfTwo(13))
            copy_literal_string_to_memory_3855568786(add($t3, 32))
            // Evm::require($t2, $t3)
            A2_Evm_require($t2, $t3)
            // return ()
        }

        function A2_Evm_require(cond, message) {
            let $t2
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // Evm::abort_with($t1)
                    A2_Evm_abort_with(message)
                    // goto L0
                    $block := 3
                }
                case 3 {
                    // label L0
                    // return ()
                    leave
                }
                case 4 {
                    // $t2 := !($t0)
                    $t2 := $LogicalNot(cond)
                    // if ($t2) goto L1 else goto L0
                    switch $t2
                    case 0  { $block := 3 }
                    default { $block := 2 }
                }
            }
        }

        function A2_Evm_abort_with(message) {
          let head := $Malloc(32)
          // store the function selector for Error(string)
          mstore(head, 3963877391197344453575983046348115674221700746820753546331534351508065746944)
          let pos := add(head, 4)
          mstore(pos, 32)
          pos := add(pos, 32)
          let size := $MemoryLoadU64(message)
          mstore(pos, size)
          pos := add(pos, 32)
          $CopyMemory(add(message, 32), pos, size)
          size := $RoundUp(size)
          let end := add(pos, size)
          revert(head, sub(end, head))
        }
        function copy_literal_string_to_memory_3855568786(value) {
            $MemoryStoreU8(value, 101)
            value := add(value, 1)
            $MemoryStoreU8(value, 114)
            value := add(value, 1)
            $MemoryStoreU8(value, 114)
            value := add(value, 1)
            $MemoryStoreU8(value, 111)
            value := add(value, 1)
            $MemoryStoreU8(value, 114)
            value := add(value, 1)
            $MemoryStoreU8(value, 95)
            value := add(value, 1)
            $MemoryStoreU8(value, 109)
            value := add(value, 1)
            $MemoryStoreU8(value, 101)
            value := add(value, 1)
            $MemoryStoreU8(value, 115)
            value := add(value, 1)
            $MemoryStoreU8(value, 115)
            value := add(value, 1)
            $MemoryStoreU8(value, 97)
            value := add(value, 1)
            $MemoryStoreU8(value, 103)
            value := add(value, 1)
            $MemoryStoreU8(value, 101)
            value := add(value, 1)
        }
        function $Malloc(size) -> offs {
            offs := mload(0)
            // pad to word size
            mstore(0, add(offs, shl(5, shr(5, add(size, 31)))))
        }
        function $MaskForSize(size) -> mask {
          mask := sub(shl(shl(3, size), 1), 1)
        }
        function $ToWordOffs(offs) -> word_offs, byte_offset {
          word_offs := shr(5, offs)
          byte_offset := and(offs, 0x1F)
        }
        function $MemoryLoadBytes(offs, size) -> val {
          // Lower bit where the value in the higher bytes ends
          let bit_end := shl(3, sub(32, size))
          val := shr(bit_end, mload(offs))
        }
        function $MemoryStoreBytes(offs, size, val) {
          let bit_end := shl(3, sub(32, size))
          let mask := shl(bit_end, $MaskForSize(size))
          mstore(offs, or(and(mload(offs), not(mask)), shl(bit_end, val)))
        }
        function $MemoryStoreU8(offs, val) {
          // Shortcut via special instruction
          mstore8(offs, val)
        }
        function $MemoryLoadU64(offs) -> val {
          val := $MemoryLoadBytes(offs, 8)
        }
        function $MemoryStoreU64(offs, val) {
          $MemoryStoreBytes(offs, 8, val)
        }
        function $CopyMemory(src, dst, size) {
          let num_words, overflow_bytes := $ToWordOffs(size)
          let i := 0
          for { } lt(i, mul(num_words, 32)) { i := add(i, 32) } {
            mstore(add(dst, i), mload(add(src, i)))
          }
          if overflow_bytes {
            let mask := $MaskForSize(sub(32, overflow_bytes))
            let overflow_offs := mul(num_words, 32)
            let dst_word := and(mload(add(dst, overflow_offs)), mask)
            let src_word := and(mload(add(src, overflow_offs)), not(mask))
            mstore(add(dst, overflow_offs), or(dst_word, src_word))
          }
        }
        function $LogicalNot(x) -> r {
            r := iszero(x)
        }
        function $ClosestGreaterPowerOfTwo(x) -> r {
            r := or(r, shr(1, x))
            r := or(r, shr(2, r))
            r := or(r, shr(4, r))
            r := or(r, shr(8, r))
            r := or(r, shr(16, r))
            r := or(r, shr(32, r))
            r := add(x, 1)
        }
        function $RoundUp(value) -> result {
            result := and(add(value, 31), not(31))
        }
    }
}
===> Test result of M::test_same_literals: Succeed(Returned) (used_gas=1078): []
