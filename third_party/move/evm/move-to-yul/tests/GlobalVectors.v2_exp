/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "A2_GlobalVectors" {
    code {
        codecopy(0, dataoffset("A2_GlobalVectors_deployed"), datasize("A2_GlobalVectors_deployed"))
        return(0, datasize("A2_GlobalVectors_deployed"))
    }
    object "A2_GlobalVectors_deployed" {
        code {
            mstore(0, memoryguard(160))
            if iszero(lt(calldatasize(), 4))
            {
                let selector := $Shr(calldataload(0), 224)
                switch selector
                default {}
            }
            $Abort(97)
            function $Abort(code) {
                mstore(0, code)
                revert(24, 8) // TODO: store code as a string?
            }
            function $Shr(x, y) -> r {
                r := shr(y, x)
            }
        }
    }
}


!! Succeeded compiling Yul


!! Unit tests

// test of GlobalVectors::test_borrow_mut_global
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_GlobalVectors_test_borrow_mut_global" {
    code {
        mstore(0, memoryguard(160))
        A2_GlobalVectors_test_borrow_mut_global()
        return (0, 0)
        function A2_GlobalVectors_test_borrow_mut_global() {
            let e, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27
            let $locals := $Malloc(64)
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // goto L2
                    $block := 5
                }
                case 3 {
                    // label L0
                    // $t27 := 102
                    $t27 := 102
                    // abort($t27)
                    $Abort($t27)
                }
                case 4 {
                    // $t2 := vector::empty<u64>()
                    mstore($locals, A1_vector_empty$u64$())
                    // $t3 := borrow_local($t2)
                    $t3 := $MakePtr(false, $locals)
                    // $t4 := 42
                    $t4 := 42
                    // vector::push_back<u64>($t3, $t4)
                    A1_vector_push_back$u64$($t3, $t4)
                    // $t5 := borrow_local($t2)
                    $t5 := $MakePtr(false, $locals)
                    // $t6 := 43
                    $t6 := 43
                    // vector::push_back<u64>($t5, $t6)
                    A1_vector_push_back$u64$($t5, $t6)
                    // $t7 := borrow_local($t2)
                    $t7 := $MakePtr(false, $locals)
                    // $t8 := 44
                    $t8 := 44
                    // vector::push_back<u64>($t7, $t8)
                    A1_vector_push_back$u64$($t7, $t8)
                    // $t9 := 0x42
                    $t9 := 0x42
                    // $t0 := Evm::sign($t9)
                    mstore(add($locals, 32), A2_Evm_sign($t9))
                    // $t10 := borrow_local($t0)
                    $t10 := $MakePtr(false, add($locals, 32))
                    // $t11 := move($t2)
                    $t11 := mload($locals)
                    // $t12 := pack 0x2::GlobalVectors::T<u64>($t11)
                    {
                        let $mem := $Malloc(32)
                        $MemoryStoreU256(add($mem, 0), $t11)
                        $t12 := $mem
                    }
                    // move_to<0x2::GlobalVectors::T<u64>>($t12, $t10)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $LoadU256($t10))
                        if $AlignedStorageLoad($base_offset) {
                          $AbortBuiltin()
                        }
                        $AlignedStorageStore($base_offset, true)
                        {
                            let $dst := add($base_offset, 32)
                            let $src := $t12
                            {
                                let $linked_src_814019441 := mload(add($src, 0))
                                let $linked_dst_814019441 := $NewLinkedStorageBase(0x3084f371)
                                let $size_814019441 := $MemoryLoadU64($linked_src_814019441)
                                let $data_size_814019441 := mul($size_814019441, 8)
                                $AlignedStorageStore($linked_dst_814019441, mload($linked_src_814019441))
                                let $data_src_814019441 := add($linked_src_814019441, 32)
                                let $data_dst_814019441 := add($linked_dst_814019441, 32)
                                for { let $offs_814019441 := 0 } lt($offs_814019441, $data_size_814019441) { $offs_814019441 := add($offs_814019441, 32)} {
                                    $AlignedStorageStore(add($data_dst_814019441, $offs_814019441), mload(add($data_src_814019441, $offs_814019441)))
                                    $Free($linked_src_814019441, add($data_size_814019441, 32))
                                }
                                $AlignedStorageStore(add($dst, 0), $linked_dst_814019441)
                            }
                            $Free($src, 32)
                        }
                    }
                    // $t13 := 0x42
                    $t13 := 0x42
                    // $t14 := borrow_global<0x2::GlobalVectors::T<u64>>($t13)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $t13)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t14 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t15 := borrow_field<0x2::GlobalVectors::T<u64>>.v($t14)
                    $t15 := $t14
                    // $t16 := 0
                    $t16 := 0
                    // $t17 := vector::borrow_mut<u64>($t15, $t16)
                    $t17 := A1_vector_borrow_mut$u64$($t15, $t16)
                    // $t18 := 12
                    $t18 := 12
                    // write_ref($t17, $t18)
                    $StoreU64($t17, $t18)
                    // $t19 := 0x42
                    $t19 := 0x42
                    // $t20 := borrow_global<0x2::GlobalVectors::T<u64>>($t19)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $t19)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t20 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t21 := borrow_field<0x2::GlobalVectors::T<u64>>.v($t20)
                    $t21 := $t20
                    // $t22 := 0
                    $t22 := 0
                    // $t23 := vector::borrow<u64>($t21, $t22)
                    $t23 := A1_vector_borrow$u64$($t21, $t22)
                    // $t24 := read_ref($t23)
                    $t24 := $LoadU64($t23)
                    // $t25 := 12
                    $t25 := 12
                    // $t26 := ==($t24, $t25)
                    $t26 := $Eq($t24, $t25)
                    // if ($t26) goto L1 else goto L0
                    switch $t26
                    case 0  { $block := 3 }
                    default { $block := 2 }
                }
                case 5 {
                    // label L2
                    // return ()
                    $Free($locals, 64)
                    leave
                }
            }
        }

        function A1_vector_borrow$u64$(v_ref, i) -> e_ptr {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            if $GtEq(i, size) { $AbortBuiltin() }
            e_ptr := $IndexPtr(v_ptr, add(32, mul(i, 8)))
        }
        function A1_vector_borrow_mut$u64$(v_ref, i) -> e_ptr {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            if $GtEq(i, size) { $AbortBuiltin() }
            e_ptr := $IndexPtr(v_ptr, add(32, mul(i, 8)))
        }
        function A2_Evm_sign(addr) -> signer {
          signer := addr
        }
        function A1_vector_push_back$u64$(v_ref, e) {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            let e_ptr := $IndexPtr(v_ptr, add(32, mul(size, 8)))
            $StoreU64(e_ptr, e)
            size := add(size, 1)
            $StoreU64(v_ptr, size)
            let capacity := $LoadU64($IndexPtr(v_ptr, 8))
            if and(iszero($IsStoragePtr(v_ptr)), eq(size, capacity)) {
                let new_v_offs := $ResizeVector(v_offs, capacity, 8)
                $StoreU256(v_ref, new_v_offs)
            }
        }
        function A1_vector_empty$u64$() -> vector {
            vector := $Malloc(48)
            $MemoryStoreU64(add(vector, 8), 2)
        }
        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Malloc(size) -> offs {
            offs := mload(0)
            // pad to word size
            mstore(0, add(offs, shl(5, shr(5, add(size, 31)))))
        }
        function $Free(offs, size) {
        }
        function $MakePtr(is_storage, offs) -> ptr {
          ptr := or(is_storage, shl(1, offs))
        }
        function $IsStoragePtr(ptr) -> b {
          b := and(ptr, 0x1)
        }
        function $OffsetPtr(ptr) -> offs {
          offs := shr(1, ptr)
        }
        function $MaskForSize(size) -> mask {
          mask := sub(shl(shl(3, size), 1), 1)
        }
        function $ExtractBytes(word, start, size) -> bytes {
           switch size
           case 1 {
              // use the faster byte primitive
              bytes := byte(start, word)
           }
           default {
              // As we have big endian, we need to right shift the value from
              // where the highest byte starts in the word (32 - start), minus
              // the size.
              let shift_bits := shl(3, sub(sub(32, start), size))
              bytes := and(shr(shift_bits, word), $MaskForSize(size))
           }
        }
        function $InjectBytes(word, start, size, bytes) -> new_word {
           let shift_bits := shl(3, sub(sub(32, start), size))
           // Blend out the bits which we inject
           let neg_mask := not(shl(shift_bits, $MaskForSize(size)))
           word := and(word, neg_mask)
           // Overlay the bits we inject
           new_word := or(word, shl(shift_bits, bytes))
        }
        function $ToWordOffs(offs) -> word_offs, byte_offset {
          word_offs := shr(5, offs)
          byte_offset := and(offs, 0x1F)
        }
        function $OverflowBytes(byte_offset, size) -> overflow_bytes {
          let available_bytes := sub(32, byte_offset)
          switch gt(size, available_bytes)
          case 0 {
            overflow_bytes := 0
          }
          default {
            overflow_bytes := sub(size, available_bytes)
          }
        }
        function $MemoryLoadBytes(offs, size) -> val {
          // Lower bit where the value in the higher bytes ends
          let bit_end := shl(3, sub(32, size))
          val := shr(bit_end, mload(offs))
        }
        function $MemoryStoreBytes(offs, size, val) {
          let bit_end := shl(3, sub(32, size))
          let mask := shl(bit_end, $MaskForSize(size))
          mstore(offs, or(and(mload(offs), not(mask)), shl(bit_end, val)))
        }
        function $StorageLoadBytes(offs, size) -> val {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          val := $ExtractBytes(sload(key), byte_offs, size)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          if $LogicalNot(iszero(overflow_bytes)) {
            key := $StorageKey(0, add(word_offs, 1))
            let extra_bytes := $ExtractBytes(sload(key), 0, overflow_bytes)
            val := or(shl(shl(3, overflow_bytes), val), extra_bytes)
          }
        }
        function $StorageStoreBytes(offs, size, bytes) {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          switch overflow_bytes
          case 0 {
            sstore(key, $InjectBytes(sload(key), byte_offs, size, bytes))
          }
          default {
            // Shift the higher bytes to the right
            let used_bytes := sub(size, overflow_bytes)
            let higher_bytes := shr(used_bytes, bytes)
            let lower_bytes := and(bytes, $MaskForSize(overflow_bytes))
            sstore(key, $InjectBytes(sload(key), byte_offs, used_bytes, higher_bytes))
            key := $StorageKey(0, add(word_offs, 1))
            sstore(key, $InjectBytes(sload(key), 0, overflow_bytes, lower_bytes))
          }
        }
        function $StorageKey(group, word) -> key {
          mstore(32, word)
          mstore(64, shl(224, group))
          key := keccak256(32, 36)
        }
        function $MakeTypeStorageBase(category, type_hash, id) -> offs {
          offs := or(shl(252, category), or(shl(220, type_hash), shl(60, id)))
        }
        function $NewLinkedStorageBase(type_hash) -> offs {
          let key := $StorageKey(1, 1)
          let handle := sload(key)
          sstore(key, add(handle, 1))
          offs := $MakeTypeStorageBase(1, type_hash, handle)
        }
        function $IndexPtr(ptr, offs) -> new_ptr {
          new_ptr := $MakePtr($IsStoragePtr(ptr), add($OffsetPtr(ptr), offs))
        }
        function $LoadU64(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU64(offs)
          }
          default {
            val := $StorageLoadU64(offs)
          }
        }
        function $MemoryLoadU64(offs) -> val {
          val := $MemoryLoadBytes(offs, 8)
        }
        function $StorageLoadU64(offs) -> val {
          val := $StorageLoadBytes(offs, 8)
        }
        function $StoreU64(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU64(offs, val)
          }
          default {
            $StorageStoreU64(offs, val)
          }
        }
        function $MemoryStoreU64(offs, val) {
          $MemoryStoreBytes(offs, 8, val)
        }
        function $StorageStoreU64(offs, val) {
          $StorageStoreBytes(offs, 8, val)
        }
        function $LoadU256(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU256(offs)
          }
          default {
            val := $StorageLoadU256(offs)
          }
        }
        function $MemoryLoadU256(offs) -> val {
          val := $MemoryLoadBytes(offs, 32)
        }
        function $StorageLoadU256(offs) -> val {
          val := $StorageLoadBytes(offs, 32)
        }
        function $StoreU256(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU256(offs, val)
          }
          default {
            $StorageStoreU256(offs, val)
          }
        }
        function $MemoryStoreU256(offs, val) {
          $MemoryStoreBytes(offs, 32, val)
        }
        function $StorageStoreU256(offs, val) {
          $StorageStoreBytes(offs, 32, val)
        }
        function $AlignedStorageLoad(offs) -> val {
          let word_offs := shr(5, offs)
          val := sload($StorageKey(0, word_offs))
        }
        function $AlignedStorageStore(offs, val) {
          let word_offs := shr(5, offs)
          sstore($StorageKey(0, word_offs), val)
        }
        function $CopyMemory(src, dst, size) {
          let num_words, overflow_bytes := $ToWordOffs(size)
          let i := 0
          for { } lt(i, mul(num_words, 32)) { i := add(i, 32) } {
            mstore(add(dst, i), mload(add(src, i)))
          }
          if overflow_bytes {
            let mask := $MaskForSize(sub(32, overflow_bytes))
            let overflow_offs := mul(num_words, 32)
            let dst_word := and(mload(add(dst, overflow_offs)), mask)
            let src_word := and(mload(add(src, overflow_offs)), not(mask))
            mstore(add(dst, overflow_offs), or(dst_word, src_word))
          }
        }
        function $ResizeVector(v_offs, capacity, type_size) -> new_v_offs {
            let new_capacity := mul(capacity, 2)
            let data_size := add(32, mul(capacity, type_size))
            let new_data_size := add(32, mul(new_capacity, type_size))
            new_v_offs := $Malloc(new_data_size)
            $CopyMemory(v_offs, new_v_offs, data_size)
            // update capacity at new location
            $MemoryStoreU64(add(new_v_offs, 8), new_capacity)
            $Free(v_offs, data_size)
        }
        function $GtEq(x, y) -> r {
            r := or(gt(x, y), eq(x, y))
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
        function $LogicalNot(x) -> r {
            r := iszero(x)
        }
    }
}
===> Test result of GlobalVectors::test_borrow_mut_global: Succeed(Stopped) (used_gas=117389): []

// test of GlobalVectors::test_move_from
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_GlobalVectors_test_move_from" {
    code {
        mstore(0, memoryguard(160))
        A2_GlobalVectors_test_move_from()
        return (0, 0)
        function A2_GlobalVectors_test_move_from() {
            let $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27, $t28, $t29, $t30, $t31, $t32, $t33, $t34, $t35, $t36, $t37, $t38, $t39, $t40, $t41, $t42, $t43, $t44, $t45, $t46, $t47, $t48, $t49, $t50, $t51, $t52, $t53, $t54, $t55, $t56, $t57, $t58
            let $locals := $Malloc(96)
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // goto L2
                    $block := 5
                }
                case 3 {
                    // label L0
                    // $t19 := 101
                    $t19 := 101
                    // abort($t19)
                    $Abort($t19)
                }
                case 4 {
                    // $t1 := vector::empty<u64>()
                    mstore($locals, A1_vector_empty$u64$())
                    // $t3 := borrow_local($t1)
                    $t3 := $MakePtr(false, $locals)
                    // $t4 := 10
                    $t4 := 10
                    // vector::push_back<u64>($t3, $t4)
                    A1_vector_push_back$u64$($t3, $t4)
                    // $t5 := borrow_local($t1)
                    $t5 := $MakePtr(false, $locals)
                    // $t6 := 11
                    $t6 := 11
                    // vector::push_back<u64>($t5, $t6)
                    A1_vector_push_back$u64$($t5, $t6)
                    // $t7 := borrow_local($t1)
                    $t7 := $MakePtr(false, $locals)
                    // $t8 := 12
                    $t8 := 12
                    // vector::push_back<u64>($t7, $t8)
                    A1_vector_push_back$u64$($t7, $t8)
                    // $t9 := 0x42
                    $t9 := 0x42
                    // $t0 := Evm::sign($t9)
                    mstore(add($locals, 32), A2_Evm_sign($t9))
                    // $t10 := borrow_local($t0)
                    $t10 := $MakePtr(false, add($locals, 32))
                    // $t11 := move($t1)
                    $t11 := mload($locals)
                    // $t12 := pack 0x2::GlobalVectors::T<u64>($t11)
                    {
                        let $mem := $Malloc(32)
                        $MemoryStoreU256(add($mem, 0), $t11)
                        $t12 := $mem
                    }
                    // move_to<0x2::GlobalVectors::T<u64>>($t12, $t10)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $LoadU256($t10))
                        if $AlignedStorageLoad($base_offset) {
                          $AbortBuiltin()
                        }
                        $AlignedStorageStore($base_offset, true)
                        {
                            let $dst := add($base_offset, 32)
                            let $src := $t12
                            {
                                let $linked_src_814019441 := mload(add($src, 0))
                                let $linked_dst_814019441 := $NewLinkedStorageBase(0x3084f371)
                                let $size_814019441 := $MemoryLoadU64($linked_src_814019441)
                                let $data_size_814019441 := mul($size_814019441, 8)
                                $AlignedStorageStore($linked_dst_814019441, mload($linked_src_814019441))
                                let $data_src_814019441 := add($linked_src_814019441, 32)
                                let $data_dst_814019441 := add($linked_dst_814019441, 32)
                                for { let $offs_814019441 := 0 } lt($offs_814019441, $data_size_814019441) { $offs_814019441 := add($offs_814019441, 32)} {
                                    $AlignedStorageStore(add($data_dst_814019441, $offs_814019441), mload(add($data_src_814019441, $offs_814019441)))
                                    $Free($linked_src_814019441, add($data_size_814019441, 32))
                                }
                                $AlignedStorageStore(add($dst, 0), $linked_dst_814019441)
                            }
                            $Free($src, 32)
                        }
                    }
                    // $t13 := 0x42
                    $t13 := 0x42
                    // $t14 := move_from<0x2::GlobalVectors::T<u64>>($t13)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $t13)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $AlignedStorageStore($base_offset, false)
                        {
                            let $src := add($base_offset, 32)
                            let $dst
                            $dst := $Malloc(32)
                            {
                                let $linked_src_814019441 := $AlignedStorageLoad(add($src, 0))
                                let $linked_dst_814019441
                                let $size_814019441 := $StorageLoadU64($linked_src_814019441)
                                let $capacity_814019441 := $ClosestGreaterPowerOfTwo($size_814019441)
                                $linked_dst_814019441 := $Malloc(add(32, mul($capacity_814019441, 8)))
                                let $data_size_814019441 := mul($size_814019441, 8)
                                mstore($linked_dst_814019441, $AlignedStorageLoad($linked_src_814019441))
                                $MemoryStoreU64(add($linked_dst_814019441, 8), $capacity_814019441)
                                let $data_src_814019441 := add($linked_src_814019441, 32)
                                let $data_dst_814019441 := add($linked_dst_814019441, 32)
                                for { let $offs_814019441 := 0 } lt($offs_814019441, $data_size_814019441) { $offs_814019441 := add($offs_814019441, 32)} {
                                    mstore(add($data_dst_814019441, $offs_814019441), $AlignedStorageLoad(add($data_src_814019441, $offs_814019441)))
                                    $AlignedStorageStore(add($data_src_814019441, $offs_814019441), 0)
                                }
                                mstore(add($dst, 0), $linked_dst_814019441)
                                $AlignedStorageStore(add($src, 0), 0)
                            }
                            $t14 := $dst
                        }
                    }
                    // $t2 := unpack 0x2::GlobalVectors::T<u64>($t14)
                    mstore(add($locals, 64), $MemoryLoadU256(add($t14, 0)))
                    $Free($t14, 32)
                    // $t15 := borrow_local($t2)
                    $t15 := $MakePtr(false, add($locals, 64))
                    // $t16 := vector::length<u64>($t15)
                    $t16 := A1_vector_length$u64$($t15)
                    // $t17 := 3
                    $t17 := 3
                    // $t18 := ==($t16, $t17)
                    $t18 := $Eq($t16, $t17)
                    // if ($t18) goto L1 else goto L0
                    switch $t18
                    case 0  { $block := 3 }
                    default { $block := 2 }
                }
                case 5 {
                    // label L2
                    // $t20 := borrow_local($t2)
                    $t20 := $MakePtr(false, add($locals, 64))
                    // $t21 := 0
                    $t21 := 0
                    // $t22 := vector::borrow<u64>($t20, $t21)
                    $t22 := A1_vector_borrow$u64$($t20, $t21)
                    // $t23 := read_ref($t22)
                    $t23 := $LoadU64($t22)
                    // $t24 := 10
                    $t24 := 10
                    // $t25 := ==($t23, $t24)
                    $t25 := $Eq($t23, $t24)
                    // if ($t25) goto L4 else goto L3
                    switch $t25
                    case 0  { $block := 7 }
                    default { $block := 6 }
                }
                case 6 {
                    // label L4
                    // goto L5
                    $block := 8
                }
                case 7 {
                    // label L3
                    // $t26 := 102
                    $t26 := 102
                    // abort($t26)
                    $Abort($t26)
                }
                case 8 {
                    // label L5
                    // $t27 := borrow_local($t2)
                    $t27 := $MakePtr(false, add($locals, 64))
                    // $t28 := 1
                    $t28 := 1
                    // $t29 := vector::borrow<u64>($t27, $t28)
                    $t29 := A1_vector_borrow$u64$($t27, $t28)
                    // $t30 := read_ref($t29)
                    $t30 := $LoadU64($t29)
                    // $t31 := 11
                    $t31 := 11
                    // $t32 := ==($t30, $t31)
                    $t32 := $Eq($t30, $t31)
                    // if ($t32) goto L7 else goto L6
                    switch $t32
                    case 0  { $block := 10 }
                    default { $block := 9 }
                }
                case 9 {
                    // label L7
                    // goto L8
                    $block := 11
                }
                case 10 {
                    // label L6
                    // $t33 := 103
                    $t33 := 103
                    // abort($t33)
                    $Abort($t33)
                }
                case 11 {
                    // label L8
                    // $t34 := borrow_local($t2)
                    $t34 := $MakePtr(false, add($locals, 64))
                    // $t35 := 2
                    $t35 := 2
                    // $t36 := vector::borrow<u64>($t34, $t35)
                    $t36 := A1_vector_borrow$u64$($t34, $t35)
                    // $t37 := read_ref($t36)
                    $t37 := $LoadU64($t36)
                    // $t38 := 12
                    $t38 := 12
                    // $t39 := ==($t37, $t38)
                    $t39 := $Eq($t37, $t38)
                    // if ($t39) goto L10 else goto L9
                    switch $t39
                    case 0  { $block := 13 }
                    default { $block := 12 }
                }
                case 12 {
                    // label L10
                    // goto L11
                    $block := 14
                }
                case 13 {
                    // label L9
                    // $t40 := 104
                    $t40 := 104
                    // abort($t40)
                    $Abort($t40)
                }
                case 14 {
                    // label L11
                    // $t41 := borrow_local($t2)
                    $t41 := $MakePtr(false, add($locals, 64))
                    // $t42 := 13
                    $t42 := 13
                    // vector::push_back<u64>($t41, $t42)
                    A1_vector_push_back$u64$($t41, $t42)
                    // $t43 := borrow_local($t2)
                    $t43 := $MakePtr(false, add($locals, 64))
                    // $t44 := 14
                    $t44 := 14
                    // vector::push_back<u64>($t43, $t44)
                    A1_vector_push_back$u64$($t43, $t44)
                    // $t45 := borrow_local($t2)
                    $t45 := $MakePtr(false, add($locals, 64))
                    // $t46 := 3
                    $t46 := 3
                    // $t47 := vector::borrow<u64>($t45, $t46)
                    $t47 := A1_vector_borrow$u64$($t45, $t46)
                    // $t48 := read_ref($t47)
                    $t48 := $LoadU64($t47)
                    // $t49 := 13
                    $t49 := 13
                    // $t50 := ==($t48, $t49)
                    $t50 := $Eq($t48, $t49)
                    // if ($t50) goto L13 else goto L12
                    switch $t50
                    case 0  { $block := 16 }
                    default { $block := 15 }
                }
                case 15 {
                    // label L13
                    // goto L14
                    $block := 17
                }
                case 16 {
                    // label L12
                    // $t51 := 105
                    $t51 := 105
                    // abort($t51)
                    $Abort($t51)
                }
                case 17 {
                    // label L14
                    // $t52 := borrow_local($t2)
                    $t52 := $MakePtr(false, add($locals, 64))
                    // $t53 := 4
                    $t53 := 4
                    // $t54 := vector::borrow<u64>($t52, $t53)
                    $t54 := A1_vector_borrow$u64$($t52, $t53)
                    // $t55 := read_ref($t54)
                    $t55 := $LoadU64($t54)
                    // $t56 := 14
                    $t56 := 14
                    // $t57 := ==($t55, $t56)
                    $t57 := $Eq($t55, $t56)
                    // if ($t57) goto L16 else goto L15
                    switch $t57
                    case 0  { $block := 19 }
                    default { $block := 18 }
                }
                case 18 {
                    // label L16
                    // goto L17
                    $block := 20
                }
                case 19 {
                    // label L15
                    // $t58 := 106
                    $t58 := 106
                    // abort($t58)
                    $Abort($t58)
                }
                case 20 {
                    // label L17
                    // return ()
                    $Free($locals, 96)
                    leave
                }
            }
        }

        function A1_vector_borrow$u64$(v_ref, i) -> e_ptr {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            if $GtEq(i, size) { $AbortBuiltin() }
            e_ptr := $IndexPtr(v_ptr, add(32, mul(i, 8)))
        }
        function A1_vector_push_back$u64$(v_ref, e) {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            let e_ptr := $IndexPtr(v_ptr, add(32, mul(size, 8)))
            $StoreU64(e_ptr, e)
            size := add(size, 1)
            $StoreU64(v_ptr, size)
            let capacity := $LoadU64($IndexPtr(v_ptr, 8))
            if and(iszero($IsStoragePtr(v_ptr)), eq(size, capacity)) {
                let new_v_offs := $ResizeVector(v_offs, capacity, 8)
                $StoreU256(v_ref, new_v_offs)
            }
        }
        function A1_vector_length$u64$(v_ref) -> len {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            len := $LoadU64(v_ptr)
        }
        function A2_Evm_sign(addr) -> signer {
          signer := addr
        }
        function A1_vector_empty$u64$() -> vector {
            vector := $Malloc(48)
            $MemoryStoreU64(add(vector, 8), 2)
        }
        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Malloc(size) -> offs {
            offs := mload(0)
            // pad to word size
            mstore(0, add(offs, shl(5, shr(5, add(size, 31)))))
        }
        function $Free(offs, size) {
        }
        function $MakePtr(is_storage, offs) -> ptr {
          ptr := or(is_storage, shl(1, offs))
        }
        function $IsStoragePtr(ptr) -> b {
          b := and(ptr, 0x1)
        }
        function $OffsetPtr(ptr) -> offs {
          offs := shr(1, ptr)
        }
        function $MaskForSize(size) -> mask {
          mask := sub(shl(shl(3, size), 1), 1)
        }
        function $ExtractBytes(word, start, size) -> bytes {
           switch size
           case 1 {
              // use the faster byte primitive
              bytes := byte(start, word)
           }
           default {
              // As we have big endian, we need to right shift the value from
              // where the highest byte starts in the word (32 - start), minus
              // the size.
              let shift_bits := shl(3, sub(sub(32, start), size))
              bytes := and(shr(shift_bits, word), $MaskForSize(size))
           }
        }
        function $InjectBytes(word, start, size, bytes) -> new_word {
           let shift_bits := shl(3, sub(sub(32, start), size))
           // Blend out the bits which we inject
           let neg_mask := not(shl(shift_bits, $MaskForSize(size)))
           word := and(word, neg_mask)
           // Overlay the bits we inject
           new_word := or(word, shl(shift_bits, bytes))
        }
        function $ToWordOffs(offs) -> word_offs, byte_offset {
          word_offs := shr(5, offs)
          byte_offset := and(offs, 0x1F)
        }
        function $OverflowBytes(byte_offset, size) -> overflow_bytes {
          let available_bytes := sub(32, byte_offset)
          switch gt(size, available_bytes)
          case 0 {
            overflow_bytes := 0
          }
          default {
            overflow_bytes := sub(size, available_bytes)
          }
        }
        function $MemoryLoadBytes(offs, size) -> val {
          // Lower bit where the value in the higher bytes ends
          let bit_end := shl(3, sub(32, size))
          val := shr(bit_end, mload(offs))
        }
        function $MemoryStoreBytes(offs, size, val) {
          let bit_end := shl(3, sub(32, size))
          let mask := shl(bit_end, $MaskForSize(size))
          mstore(offs, or(and(mload(offs), not(mask)), shl(bit_end, val)))
        }
        function $StorageLoadBytes(offs, size) -> val {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          val := $ExtractBytes(sload(key), byte_offs, size)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          if $LogicalNot(iszero(overflow_bytes)) {
            key := $StorageKey(0, add(word_offs, 1))
            let extra_bytes := $ExtractBytes(sload(key), 0, overflow_bytes)
            val := or(shl(shl(3, overflow_bytes), val), extra_bytes)
          }
        }
        function $StorageStoreBytes(offs, size, bytes) {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          switch overflow_bytes
          case 0 {
            sstore(key, $InjectBytes(sload(key), byte_offs, size, bytes))
          }
          default {
            // Shift the higher bytes to the right
            let used_bytes := sub(size, overflow_bytes)
            let higher_bytes := shr(used_bytes, bytes)
            let lower_bytes := and(bytes, $MaskForSize(overflow_bytes))
            sstore(key, $InjectBytes(sload(key), byte_offs, used_bytes, higher_bytes))
            key := $StorageKey(0, add(word_offs, 1))
            sstore(key, $InjectBytes(sload(key), 0, overflow_bytes, lower_bytes))
          }
        }
        function $StorageKey(group, word) -> key {
          mstore(32, word)
          mstore(64, shl(224, group))
          key := keccak256(32, 36)
        }
        function $MakeTypeStorageBase(category, type_hash, id) -> offs {
          offs := or(shl(252, category), or(shl(220, type_hash), shl(60, id)))
        }
        function $NewLinkedStorageBase(type_hash) -> offs {
          let key := $StorageKey(1, 1)
          let handle := sload(key)
          sstore(key, add(handle, 1))
          offs := $MakeTypeStorageBase(1, type_hash, handle)
        }
        function $IndexPtr(ptr, offs) -> new_ptr {
          new_ptr := $MakePtr($IsStoragePtr(ptr), add($OffsetPtr(ptr), offs))
        }
        function $LoadU64(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU64(offs)
          }
          default {
            val := $StorageLoadU64(offs)
          }
        }
        function $MemoryLoadU64(offs) -> val {
          val := $MemoryLoadBytes(offs, 8)
        }
        function $StorageLoadU64(offs) -> val {
          val := $StorageLoadBytes(offs, 8)
        }
        function $StoreU64(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU64(offs, val)
          }
          default {
            $StorageStoreU64(offs, val)
          }
        }
        function $MemoryStoreU64(offs, val) {
          $MemoryStoreBytes(offs, 8, val)
        }
        function $StorageStoreU64(offs, val) {
          $StorageStoreBytes(offs, 8, val)
        }
        function $LoadU256(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU256(offs)
          }
          default {
            val := $StorageLoadU256(offs)
          }
        }
        function $MemoryLoadU256(offs) -> val {
          val := $MemoryLoadBytes(offs, 32)
        }
        function $StorageLoadU256(offs) -> val {
          val := $StorageLoadBytes(offs, 32)
        }
        function $StoreU256(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU256(offs, val)
          }
          default {
            $StorageStoreU256(offs, val)
          }
        }
        function $MemoryStoreU256(offs, val) {
          $MemoryStoreBytes(offs, 32, val)
        }
        function $StorageStoreU256(offs, val) {
          $StorageStoreBytes(offs, 32, val)
        }
        function $AlignedStorageLoad(offs) -> val {
          let word_offs := shr(5, offs)
          val := sload($StorageKey(0, word_offs))
        }
        function $AlignedStorageStore(offs, val) {
          let word_offs := shr(5, offs)
          sstore($StorageKey(0, word_offs), val)
        }
        function $CopyMemory(src, dst, size) {
          let num_words, overflow_bytes := $ToWordOffs(size)
          let i := 0
          for { } lt(i, mul(num_words, 32)) { i := add(i, 32) } {
            mstore(add(dst, i), mload(add(src, i)))
          }
          if overflow_bytes {
            let mask := $MaskForSize(sub(32, overflow_bytes))
            let overflow_offs := mul(num_words, 32)
            let dst_word := and(mload(add(dst, overflow_offs)), mask)
            let src_word := and(mload(add(src, overflow_offs)), not(mask))
            mstore(add(dst, overflow_offs), or(dst_word, src_word))
          }
        }
        function $ResizeVector(v_offs, capacity, type_size) -> new_v_offs {
            let new_capacity := mul(capacity, 2)
            let data_size := add(32, mul(capacity, type_size))
            let new_data_size := add(32, mul(new_capacity, type_size))
            new_v_offs := $Malloc(new_data_size)
            $CopyMemory(v_offs, new_v_offs, data_size)
            // update capacity at new location
            $MemoryStoreU64(add(new_v_offs, 8), new_capacity)
            $Free(v_offs, data_size)
        }
        function $GtEq(x, y) -> r {
            r := or(gt(x, y), eq(x, y))
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
        function $LogicalNot(x) -> r {
            r := iszero(x)
        }
        function $ClosestGreaterPowerOfTwo(x) -> r {
            r := or(r, shr(1, x))
            r := or(r, shr(2, r))
            r := or(r, shr(4, r))
            r := or(r, shr(8, r))
            r := or(r, shr(16, r))
            r := or(r, shr(32, r))
            r := add(x, 1)
        }
    }
}
===> Test result of GlobalVectors::test_move_from: Succeed(Stopped) (used_gas=98498): []

// test of GlobalVectors::test_move_from_vector_of_struct
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_GlobalVectors_test_move_from_vector_of_struct" {
    code {
        mstore(0, memoryguard(160))
        A2_GlobalVectors_test_move_from_vector_of_struct()
        return (0, 0)
        function A2_GlobalVectors_test_move_from_vector_of_struct() {
            let local_t, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27, $t28, $t29, $t30, $t31, $t32, $t33, $t34, $t35, $t36, $t37, $t38, $t39, $t40, $t41, $t42, $t43, $t44, $t45, $t46, $t47, $t48, $t49, $t50, $t51, $t52
            let $locals := $Malloc(64)
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // goto L2
                    $block := 5
                }
                case 3 {
                    // label L0
                    // $t25 := 101
                    $t25 := 101
                    // abort($t25)
                    $Abort($t25)
                }
                case 4 {
                    // $t2 := vector::empty<0x2::GlobalVectors::S>()
                    mstore($locals, A1_vector_empty$A2_GlobalVectors_S$())
                    // $t3 := borrow_local($t2)
                    $t3 := $MakePtr(false, $locals)
                    // $t4 := 10
                    $t4 := 10
                    // $t5 := 40
                    $t5 := 40
                    // $t6 := pack 0x2::GlobalVectors::S($t4, $t5)
                    {
                        let $mem := $Malloc(24)
                        $MemoryStoreU128(add($mem, 0), $t4)
                        $MemoryStoreU64(add($mem, 16), $t5)
                        $t6 := $mem
                    }
                    // vector::push_back<0x2::GlobalVectors::S>($t3, $t6)
                    A1_vector_push_back$A2_GlobalVectors_S$($t3, $t6)
                    // $t7 := borrow_local($t2)
                    $t7 := $MakePtr(false, $locals)
                    // $t8 := 11
                    $t8 := 11
                    // $t9 := 41
                    $t9 := 41
                    // $t10 := pack 0x2::GlobalVectors::S($t8, $t9)
                    {
                        let $mem := $Malloc(24)
                        $MemoryStoreU128(add($mem, 0), $t8)
                        $MemoryStoreU64(add($mem, 16), $t9)
                        $t10 := $mem
                    }
                    // vector::push_back<0x2::GlobalVectors::S>($t7, $t10)
                    A1_vector_push_back$A2_GlobalVectors_S$($t7, $t10)
                    // $t11 := borrow_local($t2)
                    $t11 := $MakePtr(false, $locals)
                    // $t12 := 12
                    $t12 := 12
                    // $t13 := 42
                    $t13 := 42
                    // $t14 := pack 0x2::GlobalVectors::S($t12, $t13)
                    {
                        let $mem := $Malloc(24)
                        $MemoryStoreU128(add($mem, 0), $t12)
                        $MemoryStoreU64(add($mem, 16), $t13)
                        $t14 := $mem
                    }
                    // vector::push_back<0x2::GlobalVectors::S>($t11, $t14)
                    A1_vector_push_back$A2_GlobalVectors_S$($t11, $t14)
                    // $t15 := 0x42
                    $t15 := 0x42
                    // $t0 := Evm::sign($t15)
                    mstore(add($locals, 32), A2_Evm_sign($t15))
                    // $t16 := borrow_local($t0)
                    $t16 := $MakePtr(false, add($locals, 32))
                    // $t17 := move($t2)
                    $t17 := mload($locals)
                    // $t18 := pack 0x2::GlobalVectors::T<0x2::GlobalVectors::S>($t17)
                    {
                        let $mem := $Malloc(32)
                        $MemoryStoreU256(add($mem, 0), $t17)
                        $t18 := $mem
                    }
                    // move_to<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>($t18, $t16)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x27c9b6b7, $LoadU256($t16))
                        if $AlignedStorageLoad($base_offset) {
                          $AbortBuiltin()
                        }
                        $AlignedStorageStore($base_offset, true)
                        {
                            let $dst := add($base_offset, 32)
                            let $src := $t18
                            {
                                let $linked_src_634259357 := mload(add($src, 0))
                                let $linked_dst_634259357 := $NewLinkedStorageBase(0x25ce079d)
                                let $size_634259357 := $MemoryLoadU64($linked_src_634259357)
                                let $data_size_634259357 := mul($size_634259357, 32)
                                $AlignedStorageStore($linked_dst_634259357, mload($linked_src_634259357))
                                let $data_src_634259357 := add($linked_src_634259357, 32)
                                let $data_dst_634259357 := add($linked_dst_634259357, 32)
                                for { let $offs_634259357 := 0 } lt($offs_634259357, $data_size_634259357) { $offs_634259357 := add($offs_634259357, 32)} {
                                    {
                                        let $linked_src_3681206257 := mload(add($offs_634259357, $data_src_634259357))
                                        let $linked_dst_3681206257 := $NewLinkedStorageBase(0xdb6abff1)
                                        $AlignedStorageStore(add($linked_dst_3681206257, 0), mload(add($linked_src_3681206257, 0)))
                                        $Free($linked_src_3681206257, 24)
                                        $AlignedStorageStore(add($data_dst_634259357, $offs_634259357), $linked_dst_3681206257)
                                    }
                                    $Free($linked_src_634259357, add($data_size_634259357, 32))
                                }
                                $AlignedStorageStore(add($dst, 0), $linked_dst_634259357)
                            }
                            $Free($src, 32)
                        }
                    }
                    // $t19 := 0x42
                    $t19 := 0x42
                    // $t1 := move_from<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>($t19)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x27c9b6b7, $t19)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $AlignedStorageStore($base_offset, false)
                        {
                            let $src := add($base_offset, 32)
                            let $dst
                            $dst := $Malloc(32)
                            {
                                let $linked_src_634259357 := $AlignedStorageLoad(add($src, 0))
                                let $linked_dst_634259357
                                let $size_634259357 := $StorageLoadU64($linked_src_634259357)
                                let $capacity_634259357 := $ClosestGreaterPowerOfTwo($size_634259357)
                                $linked_dst_634259357 := $Malloc(add(32, mul($capacity_634259357, 32)))
                                let $data_size_634259357 := mul($size_634259357, 32)
                                mstore($linked_dst_634259357, $AlignedStorageLoad($linked_src_634259357))
                                $MemoryStoreU64(add($linked_dst_634259357, 8), $capacity_634259357)
                                let $data_src_634259357 := add($linked_src_634259357, 32)
                                let $data_dst_634259357 := add($linked_dst_634259357, 32)
                                for { let $offs_634259357 := 0 } lt($offs_634259357, $data_size_634259357) { $offs_634259357 := add($offs_634259357, 32)} {
                                    {
                                        let $linked_src_3681206257 := $AlignedStorageLoad(add($data_src_634259357, $offs_634259357))
                                        let $linked_dst_3681206257
                                        $linked_dst_3681206257 := $Malloc(24)
                                        mstore(add($linked_dst_3681206257, 0), $AlignedStorageLoad(add($linked_src_3681206257, 0)))
                                        $AlignedStorageStore(add($linked_src_3681206257, 0), 0)
                                        mstore(add($data_dst_634259357, $offs_634259357), $linked_dst_3681206257)
                                        $AlignedStorageStore(add($data_src_634259357, $offs_634259357), 0)
                                    }
                                }
                                mstore(add($dst, 0), $linked_dst_634259357)
                                $AlignedStorageStore(add($src, 0), 0)
                            }
                            local_t := $dst
                        }
                    }
                    // $t20 := borrow_local($t1)
                    $t20 := $MakePtr(false, local_t)
                    // $t21 := borrow_field<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>.v($t20)
                    $t21 := $t20
                    // $t22 := vector::length<0x2::GlobalVectors::S>($t21)
                    $t22 := A1_vector_length$A2_GlobalVectors_S$($t21)
                    // $t23 := 3
                    $t23 := 3
                    // $t24 := ==($t22, $t23)
                    $t24 := $Eq($t22, $t23)
                    // if ($t24) goto L1 else goto L0
                    switch $t24
                    case 0  { $block := 3 }
                    default { $block := 2 }
                }
                case 5 {
                    // label L2
                    // $t26 := borrow_local($t1)
                    $t26 := $MakePtr(false, local_t)
                    // $t27 := borrow_field<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>.v($t26)
                    $t27 := $t26
                    // $t28 := 0
                    $t28 := 0
                    // $t29 := vector::borrow<0x2::GlobalVectors::S>($t27, $t28)
                    $t29 := A1_vector_borrow$A2_GlobalVectors_S$($t27, $t28)
                    // $t30 := borrow_field<0x2::GlobalVectors::S>.x($t29)
                    $t30 := $t29
                    // $t31 := read_ref($t30)
                    $t31 := $LoadU128($t30)
                    // $t32 := 10
                    $t32 := 10
                    // $t33 := ==($t31, $t32)
                    $t33 := $Eq($t31, $t32)
                    // if ($t33) goto L4 else goto L3
                    switch $t33
                    case 0  { $block := 7 }
                    default { $block := 6 }
                }
                case 6 {
                    // label L4
                    // goto L5
                    $block := 8
                }
                case 7 {
                    // label L3
                    // $t34 := 102
                    $t34 := 102
                    // abort($t34)
                    $Abort($t34)
                }
                case 8 {
                    // label L5
                    // $t35 := borrow_local($t1)
                    $t35 := $MakePtr(false, local_t)
                    // $t36 := borrow_field<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>.v($t35)
                    $t36 := $t35
                    // $t37 := 1
                    $t37 := 1
                    // $t38 := vector::borrow<0x2::GlobalVectors::S>($t36, $t37)
                    $t38 := A1_vector_borrow$A2_GlobalVectors_S$($t36, $t37)
                    // $t39 := borrow_field<0x2::GlobalVectors::S>.x($t38)
                    $t39 := $t38
                    // $t40 := read_ref($t39)
                    $t40 := $LoadU128($t39)
                    // $t41 := 11
                    $t41 := 11
                    // $t42 := ==($t40, $t41)
                    $t42 := $Eq($t40, $t41)
                    // if ($t42) goto L7 else goto L6
                    switch $t42
                    case 0  { $block := 10 }
                    default { $block := 9 }
                }
                case 9 {
                    // label L7
                    // goto L8
                    $block := 11
                }
                case 10 {
                    // label L6
                    // $t43 := 103
                    $t43 := 103
                    // abort($t43)
                    $Abort($t43)
                }
                case 11 {
                    // label L8
                    // $t44 := borrow_local($t1)
                    $t44 := $MakePtr(false, local_t)
                    // $t45 := borrow_field<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>.v($t44)
                    $t45 := $t44
                    // $t46 := 2
                    $t46 := 2
                    // $t47 := vector::borrow<0x2::GlobalVectors::S>($t45, $t46)
                    $t47 := A1_vector_borrow$A2_GlobalVectors_S$($t45, $t46)
                    // $t48 := borrow_field<0x2::GlobalVectors::S>.x($t47)
                    $t48 := $t47
                    // $t49 := read_ref($t48)
                    $t49 := $LoadU128($t48)
                    // $t50 := 12
                    $t50 := 12
                    // $t51 := ==($t49, $t50)
                    $t51 := $Eq($t49, $t50)
                    // if ($t51) goto L10 else goto L9
                    switch $t51
                    case 0  { $block := 13 }
                    default { $block := 12 }
                }
                case 12 {
                    // label L10
                    // goto L11
                    $block := 14
                }
                case 13 {
                    // label L9
                    // $t52 := 104
                    $t52 := 104
                    // abort($t52)
                    $Abort($t52)
                }
                case 14 {
                    // label L11
                    // return ()
                    $Free($locals, 64)
                    leave
                }
            }
        }

        function A1_vector_borrow$A2_GlobalVectors_S$(v_ref, i) -> e_ptr {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            if $GtEq(i, size) { $AbortBuiltin() }
            e_ptr := $IndexPtr(v_ptr, add(32, mul(i, 32)))
            let e := $LoadU256(e_ptr)
            e_ptr := $MakePtr($IsStoragePtr(v_ref), e)
        }
        function A1_vector_length$A2_GlobalVectors_S$(v_ref) -> len {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            len := $LoadU64(v_ptr)
        }
        function A2_Evm_sign(addr) -> signer {
          signer := addr
        }
        function A1_vector_push_back$A2_GlobalVectors_S$(v_ref, e) {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            let e_ptr := $IndexPtr(v_ptr, add(32, mul(size, 32)))
            $StoreU256(e_ptr, e)
            if $IsStoragePtr(e_ptr) {
                let e_offs := $OffsetPtr(e_ptr)
                let $linked_dst_3681206257 := $NewLinkedStorageBase(0xdb6abff1)
                $AlignedStorageStore(add($linked_dst_3681206257, 0), mload(add(e, 0)))
                $Free(e, 24)
                $AlignedStorageStore(e_offs, $linked_dst_3681206257)
            }
            size := add(size, 1)
            $StoreU64(v_ptr, size)
            let capacity := $LoadU64($IndexPtr(v_ptr, 8))
            if and(iszero($IsStoragePtr(v_ptr)), eq(size, capacity)) {
                let new_v_offs := $ResizeVector(v_offs, capacity, 32)
                $StoreU256(v_ref, new_v_offs)
            }
        }
        function A1_vector_empty$A2_GlobalVectors_S$() -> vector {
            vector := $Malloc(96)
            $MemoryStoreU64(add(vector, 8), 2)
        }
        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Malloc(size) -> offs {
            offs := mload(0)
            // pad to word size
            mstore(0, add(offs, shl(5, shr(5, add(size, 31)))))
        }
        function $Free(offs, size) {
        }
        function $MakePtr(is_storage, offs) -> ptr {
          ptr := or(is_storage, shl(1, offs))
        }
        function $IsStoragePtr(ptr) -> b {
          b := and(ptr, 0x1)
        }
        function $OffsetPtr(ptr) -> offs {
          offs := shr(1, ptr)
        }
        function $MaskForSize(size) -> mask {
          mask := sub(shl(shl(3, size), 1), 1)
        }
        function $ExtractBytes(word, start, size) -> bytes {
           switch size
           case 1 {
              // use the faster byte primitive
              bytes := byte(start, word)
           }
           default {
              // As we have big endian, we need to right shift the value from
              // where the highest byte starts in the word (32 - start), minus
              // the size.
              let shift_bits := shl(3, sub(sub(32, start), size))
              bytes := and(shr(shift_bits, word), $MaskForSize(size))
           }
        }
        function $InjectBytes(word, start, size, bytes) -> new_word {
           let shift_bits := shl(3, sub(sub(32, start), size))
           // Blend out the bits which we inject
           let neg_mask := not(shl(shift_bits, $MaskForSize(size)))
           word := and(word, neg_mask)
           // Overlay the bits we inject
           new_word := or(word, shl(shift_bits, bytes))
        }
        function $ToWordOffs(offs) -> word_offs, byte_offset {
          word_offs := shr(5, offs)
          byte_offset := and(offs, 0x1F)
        }
        function $OverflowBytes(byte_offset, size) -> overflow_bytes {
          let available_bytes := sub(32, byte_offset)
          switch gt(size, available_bytes)
          case 0 {
            overflow_bytes := 0
          }
          default {
            overflow_bytes := sub(size, available_bytes)
          }
        }
        function $MemoryLoadBytes(offs, size) -> val {
          // Lower bit where the value in the higher bytes ends
          let bit_end := shl(3, sub(32, size))
          val := shr(bit_end, mload(offs))
        }
        function $MemoryStoreBytes(offs, size, val) {
          let bit_end := shl(3, sub(32, size))
          let mask := shl(bit_end, $MaskForSize(size))
          mstore(offs, or(and(mload(offs), not(mask)), shl(bit_end, val)))
        }
        function $StorageLoadBytes(offs, size) -> val {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          val := $ExtractBytes(sload(key), byte_offs, size)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          if $LogicalNot(iszero(overflow_bytes)) {
            key := $StorageKey(0, add(word_offs, 1))
            let extra_bytes := $ExtractBytes(sload(key), 0, overflow_bytes)
            val := or(shl(shl(3, overflow_bytes), val), extra_bytes)
          }
        }
        function $StorageStoreBytes(offs, size, bytes) {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          switch overflow_bytes
          case 0 {
            sstore(key, $InjectBytes(sload(key), byte_offs, size, bytes))
          }
          default {
            // Shift the higher bytes to the right
            let used_bytes := sub(size, overflow_bytes)
            let higher_bytes := shr(used_bytes, bytes)
            let lower_bytes := and(bytes, $MaskForSize(overflow_bytes))
            sstore(key, $InjectBytes(sload(key), byte_offs, used_bytes, higher_bytes))
            key := $StorageKey(0, add(word_offs, 1))
            sstore(key, $InjectBytes(sload(key), 0, overflow_bytes, lower_bytes))
          }
        }
        function $StorageKey(group, word) -> key {
          mstore(32, word)
          mstore(64, shl(224, group))
          key := keccak256(32, 36)
        }
        function $MakeTypeStorageBase(category, type_hash, id) -> offs {
          offs := or(shl(252, category), or(shl(220, type_hash), shl(60, id)))
        }
        function $NewLinkedStorageBase(type_hash) -> offs {
          let key := $StorageKey(1, 1)
          let handle := sload(key)
          sstore(key, add(handle, 1))
          offs := $MakeTypeStorageBase(1, type_hash, handle)
        }
        function $IndexPtr(ptr, offs) -> new_ptr {
          new_ptr := $MakePtr($IsStoragePtr(ptr), add($OffsetPtr(ptr), offs))
        }
        function $LoadU64(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU64(offs)
          }
          default {
            val := $StorageLoadU64(offs)
          }
        }
        function $MemoryLoadU64(offs) -> val {
          val := $MemoryLoadBytes(offs, 8)
        }
        function $StorageLoadU64(offs) -> val {
          val := $StorageLoadBytes(offs, 8)
        }
        function $StoreU64(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU64(offs, val)
          }
          default {
            $StorageStoreU64(offs, val)
          }
        }
        function $MemoryStoreU64(offs, val) {
          $MemoryStoreBytes(offs, 8, val)
        }
        function $StorageStoreU64(offs, val) {
          $StorageStoreBytes(offs, 8, val)
        }
        function $LoadU128(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU128(offs)
          }
          default {
            val := $StorageLoadU128(offs)
          }
        }
        function $MemoryLoadU128(offs) -> val {
          val := $MemoryLoadBytes(offs, 16)
        }
        function $StorageLoadU128(offs) -> val {
          val := $StorageLoadBytes(offs, 16)
        }
        function $MemoryStoreU128(offs, val) {
          $MemoryStoreBytes(offs, 16, val)
        }
        function $LoadU256(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU256(offs)
          }
          default {
            val := $StorageLoadU256(offs)
          }
        }
        function $MemoryLoadU256(offs) -> val {
          val := $MemoryLoadBytes(offs, 32)
        }
        function $StorageLoadU256(offs) -> val {
          val := $StorageLoadBytes(offs, 32)
        }
        function $StoreU256(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU256(offs, val)
          }
          default {
            $StorageStoreU256(offs, val)
          }
        }
        function $MemoryStoreU256(offs, val) {
          $MemoryStoreBytes(offs, 32, val)
        }
        function $StorageStoreU256(offs, val) {
          $StorageStoreBytes(offs, 32, val)
        }
        function $AlignedStorageLoad(offs) -> val {
          let word_offs := shr(5, offs)
          val := sload($StorageKey(0, word_offs))
        }
        function $AlignedStorageStore(offs, val) {
          let word_offs := shr(5, offs)
          sstore($StorageKey(0, word_offs), val)
        }
        function $CopyMemory(src, dst, size) {
          let num_words, overflow_bytes := $ToWordOffs(size)
          let i := 0
          for { } lt(i, mul(num_words, 32)) { i := add(i, 32) } {
            mstore(add(dst, i), mload(add(src, i)))
          }
          if overflow_bytes {
            let mask := $MaskForSize(sub(32, overflow_bytes))
            let overflow_offs := mul(num_words, 32)
            let dst_word := and(mload(add(dst, overflow_offs)), mask)
            let src_word := and(mload(add(src, overflow_offs)), not(mask))
            mstore(add(dst, overflow_offs), or(dst_word, src_word))
          }
        }
        function $ResizeVector(v_offs, capacity, type_size) -> new_v_offs {
            let new_capacity := mul(capacity, 2)
            let data_size := add(32, mul(capacity, type_size))
            let new_data_size := add(32, mul(new_capacity, type_size))
            new_v_offs := $Malloc(new_data_size)
            $CopyMemory(v_offs, new_v_offs, data_size)
            // update capacity at new location
            $MemoryStoreU64(add(new_v_offs, 8), new_capacity)
            $Free(v_offs, data_size)
        }
        function $GtEq(x, y) -> r {
            r := or(gt(x, y), eq(x, y))
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
        function $LogicalNot(x) -> r {
            r := iszero(x)
        }
        function $ClosestGreaterPowerOfTwo(x) -> r {
            r := or(r, shr(1, x))
            r := or(r, shr(2, r))
            r := or(r, shr(4, r))
            r := or(r, shr(8, r))
            r := or(r, shr(16, r))
            r := or(r, shr(32, r))
            r := add(x, 1)
        }
    }
}
===> Test result of GlobalVectors::test_move_from_vector_of_struct: Succeed(Stopped) (used_gas=187040): []

// test of GlobalVectors::test_move_from_vector_of_vector
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_GlobalVectors_test_move_from_vector_of_vector" {
    code {
        mstore(0, memoryguard(160))
        A2_GlobalVectors_test_move_from_vector_of_vector()
        return (0, 0)
        function A2_GlobalVectors_test_move_from_vector_of_vector() {
            let local_t, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27, $t28, $t29, $t30, $t31, $t32, $t33, $t34, $t35, $t36, $t37, $t38, $t39, $t40, $t41, $t42, $t43, $t44, $t45, $t46, $t47, $t48, $t49, $t50, $t51, $t52
            let $locals := $Malloc(64)
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // goto L2
                    $block := 5
                }
                case 3 {
                    // label L0
                    // $t22 := 101
                    $t22 := 101
                    // abort($t22)
                    $Abort($t22)
                }
                case 4 {
                    // $t2 := vector::empty<vector<u64>>()
                    mstore($locals, A1_vector_empty$vec$u64$$())
                    // $t3 := borrow_local($t2)
                    $t3 := $MakePtr(false, $locals)
                    // $t4 := 10
                    $t4 := 10
                    // $t5 := vector::singleton<u64>($t4)
                    $t5 := A1_vector_singleton$u64$($t4)
                    // vector::push_back<vector<u64>>($t3, $t5)
                    A1_vector_push_back$vec$u64$$($t3, $t5)
                    // $t6 := borrow_local($t2)
                    $t6 := $MakePtr(false, $locals)
                    // $t7 := 11
                    $t7 := 11
                    // $t8 := vector::singleton<u64>($t7)
                    $t8 := A1_vector_singleton$u64$($t7)
                    // vector::push_back<vector<u64>>($t6, $t8)
                    A1_vector_push_back$vec$u64$$($t6, $t8)
                    // $t9 := borrow_local($t2)
                    $t9 := $MakePtr(false, $locals)
                    // $t10 := 12
                    $t10 := 12
                    // $t11 := vector::singleton<u64>($t10)
                    $t11 := A1_vector_singleton$u64$($t10)
                    // vector::push_back<vector<u64>>($t9, $t11)
                    A1_vector_push_back$vec$u64$$($t9, $t11)
                    // $t12 := 0x42
                    $t12 := 0x42
                    // $t0 := Evm::sign($t12)
                    mstore(add($locals, 32), A2_Evm_sign($t12))
                    // $t13 := borrow_local($t0)
                    $t13 := $MakePtr(false, add($locals, 32))
                    // $t14 := move($t2)
                    $t14 := mload($locals)
                    // $t15 := pack 0x2::GlobalVectors::T<vector<u64>>($t14)
                    {
                        let $mem := $Malloc(32)
                        $MemoryStoreU256(add($mem, 0), $t14)
                        $t15 := $mem
                    }
                    // move_to<0x2::GlobalVectors::T<vector<u64>>>($t15, $t13)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x9947b477, $LoadU256($t13))
                        if $AlignedStorageLoad($base_offset) {
                          $AbortBuiltin()
                        }
                        $AlignedStorageStore($base_offset, true)
                        {
                            let $dst := add($base_offset, 32)
                            let $src := $t15
                            {
                                let $linked_src_3066871491 := mload(add($src, 0))
                                let $linked_dst_3066871491 := $NewLinkedStorageBase(0xb6ccbec3)
                                let $size_3066871491 := $MemoryLoadU64($linked_src_3066871491)
                                let $data_size_3066871491 := mul($size_3066871491, 32)
                                $AlignedStorageStore($linked_dst_3066871491, mload($linked_src_3066871491))
                                let $data_src_3066871491 := add($linked_src_3066871491, 32)
                                let $data_dst_3066871491 := add($linked_dst_3066871491, 32)
                                for { let $offs_3066871491 := 0 } lt($offs_3066871491, $data_size_3066871491) { $offs_3066871491 := add($offs_3066871491, 32)} {
                                    {
                                        let $linked_src_814019441 := mload(add($offs_3066871491, $data_src_3066871491))
                                        let $linked_dst_814019441 := $NewLinkedStorageBase(0x3084f371)
                                        let $size_814019441 := $MemoryLoadU64($linked_src_814019441)
                                        let $data_size_814019441 := mul($size_814019441, 8)
                                        $AlignedStorageStore($linked_dst_814019441, mload($linked_src_814019441))
                                        let $data_src_814019441 := add($linked_src_814019441, 32)
                                        let $data_dst_814019441 := add($linked_dst_814019441, 32)
                                        for { let $offs_814019441 := 0 } lt($offs_814019441, $data_size_814019441) { $offs_814019441 := add($offs_814019441, 32)} {
                                            $AlignedStorageStore(add($data_dst_814019441, $offs_814019441), mload(add($data_src_814019441, $offs_814019441)))
                                            $Free($linked_src_814019441, add($data_size_814019441, 32))
                                        }
                                        $AlignedStorageStore(add($data_dst_3066871491, $offs_3066871491), $linked_dst_814019441)
                                    }
                                    $Free($linked_src_3066871491, add($data_size_3066871491, 32))
                                }
                                $AlignedStorageStore(add($dst, 0), $linked_dst_3066871491)
                            }
                            $Free($src, 32)
                        }
                    }
                    // $t16 := 0x42
                    $t16 := 0x42
                    // $t1 := move_from<0x2::GlobalVectors::T<vector<u64>>>($t16)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x9947b477, $t16)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $AlignedStorageStore($base_offset, false)
                        {
                            let $src := add($base_offset, 32)
                            let $dst
                            $dst := $Malloc(32)
                            {
                                let $linked_src_3066871491 := $AlignedStorageLoad(add($src, 0))
                                let $linked_dst_3066871491
                                let $size_3066871491 := $StorageLoadU64($linked_src_3066871491)
                                let $capacity_3066871491 := $ClosestGreaterPowerOfTwo($size_3066871491)
                                $linked_dst_3066871491 := $Malloc(add(32, mul($capacity_3066871491, 32)))
                                let $data_size_3066871491 := mul($size_3066871491, 32)
                                mstore($linked_dst_3066871491, $AlignedStorageLoad($linked_src_3066871491))
                                $MemoryStoreU64(add($linked_dst_3066871491, 8), $capacity_3066871491)
                                let $data_src_3066871491 := add($linked_src_3066871491, 32)
                                let $data_dst_3066871491 := add($linked_dst_3066871491, 32)
                                for { let $offs_3066871491 := 0 } lt($offs_3066871491, $data_size_3066871491) { $offs_3066871491 := add($offs_3066871491, 32)} {
                                    {
                                        let $linked_src_814019441 := $AlignedStorageLoad(add($data_src_3066871491, $offs_3066871491))
                                        let $linked_dst_814019441
                                        let $size_814019441 := $StorageLoadU64($linked_src_814019441)
                                        let $capacity_814019441 := $ClosestGreaterPowerOfTwo($size_814019441)
                                        $linked_dst_814019441 := $Malloc(add(32, mul($capacity_814019441, 8)))
                                        let $data_size_814019441 := mul($size_814019441, 8)
                                        mstore($linked_dst_814019441, $AlignedStorageLoad($linked_src_814019441))
                                        $MemoryStoreU64(add($linked_dst_814019441, 8), $capacity_814019441)
                                        let $data_src_814019441 := add($linked_src_814019441, 32)
                                        let $data_dst_814019441 := add($linked_dst_814019441, 32)
                                        for { let $offs_814019441 := 0 } lt($offs_814019441, $data_size_814019441) { $offs_814019441 := add($offs_814019441, 32)} {
                                            mstore(add($data_dst_814019441, $offs_814019441), $AlignedStorageLoad(add($data_src_814019441, $offs_814019441)))
                                            $AlignedStorageStore(add($data_src_814019441, $offs_814019441), 0)
                                        }
                                        mstore(add($data_dst_3066871491, $offs_3066871491), $linked_dst_814019441)
                                        $AlignedStorageStore(add($data_src_3066871491, $offs_3066871491), 0)
                                    }
                                }
                                mstore(add($dst, 0), $linked_dst_3066871491)
                                $AlignedStorageStore(add($src, 0), 0)
                            }
                            local_t := $dst
                        }
                    }
                    // $t17 := borrow_local($t1)
                    $t17 := $MakePtr(false, local_t)
                    // $t18 := borrow_field<0x2::GlobalVectors::T<vector<u64>>>.v($t17)
                    $t18 := $t17
                    // $t19 := vector::length<vector<u64>>($t18)
                    $t19 := A1_vector_length$vec$u64$$($t18)
                    // $t20 := 3
                    $t20 := 3
                    // $t21 := ==($t19, $t20)
                    $t21 := $Eq($t19, $t20)
                    // if ($t21) goto L1 else goto L0
                    switch $t21
                    case 0  { $block := 3 }
                    default { $block := 2 }
                }
                case 5 {
                    // label L2
                    // $t23 := borrow_local($t1)
                    $t23 := $MakePtr(false, local_t)
                    // $t24 := borrow_field<0x2::GlobalVectors::T<vector<u64>>>.v($t23)
                    $t24 := $t23
                    // $t25 := 0
                    $t25 := 0
                    // $t26 := vector::borrow<vector<u64>>($t24, $t25)
                    $t26 := A1_vector_borrow$vec$u64$$($t24, $t25)
                    // $t27 := 0
                    $t27 := 0
                    // $t28 := vector::borrow<u64>($t26, $t27)
                    $t28 := A1_vector_borrow$u64$($t26, $t27)
                    // $t29 := read_ref($t28)
                    $t29 := $LoadU64($t28)
                    // $t30 := 10
                    $t30 := 10
                    // $t31 := ==($t29, $t30)
                    $t31 := $Eq($t29, $t30)
                    // if ($t31) goto L4 else goto L3
                    switch $t31
                    case 0  { $block := 7 }
                    default { $block := 6 }
                }
                case 6 {
                    // label L4
                    // goto L5
                    $block := 8
                }
                case 7 {
                    // label L3
                    // $t32 := 102
                    $t32 := 102
                    // abort($t32)
                    $Abort($t32)
                }
                case 8 {
                    // label L5
                    // $t33 := borrow_local($t1)
                    $t33 := $MakePtr(false, local_t)
                    // $t34 := borrow_field<0x2::GlobalVectors::T<vector<u64>>>.v($t33)
                    $t34 := $t33
                    // $t35 := 1
                    $t35 := 1
                    // $t36 := vector::borrow<vector<u64>>($t34, $t35)
                    $t36 := A1_vector_borrow$vec$u64$$($t34, $t35)
                    // $t37 := 0
                    $t37 := 0
                    // $t38 := vector::borrow<u64>($t36, $t37)
                    $t38 := A1_vector_borrow$u64$($t36, $t37)
                    // $t39 := read_ref($t38)
                    $t39 := $LoadU64($t38)
                    // $t40 := 11
                    $t40 := 11
                    // $t41 := ==($t39, $t40)
                    $t41 := $Eq($t39, $t40)
                    // if ($t41) goto L7 else goto L6
                    switch $t41
                    case 0  { $block := 10 }
                    default { $block := 9 }
                }
                case 9 {
                    // label L7
                    // goto L8
                    $block := 11
                }
                case 10 {
                    // label L6
                    // $t42 := 102
                    $t42 := 102
                    // abort($t42)
                    $Abort($t42)
                }
                case 11 {
                    // label L8
                    // $t43 := borrow_local($t1)
                    $t43 := $MakePtr(false, local_t)
                    // $t44 := borrow_field<0x2::GlobalVectors::T<vector<u64>>>.v($t43)
                    $t44 := $t43
                    // $t45 := 2
                    $t45 := 2
                    // $t46 := vector::borrow<vector<u64>>($t44, $t45)
                    $t46 := A1_vector_borrow$vec$u64$$($t44, $t45)
                    // $t47 := 0
                    $t47 := 0
                    // $t48 := vector::borrow<u64>($t46, $t47)
                    $t48 := A1_vector_borrow$u64$($t46, $t47)
                    // $t49 := read_ref($t48)
                    $t49 := $LoadU64($t48)
                    // $t50 := 12
                    $t50 := 12
                    // $t51 := ==($t49, $t50)
                    $t51 := $Eq($t49, $t50)
                    // if ($t51) goto L10 else goto L9
                    switch $t51
                    case 0  { $block := 13 }
                    default { $block := 12 }
                }
                case 12 {
                    // label L10
                    // goto L11
                    $block := 14
                }
                case 13 {
                    // label L9
                    // $t52 := 102
                    $t52 := 102
                    // abort($t52)
                    $Abort($t52)
                }
                case 14 {
                    // label L11
                    // return ()
                    $Free($locals, 64)
                    leave
                }
            }
        }

        function A1_vector_borrow$u64$(v_ref, i) -> e_ptr {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            if $GtEq(i, size) { $AbortBuiltin() }
            e_ptr := $IndexPtr(v_ptr, add(32, mul(i, 8)))
        }
        function A1_vector_borrow$vec$u64$$(v_ref, i) -> e_ptr {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            if $GtEq(i, size) { $AbortBuiltin() }
            e_ptr := $IndexPtr(v_ptr, add(32, mul(i, 32)))
        }
        function A1_vector_length$vec$u64$$(v_ref) -> len {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            len := $LoadU64(v_ptr)
        }
        function A2_Evm_sign(addr) -> signer {
          signer := addr
        }
        function A1_vector_push_back$vec$u64$$(v_ref, e) {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            let e_ptr := $IndexPtr(v_ptr, add(32, mul(size, 32)))
            $StoreU256(e_ptr, e)
            if $IsStoragePtr(e_ptr) {
                let e_offs := $OffsetPtr(e_ptr)
                let $linked_dst_814019441 := $NewLinkedStorageBase(0x3084f371)
                let $size_814019441 := $MemoryLoadU64(e)
                let $data_size_814019441 := mul($size_814019441, 8)
                $AlignedStorageStore($linked_dst_814019441, mload(e))
                let $data_src_814019441 := add(e, 32)
                let $data_dst_814019441 := add($linked_dst_814019441, 32)
                for { let $offs_814019441 := 0 } lt($offs_814019441, $data_size_814019441) { $offs_814019441 := add($offs_814019441, 32)} {
                    $AlignedStorageStore(add($data_dst_814019441, $offs_814019441), mload(add($data_src_814019441, $offs_814019441)))
                    $Free(e, add($data_size_814019441, 32))
                }
                $AlignedStorageStore(e_offs, $linked_dst_814019441)
            }
            size := add(size, 1)
            $StoreU64(v_ptr, size)
            let capacity := $LoadU64($IndexPtr(v_ptr, 8))
            if and(iszero($IsStoragePtr(v_ptr)), eq(size, capacity)) {
                let new_v_offs := $ResizeVector(v_offs, capacity, 32)
                $StoreU256(v_ref, new_v_offs)
            }
        }
        function A1_vector_singleton$u64$(e) -> $result {
            let $t2, $t3
            let $locals := $Malloc(32)
            // $t1 := vector::empty<#0>()
            mstore($locals, A1_vector_empty$u64$())
            // $t2 := borrow_local($t1)
            $t2 := $MakePtr(false, $locals)
            // vector::push_back<#0>($t2, $t0)
            A1_vector_push_back$u64$($t2, e)
            // $t3 := move($t1)
            $t3 := mload($locals)
            // return $t3
            $result := $t3
            $Free($locals, 32)
        }

        function A1_vector_push_back$u64$(v_ref, e) {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            let e_ptr := $IndexPtr(v_ptr, add(32, mul(size, 8)))
            $StoreU64(e_ptr, e)
            size := add(size, 1)
            $StoreU64(v_ptr, size)
            let capacity := $LoadU64($IndexPtr(v_ptr, 8))
            if and(iszero($IsStoragePtr(v_ptr)), eq(size, capacity)) {
                let new_v_offs := $ResizeVector(v_offs, capacity, 8)
                $StoreU256(v_ref, new_v_offs)
            }
        }
        function A1_vector_empty$u64$() -> vector {
            vector := $Malloc(48)
            $MemoryStoreU64(add(vector, 8), 2)
        }
        function A1_vector_empty$vec$u64$$() -> vector {
            vector := $Malloc(96)
            $MemoryStoreU64(add(vector, 8), 2)
        }
        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Malloc(size) -> offs {
            offs := mload(0)
            // pad to word size
            mstore(0, add(offs, shl(5, shr(5, add(size, 31)))))
        }
        function $Free(offs, size) {
        }
        function $MakePtr(is_storage, offs) -> ptr {
          ptr := or(is_storage, shl(1, offs))
        }
        function $IsStoragePtr(ptr) -> b {
          b := and(ptr, 0x1)
        }
        function $OffsetPtr(ptr) -> offs {
          offs := shr(1, ptr)
        }
        function $MaskForSize(size) -> mask {
          mask := sub(shl(shl(3, size), 1), 1)
        }
        function $ExtractBytes(word, start, size) -> bytes {
           switch size
           case 1 {
              // use the faster byte primitive
              bytes := byte(start, word)
           }
           default {
              // As we have big endian, we need to right shift the value from
              // where the highest byte starts in the word (32 - start), minus
              // the size.
              let shift_bits := shl(3, sub(sub(32, start), size))
              bytes := and(shr(shift_bits, word), $MaskForSize(size))
           }
        }
        function $InjectBytes(word, start, size, bytes) -> new_word {
           let shift_bits := shl(3, sub(sub(32, start), size))
           // Blend out the bits which we inject
           let neg_mask := not(shl(shift_bits, $MaskForSize(size)))
           word := and(word, neg_mask)
           // Overlay the bits we inject
           new_word := or(word, shl(shift_bits, bytes))
        }
        function $ToWordOffs(offs) -> word_offs, byte_offset {
          word_offs := shr(5, offs)
          byte_offset := and(offs, 0x1F)
        }
        function $OverflowBytes(byte_offset, size) -> overflow_bytes {
          let available_bytes := sub(32, byte_offset)
          switch gt(size, available_bytes)
          case 0 {
            overflow_bytes := 0
          }
          default {
            overflow_bytes := sub(size, available_bytes)
          }
        }
        function $MemoryLoadBytes(offs, size) -> val {
          // Lower bit where the value in the higher bytes ends
          let bit_end := shl(3, sub(32, size))
          val := shr(bit_end, mload(offs))
        }
        function $MemoryStoreBytes(offs, size, val) {
          let bit_end := shl(3, sub(32, size))
          let mask := shl(bit_end, $MaskForSize(size))
          mstore(offs, or(and(mload(offs), not(mask)), shl(bit_end, val)))
        }
        function $StorageLoadBytes(offs, size) -> val {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          val := $ExtractBytes(sload(key), byte_offs, size)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          if $LogicalNot(iszero(overflow_bytes)) {
            key := $StorageKey(0, add(word_offs, 1))
            let extra_bytes := $ExtractBytes(sload(key), 0, overflow_bytes)
            val := or(shl(shl(3, overflow_bytes), val), extra_bytes)
          }
        }
        function $StorageStoreBytes(offs, size, bytes) {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          switch overflow_bytes
          case 0 {
            sstore(key, $InjectBytes(sload(key), byte_offs, size, bytes))
          }
          default {
            // Shift the higher bytes to the right
            let used_bytes := sub(size, overflow_bytes)
            let higher_bytes := shr(used_bytes, bytes)
            let lower_bytes := and(bytes, $MaskForSize(overflow_bytes))
            sstore(key, $InjectBytes(sload(key), byte_offs, used_bytes, higher_bytes))
            key := $StorageKey(0, add(word_offs, 1))
            sstore(key, $InjectBytes(sload(key), 0, overflow_bytes, lower_bytes))
          }
        }
        function $StorageKey(group, word) -> key {
          mstore(32, word)
          mstore(64, shl(224, group))
          key := keccak256(32, 36)
        }
        function $MakeTypeStorageBase(category, type_hash, id) -> offs {
          offs := or(shl(252, category), or(shl(220, type_hash), shl(60, id)))
        }
        function $NewLinkedStorageBase(type_hash) -> offs {
          let key := $StorageKey(1, 1)
          let handle := sload(key)
          sstore(key, add(handle, 1))
          offs := $MakeTypeStorageBase(1, type_hash, handle)
        }
        function $IndexPtr(ptr, offs) -> new_ptr {
          new_ptr := $MakePtr($IsStoragePtr(ptr), add($OffsetPtr(ptr), offs))
        }
        function $LoadU64(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU64(offs)
          }
          default {
            val := $StorageLoadU64(offs)
          }
        }
        function $MemoryLoadU64(offs) -> val {
          val := $MemoryLoadBytes(offs, 8)
        }
        function $StorageLoadU64(offs) -> val {
          val := $StorageLoadBytes(offs, 8)
        }
        function $StoreU64(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU64(offs, val)
          }
          default {
            $StorageStoreU64(offs, val)
          }
        }
        function $MemoryStoreU64(offs, val) {
          $MemoryStoreBytes(offs, 8, val)
        }
        function $StorageStoreU64(offs, val) {
          $StorageStoreBytes(offs, 8, val)
        }
        function $LoadU256(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU256(offs)
          }
          default {
            val := $StorageLoadU256(offs)
          }
        }
        function $MemoryLoadU256(offs) -> val {
          val := $MemoryLoadBytes(offs, 32)
        }
        function $StorageLoadU256(offs) -> val {
          val := $StorageLoadBytes(offs, 32)
        }
        function $StoreU256(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU256(offs, val)
          }
          default {
            $StorageStoreU256(offs, val)
          }
        }
        function $MemoryStoreU256(offs, val) {
          $MemoryStoreBytes(offs, 32, val)
        }
        function $StorageStoreU256(offs, val) {
          $StorageStoreBytes(offs, 32, val)
        }
        function $AlignedStorageLoad(offs) -> val {
          let word_offs := shr(5, offs)
          val := sload($StorageKey(0, word_offs))
        }
        function $AlignedStorageStore(offs, val) {
          let word_offs := shr(5, offs)
          sstore($StorageKey(0, word_offs), val)
        }
        function $CopyMemory(src, dst, size) {
          let num_words, overflow_bytes := $ToWordOffs(size)
          let i := 0
          for { } lt(i, mul(num_words, 32)) { i := add(i, 32) } {
            mstore(add(dst, i), mload(add(src, i)))
          }
          if overflow_bytes {
            let mask := $MaskForSize(sub(32, overflow_bytes))
            let overflow_offs := mul(num_words, 32)
            let dst_word := and(mload(add(dst, overflow_offs)), mask)
            let src_word := and(mload(add(src, overflow_offs)), not(mask))
            mstore(add(dst, overflow_offs), or(dst_word, src_word))
          }
        }
        function $ResizeVector(v_offs, capacity, type_size) -> new_v_offs {
            let new_capacity := mul(capacity, 2)
            let data_size := add(32, mul(capacity, type_size))
            let new_data_size := add(32, mul(new_capacity, type_size))
            new_v_offs := $Malloc(new_data_size)
            $CopyMemory(v_offs, new_v_offs, data_size)
            // update capacity at new location
            $MemoryStoreU64(add(new_v_offs, 8), new_capacity)
            $Free(v_offs, data_size)
        }
        function $GtEq(x, y) -> r {
            r := or(gt(x, y), eq(x, y))
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
        function $LogicalNot(x) -> r {
            r := iszero(x)
        }
        function $ClosestGreaterPowerOfTwo(x) -> r {
            r := or(r, shr(1, x))
            r := or(r, shr(2, r))
            r := or(r, shr(4, r))
            r := or(r, shr(8, r))
            r := or(r, shr(16, r))
            r := or(r, shr(32, r))
            r := add(x, 1)
        }
    }
}
===> Test result of GlobalVectors::test_move_from_vector_of_vector: Succeed(Stopped) (used_gas=244640): []

// test of GlobalVectors::test_move_to
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_GlobalVectors_test_move_to" {
    code {
        mstore(0, memoryguard(160))
        A2_GlobalVectors_test_move_to()
        return (0, 0)
        function A2_GlobalVectors_test_move_to() {
            let $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27, $t28, $t29, $t30, $t31, $t32, $t33, $t34, $t35, $t36, $t37, $t38, $t39, $t40, $t41, $t42, $t43, $t44, $t45
            let $locals := $Malloc(64)
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // goto L2
                    $block := 5
                }
                case 3 {
                    // label L0
                    // $t18 := 101
                    $t18 := 101
                    // abort($t18)
                    $Abort($t18)
                }
                case 4 {
                    // $t1 := vector::empty<u64>()
                    mstore($locals, A1_vector_empty$u64$())
                    // $t2 := borrow_local($t1)
                    $t2 := $MakePtr(false, $locals)
                    // $t3 := 10
                    $t3 := 10
                    // vector::push_back<u64>($t2, $t3)
                    A1_vector_push_back$u64$($t2, $t3)
                    // $t4 := borrow_local($t1)
                    $t4 := $MakePtr(false, $locals)
                    // $t5 := 11
                    $t5 := 11
                    // vector::push_back<u64>($t4, $t5)
                    A1_vector_push_back$u64$($t4, $t5)
                    // $t6 := borrow_local($t1)
                    $t6 := $MakePtr(false, $locals)
                    // $t7 := 12
                    $t7 := 12
                    // vector::push_back<u64>($t6, $t7)
                    A1_vector_push_back$u64$($t6, $t7)
                    // $t8 := 0x42
                    $t8 := 0x42
                    // $t0 := Evm::sign($t8)
                    mstore(add($locals, 32), A2_Evm_sign($t8))
                    // $t9 := borrow_local($t0)
                    $t9 := $MakePtr(false, add($locals, 32))
                    // $t10 := move($t1)
                    $t10 := mload($locals)
                    // $t11 := pack 0x2::GlobalVectors::T<u64>($t10)
                    {
                        let $mem := $Malloc(32)
                        $MemoryStoreU256(add($mem, 0), $t10)
                        $t11 := $mem
                    }
                    // move_to<0x2::GlobalVectors::T<u64>>($t11, $t9)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $LoadU256($t9))
                        if $AlignedStorageLoad($base_offset) {
                          $AbortBuiltin()
                        }
                        $AlignedStorageStore($base_offset, true)
                        {
                            let $dst := add($base_offset, 32)
                            let $src := $t11
                            {
                                let $linked_src_814019441 := mload(add($src, 0))
                                let $linked_dst_814019441 := $NewLinkedStorageBase(0x3084f371)
                                let $size_814019441 := $MemoryLoadU64($linked_src_814019441)
                                let $data_size_814019441 := mul($size_814019441, 8)
                                $AlignedStorageStore($linked_dst_814019441, mload($linked_src_814019441))
                                let $data_src_814019441 := add($linked_src_814019441, 32)
                                let $data_dst_814019441 := add($linked_dst_814019441, 32)
                                for { let $offs_814019441 := 0 } lt($offs_814019441, $data_size_814019441) { $offs_814019441 := add($offs_814019441, 32)} {
                                    $AlignedStorageStore(add($data_dst_814019441, $offs_814019441), mload(add($data_src_814019441, $offs_814019441)))
                                    $Free($linked_src_814019441, add($data_size_814019441, 32))
                                }
                                $AlignedStorageStore(add($dst, 0), $linked_dst_814019441)
                            }
                            $Free($src, 32)
                        }
                    }
                    // $t12 := 0x42
                    $t12 := 0x42
                    // $t13 := borrow_global<0x2::GlobalVectors::T<u64>>($t12)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $t12)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t13 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t14 := borrow_field<0x2::GlobalVectors::T<u64>>.v($t13)
                    $t14 := $t13
                    // $t15 := vector::length<u64>($t14)
                    $t15 := A1_vector_length$u64$($t14)
                    // $t16 := 3
                    $t16 := 3
                    // $t17 := ==($t15, $t16)
                    $t17 := $Eq($t15, $t16)
                    // if ($t17) goto L1 else goto L0
                    switch $t17
                    case 0  { $block := 3 }
                    default { $block := 2 }
                }
                case 5 {
                    // label L2
                    // $t19 := 0x42
                    $t19 := 0x42
                    // $t20 := borrow_global<0x2::GlobalVectors::T<u64>>($t19)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $t19)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t20 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t21 := borrow_field<0x2::GlobalVectors::T<u64>>.v($t20)
                    $t21 := $t20
                    // $t22 := 0
                    $t22 := 0
                    // $t23 := vector::borrow<u64>($t21, $t22)
                    $t23 := A1_vector_borrow$u64$($t21, $t22)
                    // $t24 := read_ref($t23)
                    $t24 := $LoadU64($t23)
                    // $t25 := 10
                    $t25 := 10
                    // $t26 := ==($t24, $t25)
                    $t26 := $Eq($t24, $t25)
                    // if ($t26) goto L4 else goto L3
                    switch $t26
                    case 0  { $block := 7 }
                    default { $block := 6 }
                }
                case 6 {
                    // label L4
                    // goto L5
                    $block := 8
                }
                case 7 {
                    // label L3
                    // $t27 := 102
                    $t27 := 102
                    // abort($t27)
                    $Abort($t27)
                }
                case 8 {
                    // label L5
                    // $t28 := 0x42
                    $t28 := 0x42
                    // $t29 := borrow_global<0x2::GlobalVectors::T<u64>>($t28)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $t28)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t29 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t30 := borrow_field<0x2::GlobalVectors::T<u64>>.v($t29)
                    $t30 := $t29
                    // $t31 := 1
                    $t31 := 1
                    // $t32 := vector::borrow<u64>($t30, $t31)
                    $t32 := A1_vector_borrow$u64$($t30, $t31)
                    // $t33 := read_ref($t32)
                    $t33 := $LoadU64($t32)
                    // $t34 := 11
                    $t34 := 11
                    // $t35 := ==($t33, $t34)
                    $t35 := $Eq($t33, $t34)
                    // if ($t35) goto L7 else goto L6
                    switch $t35
                    case 0  { $block := 10 }
                    default { $block := 9 }
                }
                case 9 {
                    // label L7
                    // goto L8
                    $block := 11
                }
                case 10 {
                    // label L6
                    // $t36 := 103
                    $t36 := 103
                    // abort($t36)
                    $Abort($t36)
                }
                case 11 {
                    // label L8
                    // $t37 := 0x42
                    $t37 := 0x42
                    // $t38 := borrow_global<0x2::GlobalVectors::T<u64>>($t37)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $t37)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t38 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t39 := borrow_field<0x2::GlobalVectors::T<u64>>.v($t38)
                    $t39 := $t38
                    // $t40 := 2
                    $t40 := 2
                    // $t41 := vector::borrow<u64>($t39, $t40)
                    $t41 := A1_vector_borrow$u64$($t39, $t40)
                    // $t42 := read_ref($t41)
                    $t42 := $LoadU64($t41)
                    // $t43 := 12
                    $t43 := 12
                    // $t44 := ==($t42, $t43)
                    $t44 := $Eq($t42, $t43)
                    // if ($t44) goto L10 else goto L9
                    switch $t44
                    case 0  { $block := 13 }
                    default { $block := 12 }
                }
                case 12 {
                    // label L10
                    // goto L11
                    $block := 14
                }
                case 13 {
                    // label L9
                    // $t45 := 104
                    $t45 := 104
                    // abort($t45)
                    $Abort($t45)
                }
                case 14 {
                    // label L11
                    // return ()
                    $Free($locals, 64)
                    leave
                }
            }
        }

        function A1_vector_borrow$u64$(v_ref, i) -> e_ptr {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            if $GtEq(i, size) { $AbortBuiltin() }
            e_ptr := $IndexPtr(v_ptr, add(32, mul(i, 8)))
        }
        function A1_vector_length$u64$(v_ref) -> len {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            len := $LoadU64(v_ptr)
        }
        function A2_Evm_sign(addr) -> signer {
          signer := addr
        }
        function A1_vector_push_back$u64$(v_ref, e) {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            let e_ptr := $IndexPtr(v_ptr, add(32, mul(size, 8)))
            $StoreU64(e_ptr, e)
            size := add(size, 1)
            $StoreU64(v_ptr, size)
            let capacity := $LoadU64($IndexPtr(v_ptr, 8))
            if and(iszero($IsStoragePtr(v_ptr)), eq(size, capacity)) {
                let new_v_offs := $ResizeVector(v_offs, capacity, 8)
                $StoreU256(v_ref, new_v_offs)
            }
        }
        function A1_vector_empty$u64$() -> vector {
            vector := $Malloc(48)
            $MemoryStoreU64(add(vector, 8), 2)
        }
        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Malloc(size) -> offs {
            offs := mload(0)
            // pad to word size
            mstore(0, add(offs, shl(5, shr(5, add(size, 31)))))
        }
        function $Free(offs, size) {
        }
        function $MakePtr(is_storage, offs) -> ptr {
          ptr := or(is_storage, shl(1, offs))
        }
        function $IsStoragePtr(ptr) -> b {
          b := and(ptr, 0x1)
        }
        function $OffsetPtr(ptr) -> offs {
          offs := shr(1, ptr)
        }
        function $MaskForSize(size) -> mask {
          mask := sub(shl(shl(3, size), 1), 1)
        }
        function $ExtractBytes(word, start, size) -> bytes {
           switch size
           case 1 {
              // use the faster byte primitive
              bytes := byte(start, word)
           }
           default {
              // As we have big endian, we need to right shift the value from
              // where the highest byte starts in the word (32 - start), minus
              // the size.
              let shift_bits := shl(3, sub(sub(32, start), size))
              bytes := and(shr(shift_bits, word), $MaskForSize(size))
           }
        }
        function $InjectBytes(word, start, size, bytes) -> new_word {
           let shift_bits := shl(3, sub(sub(32, start), size))
           // Blend out the bits which we inject
           let neg_mask := not(shl(shift_bits, $MaskForSize(size)))
           word := and(word, neg_mask)
           // Overlay the bits we inject
           new_word := or(word, shl(shift_bits, bytes))
        }
        function $ToWordOffs(offs) -> word_offs, byte_offset {
          word_offs := shr(5, offs)
          byte_offset := and(offs, 0x1F)
        }
        function $OverflowBytes(byte_offset, size) -> overflow_bytes {
          let available_bytes := sub(32, byte_offset)
          switch gt(size, available_bytes)
          case 0 {
            overflow_bytes := 0
          }
          default {
            overflow_bytes := sub(size, available_bytes)
          }
        }
        function $MemoryLoadBytes(offs, size) -> val {
          // Lower bit where the value in the higher bytes ends
          let bit_end := shl(3, sub(32, size))
          val := shr(bit_end, mload(offs))
        }
        function $MemoryStoreBytes(offs, size, val) {
          let bit_end := shl(3, sub(32, size))
          let mask := shl(bit_end, $MaskForSize(size))
          mstore(offs, or(and(mload(offs), not(mask)), shl(bit_end, val)))
        }
        function $StorageLoadBytes(offs, size) -> val {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          val := $ExtractBytes(sload(key), byte_offs, size)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          if $LogicalNot(iszero(overflow_bytes)) {
            key := $StorageKey(0, add(word_offs, 1))
            let extra_bytes := $ExtractBytes(sload(key), 0, overflow_bytes)
            val := or(shl(shl(3, overflow_bytes), val), extra_bytes)
          }
        }
        function $StorageStoreBytes(offs, size, bytes) {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          switch overflow_bytes
          case 0 {
            sstore(key, $InjectBytes(sload(key), byte_offs, size, bytes))
          }
          default {
            // Shift the higher bytes to the right
            let used_bytes := sub(size, overflow_bytes)
            let higher_bytes := shr(used_bytes, bytes)
            let lower_bytes := and(bytes, $MaskForSize(overflow_bytes))
            sstore(key, $InjectBytes(sload(key), byte_offs, used_bytes, higher_bytes))
            key := $StorageKey(0, add(word_offs, 1))
            sstore(key, $InjectBytes(sload(key), 0, overflow_bytes, lower_bytes))
          }
        }
        function $StorageKey(group, word) -> key {
          mstore(32, word)
          mstore(64, shl(224, group))
          key := keccak256(32, 36)
        }
        function $MakeTypeStorageBase(category, type_hash, id) -> offs {
          offs := or(shl(252, category), or(shl(220, type_hash), shl(60, id)))
        }
        function $NewLinkedStorageBase(type_hash) -> offs {
          let key := $StorageKey(1, 1)
          let handle := sload(key)
          sstore(key, add(handle, 1))
          offs := $MakeTypeStorageBase(1, type_hash, handle)
        }
        function $IndexPtr(ptr, offs) -> new_ptr {
          new_ptr := $MakePtr($IsStoragePtr(ptr), add($OffsetPtr(ptr), offs))
        }
        function $LoadU64(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU64(offs)
          }
          default {
            val := $StorageLoadU64(offs)
          }
        }
        function $MemoryLoadU64(offs) -> val {
          val := $MemoryLoadBytes(offs, 8)
        }
        function $StorageLoadU64(offs) -> val {
          val := $StorageLoadBytes(offs, 8)
        }
        function $StoreU64(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU64(offs, val)
          }
          default {
            $StorageStoreU64(offs, val)
          }
        }
        function $MemoryStoreU64(offs, val) {
          $MemoryStoreBytes(offs, 8, val)
        }
        function $StorageStoreU64(offs, val) {
          $StorageStoreBytes(offs, 8, val)
        }
        function $LoadU256(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU256(offs)
          }
          default {
            val := $StorageLoadU256(offs)
          }
        }
        function $MemoryLoadU256(offs) -> val {
          val := $MemoryLoadBytes(offs, 32)
        }
        function $StorageLoadU256(offs) -> val {
          val := $StorageLoadBytes(offs, 32)
        }
        function $StoreU256(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU256(offs, val)
          }
          default {
            $StorageStoreU256(offs, val)
          }
        }
        function $MemoryStoreU256(offs, val) {
          $MemoryStoreBytes(offs, 32, val)
        }
        function $StorageStoreU256(offs, val) {
          $StorageStoreBytes(offs, 32, val)
        }
        function $AlignedStorageLoad(offs) -> val {
          let word_offs := shr(5, offs)
          val := sload($StorageKey(0, word_offs))
        }
        function $AlignedStorageStore(offs, val) {
          let word_offs := shr(5, offs)
          sstore($StorageKey(0, word_offs), val)
        }
        function $CopyMemory(src, dst, size) {
          let num_words, overflow_bytes := $ToWordOffs(size)
          let i := 0
          for { } lt(i, mul(num_words, 32)) { i := add(i, 32) } {
            mstore(add(dst, i), mload(add(src, i)))
          }
          if overflow_bytes {
            let mask := $MaskForSize(sub(32, overflow_bytes))
            let overflow_offs := mul(num_words, 32)
            let dst_word := and(mload(add(dst, overflow_offs)), mask)
            let src_word := and(mload(add(src, overflow_offs)), not(mask))
            mstore(add(dst, overflow_offs), or(dst_word, src_word))
          }
        }
        function $ResizeVector(v_offs, capacity, type_size) -> new_v_offs {
            let new_capacity := mul(capacity, 2)
            let data_size := add(32, mul(capacity, type_size))
            let new_data_size := add(32, mul(new_capacity, type_size))
            new_v_offs := $Malloc(new_data_size)
            $CopyMemory(v_offs, new_v_offs, data_size)
            // update capacity at new location
            $MemoryStoreU64(add(new_v_offs, 8), new_capacity)
            $Free(v_offs, data_size)
        }
        function $GtEq(x, y) -> r {
            r := or(gt(x, y), eq(x, y))
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
        function $LogicalNot(x) -> r {
            r := iszero(x)
        }
    }
}
===> Test result of GlobalVectors::test_move_to: Succeed(Stopped) (used_gas=121112): []

// test of GlobalVectors::test_move_to_vector_of_struct
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_GlobalVectors_test_move_to_vector_of_struct" {
    code {
        mstore(0, memoryguard(160))
        A2_GlobalVectors_test_move_to_vector_of_struct()
        return (0, 0)
        function A2_GlobalVectors_test_move_to_vector_of_struct() {
            let $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27, $t28, $t29, $t30, $t31, $t32, $t33, $t34, $t35, $t36, $t37, $t38, $t39, $t40, $t41, $t42, $t43, $t44, $t45, $t46, $t47, $t48, $t49, $t50, $t51, $t52, $t53, $t54
            let $locals := $Malloc(64)
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // goto L2
                    $block := 5
                }
                case 3 {
                    // label L0
                    // $t24 := 101
                    $t24 := 101
                    // abort($t24)
                    $Abort($t24)
                }
                case 4 {
                    // $t1 := vector::empty<0x2::GlobalVectors::S>()
                    mstore($locals, A1_vector_empty$A2_GlobalVectors_S$())
                    // $t2 := borrow_local($t1)
                    $t2 := $MakePtr(false, $locals)
                    // $t3 := 10
                    $t3 := 10
                    // $t4 := 40
                    $t4 := 40
                    // $t5 := pack 0x2::GlobalVectors::S($t3, $t4)
                    {
                        let $mem := $Malloc(24)
                        $MemoryStoreU128(add($mem, 0), $t3)
                        $MemoryStoreU64(add($mem, 16), $t4)
                        $t5 := $mem
                    }
                    // vector::push_back<0x2::GlobalVectors::S>($t2, $t5)
                    A1_vector_push_back$A2_GlobalVectors_S$($t2, $t5)
                    // $t6 := borrow_local($t1)
                    $t6 := $MakePtr(false, $locals)
                    // $t7 := 11
                    $t7 := 11
                    // $t8 := 41
                    $t8 := 41
                    // $t9 := pack 0x2::GlobalVectors::S($t7, $t8)
                    {
                        let $mem := $Malloc(24)
                        $MemoryStoreU128(add($mem, 0), $t7)
                        $MemoryStoreU64(add($mem, 16), $t8)
                        $t9 := $mem
                    }
                    // vector::push_back<0x2::GlobalVectors::S>($t6, $t9)
                    A1_vector_push_back$A2_GlobalVectors_S$($t6, $t9)
                    // $t10 := borrow_local($t1)
                    $t10 := $MakePtr(false, $locals)
                    // $t11 := 12
                    $t11 := 12
                    // $t12 := 42
                    $t12 := 42
                    // $t13 := pack 0x2::GlobalVectors::S($t11, $t12)
                    {
                        let $mem := $Malloc(24)
                        $MemoryStoreU128(add($mem, 0), $t11)
                        $MemoryStoreU64(add($mem, 16), $t12)
                        $t13 := $mem
                    }
                    // vector::push_back<0x2::GlobalVectors::S>($t10, $t13)
                    A1_vector_push_back$A2_GlobalVectors_S$($t10, $t13)
                    // $t14 := 0x42
                    $t14 := 0x42
                    // $t0 := Evm::sign($t14)
                    mstore(add($locals, 32), A2_Evm_sign($t14))
                    // $t15 := borrow_local($t0)
                    $t15 := $MakePtr(false, add($locals, 32))
                    // $t16 := move($t1)
                    $t16 := mload($locals)
                    // $t17 := pack 0x2::GlobalVectors::T<0x2::GlobalVectors::S>($t16)
                    {
                        let $mem := $Malloc(32)
                        $MemoryStoreU256(add($mem, 0), $t16)
                        $t17 := $mem
                    }
                    // move_to<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>($t17, $t15)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x27c9b6b7, $LoadU256($t15))
                        if $AlignedStorageLoad($base_offset) {
                          $AbortBuiltin()
                        }
                        $AlignedStorageStore($base_offset, true)
                        {
                            let $dst := add($base_offset, 32)
                            let $src := $t17
                            {
                                let $linked_src_634259357 := mload(add($src, 0))
                                let $linked_dst_634259357 := $NewLinkedStorageBase(0x25ce079d)
                                let $size_634259357 := $MemoryLoadU64($linked_src_634259357)
                                let $data_size_634259357 := mul($size_634259357, 32)
                                $AlignedStorageStore($linked_dst_634259357, mload($linked_src_634259357))
                                let $data_src_634259357 := add($linked_src_634259357, 32)
                                let $data_dst_634259357 := add($linked_dst_634259357, 32)
                                for { let $offs_634259357 := 0 } lt($offs_634259357, $data_size_634259357) { $offs_634259357 := add($offs_634259357, 32)} {
                                    {
                                        let $linked_src_3681206257 := mload(add($offs_634259357, $data_src_634259357))
                                        let $linked_dst_3681206257 := $NewLinkedStorageBase(0xdb6abff1)
                                        $AlignedStorageStore(add($linked_dst_3681206257, 0), mload(add($linked_src_3681206257, 0)))
                                        $Free($linked_src_3681206257, 24)
                                        $AlignedStorageStore(add($data_dst_634259357, $offs_634259357), $linked_dst_3681206257)
                                    }
                                    $Free($linked_src_634259357, add($data_size_634259357, 32))
                                }
                                $AlignedStorageStore(add($dst, 0), $linked_dst_634259357)
                            }
                            $Free($src, 32)
                        }
                    }
                    // $t18 := 0x42
                    $t18 := 0x42
                    // $t19 := borrow_global<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>($t18)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x27c9b6b7, $t18)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t19 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t20 := borrow_field<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>.v($t19)
                    $t20 := $t19
                    // $t21 := vector::length<0x2::GlobalVectors::S>($t20)
                    $t21 := A1_vector_length$A2_GlobalVectors_S$($t20)
                    // $t22 := 3
                    $t22 := 3
                    // $t23 := ==($t21, $t22)
                    $t23 := $Eq($t21, $t22)
                    // if ($t23) goto L1 else goto L0
                    switch $t23
                    case 0  { $block := 3 }
                    default { $block := 2 }
                }
                case 5 {
                    // label L2
                    // $t25 := 0x42
                    $t25 := 0x42
                    // $t26 := borrow_global<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>($t25)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x27c9b6b7, $t25)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t26 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t27 := borrow_field<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>.v($t26)
                    $t27 := $t26
                    // $t28 := 0
                    $t28 := 0
                    // $t29 := vector::borrow<0x2::GlobalVectors::S>($t27, $t28)
                    $t29 := A1_vector_borrow$A2_GlobalVectors_S$($t27, $t28)
                    // $t30 := borrow_field<0x2::GlobalVectors::S>.x($t29)
                    $t30 := $t29
                    // $t31 := read_ref($t30)
                    $t31 := $LoadU128($t30)
                    // $t32 := 10
                    $t32 := 10
                    // $t33 := ==($t31, $t32)
                    $t33 := $Eq($t31, $t32)
                    // if ($t33) goto L4 else goto L3
                    switch $t33
                    case 0  { $block := 7 }
                    default { $block := 6 }
                }
                case 6 {
                    // label L4
                    // goto L5
                    $block := 8
                }
                case 7 {
                    // label L3
                    // $t34 := 102
                    $t34 := 102
                    // abort($t34)
                    $Abort($t34)
                }
                case 8 {
                    // label L5
                    // $t35 := 0x42
                    $t35 := 0x42
                    // $t36 := borrow_global<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>($t35)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x27c9b6b7, $t35)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t36 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t37 := borrow_field<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>.v($t36)
                    $t37 := $t36
                    // $t38 := 1
                    $t38 := 1
                    // $t39 := vector::borrow<0x2::GlobalVectors::S>($t37, $t38)
                    $t39 := A1_vector_borrow$A2_GlobalVectors_S$($t37, $t38)
                    // $t40 := borrow_field<0x2::GlobalVectors::S>.x($t39)
                    $t40 := $t39
                    // $t41 := read_ref($t40)
                    $t41 := $LoadU128($t40)
                    // $t42 := 11
                    $t42 := 11
                    // $t43 := ==($t41, $t42)
                    $t43 := $Eq($t41, $t42)
                    // if ($t43) goto L7 else goto L6
                    switch $t43
                    case 0  { $block := 10 }
                    default { $block := 9 }
                }
                case 9 {
                    // label L7
                    // goto L8
                    $block := 11
                }
                case 10 {
                    // label L6
                    // $t44 := 103
                    $t44 := 103
                    // abort($t44)
                    $Abort($t44)
                }
                case 11 {
                    // label L8
                    // $t45 := 0x42
                    $t45 := 0x42
                    // $t46 := borrow_global<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>($t45)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x27c9b6b7, $t45)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t46 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t47 := borrow_field<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>.v($t46)
                    $t47 := $t46
                    // $t48 := 2
                    $t48 := 2
                    // $t49 := vector::borrow<0x2::GlobalVectors::S>($t47, $t48)
                    $t49 := A1_vector_borrow$A2_GlobalVectors_S$($t47, $t48)
                    // $t50 := borrow_field<0x2::GlobalVectors::S>.x($t49)
                    $t50 := $t49
                    // $t51 := read_ref($t50)
                    $t51 := $LoadU128($t50)
                    // $t52 := 12
                    $t52 := 12
                    // $t53 := ==($t51, $t52)
                    $t53 := $Eq($t51, $t52)
                    // if ($t53) goto L10 else goto L9
                    switch $t53
                    case 0  { $block := 13 }
                    default { $block := 12 }
                }
                case 12 {
                    // label L10
                    // goto L11
                    $block := 14
                }
                case 13 {
                    // label L9
                    // $t54 := 104
                    $t54 := 104
                    // abort($t54)
                    $Abort($t54)
                }
                case 14 {
                    // label L11
                    // return ()
                    $Free($locals, 64)
                    leave
                }
            }
        }

        function A1_vector_borrow$A2_GlobalVectors_S$(v_ref, i) -> e_ptr {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            if $GtEq(i, size) { $AbortBuiltin() }
            e_ptr := $IndexPtr(v_ptr, add(32, mul(i, 32)))
            let e := $LoadU256(e_ptr)
            e_ptr := $MakePtr($IsStoragePtr(v_ref), e)
        }
        function A1_vector_length$A2_GlobalVectors_S$(v_ref) -> len {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            len := $LoadU64(v_ptr)
        }
        function A2_Evm_sign(addr) -> signer {
          signer := addr
        }
        function A1_vector_push_back$A2_GlobalVectors_S$(v_ref, e) {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            let e_ptr := $IndexPtr(v_ptr, add(32, mul(size, 32)))
            $StoreU256(e_ptr, e)
            if $IsStoragePtr(e_ptr) {
                let e_offs := $OffsetPtr(e_ptr)
                let $linked_dst_3681206257 := $NewLinkedStorageBase(0xdb6abff1)
                $AlignedStorageStore(add($linked_dst_3681206257, 0), mload(add(e, 0)))
                $Free(e, 24)
                $AlignedStorageStore(e_offs, $linked_dst_3681206257)
            }
            size := add(size, 1)
            $StoreU64(v_ptr, size)
            let capacity := $LoadU64($IndexPtr(v_ptr, 8))
            if and(iszero($IsStoragePtr(v_ptr)), eq(size, capacity)) {
                let new_v_offs := $ResizeVector(v_offs, capacity, 32)
                $StoreU256(v_ref, new_v_offs)
            }
        }
        function A1_vector_empty$A2_GlobalVectors_S$() -> vector {
            vector := $Malloc(96)
            $MemoryStoreU64(add(vector, 8), 2)
        }
        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Malloc(size) -> offs {
            offs := mload(0)
            // pad to word size
            mstore(0, add(offs, shl(5, shr(5, add(size, 31)))))
        }
        function $Free(offs, size) {
        }
        function $MakePtr(is_storage, offs) -> ptr {
          ptr := or(is_storage, shl(1, offs))
        }
        function $IsStoragePtr(ptr) -> b {
          b := and(ptr, 0x1)
        }
        function $OffsetPtr(ptr) -> offs {
          offs := shr(1, ptr)
        }
        function $MaskForSize(size) -> mask {
          mask := sub(shl(shl(3, size), 1), 1)
        }
        function $ExtractBytes(word, start, size) -> bytes {
           switch size
           case 1 {
              // use the faster byte primitive
              bytes := byte(start, word)
           }
           default {
              // As we have big endian, we need to right shift the value from
              // where the highest byte starts in the word (32 - start), minus
              // the size.
              let shift_bits := shl(3, sub(sub(32, start), size))
              bytes := and(shr(shift_bits, word), $MaskForSize(size))
           }
        }
        function $InjectBytes(word, start, size, bytes) -> new_word {
           let shift_bits := shl(3, sub(sub(32, start), size))
           // Blend out the bits which we inject
           let neg_mask := not(shl(shift_bits, $MaskForSize(size)))
           word := and(word, neg_mask)
           // Overlay the bits we inject
           new_word := or(word, shl(shift_bits, bytes))
        }
        function $ToWordOffs(offs) -> word_offs, byte_offset {
          word_offs := shr(5, offs)
          byte_offset := and(offs, 0x1F)
        }
        function $OverflowBytes(byte_offset, size) -> overflow_bytes {
          let available_bytes := sub(32, byte_offset)
          switch gt(size, available_bytes)
          case 0 {
            overflow_bytes := 0
          }
          default {
            overflow_bytes := sub(size, available_bytes)
          }
        }
        function $MemoryLoadBytes(offs, size) -> val {
          // Lower bit where the value in the higher bytes ends
          let bit_end := shl(3, sub(32, size))
          val := shr(bit_end, mload(offs))
        }
        function $MemoryStoreBytes(offs, size, val) {
          let bit_end := shl(3, sub(32, size))
          let mask := shl(bit_end, $MaskForSize(size))
          mstore(offs, or(and(mload(offs), not(mask)), shl(bit_end, val)))
        }
        function $StorageLoadBytes(offs, size) -> val {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          val := $ExtractBytes(sload(key), byte_offs, size)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          if $LogicalNot(iszero(overflow_bytes)) {
            key := $StorageKey(0, add(word_offs, 1))
            let extra_bytes := $ExtractBytes(sload(key), 0, overflow_bytes)
            val := or(shl(shl(3, overflow_bytes), val), extra_bytes)
          }
        }
        function $StorageStoreBytes(offs, size, bytes) {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          switch overflow_bytes
          case 0 {
            sstore(key, $InjectBytes(sload(key), byte_offs, size, bytes))
          }
          default {
            // Shift the higher bytes to the right
            let used_bytes := sub(size, overflow_bytes)
            let higher_bytes := shr(used_bytes, bytes)
            let lower_bytes := and(bytes, $MaskForSize(overflow_bytes))
            sstore(key, $InjectBytes(sload(key), byte_offs, used_bytes, higher_bytes))
            key := $StorageKey(0, add(word_offs, 1))
            sstore(key, $InjectBytes(sload(key), 0, overflow_bytes, lower_bytes))
          }
        }
        function $StorageKey(group, word) -> key {
          mstore(32, word)
          mstore(64, shl(224, group))
          key := keccak256(32, 36)
        }
        function $MakeTypeStorageBase(category, type_hash, id) -> offs {
          offs := or(shl(252, category), or(shl(220, type_hash), shl(60, id)))
        }
        function $NewLinkedStorageBase(type_hash) -> offs {
          let key := $StorageKey(1, 1)
          let handle := sload(key)
          sstore(key, add(handle, 1))
          offs := $MakeTypeStorageBase(1, type_hash, handle)
        }
        function $IndexPtr(ptr, offs) -> new_ptr {
          new_ptr := $MakePtr($IsStoragePtr(ptr), add($OffsetPtr(ptr), offs))
        }
        function $LoadU64(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU64(offs)
          }
          default {
            val := $StorageLoadU64(offs)
          }
        }
        function $MemoryLoadU64(offs) -> val {
          val := $MemoryLoadBytes(offs, 8)
        }
        function $StorageLoadU64(offs) -> val {
          val := $StorageLoadBytes(offs, 8)
        }
        function $StoreU64(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU64(offs, val)
          }
          default {
            $StorageStoreU64(offs, val)
          }
        }
        function $MemoryStoreU64(offs, val) {
          $MemoryStoreBytes(offs, 8, val)
        }
        function $StorageStoreU64(offs, val) {
          $StorageStoreBytes(offs, 8, val)
        }
        function $LoadU128(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU128(offs)
          }
          default {
            val := $StorageLoadU128(offs)
          }
        }
        function $MemoryLoadU128(offs) -> val {
          val := $MemoryLoadBytes(offs, 16)
        }
        function $StorageLoadU128(offs) -> val {
          val := $StorageLoadBytes(offs, 16)
        }
        function $MemoryStoreU128(offs, val) {
          $MemoryStoreBytes(offs, 16, val)
        }
        function $LoadU256(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU256(offs)
          }
          default {
            val := $StorageLoadU256(offs)
          }
        }
        function $MemoryLoadU256(offs) -> val {
          val := $MemoryLoadBytes(offs, 32)
        }
        function $StorageLoadU256(offs) -> val {
          val := $StorageLoadBytes(offs, 32)
        }
        function $StoreU256(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU256(offs, val)
          }
          default {
            $StorageStoreU256(offs, val)
          }
        }
        function $MemoryStoreU256(offs, val) {
          $MemoryStoreBytes(offs, 32, val)
        }
        function $StorageStoreU256(offs, val) {
          $StorageStoreBytes(offs, 32, val)
        }
        function $AlignedStorageLoad(offs) -> val {
          let word_offs := shr(5, offs)
          val := sload($StorageKey(0, word_offs))
        }
        function $AlignedStorageStore(offs, val) {
          let word_offs := shr(5, offs)
          sstore($StorageKey(0, word_offs), val)
        }
        function $CopyMemory(src, dst, size) {
          let num_words, overflow_bytes := $ToWordOffs(size)
          let i := 0
          for { } lt(i, mul(num_words, 32)) { i := add(i, 32) } {
            mstore(add(dst, i), mload(add(src, i)))
          }
          if overflow_bytes {
            let mask := $MaskForSize(sub(32, overflow_bytes))
            let overflow_offs := mul(num_words, 32)
            let dst_word := and(mload(add(dst, overflow_offs)), mask)
            let src_word := and(mload(add(src, overflow_offs)), not(mask))
            mstore(add(dst, overflow_offs), or(dst_word, src_word))
          }
        }
        function $ResizeVector(v_offs, capacity, type_size) -> new_v_offs {
            let new_capacity := mul(capacity, 2)
            let data_size := add(32, mul(capacity, type_size))
            let new_data_size := add(32, mul(new_capacity, type_size))
            new_v_offs := $Malloc(new_data_size)
            $CopyMemory(v_offs, new_v_offs, data_size)
            // update capacity at new location
            $MemoryStoreU64(add(new_v_offs, 8), new_capacity)
            $Free(v_offs, data_size)
        }
        function $GtEq(x, y) -> r {
            r := or(gt(x, y), eq(x, y))
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
        function $LogicalNot(x) -> r {
            r := iszero(x)
        }
    }
}
===> Test result of GlobalVectors::test_move_to_vector_of_struct: Succeed(Stopped) (used_gas=234677): []

// test of GlobalVectors::test_move_to_vector_of_vector
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_GlobalVectors_test_move_to_vector_of_vector" {
    code {
        mstore(0, memoryguard(160))
        A2_GlobalVectors_test_move_to_vector_of_vector()
        return (0, 0)
        function A2_GlobalVectors_test_move_to_vector_of_vector() {
            let $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27, $t28, $t29, $t30, $t31, $t32, $t33, $t34, $t35, $t36, $t37, $t38, $t39, $t40, $t41, $t42, $t43, $t44, $t45, $t46, $t47, $t48, $t49, $t50, $t51, $t52, $t53, $t54
            let $locals := $Malloc(64)
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // goto L2
                    $block := 5
                }
                case 3 {
                    // label L0
                    // $t21 := 101
                    $t21 := 101
                    // abort($t21)
                    $Abort($t21)
                }
                case 4 {
                    // $t1 := vector::empty<vector<u64>>()
                    mstore($locals, A1_vector_empty$vec$u64$$())
                    // $t2 := borrow_local($t1)
                    $t2 := $MakePtr(false, $locals)
                    // $t3 := 10
                    $t3 := 10
                    // $t4 := vector::singleton<u64>($t3)
                    $t4 := A1_vector_singleton$u64$($t3)
                    // vector::push_back<vector<u64>>($t2, $t4)
                    A1_vector_push_back$vec$u64$$($t2, $t4)
                    // $t5 := borrow_local($t1)
                    $t5 := $MakePtr(false, $locals)
                    // $t6 := 11
                    $t6 := 11
                    // $t7 := vector::singleton<u64>($t6)
                    $t7 := A1_vector_singleton$u64$($t6)
                    // vector::push_back<vector<u64>>($t5, $t7)
                    A1_vector_push_back$vec$u64$$($t5, $t7)
                    // $t8 := borrow_local($t1)
                    $t8 := $MakePtr(false, $locals)
                    // $t9 := 12
                    $t9 := 12
                    // $t10 := vector::singleton<u64>($t9)
                    $t10 := A1_vector_singleton$u64$($t9)
                    // vector::push_back<vector<u64>>($t8, $t10)
                    A1_vector_push_back$vec$u64$$($t8, $t10)
                    // $t11 := 0x42
                    $t11 := 0x42
                    // $t0 := Evm::sign($t11)
                    mstore(add($locals, 32), A2_Evm_sign($t11))
                    // $t12 := borrow_local($t0)
                    $t12 := $MakePtr(false, add($locals, 32))
                    // $t13 := move($t1)
                    $t13 := mload($locals)
                    // $t14 := pack 0x2::GlobalVectors::T<vector<u64>>($t13)
                    {
                        let $mem := $Malloc(32)
                        $MemoryStoreU256(add($mem, 0), $t13)
                        $t14 := $mem
                    }
                    // move_to<0x2::GlobalVectors::T<vector<u64>>>($t14, $t12)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x9947b477, $LoadU256($t12))
                        if $AlignedStorageLoad($base_offset) {
                          $AbortBuiltin()
                        }
                        $AlignedStorageStore($base_offset, true)
                        {
                            let $dst := add($base_offset, 32)
                            let $src := $t14
                            {
                                let $linked_src_3066871491 := mload(add($src, 0))
                                let $linked_dst_3066871491 := $NewLinkedStorageBase(0xb6ccbec3)
                                let $size_3066871491 := $MemoryLoadU64($linked_src_3066871491)
                                let $data_size_3066871491 := mul($size_3066871491, 32)
                                $AlignedStorageStore($linked_dst_3066871491, mload($linked_src_3066871491))
                                let $data_src_3066871491 := add($linked_src_3066871491, 32)
                                let $data_dst_3066871491 := add($linked_dst_3066871491, 32)
                                for { let $offs_3066871491 := 0 } lt($offs_3066871491, $data_size_3066871491) { $offs_3066871491 := add($offs_3066871491, 32)} {
                                    {
                                        let $linked_src_814019441 := mload(add($offs_3066871491, $data_src_3066871491))
                                        let $linked_dst_814019441 := $NewLinkedStorageBase(0x3084f371)
                                        let $size_814019441 := $MemoryLoadU64($linked_src_814019441)
                                        let $data_size_814019441 := mul($size_814019441, 8)
                                        $AlignedStorageStore($linked_dst_814019441, mload($linked_src_814019441))
                                        let $data_src_814019441 := add($linked_src_814019441, 32)
                                        let $data_dst_814019441 := add($linked_dst_814019441, 32)
                                        for { let $offs_814019441 := 0 } lt($offs_814019441, $data_size_814019441) { $offs_814019441 := add($offs_814019441, 32)} {
                                            $AlignedStorageStore(add($data_dst_814019441, $offs_814019441), mload(add($data_src_814019441, $offs_814019441)))
                                            $Free($linked_src_814019441, add($data_size_814019441, 32))
                                        }
                                        $AlignedStorageStore(add($data_dst_3066871491, $offs_3066871491), $linked_dst_814019441)
                                    }
                                    $Free($linked_src_3066871491, add($data_size_3066871491, 32))
                                }
                                $AlignedStorageStore(add($dst, 0), $linked_dst_3066871491)
                            }
                            $Free($src, 32)
                        }
                    }
                    // $t15 := 0x42
                    $t15 := 0x42
                    // $t16 := borrow_global<0x2::GlobalVectors::T<vector<u64>>>($t15)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x9947b477, $t15)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t16 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t17 := borrow_field<0x2::GlobalVectors::T<vector<u64>>>.v($t16)
                    $t17 := $t16
                    // $t18 := vector::length<vector<u64>>($t17)
                    $t18 := A1_vector_length$vec$u64$$($t17)
                    // $t19 := 3
                    $t19 := 3
                    // $t20 := ==($t18, $t19)
                    $t20 := $Eq($t18, $t19)
                    // if ($t20) goto L1 else goto L0
                    switch $t20
                    case 0  { $block := 3 }
                    default { $block := 2 }
                }
                case 5 {
                    // label L2
                    // $t22 := 0x42
                    $t22 := 0x42
                    // $t23 := borrow_global<0x2::GlobalVectors::T<vector<u64>>>($t22)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x9947b477, $t22)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t23 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t24 := borrow_field<0x2::GlobalVectors::T<vector<u64>>>.v($t23)
                    $t24 := $t23
                    // $t25 := 0
                    $t25 := 0
                    // $t26 := vector::borrow<vector<u64>>($t24, $t25)
                    $t26 := A1_vector_borrow$vec$u64$$($t24, $t25)
                    // $t27 := 0
                    $t27 := 0
                    // $t28 := vector::borrow<u64>($t26, $t27)
                    $t28 := A1_vector_borrow$u64$($t26, $t27)
                    // $t29 := read_ref($t28)
                    $t29 := $LoadU64($t28)
                    // $t30 := 10
                    $t30 := 10
                    // $t31 := ==($t29, $t30)
                    $t31 := $Eq($t29, $t30)
                    // if ($t31) goto L4 else goto L3
                    switch $t31
                    case 0  { $block := 7 }
                    default { $block := 6 }
                }
                case 6 {
                    // label L4
                    // goto L5
                    $block := 8
                }
                case 7 {
                    // label L3
                    // $t32 := 102
                    $t32 := 102
                    // abort($t32)
                    $Abort($t32)
                }
                case 8 {
                    // label L5
                    // $t33 := 0x42
                    $t33 := 0x42
                    // $t34 := borrow_global<0x2::GlobalVectors::T<vector<u64>>>($t33)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x9947b477, $t33)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t34 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t35 := borrow_field<0x2::GlobalVectors::T<vector<u64>>>.v($t34)
                    $t35 := $t34
                    // $t36 := 1
                    $t36 := 1
                    // $t37 := vector::borrow<vector<u64>>($t35, $t36)
                    $t37 := A1_vector_borrow$vec$u64$$($t35, $t36)
                    // $t38 := 0
                    $t38 := 0
                    // $t39 := vector::borrow<u64>($t37, $t38)
                    $t39 := A1_vector_borrow$u64$($t37, $t38)
                    // $t40 := read_ref($t39)
                    $t40 := $LoadU64($t39)
                    // $t41 := 11
                    $t41 := 11
                    // $t42 := ==($t40, $t41)
                    $t42 := $Eq($t40, $t41)
                    // if ($t42) goto L7 else goto L6
                    switch $t42
                    case 0  { $block := 10 }
                    default { $block := 9 }
                }
                case 9 {
                    // label L7
                    // goto L8
                    $block := 11
                }
                case 10 {
                    // label L6
                    // $t43 := 102
                    $t43 := 102
                    // abort($t43)
                    $Abort($t43)
                }
                case 11 {
                    // label L8
                    // $t44 := 0x42
                    $t44 := 0x42
                    // $t45 := borrow_global<0x2::GlobalVectors::T<vector<u64>>>($t44)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x9947b477, $t44)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t45 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t46 := borrow_field<0x2::GlobalVectors::T<vector<u64>>>.v($t45)
                    $t46 := $t45
                    // $t47 := 2
                    $t47 := 2
                    // $t48 := vector::borrow<vector<u64>>($t46, $t47)
                    $t48 := A1_vector_borrow$vec$u64$$($t46, $t47)
                    // $t49 := 0
                    $t49 := 0
                    // $t50 := vector::borrow<u64>($t48, $t49)
                    $t50 := A1_vector_borrow$u64$($t48, $t49)
                    // $t51 := read_ref($t50)
                    $t51 := $LoadU64($t50)
                    // $t52 := 12
                    $t52 := 12
                    // $t53 := ==($t51, $t52)
                    $t53 := $Eq($t51, $t52)
                    // if ($t53) goto L10 else goto L9
                    switch $t53
                    case 0  { $block := 13 }
                    default { $block := 12 }
                }
                case 12 {
                    // label L10
                    // goto L11
                    $block := 14
                }
                case 13 {
                    // label L9
                    // $t54 := 102
                    $t54 := 102
                    // abort($t54)
                    $Abort($t54)
                }
                case 14 {
                    // label L11
                    // return ()
                    $Free($locals, 64)
                    leave
                }
            }
        }

        function A1_vector_borrow$u64$(v_ref, i) -> e_ptr {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            if $GtEq(i, size) { $AbortBuiltin() }
            e_ptr := $IndexPtr(v_ptr, add(32, mul(i, 8)))
        }
        function A1_vector_borrow$vec$u64$$(v_ref, i) -> e_ptr {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            if $GtEq(i, size) { $AbortBuiltin() }
            e_ptr := $IndexPtr(v_ptr, add(32, mul(i, 32)))
        }
        function A1_vector_length$vec$u64$$(v_ref) -> len {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            len := $LoadU64(v_ptr)
        }
        function A2_Evm_sign(addr) -> signer {
          signer := addr
        }
        function A1_vector_push_back$vec$u64$$(v_ref, e) {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            let e_ptr := $IndexPtr(v_ptr, add(32, mul(size, 32)))
            $StoreU256(e_ptr, e)
            if $IsStoragePtr(e_ptr) {
                let e_offs := $OffsetPtr(e_ptr)
                let $linked_dst_814019441 := $NewLinkedStorageBase(0x3084f371)
                let $size_814019441 := $MemoryLoadU64(e)
                let $data_size_814019441 := mul($size_814019441, 8)
                $AlignedStorageStore($linked_dst_814019441, mload(e))
                let $data_src_814019441 := add(e, 32)
                let $data_dst_814019441 := add($linked_dst_814019441, 32)
                for { let $offs_814019441 := 0 } lt($offs_814019441, $data_size_814019441) { $offs_814019441 := add($offs_814019441, 32)} {
                    $AlignedStorageStore(add($data_dst_814019441, $offs_814019441), mload(add($data_src_814019441, $offs_814019441)))
                    $Free(e, add($data_size_814019441, 32))
                }
                $AlignedStorageStore(e_offs, $linked_dst_814019441)
            }
            size := add(size, 1)
            $StoreU64(v_ptr, size)
            let capacity := $LoadU64($IndexPtr(v_ptr, 8))
            if and(iszero($IsStoragePtr(v_ptr)), eq(size, capacity)) {
                let new_v_offs := $ResizeVector(v_offs, capacity, 32)
                $StoreU256(v_ref, new_v_offs)
            }
        }
        function A1_vector_singleton$u64$(e) -> $result {
            let $t2, $t3
            let $locals := $Malloc(32)
            // $t1 := vector::empty<#0>()
            mstore($locals, A1_vector_empty$u64$())
            // $t2 := borrow_local($t1)
            $t2 := $MakePtr(false, $locals)
            // vector::push_back<#0>($t2, $t0)
            A1_vector_push_back$u64$($t2, e)
            // $t3 := move($t1)
            $t3 := mload($locals)
            // return $t3
            $result := $t3
            $Free($locals, 32)
        }

        function A1_vector_push_back$u64$(v_ref, e) {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            let e_ptr := $IndexPtr(v_ptr, add(32, mul(size, 8)))
            $StoreU64(e_ptr, e)
            size := add(size, 1)
            $StoreU64(v_ptr, size)
            let capacity := $LoadU64($IndexPtr(v_ptr, 8))
            if and(iszero($IsStoragePtr(v_ptr)), eq(size, capacity)) {
                let new_v_offs := $ResizeVector(v_offs, capacity, 8)
                $StoreU256(v_ref, new_v_offs)
            }
        }
        function A1_vector_empty$u64$() -> vector {
            vector := $Malloc(48)
            $MemoryStoreU64(add(vector, 8), 2)
        }
        function A1_vector_empty$vec$u64$$() -> vector {
            vector := $Malloc(96)
            $MemoryStoreU64(add(vector, 8), 2)
        }
        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Malloc(size) -> offs {
            offs := mload(0)
            // pad to word size
            mstore(0, add(offs, shl(5, shr(5, add(size, 31)))))
        }
        function $Free(offs, size) {
        }
        function $MakePtr(is_storage, offs) -> ptr {
          ptr := or(is_storage, shl(1, offs))
        }
        function $IsStoragePtr(ptr) -> b {
          b := and(ptr, 0x1)
        }
        function $OffsetPtr(ptr) -> offs {
          offs := shr(1, ptr)
        }
        function $MaskForSize(size) -> mask {
          mask := sub(shl(shl(3, size), 1), 1)
        }
        function $ExtractBytes(word, start, size) -> bytes {
           switch size
           case 1 {
              // use the faster byte primitive
              bytes := byte(start, word)
           }
           default {
              // As we have big endian, we need to right shift the value from
              // where the highest byte starts in the word (32 - start), minus
              // the size.
              let shift_bits := shl(3, sub(sub(32, start), size))
              bytes := and(shr(shift_bits, word), $MaskForSize(size))
           }
        }
        function $InjectBytes(word, start, size, bytes) -> new_word {
           let shift_bits := shl(3, sub(sub(32, start), size))
           // Blend out the bits which we inject
           let neg_mask := not(shl(shift_bits, $MaskForSize(size)))
           word := and(word, neg_mask)
           // Overlay the bits we inject
           new_word := or(word, shl(shift_bits, bytes))
        }
        function $ToWordOffs(offs) -> word_offs, byte_offset {
          word_offs := shr(5, offs)
          byte_offset := and(offs, 0x1F)
        }
        function $OverflowBytes(byte_offset, size) -> overflow_bytes {
          let available_bytes := sub(32, byte_offset)
          switch gt(size, available_bytes)
          case 0 {
            overflow_bytes := 0
          }
          default {
            overflow_bytes := sub(size, available_bytes)
          }
        }
        function $MemoryLoadBytes(offs, size) -> val {
          // Lower bit where the value in the higher bytes ends
          let bit_end := shl(3, sub(32, size))
          val := shr(bit_end, mload(offs))
        }
        function $MemoryStoreBytes(offs, size, val) {
          let bit_end := shl(3, sub(32, size))
          let mask := shl(bit_end, $MaskForSize(size))
          mstore(offs, or(and(mload(offs), not(mask)), shl(bit_end, val)))
        }
        function $StorageLoadBytes(offs, size) -> val {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          val := $ExtractBytes(sload(key), byte_offs, size)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          if $LogicalNot(iszero(overflow_bytes)) {
            key := $StorageKey(0, add(word_offs, 1))
            let extra_bytes := $ExtractBytes(sload(key), 0, overflow_bytes)
            val := or(shl(shl(3, overflow_bytes), val), extra_bytes)
          }
        }
        function $StorageStoreBytes(offs, size, bytes) {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          switch overflow_bytes
          case 0 {
            sstore(key, $InjectBytes(sload(key), byte_offs, size, bytes))
          }
          default {
            // Shift the higher bytes to the right
            let used_bytes := sub(size, overflow_bytes)
            let higher_bytes := shr(used_bytes, bytes)
            let lower_bytes := and(bytes, $MaskForSize(overflow_bytes))
            sstore(key, $InjectBytes(sload(key), byte_offs, used_bytes, higher_bytes))
            key := $StorageKey(0, add(word_offs, 1))
            sstore(key, $InjectBytes(sload(key), 0, overflow_bytes, lower_bytes))
          }
        }
        function $StorageKey(group, word) -> key {
          mstore(32, word)
          mstore(64, shl(224, group))
          key := keccak256(32, 36)
        }
        function $MakeTypeStorageBase(category, type_hash, id) -> offs {
          offs := or(shl(252, category), or(shl(220, type_hash), shl(60, id)))
        }
        function $NewLinkedStorageBase(type_hash) -> offs {
          let key := $StorageKey(1, 1)
          let handle := sload(key)
          sstore(key, add(handle, 1))
          offs := $MakeTypeStorageBase(1, type_hash, handle)
        }
        function $IndexPtr(ptr, offs) -> new_ptr {
          new_ptr := $MakePtr($IsStoragePtr(ptr), add($OffsetPtr(ptr), offs))
        }
        function $LoadU64(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU64(offs)
          }
          default {
            val := $StorageLoadU64(offs)
          }
        }
        function $MemoryLoadU64(offs) -> val {
          val := $MemoryLoadBytes(offs, 8)
        }
        function $StorageLoadU64(offs) -> val {
          val := $StorageLoadBytes(offs, 8)
        }
        function $StoreU64(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU64(offs, val)
          }
          default {
            $StorageStoreU64(offs, val)
          }
        }
        function $MemoryStoreU64(offs, val) {
          $MemoryStoreBytes(offs, 8, val)
        }
        function $StorageStoreU64(offs, val) {
          $StorageStoreBytes(offs, 8, val)
        }
        function $LoadU256(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU256(offs)
          }
          default {
            val := $StorageLoadU256(offs)
          }
        }
        function $MemoryLoadU256(offs) -> val {
          val := $MemoryLoadBytes(offs, 32)
        }
        function $StorageLoadU256(offs) -> val {
          val := $StorageLoadBytes(offs, 32)
        }
        function $StoreU256(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU256(offs, val)
          }
          default {
            $StorageStoreU256(offs, val)
          }
        }
        function $MemoryStoreU256(offs, val) {
          $MemoryStoreBytes(offs, 32, val)
        }
        function $StorageStoreU256(offs, val) {
          $StorageStoreBytes(offs, 32, val)
        }
        function $AlignedStorageLoad(offs) -> val {
          let word_offs := shr(5, offs)
          val := sload($StorageKey(0, word_offs))
        }
        function $AlignedStorageStore(offs, val) {
          let word_offs := shr(5, offs)
          sstore($StorageKey(0, word_offs), val)
        }
        function $CopyMemory(src, dst, size) {
          let num_words, overflow_bytes := $ToWordOffs(size)
          let i := 0
          for { } lt(i, mul(num_words, 32)) { i := add(i, 32) } {
            mstore(add(dst, i), mload(add(src, i)))
          }
          if overflow_bytes {
            let mask := $MaskForSize(sub(32, overflow_bytes))
            let overflow_offs := mul(num_words, 32)
            let dst_word := and(mload(add(dst, overflow_offs)), mask)
            let src_word := and(mload(add(src, overflow_offs)), not(mask))
            mstore(add(dst, overflow_offs), or(dst_word, src_word))
          }
        }
        function $ResizeVector(v_offs, capacity, type_size) -> new_v_offs {
            let new_capacity := mul(capacity, 2)
            let data_size := add(32, mul(capacity, type_size))
            let new_data_size := add(32, mul(new_capacity, type_size))
            new_v_offs := $Malloc(new_data_size)
            $CopyMemory(v_offs, new_v_offs, data_size)
            // update capacity at new location
            $MemoryStoreU64(add(new_v_offs, 8), new_capacity)
            $Free(v_offs, data_size)
        }
        function $GtEq(x, y) -> r {
            r := or(gt(x, y), eq(x, y))
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
        function $LogicalNot(x) -> r {
            r := iszero(x)
        }
    }
}
===> Test result of GlobalVectors::test_move_to_vector_of_vector: Succeed(Stopped) (used_gas=305279): []

// test of GlobalVectors::test_pop_back_global
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_GlobalVectors_test_pop_back_global" {
    code {
        mstore(0, memoryguard(160))
        A2_GlobalVectors_test_pop_back_global()
        return (0, 0)
        function A2_GlobalVectors_test_pop_back_global() {
            let $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27, $t28, $t29, $t30, $t31, $t32, $t33, $t34, $t35, $t36, $t37, $t38, $t39
            let $locals := $Malloc(64)
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // goto L2
                    $block := 5
                }
                case 3 {
                    // label L0
                    // $t18 := 101
                    $t18 := 101
                    // abort($t18)
                    $Abort($t18)
                }
                case 4 {
                    // $t1 := vector::empty<u64>()
                    mstore($locals, A1_vector_empty$u64$())
                    // $t2 := borrow_local($t1)
                    $t2 := $MakePtr(false, $locals)
                    // $t3 := 10
                    $t3 := 10
                    // vector::push_back<u64>($t2, $t3)
                    A1_vector_push_back$u64$($t2, $t3)
                    // $t4 := borrow_local($t1)
                    $t4 := $MakePtr(false, $locals)
                    // $t5 := 11
                    $t5 := 11
                    // vector::push_back<u64>($t4, $t5)
                    A1_vector_push_back$u64$($t4, $t5)
                    // $t6 := borrow_local($t1)
                    $t6 := $MakePtr(false, $locals)
                    // $t7 := 12
                    $t7 := 12
                    // vector::push_back<u64>($t6, $t7)
                    A1_vector_push_back$u64$($t6, $t7)
                    // $t8 := 0x42
                    $t8 := 0x42
                    // $t0 := Evm::sign($t8)
                    mstore(add($locals, 32), A2_Evm_sign($t8))
                    // $t9 := borrow_local($t0)
                    $t9 := $MakePtr(false, add($locals, 32))
                    // $t10 := move($t1)
                    $t10 := mload($locals)
                    // $t11 := pack 0x2::GlobalVectors::T<u64>($t10)
                    {
                        let $mem := $Malloc(32)
                        $MemoryStoreU256(add($mem, 0), $t10)
                        $t11 := $mem
                    }
                    // move_to<0x2::GlobalVectors::T<u64>>($t11, $t9)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $LoadU256($t9))
                        if $AlignedStorageLoad($base_offset) {
                          $AbortBuiltin()
                        }
                        $AlignedStorageStore($base_offset, true)
                        {
                            let $dst := add($base_offset, 32)
                            let $src := $t11
                            {
                                let $linked_src_814019441 := mload(add($src, 0))
                                let $linked_dst_814019441 := $NewLinkedStorageBase(0x3084f371)
                                let $size_814019441 := $MemoryLoadU64($linked_src_814019441)
                                let $data_size_814019441 := mul($size_814019441, 8)
                                $AlignedStorageStore($linked_dst_814019441, mload($linked_src_814019441))
                                let $data_src_814019441 := add($linked_src_814019441, 32)
                                let $data_dst_814019441 := add($linked_dst_814019441, 32)
                                for { let $offs_814019441 := 0 } lt($offs_814019441, $data_size_814019441) { $offs_814019441 := add($offs_814019441, 32)} {
                                    $AlignedStorageStore(add($data_dst_814019441, $offs_814019441), mload(add($data_src_814019441, $offs_814019441)))
                                    $Free($linked_src_814019441, add($data_size_814019441, 32))
                                }
                                $AlignedStorageStore(add($dst, 0), $linked_dst_814019441)
                            }
                            $Free($src, 32)
                        }
                    }
                    // $t12 := 0x42
                    $t12 := 0x42
                    // $t13 := borrow_global<0x2::GlobalVectors::T<u64>>($t12)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $t12)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t13 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t14 := borrow_field<0x2::GlobalVectors::T<u64>>.v($t13)
                    $t14 := $t13
                    // $t15 := vector::pop_back<u64>($t14)
                    $t15 := A1_vector_pop_back$u64$($t14)
                    // $t16 := 12
                    $t16 := 12
                    // $t17 := ==($t15, $t16)
                    $t17 := $Eq($t15, $t16)
                    // if ($t17) goto L1 else goto L0
                    switch $t17
                    case 0  { $block := 3 }
                    default { $block := 2 }
                }
                case 5 {
                    // label L2
                    // $t19 := 0x42
                    $t19 := 0x42
                    // $t20 := borrow_global<0x2::GlobalVectors::T<u64>>($t19)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $t19)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t20 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t21 := borrow_field<0x2::GlobalVectors::T<u64>>.v($t20)
                    $t21 := $t20
                    // $t22 := vector::length<u64>($t21)
                    $t22 := A1_vector_length$u64$($t21)
                    // $t23 := 2
                    $t23 := 2
                    // $t24 := ==($t22, $t23)
                    $t24 := $Eq($t22, $t23)
                    // if ($t24) goto L4 else goto L3
                    switch $t24
                    case 0  { $block := 7 }
                    default { $block := 6 }
                }
                case 6 {
                    // label L4
                    // goto L5
                    $block := 8
                }
                case 7 {
                    // label L3
                    // $t25 := 102
                    $t25 := 102
                    // abort($t25)
                    $Abort($t25)
                }
                case 8 {
                    // label L5
                    // $t26 := 0x42
                    $t26 := 0x42
                    // $t27 := borrow_global<0x2::GlobalVectors::T<u64>>($t26)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $t26)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t27 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t28 := borrow_field<0x2::GlobalVectors::T<u64>>.v($t27)
                    $t28 := $t27
                    // $t29 := vector::pop_back<u64>($t28)
                    $t29 := A1_vector_pop_back$u64$($t28)
                    // $t30 := 11
                    $t30 := 11
                    // $t31 := ==($t29, $t30)
                    $t31 := $Eq($t29, $t30)
                    // if ($t31) goto L7 else goto L6
                    switch $t31
                    case 0  { $block := 10 }
                    default { $block := 9 }
                }
                case 9 {
                    // label L7
                    // goto L8
                    $block := 11
                }
                case 10 {
                    // label L6
                    // $t32 := 103
                    $t32 := 103
                    // abort($t32)
                    $Abort($t32)
                }
                case 11 {
                    // label L8
                    // $t33 := 0x42
                    $t33 := 0x42
                    // $t34 := borrow_global<0x2::GlobalVectors::T<u64>>($t33)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $t33)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t34 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t35 := borrow_field<0x2::GlobalVectors::T<u64>>.v($t34)
                    $t35 := $t34
                    // $t36 := vector::length<u64>($t35)
                    $t36 := A1_vector_length$u64$($t35)
                    // $t37 := 1
                    $t37 := 1
                    // $t38 := ==($t36, $t37)
                    $t38 := $Eq($t36, $t37)
                    // if ($t38) goto L10 else goto L9
                    switch $t38
                    case 0  { $block := 13 }
                    default { $block := 12 }
                }
                case 12 {
                    // label L10
                    // goto L11
                    $block := 14
                }
                case 13 {
                    // label L9
                    // $t39 := 104
                    $t39 := 104
                    // abort($t39)
                    $Abort($t39)
                }
                case 14 {
                    // label L11
                    // return ()
                    $Free($locals, 64)
                    leave
                }
            }
        }

        function A1_vector_length$u64$(v_ref) -> len {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            len := $LoadU64(v_ptr)
        }
        function A1_vector_pop_back$u64$(v_ref) -> e {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            if iszero(size) { $AbortBuiltin() }
            let e_ptr := $IndexPtr(v_ptr, add(32, mul(sub(size, 1), 8)))
            e := $LoadU64(e_ptr)
            $StoreU64(v_ptr, sub(size, 1))
        }
        function A2_Evm_sign(addr) -> signer {
          signer := addr
        }
        function A1_vector_push_back$u64$(v_ref, e) {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            let e_ptr := $IndexPtr(v_ptr, add(32, mul(size, 8)))
            $StoreU64(e_ptr, e)
            size := add(size, 1)
            $StoreU64(v_ptr, size)
            let capacity := $LoadU64($IndexPtr(v_ptr, 8))
            if and(iszero($IsStoragePtr(v_ptr)), eq(size, capacity)) {
                let new_v_offs := $ResizeVector(v_offs, capacity, 8)
                $StoreU256(v_ref, new_v_offs)
            }
        }
        function A1_vector_empty$u64$() -> vector {
            vector := $Malloc(48)
            $MemoryStoreU64(add(vector, 8), 2)
        }
        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Malloc(size) -> offs {
            offs := mload(0)
            // pad to word size
            mstore(0, add(offs, shl(5, shr(5, add(size, 31)))))
        }
        function $Free(offs, size) {
        }
        function $MakePtr(is_storage, offs) -> ptr {
          ptr := or(is_storage, shl(1, offs))
        }
        function $IsStoragePtr(ptr) -> b {
          b := and(ptr, 0x1)
        }
        function $OffsetPtr(ptr) -> offs {
          offs := shr(1, ptr)
        }
        function $MaskForSize(size) -> mask {
          mask := sub(shl(shl(3, size), 1), 1)
        }
        function $ExtractBytes(word, start, size) -> bytes {
           switch size
           case 1 {
              // use the faster byte primitive
              bytes := byte(start, word)
           }
           default {
              // As we have big endian, we need to right shift the value from
              // where the highest byte starts in the word (32 - start), minus
              // the size.
              let shift_bits := shl(3, sub(sub(32, start), size))
              bytes := and(shr(shift_bits, word), $MaskForSize(size))
           }
        }
        function $InjectBytes(word, start, size, bytes) -> new_word {
           let shift_bits := shl(3, sub(sub(32, start), size))
           // Blend out the bits which we inject
           let neg_mask := not(shl(shift_bits, $MaskForSize(size)))
           word := and(word, neg_mask)
           // Overlay the bits we inject
           new_word := or(word, shl(shift_bits, bytes))
        }
        function $ToWordOffs(offs) -> word_offs, byte_offset {
          word_offs := shr(5, offs)
          byte_offset := and(offs, 0x1F)
        }
        function $OverflowBytes(byte_offset, size) -> overflow_bytes {
          let available_bytes := sub(32, byte_offset)
          switch gt(size, available_bytes)
          case 0 {
            overflow_bytes := 0
          }
          default {
            overflow_bytes := sub(size, available_bytes)
          }
        }
        function $MemoryLoadBytes(offs, size) -> val {
          // Lower bit where the value in the higher bytes ends
          let bit_end := shl(3, sub(32, size))
          val := shr(bit_end, mload(offs))
        }
        function $MemoryStoreBytes(offs, size, val) {
          let bit_end := shl(3, sub(32, size))
          let mask := shl(bit_end, $MaskForSize(size))
          mstore(offs, or(and(mload(offs), not(mask)), shl(bit_end, val)))
        }
        function $StorageLoadBytes(offs, size) -> val {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          val := $ExtractBytes(sload(key), byte_offs, size)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          if $LogicalNot(iszero(overflow_bytes)) {
            key := $StorageKey(0, add(word_offs, 1))
            let extra_bytes := $ExtractBytes(sload(key), 0, overflow_bytes)
            val := or(shl(shl(3, overflow_bytes), val), extra_bytes)
          }
        }
        function $StorageStoreBytes(offs, size, bytes) {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          switch overflow_bytes
          case 0 {
            sstore(key, $InjectBytes(sload(key), byte_offs, size, bytes))
          }
          default {
            // Shift the higher bytes to the right
            let used_bytes := sub(size, overflow_bytes)
            let higher_bytes := shr(used_bytes, bytes)
            let lower_bytes := and(bytes, $MaskForSize(overflow_bytes))
            sstore(key, $InjectBytes(sload(key), byte_offs, used_bytes, higher_bytes))
            key := $StorageKey(0, add(word_offs, 1))
            sstore(key, $InjectBytes(sload(key), 0, overflow_bytes, lower_bytes))
          }
        }
        function $StorageKey(group, word) -> key {
          mstore(32, word)
          mstore(64, shl(224, group))
          key := keccak256(32, 36)
        }
        function $MakeTypeStorageBase(category, type_hash, id) -> offs {
          offs := or(shl(252, category), or(shl(220, type_hash), shl(60, id)))
        }
        function $NewLinkedStorageBase(type_hash) -> offs {
          let key := $StorageKey(1, 1)
          let handle := sload(key)
          sstore(key, add(handle, 1))
          offs := $MakeTypeStorageBase(1, type_hash, handle)
        }
        function $IndexPtr(ptr, offs) -> new_ptr {
          new_ptr := $MakePtr($IsStoragePtr(ptr), add($OffsetPtr(ptr), offs))
        }
        function $LoadU64(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU64(offs)
          }
          default {
            val := $StorageLoadU64(offs)
          }
        }
        function $MemoryLoadU64(offs) -> val {
          val := $MemoryLoadBytes(offs, 8)
        }
        function $StorageLoadU64(offs) -> val {
          val := $StorageLoadBytes(offs, 8)
        }
        function $StoreU64(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU64(offs, val)
          }
          default {
            $StorageStoreU64(offs, val)
          }
        }
        function $MemoryStoreU64(offs, val) {
          $MemoryStoreBytes(offs, 8, val)
        }
        function $StorageStoreU64(offs, val) {
          $StorageStoreBytes(offs, 8, val)
        }
        function $LoadU256(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU256(offs)
          }
          default {
            val := $StorageLoadU256(offs)
          }
        }
        function $MemoryLoadU256(offs) -> val {
          val := $MemoryLoadBytes(offs, 32)
        }
        function $StorageLoadU256(offs) -> val {
          val := $StorageLoadBytes(offs, 32)
        }
        function $StoreU256(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU256(offs, val)
          }
          default {
            $StorageStoreU256(offs, val)
          }
        }
        function $MemoryStoreU256(offs, val) {
          $MemoryStoreBytes(offs, 32, val)
        }
        function $StorageStoreU256(offs, val) {
          $StorageStoreBytes(offs, 32, val)
        }
        function $AlignedStorageLoad(offs) -> val {
          let word_offs := shr(5, offs)
          val := sload($StorageKey(0, word_offs))
        }
        function $AlignedStorageStore(offs, val) {
          let word_offs := shr(5, offs)
          sstore($StorageKey(0, word_offs), val)
        }
        function $CopyMemory(src, dst, size) {
          let num_words, overflow_bytes := $ToWordOffs(size)
          let i := 0
          for { } lt(i, mul(num_words, 32)) { i := add(i, 32) } {
            mstore(add(dst, i), mload(add(src, i)))
          }
          if overflow_bytes {
            let mask := $MaskForSize(sub(32, overflow_bytes))
            let overflow_offs := mul(num_words, 32)
            let dst_word := and(mload(add(dst, overflow_offs)), mask)
            let src_word := and(mload(add(src, overflow_offs)), not(mask))
            mstore(add(dst, overflow_offs), or(dst_word, src_word))
          }
        }
        function $ResizeVector(v_offs, capacity, type_size) -> new_v_offs {
            let new_capacity := mul(capacity, 2)
            let data_size := add(32, mul(capacity, type_size))
            let new_data_size := add(32, mul(new_capacity, type_size))
            new_v_offs := $Malloc(new_data_size)
            $CopyMemory(v_offs, new_v_offs, data_size)
            // update capacity at new location
            $MemoryStoreU64(add(new_v_offs, 8), new_capacity)
            $Free(v_offs, data_size)
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
        function $LogicalNot(x) -> r {
            r := iszero(x)
        }
    }
}
===> Test result of GlobalVectors::test_pop_back_global: Succeed(Stopped) (used_gas=121755): []

// test of GlobalVectors::test_pop_back_struct_global
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_GlobalVectors_test_pop_back_struct_global" {
    code {
        mstore(0, memoryguard(160))
        A2_GlobalVectors_test_pop_back_struct_global()
        return (0, 0)
        function A2_GlobalVectors_test_pop_back_struct_global() {
            let tmp_$1, tmp_$2, e, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27, $t28, $t29, $t30, $t31, $t32, $t33, $t34, $t35, $t36, $t37, $t38, $t39, $t40, $t41, $t42, $t43, $t44, $t45, $t46, $t47, $t48, $t49, $t50, $t51, $t52, $t53, $t54, $t55, $t56, $t57, $t58, $t59, $t60, $t61, $t62
            let $locals := $Malloc(64)
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // $t29 := borrow_local($t3)
                    $t29 := $MakePtr(false, e)
                    // $t30 := borrow_field<0x2::GlobalVectors::S>.y($t29)
                    $t30 := $IndexPtr($t29, 16)
                    // $t31 := read_ref($t30)
                    $t31 := $LoadU64($t30)
                    // $t32 := 42
                    $t32 := 42
                    // $t1 := ==($t31, $t32)
                    tmp_$1 := $Eq($t31, $t32)
                    // goto L2
                    $block := 5
                }
                case 3 {
                    // label L0
                    // $t33 := false
                    $t33 := false
                    // $t1 := $t33
                    tmp_$1 := $t33
                    // goto L2
                    $block := 5
                }
                case 4 {
                    // $t4 := vector::empty<0x2::GlobalVectors::S>()
                    mstore($locals, A1_vector_empty$A2_GlobalVectors_S$())
                    // $t5 := borrow_local($t4)
                    $t5 := $MakePtr(false, $locals)
                    // $t6 := 10
                    $t6 := 10
                    // $t7 := 40
                    $t7 := 40
                    // $t8 := pack 0x2::GlobalVectors::S($t6, $t7)
                    {
                        let $mem := $Malloc(24)
                        $MemoryStoreU128(add($mem, 0), $t6)
                        $MemoryStoreU64(add($mem, 16), $t7)
                        $t8 := $mem
                    }
                    // vector::push_back<0x2::GlobalVectors::S>($t5, $t8)
                    A1_vector_push_back$A2_GlobalVectors_S$($t5, $t8)
                    // $t9 := borrow_local($t4)
                    $t9 := $MakePtr(false, $locals)
                    // $t10 := 11
                    $t10 := 11
                    // $t11 := 41
                    $t11 := 41
                    // $t12 := pack 0x2::GlobalVectors::S($t10, $t11)
                    {
                        let $mem := $Malloc(24)
                        $MemoryStoreU128(add($mem, 0), $t10)
                        $MemoryStoreU64(add($mem, 16), $t11)
                        $t12 := $mem
                    }
                    // vector::push_back<0x2::GlobalVectors::S>($t9, $t12)
                    A1_vector_push_back$A2_GlobalVectors_S$($t9, $t12)
                    // $t13 := borrow_local($t4)
                    $t13 := $MakePtr(false, $locals)
                    // $t14 := 12
                    $t14 := 12
                    // $t15 := 42
                    $t15 := 42
                    // $t16 := pack 0x2::GlobalVectors::S($t14, $t15)
                    {
                        let $mem := $Malloc(24)
                        $MemoryStoreU128(add($mem, 0), $t14)
                        $MemoryStoreU64(add($mem, 16), $t15)
                        $t16 := $mem
                    }
                    // vector::push_back<0x2::GlobalVectors::S>($t13, $t16)
                    A1_vector_push_back$A2_GlobalVectors_S$($t13, $t16)
                    // $t17 := 0x42
                    $t17 := 0x42
                    // $t0 := Evm::sign($t17)
                    mstore(add($locals, 32), A2_Evm_sign($t17))
                    // $t18 := borrow_local($t0)
                    $t18 := $MakePtr(false, add($locals, 32))
                    // $t19 := move($t4)
                    $t19 := mload($locals)
                    // $t20 := pack 0x2::GlobalVectors::T<0x2::GlobalVectors::S>($t19)
                    {
                        let $mem := $Malloc(32)
                        $MemoryStoreU256(add($mem, 0), $t19)
                        $t20 := $mem
                    }
                    // move_to<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>($t20, $t18)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x27c9b6b7, $LoadU256($t18))
                        if $AlignedStorageLoad($base_offset) {
                          $AbortBuiltin()
                        }
                        $AlignedStorageStore($base_offset, true)
                        {
                            let $dst := add($base_offset, 32)
                            let $src := $t20
                            {
                                let $linked_src_634259357 := mload(add($src, 0))
                                let $linked_dst_634259357 := $NewLinkedStorageBase(0x25ce079d)
                                let $size_634259357 := $MemoryLoadU64($linked_src_634259357)
                                let $data_size_634259357 := mul($size_634259357, 32)
                                $AlignedStorageStore($linked_dst_634259357, mload($linked_src_634259357))
                                let $data_src_634259357 := add($linked_src_634259357, 32)
                                let $data_dst_634259357 := add($linked_dst_634259357, 32)
                                for { let $offs_634259357 := 0 } lt($offs_634259357, $data_size_634259357) { $offs_634259357 := add($offs_634259357, 32)} {
                                    {
                                        let $linked_src_3681206257 := mload(add($offs_634259357, $data_src_634259357))
                                        let $linked_dst_3681206257 := $NewLinkedStorageBase(0xdb6abff1)
                                        $AlignedStorageStore(add($linked_dst_3681206257, 0), mload(add($linked_src_3681206257, 0)))
                                        $Free($linked_src_3681206257, 24)
                                        $AlignedStorageStore(add($data_dst_634259357, $offs_634259357), $linked_dst_3681206257)
                                    }
                                    $Free($linked_src_634259357, add($data_size_634259357, 32))
                                }
                                $AlignedStorageStore(add($dst, 0), $linked_dst_634259357)
                            }
                            $Free($src, 32)
                        }
                    }
                    // $t21 := 0x42
                    $t21 := 0x42
                    // $t22 := borrow_global<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>($t21)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x27c9b6b7, $t21)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t22 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t23 := borrow_field<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>.v($t22)
                    $t23 := $t22
                    // $t3 := vector::pop_back<0x2::GlobalVectors::S>($t23)
                    e := A1_vector_pop_back$A2_GlobalVectors_S$($t23)
                    // $t24 := borrow_local($t3)
                    $t24 := $MakePtr(false, e)
                    // $t25 := borrow_field<0x2::GlobalVectors::S>.x($t24)
                    $t25 := $t24
                    // $t26 := read_ref($t25)
                    $t26 := $LoadU128($t25)
                    // $t27 := 12
                    $t27 := 12
                    // $t28 := ==($t26, $t27)
                    $t28 := $Eq($t26, $t27)
                    // if ($t28) goto L1 else goto L0
                    switch $t28
                    case 0  { $block := 3 }
                    default { $block := 2 }
                }
                case 5 {
                    // label L2
                    // if ($t1) goto L4 else goto L3
                    switch tmp_$1
                    case 0  { $block := 7 }
                    default { $block := 6 }
                }
                case 6 {
                    // label L4
                    // goto L5
                    $block := 8
                }
                case 7 {
                    // label L3
                    // $t34 := 101
                    $t34 := 101
                    // abort($t34)
                    $Abort($t34)
                }
                case 8 {
                    // label L5
                    // $t35 := 0x42
                    $t35 := 0x42
                    // $t36 := borrow_global<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>($t35)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x27c9b6b7, $t35)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t36 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t37 := borrow_field<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>.v($t36)
                    $t37 := $t36
                    // $t38 := vector::length<0x2::GlobalVectors::S>($t37)
                    $t38 := A1_vector_length$A2_GlobalVectors_S$($t37)
                    // $t39 := 2
                    $t39 := 2
                    // $t40 := ==($t38, $t39)
                    $t40 := $Eq($t38, $t39)
                    // if ($t40) goto L7 else goto L6
                    switch $t40
                    case 0  { $block := 10 }
                    default { $block := 9 }
                }
                case 9 {
                    // label L7
                    // goto L8
                    $block := 11
                }
                case 10 {
                    // label L6
                    // $t41 := 102
                    $t41 := 102
                    // abort($t41)
                    $Abort($t41)
                }
                case 11 {
                    // label L8
                    // $t42 := 0x42
                    $t42 := 0x42
                    // $t43 := borrow_global<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>($t42)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x27c9b6b7, $t42)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t43 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t44 := borrow_field<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>.v($t43)
                    $t44 := $t43
                    // $t3 := vector::pop_back<0x2::GlobalVectors::S>($t44)
                    e := A1_vector_pop_back$A2_GlobalVectors_S$($t44)
                    // $t45 := borrow_local($t3)
                    $t45 := $MakePtr(false, e)
                    // $t46 := borrow_field<0x2::GlobalVectors::S>.x($t45)
                    $t46 := $t45
                    // $t47 := read_ref($t46)
                    $t47 := $LoadU128($t46)
                    // $t48 := 11
                    $t48 := 11
                    // $t49 := ==($t47, $t48)
                    $t49 := $Eq($t47, $t48)
                    // if ($t49) goto L10 else goto L9
                    switch $t49
                    case 0  { $block := 13 }
                    default { $block := 12 }
                }
                case 12 {
                    // label L10
                    // $t50 := borrow_local($t3)
                    $t50 := $MakePtr(false, e)
                    // $t51 := borrow_field<0x2::GlobalVectors::S>.y($t50)
                    $t51 := $IndexPtr($t50, 16)
                    // $t52 := read_ref($t51)
                    $t52 := $LoadU64($t51)
                    // $t53 := 41
                    $t53 := 41
                    // $t2 := ==($t52, $t53)
                    tmp_$2 := $Eq($t52, $t53)
                    // goto L11
                    $block := 14
                }
                case 13 {
                    // label L9
                    // $t54 := false
                    $t54 := false
                    // $t2 := $t54
                    tmp_$2 := $t54
                    // goto L11
                    $block := 14
                }
                case 14 {
                    // label L11
                    // if ($t2) goto L13 else goto L12
                    switch tmp_$2
                    case 0  { $block := 16 }
                    default { $block := 15 }
                }
                case 15 {
                    // label L13
                    // goto L14
                    $block := 17
                }
                case 16 {
                    // label L12
                    // $t55 := 103
                    $t55 := 103
                    // abort($t55)
                    $Abort($t55)
                }
                case 17 {
                    // label L14
                    // $t56 := 0x42
                    $t56 := 0x42
                    // $t57 := borrow_global<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>($t56)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x27c9b6b7, $t56)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t57 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t58 := borrow_field<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>.v($t57)
                    $t58 := $t57
                    // $t59 := vector::length<0x2::GlobalVectors::S>($t58)
                    $t59 := A1_vector_length$A2_GlobalVectors_S$($t58)
                    // $t60 := 1
                    $t60 := 1
                    // $t61 := ==($t59, $t60)
                    $t61 := $Eq($t59, $t60)
                    // if ($t61) goto L16 else goto L15
                    switch $t61
                    case 0  { $block := 19 }
                    default { $block := 18 }
                }
                case 18 {
                    // label L16
                    // goto L17
                    $block := 20
                }
                case 19 {
                    // label L15
                    // $t62 := 104
                    $t62 := 104
                    // abort($t62)
                    $Abort($t62)
                }
                case 20 {
                    // label L17
                    // return ()
                    $Free($locals, 64)
                    leave
                }
            }
        }

        function A1_vector_length$A2_GlobalVectors_S$(v_ref) -> len {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            len := $LoadU64(v_ptr)
        }
        function A1_vector_pop_back$A2_GlobalVectors_S$(v_ref) -> e {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            if iszero(size) { $AbortBuiltin() }
            let e_ptr := $IndexPtr(v_ptr, add(32, mul(sub(size, 1), 32)))
            e := $LoadU256(e_ptr)
            if $IsStoragePtr(e_ptr) {
                let e_offs := $OffsetPtr(e_ptr)
                let linked_src := $AlignedStorageLoad(e_offs)
                e := $Malloc(24)
                mstore(add(e, 0), $AlignedStorageLoad(add(linked_src, 0)))
                $AlignedStorageStore(add(linked_src, 0), 0)
                $AlignedStorageStore(e_offs, 0)
            }
            $StoreU64(v_ptr, sub(size, 1))
        }
        function A2_Evm_sign(addr) -> signer {
          signer := addr
        }
        function A1_vector_push_back$A2_GlobalVectors_S$(v_ref, e) {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            let e_ptr := $IndexPtr(v_ptr, add(32, mul(size, 32)))
            $StoreU256(e_ptr, e)
            if $IsStoragePtr(e_ptr) {
                let e_offs := $OffsetPtr(e_ptr)
                let $linked_dst_3681206257 := $NewLinkedStorageBase(0xdb6abff1)
                $AlignedStorageStore(add($linked_dst_3681206257, 0), mload(add(e, 0)))
                $Free(e, 24)
                $AlignedStorageStore(e_offs, $linked_dst_3681206257)
            }
            size := add(size, 1)
            $StoreU64(v_ptr, size)
            let capacity := $LoadU64($IndexPtr(v_ptr, 8))
            if and(iszero($IsStoragePtr(v_ptr)), eq(size, capacity)) {
                let new_v_offs := $ResizeVector(v_offs, capacity, 32)
                $StoreU256(v_ref, new_v_offs)
            }
        }
        function A1_vector_empty$A2_GlobalVectors_S$() -> vector {
            vector := $Malloc(96)
            $MemoryStoreU64(add(vector, 8), 2)
        }
        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Malloc(size) -> offs {
            offs := mload(0)
            // pad to word size
            mstore(0, add(offs, shl(5, shr(5, add(size, 31)))))
        }
        function $Free(offs, size) {
        }
        function $MakePtr(is_storage, offs) -> ptr {
          ptr := or(is_storage, shl(1, offs))
        }
        function $IsStoragePtr(ptr) -> b {
          b := and(ptr, 0x1)
        }
        function $OffsetPtr(ptr) -> offs {
          offs := shr(1, ptr)
        }
        function $MaskForSize(size) -> mask {
          mask := sub(shl(shl(3, size), 1), 1)
        }
        function $ExtractBytes(word, start, size) -> bytes {
           switch size
           case 1 {
              // use the faster byte primitive
              bytes := byte(start, word)
           }
           default {
              // As we have big endian, we need to right shift the value from
              // where the highest byte starts in the word (32 - start), minus
              // the size.
              let shift_bits := shl(3, sub(sub(32, start), size))
              bytes := and(shr(shift_bits, word), $MaskForSize(size))
           }
        }
        function $InjectBytes(word, start, size, bytes) -> new_word {
           let shift_bits := shl(3, sub(sub(32, start), size))
           // Blend out the bits which we inject
           let neg_mask := not(shl(shift_bits, $MaskForSize(size)))
           word := and(word, neg_mask)
           // Overlay the bits we inject
           new_word := or(word, shl(shift_bits, bytes))
        }
        function $ToWordOffs(offs) -> word_offs, byte_offset {
          word_offs := shr(5, offs)
          byte_offset := and(offs, 0x1F)
        }
        function $OverflowBytes(byte_offset, size) -> overflow_bytes {
          let available_bytes := sub(32, byte_offset)
          switch gt(size, available_bytes)
          case 0 {
            overflow_bytes := 0
          }
          default {
            overflow_bytes := sub(size, available_bytes)
          }
        }
        function $MemoryLoadBytes(offs, size) -> val {
          // Lower bit where the value in the higher bytes ends
          let bit_end := shl(3, sub(32, size))
          val := shr(bit_end, mload(offs))
        }
        function $MemoryStoreBytes(offs, size, val) {
          let bit_end := shl(3, sub(32, size))
          let mask := shl(bit_end, $MaskForSize(size))
          mstore(offs, or(and(mload(offs), not(mask)), shl(bit_end, val)))
        }
        function $StorageLoadBytes(offs, size) -> val {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          val := $ExtractBytes(sload(key), byte_offs, size)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          if $LogicalNot(iszero(overflow_bytes)) {
            key := $StorageKey(0, add(word_offs, 1))
            let extra_bytes := $ExtractBytes(sload(key), 0, overflow_bytes)
            val := or(shl(shl(3, overflow_bytes), val), extra_bytes)
          }
        }
        function $StorageStoreBytes(offs, size, bytes) {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          switch overflow_bytes
          case 0 {
            sstore(key, $InjectBytes(sload(key), byte_offs, size, bytes))
          }
          default {
            // Shift the higher bytes to the right
            let used_bytes := sub(size, overflow_bytes)
            let higher_bytes := shr(used_bytes, bytes)
            let lower_bytes := and(bytes, $MaskForSize(overflow_bytes))
            sstore(key, $InjectBytes(sload(key), byte_offs, used_bytes, higher_bytes))
            key := $StorageKey(0, add(word_offs, 1))
            sstore(key, $InjectBytes(sload(key), 0, overflow_bytes, lower_bytes))
          }
        }
        function $StorageKey(group, word) -> key {
          mstore(32, word)
          mstore(64, shl(224, group))
          key := keccak256(32, 36)
        }
        function $MakeTypeStorageBase(category, type_hash, id) -> offs {
          offs := or(shl(252, category), or(shl(220, type_hash), shl(60, id)))
        }
        function $NewLinkedStorageBase(type_hash) -> offs {
          let key := $StorageKey(1, 1)
          let handle := sload(key)
          sstore(key, add(handle, 1))
          offs := $MakeTypeStorageBase(1, type_hash, handle)
        }
        function $IndexPtr(ptr, offs) -> new_ptr {
          new_ptr := $MakePtr($IsStoragePtr(ptr), add($OffsetPtr(ptr), offs))
        }
        function $LoadU64(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU64(offs)
          }
          default {
            val := $StorageLoadU64(offs)
          }
        }
        function $MemoryLoadU64(offs) -> val {
          val := $MemoryLoadBytes(offs, 8)
        }
        function $StorageLoadU64(offs) -> val {
          val := $StorageLoadBytes(offs, 8)
        }
        function $StoreU64(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU64(offs, val)
          }
          default {
            $StorageStoreU64(offs, val)
          }
        }
        function $MemoryStoreU64(offs, val) {
          $MemoryStoreBytes(offs, 8, val)
        }
        function $StorageStoreU64(offs, val) {
          $StorageStoreBytes(offs, 8, val)
        }
        function $LoadU128(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU128(offs)
          }
          default {
            val := $StorageLoadU128(offs)
          }
        }
        function $MemoryLoadU128(offs) -> val {
          val := $MemoryLoadBytes(offs, 16)
        }
        function $StorageLoadU128(offs) -> val {
          val := $StorageLoadBytes(offs, 16)
        }
        function $MemoryStoreU128(offs, val) {
          $MemoryStoreBytes(offs, 16, val)
        }
        function $LoadU256(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU256(offs)
          }
          default {
            val := $StorageLoadU256(offs)
          }
        }
        function $MemoryLoadU256(offs) -> val {
          val := $MemoryLoadBytes(offs, 32)
        }
        function $StorageLoadU256(offs) -> val {
          val := $StorageLoadBytes(offs, 32)
        }
        function $StoreU256(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU256(offs, val)
          }
          default {
            $StorageStoreU256(offs, val)
          }
        }
        function $MemoryStoreU256(offs, val) {
          $MemoryStoreBytes(offs, 32, val)
        }
        function $StorageStoreU256(offs, val) {
          $StorageStoreBytes(offs, 32, val)
        }
        function $AlignedStorageLoad(offs) -> val {
          let word_offs := shr(5, offs)
          val := sload($StorageKey(0, word_offs))
        }
        function $AlignedStorageStore(offs, val) {
          let word_offs := shr(5, offs)
          sstore($StorageKey(0, word_offs), val)
        }
        function $CopyMemory(src, dst, size) {
          let num_words, overflow_bytes := $ToWordOffs(size)
          let i := 0
          for { } lt(i, mul(num_words, 32)) { i := add(i, 32) } {
            mstore(add(dst, i), mload(add(src, i)))
          }
          if overflow_bytes {
            let mask := $MaskForSize(sub(32, overflow_bytes))
            let overflow_offs := mul(num_words, 32)
            let dst_word := and(mload(add(dst, overflow_offs)), mask)
            let src_word := and(mload(add(src, overflow_offs)), not(mask))
            mstore(add(dst, overflow_offs), or(dst_word, src_word))
          }
        }
        function $ResizeVector(v_offs, capacity, type_size) -> new_v_offs {
            let new_capacity := mul(capacity, 2)
            let data_size := add(32, mul(capacity, type_size))
            let new_data_size := add(32, mul(new_capacity, type_size))
            new_v_offs := $Malloc(new_data_size)
            $CopyMemory(v_offs, new_v_offs, data_size)
            // update capacity at new location
            $MemoryStoreU64(add(new_v_offs, 8), new_capacity)
            $Free(v_offs, data_size)
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
        function $LogicalNot(x) -> r {
            r := iszero(x)
        }
    }
}
===> Test result of GlobalVectors::test_pop_back_struct_global: Succeed(Stopped) (used_gas=190461): []

// test of GlobalVectors::test_push_back_global
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_GlobalVectors_test_push_back_global" {
    code {
        mstore(0, memoryguard(160))
        A2_GlobalVectors_test_push_back_global()
        return (0, 0)
        function A2_GlobalVectors_test_push_back_global() {
            let $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27, $t28, $t29, $t30, $t31, $t32, $t33, $t34, $t35, $t36, $t37, $t38, $t39, $t40, $t41, $t42, $t43, $t44, $t45, $t46, $t47, $t48, $t49, $t50, $t51, $t52, $t53, $t54, $t55, $t56, $t57, $t58, $t59, $t60, $t61, $t62, $t63, $t64, $t65, $t66, $t67, $t68, $t69, $t70, $t71
            let $locals := $Malloc(64)
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // goto L2
                    $block := 5
                }
                case 3 {
                    // label L0
                    // $t26 := 101
                    $t26 := 101
                    // abort($t26)
                    $Abort($t26)
                }
                case 4 {
                    // $t1 := vector::empty<u64>()
                    mstore($locals, A1_vector_empty$u64$())
                    // $t2 := borrow_local($t1)
                    $t2 := $MakePtr(false, $locals)
                    // $t3 := 10
                    $t3 := 10
                    // vector::push_back<u64>($t2, $t3)
                    A1_vector_push_back$u64$($t2, $t3)
                    // $t4 := borrow_local($t1)
                    $t4 := $MakePtr(false, $locals)
                    // $t5 := 11
                    $t5 := 11
                    // vector::push_back<u64>($t4, $t5)
                    A1_vector_push_back$u64$($t4, $t5)
                    // $t6 := borrow_local($t1)
                    $t6 := $MakePtr(false, $locals)
                    // $t7 := 12
                    $t7 := 12
                    // vector::push_back<u64>($t6, $t7)
                    A1_vector_push_back$u64$($t6, $t7)
                    // $t8 := 0x42
                    $t8 := 0x42
                    // $t0 := Evm::sign($t8)
                    mstore(add($locals, 32), A2_Evm_sign($t8))
                    // $t9 := borrow_local($t0)
                    $t9 := $MakePtr(false, add($locals, 32))
                    // $t10 := copy($t1)
                    $t10 := mload($locals)
                    // $t11 := pack 0x2::GlobalVectors::T<u64>($t10)
                    {
                        let $mem := $Malloc(32)
                        $MemoryStoreU256(add($mem, 0), $t10)
                        $t11 := $mem
                    }
                    // move_to<0x2::GlobalVectors::T<u64>>($t11, $t9)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $LoadU256($t9))
                        if $AlignedStorageLoad($base_offset) {
                          $AbortBuiltin()
                        }
                        $AlignedStorageStore($base_offset, true)
                        {
                            let $dst := add($base_offset, 32)
                            let $src := $t11
                            {
                                let $linked_src_814019441 := mload(add($src, 0))
                                let $linked_dst_814019441 := $NewLinkedStorageBase(0x3084f371)
                                let $size_814019441 := $MemoryLoadU64($linked_src_814019441)
                                let $data_size_814019441 := mul($size_814019441, 8)
                                $AlignedStorageStore($linked_dst_814019441, mload($linked_src_814019441))
                                let $data_src_814019441 := add($linked_src_814019441, 32)
                                let $data_dst_814019441 := add($linked_dst_814019441, 32)
                                for { let $offs_814019441 := 0 } lt($offs_814019441, $data_size_814019441) { $offs_814019441 := add($offs_814019441, 32)} {
                                    $AlignedStorageStore(add($data_dst_814019441, $offs_814019441), mload(add($data_src_814019441, $offs_814019441)))
                                    $Free($linked_src_814019441, add($data_size_814019441, 32))
                                }
                                $AlignedStorageStore(add($dst, 0), $linked_dst_814019441)
                            }
                            $Free($src, 32)
                        }
                    }
                    // $t12 := 0x42
                    $t12 := 0x42
                    // $t13 := borrow_global<0x2::GlobalVectors::T<u64>>($t12)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $t12)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t13 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t14 := borrow_field<0x2::GlobalVectors::T<u64>>.v($t13)
                    $t14 := $t13
                    // $t15 := 13
                    $t15 := 13
                    // vector::push_back<u64>($t14, $t15)
                    A1_vector_push_back$u64$($t14, $t15)
                    // $t16 := 0x42
                    $t16 := 0x42
                    // $t17 := borrow_global<0x2::GlobalVectors::T<u64>>($t16)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $t16)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t17 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t18 := borrow_field<0x2::GlobalVectors::T<u64>>.v($t17)
                    $t18 := $t17
                    // $t19 := 14
                    $t19 := 14
                    // vector::push_back<u64>($t18, $t19)
                    A1_vector_push_back$u64$($t18, $t19)
                    // $t20 := 0x42
                    $t20 := 0x42
                    // $t21 := borrow_global<0x2::GlobalVectors::T<u64>>($t20)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $t20)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t21 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t22 := borrow_field<0x2::GlobalVectors::T<u64>>.v($t21)
                    $t22 := $t21
                    // $t23 := vector::length<u64>($t22)
                    $t23 := A1_vector_length$u64$($t22)
                    // $t24 := 5
                    $t24 := 5
                    // $t25 := ==($t23, $t24)
                    $t25 := $Eq($t23, $t24)
                    // if ($t25) goto L1 else goto L0
                    switch $t25
                    case 0  { $block := 3 }
                    default { $block := 2 }
                }
                case 5 {
                    // label L2
                    // $t27 := 0x42
                    $t27 := 0x42
                    // $t28 := borrow_global<0x2::GlobalVectors::T<u64>>($t27)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $t27)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t28 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t29 := borrow_field<0x2::GlobalVectors::T<u64>>.v($t28)
                    $t29 := $t28
                    // $t30 := 0
                    $t30 := 0
                    // $t31 := vector::borrow<u64>($t29, $t30)
                    $t31 := A1_vector_borrow$u64$($t29, $t30)
                    // $t32 := read_ref($t31)
                    $t32 := $LoadU64($t31)
                    // $t33 := 10
                    $t33 := 10
                    // $t34 := ==($t32, $t33)
                    $t34 := $Eq($t32, $t33)
                    // if ($t34) goto L4 else goto L3
                    switch $t34
                    case 0  { $block := 7 }
                    default { $block := 6 }
                }
                case 6 {
                    // label L4
                    // goto L5
                    $block := 8
                }
                case 7 {
                    // label L3
                    // $t35 := 102
                    $t35 := 102
                    // abort($t35)
                    $Abort($t35)
                }
                case 8 {
                    // label L5
                    // $t36 := 0x42
                    $t36 := 0x42
                    // $t37 := borrow_global<0x2::GlobalVectors::T<u64>>($t36)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $t36)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t37 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t38 := borrow_field<0x2::GlobalVectors::T<u64>>.v($t37)
                    $t38 := $t37
                    // $t39 := 1
                    $t39 := 1
                    // $t40 := vector::borrow<u64>($t38, $t39)
                    $t40 := A1_vector_borrow$u64$($t38, $t39)
                    // $t41 := read_ref($t40)
                    $t41 := $LoadU64($t40)
                    // $t42 := 11
                    $t42 := 11
                    // $t43 := ==($t41, $t42)
                    $t43 := $Eq($t41, $t42)
                    // if ($t43) goto L7 else goto L6
                    switch $t43
                    case 0  { $block := 10 }
                    default { $block := 9 }
                }
                case 9 {
                    // label L7
                    // goto L8
                    $block := 11
                }
                case 10 {
                    // label L6
                    // $t44 := 103
                    $t44 := 103
                    // abort($t44)
                    $Abort($t44)
                }
                case 11 {
                    // label L8
                    // $t45 := 0x42
                    $t45 := 0x42
                    // $t46 := borrow_global<0x2::GlobalVectors::T<u64>>($t45)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $t45)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t46 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t47 := borrow_field<0x2::GlobalVectors::T<u64>>.v($t46)
                    $t47 := $t46
                    // $t48 := 2
                    $t48 := 2
                    // $t49 := vector::borrow<u64>($t47, $t48)
                    $t49 := A1_vector_borrow$u64$($t47, $t48)
                    // $t50 := read_ref($t49)
                    $t50 := $LoadU64($t49)
                    // $t51 := 12
                    $t51 := 12
                    // $t52 := ==($t50, $t51)
                    $t52 := $Eq($t50, $t51)
                    // if ($t52) goto L10 else goto L9
                    switch $t52
                    case 0  { $block := 13 }
                    default { $block := 12 }
                }
                case 12 {
                    // label L10
                    // goto L11
                    $block := 14
                }
                case 13 {
                    // label L9
                    // $t53 := 104
                    $t53 := 104
                    // abort($t53)
                    $Abort($t53)
                }
                case 14 {
                    // label L11
                    // $t54 := 0x42
                    $t54 := 0x42
                    // $t55 := borrow_global<0x2::GlobalVectors::T<u64>>($t54)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $t54)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t55 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t56 := borrow_field<0x2::GlobalVectors::T<u64>>.v($t55)
                    $t56 := $t55
                    // $t57 := 3
                    $t57 := 3
                    // $t58 := vector::borrow<u64>($t56, $t57)
                    $t58 := A1_vector_borrow$u64$($t56, $t57)
                    // $t59 := read_ref($t58)
                    $t59 := $LoadU64($t58)
                    // $t60 := 13
                    $t60 := 13
                    // $t61 := ==($t59, $t60)
                    $t61 := $Eq($t59, $t60)
                    // if ($t61) goto L13 else goto L12
                    switch $t61
                    case 0  { $block := 16 }
                    default { $block := 15 }
                }
                case 15 {
                    // label L13
                    // goto L14
                    $block := 17
                }
                case 16 {
                    // label L12
                    // $t62 := 105
                    $t62 := 105
                    // abort($t62)
                    $Abort($t62)
                }
                case 17 {
                    // label L14
                    // $t63 := 0x42
                    $t63 := 0x42
                    // $t64 := borrow_global<0x2::GlobalVectors::T<u64>>($t63)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $t63)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t64 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t65 := borrow_field<0x2::GlobalVectors::T<u64>>.v($t64)
                    $t65 := $t64
                    // $t66 := 4
                    $t66 := 4
                    // $t67 := vector::borrow<u64>($t65, $t66)
                    $t67 := A1_vector_borrow$u64$($t65, $t66)
                    // $t68 := read_ref($t67)
                    $t68 := $LoadU64($t67)
                    // $t69 := 14
                    $t69 := 14
                    // $t70 := ==($t68, $t69)
                    $t70 := $Eq($t68, $t69)
                    // if ($t70) goto L16 else goto L15
                    switch $t70
                    case 0  { $block := 19 }
                    default { $block := 18 }
                }
                case 18 {
                    // label L16
                    // goto L17
                    $block := 20
                }
                case 19 {
                    // label L15
                    // $t71 := 106
                    $t71 := 106
                    // abort($t71)
                    $Abort($t71)
                }
                case 20 {
                    // label L17
                    // return ()
                    $Free($locals, 64)
                    leave
                }
            }
        }

        function A1_vector_borrow$u64$(v_ref, i) -> e_ptr {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            if $GtEq(i, size) { $AbortBuiltin() }
            e_ptr := $IndexPtr(v_ptr, add(32, mul(i, 8)))
        }
        function A1_vector_length$u64$(v_ref) -> len {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            len := $LoadU64(v_ptr)
        }
        function A1_vector_push_back$u64$(v_ref, e) {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            let e_ptr := $IndexPtr(v_ptr, add(32, mul(size, 8)))
            $StoreU64(e_ptr, e)
            size := add(size, 1)
            $StoreU64(v_ptr, size)
            let capacity := $LoadU64($IndexPtr(v_ptr, 8))
            if and(iszero($IsStoragePtr(v_ptr)), eq(size, capacity)) {
                let new_v_offs := $ResizeVector(v_offs, capacity, 8)
                $StoreU256(v_ref, new_v_offs)
            }
        }
        function A2_Evm_sign(addr) -> signer {
          signer := addr
        }
        function A1_vector_empty$u64$() -> vector {
            vector := $Malloc(48)
            $MemoryStoreU64(add(vector, 8), 2)
        }
        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Malloc(size) -> offs {
            offs := mload(0)
            // pad to word size
            mstore(0, add(offs, shl(5, shr(5, add(size, 31)))))
        }
        function $Free(offs, size) {
        }
        function $MakePtr(is_storage, offs) -> ptr {
          ptr := or(is_storage, shl(1, offs))
        }
        function $IsStoragePtr(ptr) -> b {
          b := and(ptr, 0x1)
        }
        function $OffsetPtr(ptr) -> offs {
          offs := shr(1, ptr)
        }
        function $MaskForSize(size) -> mask {
          mask := sub(shl(shl(3, size), 1), 1)
        }
        function $ExtractBytes(word, start, size) -> bytes {
           switch size
           case 1 {
              // use the faster byte primitive
              bytes := byte(start, word)
           }
           default {
              // As we have big endian, we need to right shift the value from
              // where the highest byte starts in the word (32 - start), minus
              // the size.
              let shift_bits := shl(3, sub(sub(32, start), size))
              bytes := and(shr(shift_bits, word), $MaskForSize(size))
           }
        }
        function $InjectBytes(word, start, size, bytes) -> new_word {
           let shift_bits := shl(3, sub(sub(32, start), size))
           // Blend out the bits which we inject
           let neg_mask := not(shl(shift_bits, $MaskForSize(size)))
           word := and(word, neg_mask)
           // Overlay the bits we inject
           new_word := or(word, shl(shift_bits, bytes))
        }
        function $ToWordOffs(offs) -> word_offs, byte_offset {
          word_offs := shr(5, offs)
          byte_offset := and(offs, 0x1F)
        }
        function $OverflowBytes(byte_offset, size) -> overflow_bytes {
          let available_bytes := sub(32, byte_offset)
          switch gt(size, available_bytes)
          case 0 {
            overflow_bytes := 0
          }
          default {
            overflow_bytes := sub(size, available_bytes)
          }
        }
        function $MemoryLoadBytes(offs, size) -> val {
          // Lower bit where the value in the higher bytes ends
          let bit_end := shl(3, sub(32, size))
          val := shr(bit_end, mload(offs))
        }
        function $MemoryStoreBytes(offs, size, val) {
          let bit_end := shl(3, sub(32, size))
          let mask := shl(bit_end, $MaskForSize(size))
          mstore(offs, or(and(mload(offs), not(mask)), shl(bit_end, val)))
        }
        function $StorageLoadBytes(offs, size) -> val {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          val := $ExtractBytes(sload(key), byte_offs, size)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          if $LogicalNot(iszero(overflow_bytes)) {
            key := $StorageKey(0, add(word_offs, 1))
            let extra_bytes := $ExtractBytes(sload(key), 0, overflow_bytes)
            val := or(shl(shl(3, overflow_bytes), val), extra_bytes)
          }
        }
        function $StorageStoreBytes(offs, size, bytes) {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          switch overflow_bytes
          case 0 {
            sstore(key, $InjectBytes(sload(key), byte_offs, size, bytes))
          }
          default {
            // Shift the higher bytes to the right
            let used_bytes := sub(size, overflow_bytes)
            let higher_bytes := shr(used_bytes, bytes)
            let lower_bytes := and(bytes, $MaskForSize(overflow_bytes))
            sstore(key, $InjectBytes(sload(key), byte_offs, used_bytes, higher_bytes))
            key := $StorageKey(0, add(word_offs, 1))
            sstore(key, $InjectBytes(sload(key), 0, overflow_bytes, lower_bytes))
          }
        }
        function $StorageKey(group, word) -> key {
          mstore(32, word)
          mstore(64, shl(224, group))
          key := keccak256(32, 36)
        }
        function $MakeTypeStorageBase(category, type_hash, id) -> offs {
          offs := or(shl(252, category), or(shl(220, type_hash), shl(60, id)))
        }
        function $NewLinkedStorageBase(type_hash) -> offs {
          let key := $StorageKey(1, 1)
          let handle := sload(key)
          sstore(key, add(handle, 1))
          offs := $MakeTypeStorageBase(1, type_hash, handle)
        }
        function $IndexPtr(ptr, offs) -> new_ptr {
          new_ptr := $MakePtr($IsStoragePtr(ptr), add($OffsetPtr(ptr), offs))
        }
        function $LoadU64(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU64(offs)
          }
          default {
            val := $StorageLoadU64(offs)
          }
        }
        function $MemoryLoadU64(offs) -> val {
          val := $MemoryLoadBytes(offs, 8)
        }
        function $StorageLoadU64(offs) -> val {
          val := $StorageLoadBytes(offs, 8)
        }
        function $StoreU64(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU64(offs, val)
          }
          default {
            $StorageStoreU64(offs, val)
          }
        }
        function $MemoryStoreU64(offs, val) {
          $MemoryStoreBytes(offs, 8, val)
        }
        function $StorageStoreU64(offs, val) {
          $StorageStoreBytes(offs, 8, val)
        }
        function $LoadU256(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU256(offs)
          }
          default {
            val := $StorageLoadU256(offs)
          }
        }
        function $MemoryLoadU256(offs) -> val {
          val := $MemoryLoadBytes(offs, 32)
        }
        function $StorageLoadU256(offs) -> val {
          val := $StorageLoadBytes(offs, 32)
        }
        function $StoreU256(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU256(offs, val)
          }
          default {
            $StorageStoreU256(offs, val)
          }
        }
        function $MemoryStoreU256(offs, val) {
          $MemoryStoreBytes(offs, 32, val)
        }
        function $StorageStoreU256(offs, val) {
          $StorageStoreBytes(offs, 32, val)
        }
        function $AlignedStorageLoad(offs) -> val {
          let word_offs := shr(5, offs)
          val := sload($StorageKey(0, word_offs))
        }
        function $AlignedStorageStore(offs, val) {
          let word_offs := shr(5, offs)
          sstore($StorageKey(0, word_offs), val)
        }
        function $CopyMemory(src, dst, size) {
          let num_words, overflow_bytes := $ToWordOffs(size)
          let i := 0
          for { } lt(i, mul(num_words, 32)) { i := add(i, 32) } {
            mstore(add(dst, i), mload(add(src, i)))
          }
          if overflow_bytes {
            let mask := $MaskForSize(sub(32, overflow_bytes))
            let overflow_offs := mul(num_words, 32)
            let dst_word := and(mload(add(dst, overflow_offs)), mask)
            let src_word := and(mload(add(src, overflow_offs)), not(mask))
            mstore(add(dst, overflow_offs), or(dst_word, src_word))
          }
        }
        function $ResizeVector(v_offs, capacity, type_size) -> new_v_offs {
            let new_capacity := mul(capacity, 2)
            let data_size := add(32, mul(capacity, type_size))
            let new_data_size := add(32, mul(new_capacity, type_size))
            new_v_offs := $Malloc(new_data_size)
            $CopyMemory(v_offs, new_v_offs, data_size)
            // update capacity at new location
            $MemoryStoreU64(add(new_v_offs, 8), new_capacity)
            $Free(v_offs, data_size)
        }
        function $GtEq(x, y) -> r {
            r := or(gt(x, y), eq(x, y))
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
        function $LogicalNot(x) -> r {
            r := iszero(x)
        }
    }
}
===> Test result of GlobalVectors::test_push_back_global: Succeed(Stopped) (used_gas=152738): []

// test of GlobalVectors::test_push_back_struct_global
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_GlobalVectors_test_push_back_struct_global" {
    code {
        mstore(0, memoryguard(160))
        A2_GlobalVectors_test_push_back_struct_global()
        return (0, 0)
        function A2_GlobalVectors_test_push_back_struct_global() {
            let $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27, $t28, $t29, $t30, $t31, $t32, $t33, $t34, $t35, $t36, $t37, $t38, $t39, $t40, $t41, $t42, $t43, $t44, $t45, $t46, $t47, $t48, $t49, $t50, $t51, $t52, $t53, $t54, $t55, $t56, $t57, $t58, $t59, $t60, $t61, $t62, $t63, $t64, $t65, $t66
            let $locals := $Malloc(64)
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // goto L2
                    $block := 5
                }
                case 3 {
                    // label L0
                    // $t36 := 101
                    $t36 := 101
                    // abort($t36)
                    $Abort($t36)
                }
                case 4 {
                    // $t1 := vector::empty<0x2::GlobalVectors::S>()
                    mstore($locals, A1_vector_empty$A2_GlobalVectors_S$())
                    // $t2 := borrow_local($t1)
                    $t2 := $MakePtr(false, $locals)
                    // $t3 := 10
                    $t3 := 10
                    // $t4 := 40
                    $t4 := 40
                    // $t5 := pack 0x2::GlobalVectors::S($t3, $t4)
                    {
                        let $mem := $Malloc(24)
                        $MemoryStoreU128(add($mem, 0), $t3)
                        $MemoryStoreU64(add($mem, 16), $t4)
                        $t5 := $mem
                    }
                    // vector::push_back<0x2::GlobalVectors::S>($t2, $t5)
                    A1_vector_push_back$A2_GlobalVectors_S$($t2, $t5)
                    // $t6 := borrow_local($t1)
                    $t6 := $MakePtr(false, $locals)
                    // $t7 := 11
                    $t7 := 11
                    // $t8 := 41
                    $t8 := 41
                    // $t9 := pack 0x2::GlobalVectors::S($t7, $t8)
                    {
                        let $mem := $Malloc(24)
                        $MemoryStoreU128(add($mem, 0), $t7)
                        $MemoryStoreU64(add($mem, 16), $t8)
                        $t9 := $mem
                    }
                    // vector::push_back<0x2::GlobalVectors::S>($t6, $t9)
                    A1_vector_push_back$A2_GlobalVectors_S$($t6, $t9)
                    // $t10 := borrow_local($t1)
                    $t10 := $MakePtr(false, $locals)
                    // $t11 := 12
                    $t11 := 12
                    // $t12 := 42
                    $t12 := 42
                    // $t13 := pack 0x2::GlobalVectors::S($t11, $t12)
                    {
                        let $mem := $Malloc(24)
                        $MemoryStoreU128(add($mem, 0), $t11)
                        $MemoryStoreU64(add($mem, 16), $t12)
                        $t13 := $mem
                    }
                    // vector::push_back<0x2::GlobalVectors::S>($t10, $t13)
                    A1_vector_push_back$A2_GlobalVectors_S$($t10, $t13)
                    // $t14 := 0x42
                    $t14 := 0x42
                    // $t0 := Evm::sign($t14)
                    mstore(add($locals, 32), A2_Evm_sign($t14))
                    // $t15 := borrow_local($t0)
                    $t15 := $MakePtr(false, add($locals, 32))
                    // $t16 := move($t1)
                    $t16 := mload($locals)
                    // $t17 := pack 0x2::GlobalVectors::T<0x2::GlobalVectors::S>($t16)
                    {
                        let $mem := $Malloc(32)
                        $MemoryStoreU256(add($mem, 0), $t16)
                        $t17 := $mem
                    }
                    // move_to<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>($t17, $t15)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x27c9b6b7, $LoadU256($t15))
                        if $AlignedStorageLoad($base_offset) {
                          $AbortBuiltin()
                        }
                        $AlignedStorageStore($base_offset, true)
                        {
                            let $dst := add($base_offset, 32)
                            let $src := $t17
                            {
                                let $linked_src_634259357 := mload(add($src, 0))
                                let $linked_dst_634259357 := $NewLinkedStorageBase(0x25ce079d)
                                let $size_634259357 := $MemoryLoadU64($linked_src_634259357)
                                let $data_size_634259357 := mul($size_634259357, 32)
                                $AlignedStorageStore($linked_dst_634259357, mload($linked_src_634259357))
                                let $data_src_634259357 := add($linked_src_634259357, 32)
                                let $data_dst_634259357 := add($linked_dst_634259357, 32)
                                for { let $offs_634259357 := 0 } lt($offs_634259357, $data_size_634259357) { $offs_634259357 := add($offs_634259357, 32)} {
                                    {
                                        let $linked_src_3681206257 := mload(add($offs_634259357, $data_src_634259357))
                                        let $linked_dst_3681206257 := $NewLinkedStorageBase(0xdb6abff1)
                                        $AlignedStorageStore(add($linked_dst_3681206257, 0), mload(add($linked_src_3681206257, 0)))
                                        $Free($linked_src_3681206257, 24)
                                        $AlignedStorageStore(add($data_dst_634259357, $offs_634259357), $linked_dst_3681206257)
                                    }
                                    $Free($linked_src_634259357, add($data_size_634259357, 32))
                                }
                                $AlignedStorageStore(add($dst, 0), $linked_dst_634259357)
                            }
                            $Free($src, 32)
                        }
                    }
                    // $t18 := 0x42
                    $t18 := 0x42
                    // $t19 := borrow_global<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>($t18)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x27c9b6b7, $t18)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t19 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t20 := borrow_field<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>.v($t19)
                    $t20 := $t19
                    // $t21 := 13
                    $t21 := 13
                    // $t22 := 43
                    $t22 := 43
                    // $t23 := pack 0x2::GlobalVectors::S($t21, $t22)
                    {
                        let $mem := $Malloc(24)
                        $MemoryStoreU128(add($mem, 0), $t21)
                        $MemoryStoreU64(add($mem, 16), $t22)
                        $t23 := $mem
                    }
                    // vector::push_back<0x2::GlobalVectors::S>($t20, $t23)
                    A1_vector_push_back$A2_GlobalVectors_S$($t20, $t23)
                    // $t24 := 0x42
                    $t24 := 0x42
                    // $t25 := borrow_global<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>($t24)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x27c9b6b7, $t24)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t25 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t26 := borrow_field<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>.v($t25)
                    $t26 := $t25
                    // $t27 := 14
                    $t27 := 14
                    // $t28 := 44
                    $t28 := 44
                    // $t29 := pack 0x2::GlobalVectors::S($t27, $t28)
                    {
                        let $mem := $Malloc(24)
                        $MemoryStoreU128(add($mem, 0), $t27)
                        $MemoryStoreU64(add($mem, 16), $t28)
                        $t29 := $mem
                    }
                    // vector::push_back<0x2::GlobalVectors::S>($t26, $t29)
                    A1_vector_push_back$A2_GlobalVectors_S$($t26, $t29)
                    // $t30 := 0x42
                    $t30 := 0x42
                    // $t31 := borrow_global<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>($t30)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x27c9b6b7, $t30)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t31 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t32 := borrow_field<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>.v($t31)
                    $t32 := $t31
                    // $t33 := vector::length<0x2::GlobalVectors::S>($t32)
                    $t33 := A1_vector_length$A2_GlobalVectors_S$($t32)
                    // $t34 := 5
                    $t34 := 5
                    // $t35 := ==($t33, $t34)
                    $t35 := $Eq($t33, $t34)
                    // if ($t35) goto L1 else goto L0
                    switch $t35
                    case 0  { $block := 3 }
                    default { $block := 2 }
                }
                case 5 {
                    // label L2
                    // $t37 := 0x42
                    $t37 := 0x42
                    // $t38 := borrow_global<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>($t37)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x27c9b6b7, $t37)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t38 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t39 := borrow_field<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>.v($t38)
                    $t39 := $t38
                    // $t40 := 0
                    $t40 := 0
                    // $t41 := vector::borrow<0x2::GlobalVectors::S>($t39, $t40)
                    $t41 := A1_vector_borrow$A2_GlobalVectors_S$($t39, $t40)
                    // $t42 := borrow_field<0x2::GlobalVectors::S>.x($t41)
                    $t42 := $t41
                    // $t43 := read_ref($t42)
                    $t43 := $LoadU128($t42)
                    // $t44 := 10
                    $t44 := 10
                    // $t45 := ==($t43, $t44)
                    $t45 := $Eq($t43, $t44)
                    // if ($t45) goto L4 else goto L3
                    switch $t45
                    case 0  { $block := 7 }
                    default { $block := 6 }
                }
                case 6 {
                    // label L4
                    // goto L5
                    $block := 8
                }
                case 7 {
                    // label L3
                    // $t46 := 102
                    $t46 := 102
                    // abort($t46)
                    $Abort($t46)
                }
                case 8 {
                    // label L5
                    // $t47 := 0x42
                    $t47 := 0x42
                    // $t48 := borrow_global<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>($t47)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x27c9b6b7, $t47)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t48 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t49 := borrow_field<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>.v($t48)
                    $t49 := $t48
                    // $t50 := 1
                    $t50 := 1
                    // $t51 := vector::borrow<0x2::GlobalVectors::S>($t49, $t50)
                    $t51 := A1_vector_borrow$A2_GlobalVectors_S$($t49, $t50)
                    // $t52 := borrow_field<0x2::GlobalVectors::S>.x($t51)
                    $t52 := $t51
                    // $t53 := read_ref($t52)
                    $t53 := $LoadU128($t52)
                    // $t54 := 11
                    $t54 := 11
                    // $t55 := ==($t53, $t54)
                    $t55 := $Eq($t53, $t54)
                    // if ($t55) goto L7 else goto L6
                    switch $t55
                    case 0  { $block := 10 }
                    default { $block := 9 }
                }
                case 9 {
                    // label L7
                    // goto L8
                    $block := 11
                }
                case 10 {
                    // label L6
                    // $t56 := 103
                    $t56 := 103
                    // abort($t56)
                    $Abort($t56)
                }
                case 11 {
                    // label L8
                    // $t57 := 0x42
                    $t57 := 0x42
                    // $t58 := borrow_global<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>($t57)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x27c9b6b7, $t57)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t58 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t59 := borrow_field<0x2::GlobalVectors::T<0x2::GlobalVectors::S>>.v($t58)
                    $t59 := $t58
                    // $t60 := 2
                    $t60 := 2
                    // $t61 := vector::borrow<0x2::GlobalVectors::S>($t59, $t60)
                    $t61 := A1_vector_borrow$A2_GlobalVectors_S$($t59, $t60)
                    // $t62 := borrow_field<0x2::GlobalVectors::S>.x($t61)
                    $t62 := $t61
                    // $t63 := read_ref($t62)
                    $t63 := $LoadU128($t62)
                    // $t64 := 12
                    $t64 := 12
                    // $t65 := ==($t63, $t64)
                    $t65 := $Eq($t63, $t64)
                    // if ($t65) goto L10 else goto L9
                    switch $t65
                    case 0  { $block := 13 }
                    default { $block := 12 }
                }
                case 12 {
                    // label L10
                    // goto L11
                    $block := 14
                }
                case 13 {
                    // label L9
                    // $t66 := 104
                    $t66 := 104
                    // abort($t66)
                    $Abort($t66)
                }
                case 14 {
                    // label L11
                    // return ()
                    $Free($locals, 64)
                    leave
                }
            }
        }

        function A1_vector_borrow$A2_GlobalVectors_S$(v_ref, i) -> e_ptr {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            if $GtEq(i, size) { $AbortBuiltin() }
            e_ptr := $IndexPtr(v_ptr, add(32, mul(i, 32)))
            let e := $LoadU256(e_ptr)
            e_ptr := $MakePtr($IsStoragePtr(v_ref), e)
        }
        function A1_vector_length$A2_GlobalVectors_S$(v_ref) -> len {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            len := $LoadU64(v_ptr)
        }
        function A1_vector_push_back$A2_GlobalVectors_S$(v_ref, e) {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            let e_ptr := $IndexPtr(v_ptr, add(32, mul(size, 32)))
            $StoreU256(e_ptr, e)
            if $IsStoragePtr(e_ptr) {
                let e_offs := $OffsetPtr(e_ptr)
                let $linked_dst_3681206257 := $NewLinkedStorageBase(0xdb6abff1)
                $AlignedStorageStore(add($linked_dst_3681206257, 0), mload(add(e, 0)))
                $Free(e, 24)
                $AlignedStorageStore(e_offs, $linked_dst_3681206257)
            }
            size := add(size, 1)
            $StoreU64(v_ptr, size)
            let capacity := $LoadU64($IndexPtr(v_ptr, 8))
            if and(iszero($IsStoragePtr(v_ptr)), eq(size, capacity)) {
                let new_v_offs := $ResizeVector(v_offs, capacity, 32)
                $StoreU256(v_ref, new_v_offs)
            }
        }
        function A2_Evm_sign(addr) -> signer {
          signer := addr
        }
        function A1_vector_empty$A2_GlobalVectors_S$() -> vector {
            vector := $Malloc(96)
            $MemoryStoreU64(add(vector, 8), 2)
        }
        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Malloc(size) -> offs {
            offs := mload(0)
            // pad to word size
            mstore(0, add(offs, shl(5, shr(5, add(size, 31)))))
        }
        function $Free(offs, size) {
        }
        function $MakePtr(is_storage, offs) -> ptr {
          ptr := or(is_storage, shl(1, offs))
        }
        function $IsStoragePtr(ptr) -> b {
          b := and(ptr, 0x1)
        }
        function $OffsetPtr(ptr) -> offs {
          offs := shr(1, ptr)
        }
        function $MaskForSize(size) -> mask {
          mask := sub(shl(shl(3, size), 1), 1)
        }
        function $ExtractBytes(word, start, size) -> bytes {
           switch size
           case 1 {
              // use the faster byte primitive
              bytes := byte(start, word)
           }
           default {
              // As we have big endian, we need to right shift the value from
              // where the highest byte starts in the word (32 - start), minus
              // the size.
              let shift_bits := shl(3, sub(sub(32, start), size))
              bytes := and(shr(shift_bits, word), $MaskForSize(size))
           }
        }
        function $InjectBytes(word, start, size, bytes) -> new_word {
           let shift_bits := shl(3, sub(sub(32, start), size))
           // Blend out the bits which we inject
           let neg_mask := not(shl(shift_bits, $MaskForSize(size)))
           word := and(word, neg_mask)
           // Overlay the bits we inject
           new_word := or(word, shl(shift_bits, bytes))
        }
        function $ToWordOffs(offs) -> word_offs, byte_offset {
          word_offs := shr(5, offs)
          byte_offset := and(offs, 0x1F)
        }
        function $OverflowBytes(byte_offset, size) -> overflow_bytes {
          let available_bytes := sub(32, byte_offset)
          switch gt(size, available_bytes)
          case 0 {
            overflow_bytes := 0
          }
          default {
            overflow_bytes := sub(size, available_bytes)
          }
        }
        function $MemoryLoadBytes(offs, size) -> val {
          // Lower bit where the value in the higher bytes ends
          let bit_end := shl(3, sub(32, size))
          val := shr(bit_end, mload(offs))
        }
        function $MemoryStoreBytes(offs, size, val) {
          let bit_end := shl(3, sub(32, size))
          let mask := shl(bit_end, $MaskForSize(size))
          mstore(offs, or(and(mload(offs), not(mask)), shl(bit_end, val)))
        }
        function $StorageLoadBytes(offs, size) -> val {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          val := $ExtractBytes(sload(key), byte_offs, size)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          if $LogicalNot(iszero(overflow_bytes)) {
            key := $StorageKey(0, add(word_offs, 1))
            let extra_bytes := $ExtractBytes(sload(key), 0, overflow_bytes)
            val := or(shl(shl(3, overflow_bytes), val), extra_bytes)
          }
        }
        function $StorageStoreBytes(offs, size, bytes) {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          switch overflow_bytes
          case 0 {
            sstore(key, $InjectBytes(sload(key), byte_offs, size, bytes))
          }
          default {
            // Shift the higher bytes to the right
            let used_bytes := sub(size, overflow_bytes)
            let higher_bytes := shr(used_bytes, bytes)
            let lower_bytes := and(bytes, $MaskForSize(overflow_bytes))
            sstore(key, $InjectBytes(sload(key), byte_offs, used_bytes, higher_bytes))
            key := $StorageKey(0, add(word_offs, 1))
            sstore(key, $InjectBytes(sload(key), 0, overflow_bytes, lower_bytes))
          }
        }
        function $StorageKey(group, word) -> key {
          mstore(32, word)
          mstore(64, shl(224, group))
          key := keccak256(32, 36)
        }
        function $MakeTypeStorageBase(category, type_hash, id) -> offs {
          offs := or(shl(252, category), or(shl(220, type_hash), shl(60, id)))
        }
        function $NewLinkedStorageBase(type_hash) -> offs {
          let key := $StorageKey(1, 1)
          let handle := sload(key)
          sstore(key, add(handle, 1))
          offs := $MakeTypeStorageBase(1, type_hash, handle)
        }
        function $IndexPtr(ptr, offs) -> new_ptr {
          new_ptr := $MakePtr($IsStoragePtr(ptr), add($OffsetPtr(ptr), offs))
        }
        function $LoadU64(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU64(offs)
          }
          default {
            val := $StorageLoadU64(offs)
          }
        }
        function $MemoryLoadU64(offs) -> val {
          val := $MemoryLoadBytes(offs, 8)
        }
        function $StorageLoadU64(offs) -> val {
          val := $StorageLoadBytes(offs, 8)
        }
        function $StoreU64(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU64(offs, val)
          }
          default {
            $StorageStoreU64(offs, val)
          }
        }
        function $MemoryStoreU64(offs, val) {
          $MemoryStoreBytes(offs, 8, val)
        }
        function $StorageStoreU64(offs, val) {
          $StorageStoreBytes(offs, 8, val)
        }
        function $LoadU128(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU128(offs)
          }
          default {
            val := $StorageLoadU128(offs)
          }
        }
        function $MemoryLoadU128(offs) -> val {
          val := $MemoryLoadBytes(offs, 16)
        }
        function $StorageLoadU128(offs) -> val {
          val := $StorageLoadBytes(offs, 16)
        }
        function $MemoryStoreU128(offs, val) {
          $MemoryStoreBytes(offs, 16, val)
        }
        function $LoadU256(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU256(offs)
          }
          default {
            val := $StorageLoadU256(offs)
          }
        }
        function $MemoryLoadU256(offs) -> val {
          val := $MemoryLoadBytes(offs, 32)
        }
        function $StorageLoadU256(offs) -> val {
          val := $StorageLoadBytes(offs, 32)
        }
        function $StoreU256(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU256(offs, val)
          }
          default {
            $StorageStoreU256(offs, val)
          }
        }
        function $MemoryStoreU256(offs, val) {
          $MemoryStoreBytes(offs, 32, val)
        }
        function $StorageStoreU256(offs, val) {
          $StorageStoreBytes(offs, 32, val)
        }
        function $AlignedStorageLoad(offs) -> val {
          let word_offs := shr(5, offs)
          val := sload($StorageKey(0, word_offs))
        }
        function $AlignedStorageStore(offs, val) {
          let word_offs := shr(5, offs)
          sstore($StorageKey(0, word_offs), val)
        }
        function $CopyMemory(src, dst, size) {
          let num_words, overflow_bytes := $ToWordOffs(size)
          let i := 0
          for { } lt(i, mul(num_words, 32)) { i := add(i, 32) } {
            mstore(add(dst, i), mload(add(src, i)))
          }
          if overflow_bytes {
            let mask := $MaskForSize(sub(32, overflow_bytes))
            let overflow_offs := mul(num_words, 32)
            let dst_word := and(mload(add(dst, overflow_offs)), mask)
            let src_word := and(mload(add(src, overflow_offs)), not(mask))
            mstore(add(dst, overflow_offs), or(dst_word, src_word))
          }
        }
        function $ResizeVector(v_offs, capacity, type_size) -> new_v_offs {
            let new_capacity := mul(capacity, 2)
            let data_size := add(32, mul(capacity, type_size))
            let new_data_size := add(32, mul(new_capacity, type_size))
            new_v_offs := $Malloc(new_data_size)
            $CopyMemory(v_offs, new_v_offs, data_size)
            // update capacity at new location
            $MemoryStoreU64(add(new_v_offs, 8), new_capacity)
            $Free(v_offs, data_size)
        }
        function $GtEq(x, y) -> r {
            r := or(gt(x, y), eq(x, y))
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
        function $LogicalNot(x) -> r {
            r := iszero(x)
        }
    }
}
===> Test result of GlobalVectors::test_push_back_struct_global: Succeed(Stopped) (used_gas=329341): []

// test of GlobalVectors::test_read_ref_copy
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_GlobalVectors_test_read_ref_copy" {
    code {
        mstore(0, memoryguard(160))
        A2_GlobalVectors_test_read_ref_copy()
        return (0, 0)
        function A2_GlobalVectors_test_read_ref_copy() {
            let $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23
            let $locals := $Malloc(96)
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // goto L2
                    $block := 5
                }
                case 3 {
                    // label L0
                    // $t16 := 101
                    $t16 := 101
                    // abort($t16)
                    $Abort($t16)
                }
                case 4 {
                    // $t1 := vector::empty<u8>()
                    mstore($locals, A1_vector_empty$u8$())
                    // $t3 := borrow_local($t1)
                    $t3 := $MakePtr(false, $locals)
                    // $t4 := 65
                    $t4 := 65
                    // vector::push_back<u8>($t3, $t4)
                    A1_vector_push_back$u8$($t3, $t4)
                    // $t5 := 0x42
                    $t5 := 0x42
                    // $t0 := Evm::sign($t5)
                    mstore(add($locals, 32), A2_Evm_sign($t5))
                    // $t6 := borrow_local($t0)
                    $t6 := $MakePtr(false, add($locals, 32))
                    // $t7 := move($t1)
                    $t7 := mload($locals)
                    // $t8 := pack 0x2::GlobalVectors::T<u8>($t7)
                    {
                        let $mem := $Malloc(32)
                        $MemoryStoreU256(add($mem, 0), $t7)
                        $t8 := $mem
                    }
                    // move_to<0x2::GlobalVectors::T<u8>>($t8, $t6)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x10b7746c, $LoadU256($t6))
                        if $AlignedStorageLoad($base_offset) {
                          $AbortBuiltin()
                        }
                        $AlignedStorageStore($base_offset, true)
                        {
                            let $dst := add($base_offset, 32)
                            let $src := $t8
                            {
                                let $linked_src_2300595445 := mload(add($src, 0))
                                let $linked_dst_2300595445 := $NewLinkedStorageBase(0x89204cf5)
                                let $size_2300595445 := $MemoryLoadU64($linked_src_2300595445)
                                let $data_size_2300595445 := mul($size_2300595445, 1)
                                $AlignedStorageStore($linked_dst_2300595445, mload($linked_src_2300595445))
                                let $data_src_2300595445 := add($linked_src_2300595445, 32)
                                let $data_dst_2300595445 := add($linked_dst_2300595445, 32)
                                for { let $offs_2300595445 := 0 } lt($offs_2300595445, $data_size_2300595445) { $offs_2300595445 := add($offs_2300595445, 32)} {
                                    $AlignedStorageStore(add($data_dst_2300595445, $offs_2300595445), mload(add($data_src_2300595445, $offs_2300595445)))
                                    $Free($linked_src_2300595445, add($data_size_2300595445, 32))
                                }
                                $AlignedStorageStore(add($dst, 0), $linked_dst_2300595445)
                            }
                            $Free($src, 32)
                        }
                    }
                    // $t9 := 0x42
                    $t9 := 0x42
                    // $t10 := borrow_global<0x2::GlobalVectors::T<u8>>($t9)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x10b7746c, $t9)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t10 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t11 := borrow_field<0x2::GlobalVectors::T<u8>>.v($t10)
                    $t11 := $t10
                    // $t2 := read_ref($t11)
                    mstore(add($locals, 64), $LoadU256($t11))
                    if $IsStoragePtr($t11){
                        let $storage_ptr_2300595445
                        let $size_2300595445 := $StorageLoadU64(mload(add($locals, 64)))
                        let $capacity_2300595445 := $ClosestGreaterPowerOfTwo($size_2300595445)
                        $storage_ptr_2300595445 := $Malloc(add(32, mul($capacity_2300595445, 1)))
                        let $data_size_2300595445 := mul($size_2300595445, 1)
                        mstore($storage_ptr_2300595445, $AlignedStorageLoad(mload(add($locals, 64))))
                        $MemoryStoreU64(add($storage_ptr_2300595445, 8), $capacity_2300595445)
                        let $data_src_2300595445 := add(mload(add($locals, 64)), 32)
                        let $data_dst_2300595445 := add($storage_ptr_2300595445, 32)
                        for { let $offs_2300595445 := 0 } lt($offs_2300595445, $data_size_2300595445) { $offs_2300595445 := add($offs_2300595445, 32)} {
                            mstore(add($data_dst_2300595445, $offs_2300595445), $AlignedStorageLoad(add($data_src_2300595445, $offs_2300595445)))
                        }
                        mstore(add($locals, 64), $storage_ptr_2300595445)
                    }
                    // $t12 := borrow_local($t2)
                    $t12 := $MakePtr(false, add($locals, 64))
                    // $t13 := vector::length<u8>($t12)
                    $t13 := A1_vector_length$u8$($t12)
                    // $t14 := 1
                    $t14 := 1
                    // $t15 := ==($t13, $t14)
                    $t15 := $Eq($t13, $t14)
                    // if ($t15) goto L1 else goto L0
                    switch $t15
                    case 0  { $block := 3 }
                    default { $block := 2 }
                }
                case 5 {
                    // label L2
                    // $t17 := borrow_local($t2)
                    $t17 := $MakePtr(false, add($locals, 64))
                    // $t18 := 0
                    $t18 := 0
                    // $t19 := vector::borrow<u8>($t17, $t18)
                    $t19 := A1_vector_borrow$u8$($t17, $t18)
                    // $t20 := read_ref($t19)
                    $t20 := $LoadU8($t19)
                    // $t21 := 65
                    $t21 := 65
                    // $t22 := ==($t20, $t21)
                    $t22 := $Eq($t20, $t21)
                    // if ($t22) goto L4 else goto L3
                    switch $t22
                    case 0  { $block := 7 }
                    default { $block := 6 }
                }
                case 6 {
                    // label L4
                    // goto L5
                    $block := 8
                }
                case 7 {
                    // label L3
                    // $t23 := 102
                    $t23 := 102
                    // abort($t23)
                    $Abort($t23)
                }
                case 8 {
                    // label L5
                    // return ()
                    $Free($locals, 96)
                    leave
                }
            }
        }

        function A1_vector_borrow$u8$(v_ref, i) -> e_ptr {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            if $GtEq(i, size) { $AbortBuiltin() }
            e_ptr := $IndexPtr(v_ptr, add(32, mul(i, 1)))
        }
        function A1_vector_length$u8$(v_ref) -> len {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            len := $LoadU64(v_ptr)
        }
        function A2_Evm_sign(addr) -> signer {
          signer := addr
        }
        function A1_vector_push_back$u8$(v_ref, e) {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            let e_ptr := $IndexPtr(v_ptr, add(32, mul(size, 1)))
            $StoreU8(e_ptr, e)
            size := add(size, 1)
            $StoreU64(v_ptr, size)
            let capacity := $LoadU64($IndexPtr(v_ptr, 8))
            if and(iszero($IsStoragePtr(v_ptr)), eq(size, capacity)) {
                let new_v_offs := $ResizeVector(v_offs, capacity, 1)
                $StoreU256(v_ref, new_v_offs)
            }
        }
        function A1_vector_empty$u8$() -> vector {
            vector := $Malloc(34)
            $MemoryStoreU64(add(vector, 8), 2)
        }
        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Malloc(size) -> offs {
            offs := mload(0)
            // pad to word size
            mstore(0, add(offs, shl(5, shr(5, add(size, 31)))))
        }
        function $Free(offs, size) {
        }
        function $MakePtr(is_storage, offs) -> ptr {
          ptr := or(is_storage, shl(1, offs))
        }
        function $IsStoragePtr(ptr) -> b {
          b := and(ptr, 0x1)
        }
        function $OffsetPtr(ptr) -> offs {
          offs := shr(1, ptr)
        }
        function $MaskForSize(size) -> mask {
          mask := sub(shl(shl(3, size), 1), 1)
        }
        function $ExtractBytes(word, start, size) -> bytes {
           switch size
           case 1 {
              // use the faster byte primitive
              bytes := byte(start, word)
           }
           default {
              // As we have big endian, we need to right shift the value from
              // where the highest byte starts in the word (32 - start), minus
              // the size.
              let shift_bits := shl(3, sub(sub(32, start), size))
              bytes := and(shr(shift_bits, word), $MaskForSize(size))
           }
        }
        function $InjectBytes(word, start, size, bytes) -> new_word {
           let shift_bits := shl(3, sub(sub(32, start), size))
           // Blend out the bits which we inject
           let neg_mask := not(shl(shift_bits, $MaskForSize(size)))
           word := and(word, neg_mask)
           // Overlay the bits we inject
           new_word := or(word, shl(shift_bits, bytes))
        }
        function $ToWordOffs(offs) -> word_offs, byte_offset {
          word_offs := shr(5, offs)
          byte_offset := and(offs, 0x1F)
        }
        function $OverflowBytes(byte_offset, size) -> overflow_bytes {
          let available_bytes := sub(32, byte_offset)
          switch gt(size, available_bytes)
          case 0 {
            overflow_bytes := 0
          }
          default {
            overflow_bytes := sub(size, available_bytes)
          }
        }
        function $MemoryLoadBytes(offs, size) -> val {
          // Lower bit where the value in the higher bytes ends
          let bit_end := shl(3, sub(32, size))
          val := shr(bit_end, mload(offs))
        }
        function $MemoryStoreBytes(offs, size, val) {
          let bit_end := shl(3, sub(32, size))
          let mask := shl(bit_end, $MaskForSize(size))
          mstore(offs, or(and(mload(offs), not(mask)), shl(bit_end, val)))
        }
        function $StorageLoadBytes(offs, size) -> val {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          val := $ExtractBytes(sload(key), byte_offs, size)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          if $LogicalNot(iszero(overflow_bytes)) {
            key := $StorageKey(0, add(word_offs, 1))
            let extra_bytes := $ExtractBytes(sload(key), 0, overflow_bytes)
            val := or(shl(shl(3, overflow_bytes), val), extra_bytes)
          }
        }
        function $StorageStoreBytes(offs, size, bytes) {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          switch overflow_bytes
          case 0 {
            sstore(key, $InjectBytes(sload(key), byte_offs, size, bytes))
          }
          default {
            // Shift the higher bytes to the right
            let used_bytes := sub(size, overflow_bytes)
            let higher_bytes := shr(used_bytes, bytes)
            let lower_bytes := and(bytes, $MaskForSize(overflow_bytes))
            sstore(key, $InjectBytes(sload(key), byte_offs, used_bytes, higher_bytes))
            key := $StorageKey(0, add(word_offs, 1))
            sstore(key, $InjectBytes(sload(key), 0, overflow_bytes, lower_bytes))
          }
        }
        function $StorageKey(group, word) -> key {
          mstore(32, word)
          mstore(64, shl(224, group))
          key := keccak256(32, 36)
        }
        function $MakeTypeStorageBase(category, type_hash, id) -> offs {
          offs := or(shl(252, category), or(shl(220, type_hash), shl(60, id)))
        }
        function $NewLinkedStorageBase(type_hash) -> offs {
          let key := $StorageKey(1, 1)
          let handle := sload(key)
          sstore(key, add(handle, 1))
          offs := $MakeTypeStorageBase(1, type_hash, handle)
        }
        function $IndexPtr(ptr, offs) -> new_ptr {
          new_ptr := $MakePtr($IsStoragePtr(ptr), add($OffsetPtr(ptr), offs))
        }
        function $LoadU8(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU8(offs)
          }
          default {
            val := $StorageLoadU8(offs)
          }
        }
        function $MemoryLoadU8(offs) -> val {
          val := $MemoryLoadBytes(offs, 1)
        }
        function $StorageLoadU8(offs) -> val {
          val := $StorageLoadBytes(offs, 1)
        }
        function $StoreU8(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU8(offs, val)
          }
          default {
            $StorageStoreU8(offs, val)
          }
        }
        function $MemoryStoreU8(offs, val) {
          // Shortcut via special instruction
          mstore8(offs, val)
        }
        function $StorageStoreU8(offs, val) {
          $StorageStoreBytes(offs, 1, val)
        }
        function $LoadU64(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU64(offs)
          }
          default {
            val := $StorageLoadU64(offs)
          }
        }
        function $MemoryLoadU64(offs) -> val {
          val := $MemoryLoadBytes(offs, 8)
        }
        function $StorageLoadU64(offs) -> val {
          val := $StorageLoadBytes(offs, 8)
        }
        function $StoreU64(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU64(offs, val)
          }
          default {
            $StorageStoreU64(offs, val)
          }
        }
        function $MemoryStoreU64(offs, val) {
          $MemoryStoreBytes(offs, 8, val)
        }
        function $StorageStoreU64(offs, val) {
          $StorageStoreBytes(offs, 8, val)
        }
        function $LoadU256(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU256(offs)
          }
          default {
            val := $StorageLoadU256(offs)
          }
        }
        function $MemoryLoadU256(offs) -> val {
          val := $MemoryLoadBytes(offs, 32)
        }
        function $StorageLoadU256(offs) -> val {
          val := $StorageLoadBytes(offs, 32)
        }
        function $StoreU256(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU256(offs, val)
          }
          default {
            $StorageStoreU256(offs, val)
          }
        }
        function $MemoryStoreU256(offs, val) {
          $MemoryStoreBytes(offs, 32, val)
        }
        function $StorageStoreU256(offs, val) {
          $StorageStoreBytes(offs, 32, val)
        }
        function $AlignedStorageLoad(offs) -> val {
          let word_offs := shr(5, offs)
          val := sload($StorageKey(0, word_offs))
        }
        function $AlignedStorageStore(offs, val) {
          let word_offs := shr(5, offs)
          sstore($StorageKey(0, word_offs), val)
        }
        function $CopyMemory(src, dst, size) {
          let num_words, overflow_bytes := $ToWordOffs(size)
          let i := 0
          for { } lt(i, mul(num_words, 32)) { i := add(i, 32) } {
            mstore(add(dst, i), mload(add(src, i)))
          }
          if overflow_bytes {
            let mask := $MaskForSize(sub(32, overflow_bytes))
            let overflow_offs := mul(num_words, 32)
            let dst_word := and(mload(add(dst, overflow_offs)), mask)
            let src_word := and(mload(add(src, overflow_offs)), not(mask))
            mstore(add(dst, overflow_offs), or(dst_word, src_word))
          }
        }
        function $ResizeVector(v_offs, capacity, type_size) -> new_v_offs {
            let new_capacity := mul(capacity, 2)
            let data_size := add(32, mul(capacity, type_size))
            let new_data_size := add(32, mul(new_capacity, type_size))
            new_v_offs := $Malloc(new_data_size)
            $CopyMemory(v_offs, new_v_offs, data_size)
            // update capacity at new location
            $MemoryStoreU64(add(new_v_offs, 8), new_capacity)
            $Free(v_offs, data_size)
        }
        function $GtEq(x, y) -> r {
            r := or(gt(x, y), eq(x, y))
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
        function $LogicalNot(x) -> r {
            r := iszero(x)
        }
        function $ClosestGreaterPowerOfTwo(x) -> r {
            r := or(r, shr(1, x))
            r := or(r, shr(2, r))
            r := or(r, shr(4, r))
            r := or(r, shr(8, r))
            r := or(r, shr(16, r))
            r := or(r, shr(32, r))
            r := add(x, 1)
        }
    }
}
===> Test result of GlobalVectors::test_read_ref_copy: Succeed(Stopped) (used_gas=114827): []

// test of GlobalVectors::test_swap_global
/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "test_A2_GlobalVectors_test_swap_global" {
    code {
        mstore(0, memoryguard(160))
        A2_GlobalVectors_test_swap_global()
        return (0, 0)
        function A2_GlobalVectors_test_swap_global() {
            let $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27, $t28, $t29, $t30, $t31, $t32, $t33, $t34, $t35, $t36, $t37, $t38, $t39, $t40, $t41, $t42, $t43, $t44, $t45, $t46, $t47, $t48, $t49, $t50
            let $locals := $Malloc(64)
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L1
                    // goto L2
                    $block := 5
                }
                case 3 {
                    // label L0
                    // $t23 := 101
                    $t23 := 101
                    // abort($t23)
                    $Abort($t23)
                }
                case 4 {
                    // $t1 := vector::empty<u64>()
                    mstore($locals, A1_vector_empty$u64$())
                    // $t2 := borrow_local($t1)
                    $t2 := $MakePtr(false, $locals)
                    // $t3 := 42
                    $t3 := 42
                    // vector::push_back<u64>($t2, $t3)
                    A1_vector_push_back$u64$($t2, $t3)
                    // $t4 := borrow_local($t1)
                    $t4 := $MakePtr(false, $locals)
                    // $t5 := 43
                    $t5 := 43
                    // vector::push_back<u64>($t4, $t5)
                    A1_vector_push_back$u64$($t4, $t5)
                    // $t6 := borrow_local($t1)
                    $t6 := $MakePtr(false, $locals)
                    // $t7 := 44
                    $t7 := 44
                    // vector::push_back<u64>($t6, $t7)
                    A1_vector_push_back$u64$($t6, $t7)
                    // $t8 := 0x42
                    $t8 := 0x42
                    // $t0 := Evm::sign($t8)
                    mstore(add($locals, 32), A2_Evm_sign($t8))
                    // $t9 := borrow_local($t0)
                    $t9 := $MakePtr(false, add($locals, 32))
                    // $t10 := move($t1)
                    $t10 := mload($locals)
                    // $t11 := pack 0x2::GlobalVectors::T<u64>($t10)
                    {
                        let $mem := $Malloc(32)
                        $MemoryStoreU256(add($mem, 0), $t10)
                        $t11 := $mem
                    }
                    // move_to<0x2::GlobalVectors::T<u64>>($t11, $t9)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $LoadU256($t9))
                        if $AlignedStorageLoad($base_offset) {
                          $AbortBuiltin()
                        }
                        $AlignedStorageStore($base_offset, true)
                        {
                            let $dst := add($base_offset, 32)
                            let $src := $t11
                            {
                                let $linked_src_814019441 := mload(add($src, 0))
                                let $linked_dst_814019441 := $NewLinkedStorageBase(0x3084f371)
                                let $size_814019441 := $MemoryLoadU64($linked_src_814019441)
                                let $data_size_814019441 := mul($size_814019441, 8)
                                $AlignedStorageStore($linked_dst_814019441, mload($linked_src_814019441))
                                let $data_src_814019441 := add($linked_src_814019441, 32)
                                let $data_dst_814019441 := add($linked_dst_814019441, 32)
                                for { let $offs_814019441 := 0 } lt($offs_814019441, $data_size_814019441) { $offs_814019441 := add($offs_814019441, 32)} {
                                    $AlignedStorageStore(add($data_dst_814019441, $offs_814019441), mload(add($data_src_814019441, $offs_814019441)))
                                    $Free($linked_src_814019441, add($data_size_814019441, 32))
                                }
                                $AlignedStorageStore(add($dst, 0), $linked_dst_814019441)
                            }
                            $Free($src, 32)
                        }
                    }
                    // $t12 := 0x42
                    $t12 := 0x42
                    // $t13 := borrow_global<0x2::GlobalVectors::T<u64>>($t12)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $t12)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t13 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t14 := borrow_field<0x2::GlobalVectors::T<u64>>.v($t13)
                    $t14 := $t13
                    // $t15 := 0
                    $t15 := 0
                    // $t16 := 2
                    $t16 := 2
                    // vector::swap<u64>($t14, $t15, $t16)
                    A1_vector_swap$u64$($t14, $t15, $t16)
                    // $t17 := 0x42
                    $t17 := 0x42
                    // $t18 := borrow_global<0x2::GlobalVectors::T<u64>>($t17)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $t17)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t18 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t19 := borrow_field<0x2::GlobalVectors::T<u64>>.v($t18)
                    $t19 := $t18
                    // $t20 := vector::length<u64>($t19)
                    $t20 := A1_vector_length$u64$($t19)
                    // $t21 := 3
                    $t21 := 3
                    // $t22 := ==($t20, $t21)
                    $t22 := $Eq($t20, $t21)
                    // if ($t22) goto L1 else goto L0
                    switch $t22
                    case 0  { $block := 3 }
                    default { $block := 2 }
                }
                case 5 {
                    // label L2
                    // $t24 := 0x42
                    $t24 := 0x42
                    // $t25 := borrow_global<0x2::GlobalVectors::T<u64>>($t24)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $t24)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t25 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t26 := borrow_field<0x2::GlobalVectors::T<u64>>.v($t25)
                    $t26 := $t25
                    // $t27 := 0
                    $t27 := 0
                    // $t28 := vector::borrow<u64>($t26, $t27)
                    $t28 := A1_vector_borrow$u64$($t26, $t27)
                    // $t29 := read_ref($t28)
                    $t29 := $LoadU64($t28)
                    // $t30 := 44
                    $t30 := 44
                    // $t31 := ==($t29, $t30)
                    $t31 := $Eq($t29, $t30)
                    // if ($t31) goto L4 else goto L3
                    switch $t31
                    case 0  { $block := 7 }
                    default { $block := 6 }
                }
                case 6 {
                    // label L4
                    // goto L5
                    $block := 8
                }
                case 7 {
                    // label L3
                    // $t32 := 102
                    $t32 := 102
                    // abort($t32)
                    $Abort($t32)
                }
                case 8 {
                    // label L5
                    // $t33 := 0x42
                    $t33 := 0x42
                    // $t34 := borrow_global<0x2::GlobalVectors::T<u64>>($t33)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $t33)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t34 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t35 := borrow_field<0x2::GlobalVectors::T<u64>>.v($t34)
                    $t35 := $t34
                    // $t36 := 1
                    $t36 := 1
                    // $t37 := vector::borrow<u64>($t35, $t36)
                    $t37 := A1_vector_borrow$u64$($t35, $t36)
                    // $t38 := read_ref($t37)
                    $t38 := $LoadU64($t37)
                    // $t39 := 43
                    $t39 := 43
                    // $t40 := ==($t38, $t39)
                    $t40 := $Eq($t38, $t39)
                    // if ($t40) goto L7 else goto L6
                    switch $t40
                    case 0  { $block := 10 }
                    default { $block := 9 }
                }
                case 9 {
                    // label L7
                    // goto L8
                    $block := 11
                }
                case 10 {
                    // label L6
                    // $t41 := 103
                    $t41 := 103
                    // abort($t41)
                    $Abort($t41)
                }
                case 11 {
                    // label L8
                    // $t42 := 0x42
                    $t42 := 0x42
                    // $t43 := borrow_global<0x2::GlobalVectors::T<u64>>($t42)
                    {
                        let $base_offset := $MakeTypeStorageBase(0, 0x7da2a540, $t42)
                        if iszero($AlignedStorageLoad($base_offset)) {
                          $AbortBuiltin()
                        }
                        $t43 := $MakePtr(true, add($base_offset, 32))
                    }
                    // $t44 := borrow_field<0x2::GlobalVectors::T<u64>>.v($t43)
                    $t44 := $t43
                    // $t45 := 2
                    $t45 := 2
                    // $t46 := vector::borrow<u64>($t44, $t45)
                    $t46 := A1_vector_borrow$u64$($t44, $t45)
                    // $t47 := read_ref($t46)
                    $t47 := $LoadU64($t46)
                    // $t48 := 42
                    $t48 := 42
                    // $t49 := ==($t47, $t48)
                    $t49 := $Eq($t47, $t48)
                    // if ($t49) goto L10 else goto L9
                    switch $t49
                    case 0  { $block := 13 }
                    default { $block := 12 }
                }
                case 12 {
                    // label L10
                    // goto L11
                    $block := 14
                }
                case 13 {
                    // label L9
                    // $t50 := 104
                    $t50 := 104
                    // abort($t50)
                    $Abort($t50)
                }
                case 14 {
                    // label L11
                    // return ()
                    $Free($locals, 64)
                    leave
                }
            }
        }

        function A1_vector_borrow$u64$(v_ref, i) -> e_ptr {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            if $GtEq(i, size) { $AbortBuiltin() }
            e_ptr := $IndexPtr(v_ptr, add(32, mul(i, 8)))
        }
        function A1_vector_length$u64$(v_ref) -> len {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            len := $LoadU64(v_ptr)
        }
        function A1_vector_swap$u64$(v_ref, i, j) {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            if or($GtEq(i, size), $GtEq(j, size)) { $AbortBuiltin() }
            let i_ptr := $IndexPtr(v_ptr, add(32, mul(i, 8)))
            let j_ptr := $IndexPtr(v_ptr, add(32, mul(j, 8)))
            let i_val := $LoadU64(i_ptr)
            let j_val := $LoadU64(j_ptr)
            $StoreU64(i_ptr, j_val)
            $StoreU64(j_ptr, i_val)
        }
        function A2_Evm_sign(addr) -> signer {
          signer := addr
        }
        function A1_vector_push_back$u64$(v_ref, e) {
            let v_offs := $LoadU256(v_ref)
            let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
            let size := $LoadU64(v_ptr)
            let e_ptr := $IndexPtr(v_ptr, add(32, mul(size, 8)))
            $StoreU64(e_ptr, e)
            size := add(size, 1)
            $StoreU64(v_ptr, size)
            let capacity := $LoadU64($IndexPtr(v_ptr, 8))
            if and(iszero($IsStoragePtr(v_ptr)), eq(size, capacity)) {
                let new_v_offs := $ResizeVector(v_offs, capacity, 8)
                $StoreU256(v_ref, new_v_offs)
            }
        }
        function A1_vector_empty$u64$() -> vector {
            vector := $Malloc(48)
            $MemoryStoreU64(add(vector, 8), 2)
        }
        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Malloc(size) -> offs {
            offs := mload(0)
            // pad to word size
            mstore(0, add(offs, shl(5, shr(5, add(size, 31)))))
        }
        function $Free(offs, size) {
        }
        function $MakePtr(is_storage, offs) -> ptr {
          ptr := or(is_storage, shl(1, offs))
        }
        function $IsStoragePtr(ptr) -> b {
          b := and(ptr, 0x1)
        }
        function $OffsetPtr(ptr) -> offs {
          offs := shr(1, ptr)
        }
        function $MaskForSize(size) -> mask {
          mask := sub(shl(shl(3, size), 1), 1)
        }
        function $ExtractBytes(word, start, size) -> bytes {
           switch size
           case 1 {
              // use the faster byte primitive
              bytes := byte(start, word)
           }
           default {
              // As we have big endian, we need to right shift the value from
              // where the highest byte starts in the word (32 - start), minus
              // the size.
              let shift_bits := shl(3, sub(sub(32, start), size))
              bytes := and(shr(shift_bits, word), $MaskForSize(size))
           }
        }
        function $InjectBytes(word, start, size, bytes) -> new_word {
           let shift_bits := shl(3, sub(sub(32, start), size))
           // Blend out the bits which we inject
           let neg_mask := not(shl(shift_bits, $MaskForSize(size)))
           word := and(word, neg_mask)
           // Overlay the bits we inject
           new_word := or(word, shl(shift_bits, bytes))
        }
        function $ToWordOffs(offs) -> word_offs, byte_offset {
          word_offs := shr(5, offs)
          byte_offset := and(offs, 0x1F)
        }
        function $OverflowBytes(byte_offset, size) -> overflow_bytes {
          let available_bytes := sub(32, byte_offset)
          switch gt(size, available_bytes)
          case 0 {
            overflow_bytes := 0
          }
          default {
            overflow_bytes := sub(size, available_bytes)
          }
        }
        function $MemoryLoadBytes(offs, size) -> val {
          // Lower bit where the value in the higher bytes ends
          let bit_end := shl(3, sub(32, size))
          val := shr(bit_end, mload(offs))
        }
        function $MemoryStoreBytes(offs, size, val) {
          let bit_end := shl(3, sub(32, size))
          let mask := shl(bit_end, $MaskForSize(size))
          mstore(offs, or(and(mload(offs), not(mask)), shl(bit_end, val)))
        }
        function $StorageLoadBytes(offs, size) -> val {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          val := $ExtractBytes(sload(key), byte_offs, size)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          if $LogicalNot(iszero(overflow_bytes)) {
            key := $StorageKey(0, add(word_offs, 1))
            let extra_bytes := $ExtractBytes(sload(key), 0, overflow_bytes)
            val := or(shl(shl(3, overflow_bytes), val), extra_bytes)
          }
        }
        function $StorageStoreBytes(offs, size, bytes) {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          switch overflow_bytes
          case 0 {
            sstore(key, $InjectBytes(sload(key), byte_offs, size, bytes))
          }
          default {
            // Shift the higher bytes to the right
            let used_bytes := sub(size, overflow_bytes)
            let higher_bytes := shr(used_bytes, bytes)
            let lower_bytes := and(bytes, $MaskForSize(overflow_bytes))
            sstore(key, $InjectBytes(sload(key), byte_offs, used_bytes, higher_bytes))
            key := $StorageKey(0, add(word_offs, 1))
            sstore(key, $InjectBytes(sload(key), 0, overflow_bytes, lower_bytes))
          }
        }
        function $StorageKey(group, word) -> key {
          mstore(32, word)
          mstore(64, shl(224, group))
          key := keccak256(32, 36)
        }
        function $MakeTypeStorageBase(category, type_hash, id) -> offs {
          offs := or(shl(252, category), or(shl(220, type_hash), shl(60, id)))
        }
        function $NewLinkedStorageBase(type_hash) -> offs {
          let key := $StorageKey(1, 1)
          let handle := sload(key)
          sstore(key, add(handle, 1))
          offs := $MakeTypeStorageBase(1, type_hash, handle)
        }
        function $IndexPtr(ptr, offs) -> new_ptr {
          new_ptr := $MakePtr($IsStoragePtr(ptr), add($OffsetPtr(ptr), offs))
        }
        function $LoadU64(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU64(offs)
          }
          default {
            val := $StorageLoadU64(offs)
          }
        }
        function $MemoryLoadU64(offs) -> val {
          val := $MemoryLoadBytes(offs, 8)
        }
        function $StorageLoadU64(offs) -> val {
          val := $StorageLoadBytes(offs, 8)
        }
        function $StoreU64(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU64(offs, val)
          }
          default {
            $StorageStoreU64(offs, val)
          }
        }
        function $MemoryStoreU64(offs, val) {
          $MemoryStoreBytes(offs, 8, val)
        }
        function $StorageStoreU64(offs, val) {
          $StorageStoreBytes(offs, 8, val)
        }
        function $LoadU256(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU256(offs)
          }
          default {
            val := $StorageLoadU256(offs)
          }
        }
        function $MemoryLoadU256(offs) -> val {
          val := $MemoryLoadBytes(offs, 32)
        }
        function $StorageLoadU256(offs) -> val {
          val := $StorageLoadBytes(offs, 32)
        }
        function $StoreU256(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU256(offs, val)
          }
          default {
            $StorageStoreU256(offs, val)
          }
        }
        function $MemoryStoreU256(offs, val) {
          $MemoryStoreBytes(offs, 32, val)
        }
        function $StorageStoreU256(offs, val) {
          $StorageStoreBytes(offs, 32, val)
        }
        function $AlignedStorageLoad(offs) -> val {
          let word_offs := shr(5, offs)
          val := sload($StorageKey(0, word_offs))
        }
        function $AlignedStorageStore(offs, val) {
          let word_offs := shr(5, offs)
          sstore($StorageKey(0, word_offs), val)
        }
        function $CopyMemory(src, dst, size) {
          let num_words, overflow_bytes := $ToWordOffs(size)
          let i := 0
          for { } lt(i, mul(num_words, 32)) { i := add(i, 32) } {
            mstore(add(dst, i), mload(add(src, i)))
          }
          if overflow_bytes {
            let mask := $MaskForSize(sub(32, overflow_bytes))
            let overflow_offs := mul(num_words, 32)
            let dst_word := and(mload(add(dst, overflow_offs)), mask)
            let src_word := and(mload(add(src, overflow_offs)), not(mask))
            mstore(add(dst, overflow_offs), or(dst_word, src_word))
          }
        }
        function $ResizeVector(v_offs, capacity, type_size) -> new_v_offs {
            let new_capacity := mul(capacity, 2)
            let data_size := add(32, mul(capacity, type_size))
            let new_data_size := add(32, mul(new_capacity, type_size))
            new_v_offs := $Malloc(new_data_size)
            $CopyMemory(v_offs, new_v_offs, data_size)
            // update capacity at new location
            $MemoryStoreU64(add(new_v_offs, 8), new_capacity)
            $Free(v_offs, data_size)
        }
        function $GtEq(x, y) -> r {
            r := or(gt(x, y), eq(x, y))
        }
        function $Eq(x, y) -> r {
            r := eq(x, y)
        }
        function $LogicalNot(x) -> r {
            r := iszero(x)
        }
    }
}
===> Test result of GlobalVectors::test_swap_global: Succeed(Stopped) (used_gas=124086): []
