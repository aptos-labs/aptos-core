/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */


object "A2_M" {
    code {
        codecopy(0, dataoffset("A2_M_deployed"), datasize("A2_M_deployed"))
        return(0, datasize("A2_M_deployed"))
    }
    object "A2_M_deployed" {
        code {
            mstore(0, memoryguard(160))
            if iszero(lt(calldatasize(), 4))
            {
                let selector := $Shr(calldataload(0), 224)
                switch selector
                case 0x52044bf1
                {
                    // test_u64(uint64[2])
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0 := abi_decode_tuple_$uint64_2_$_$vec$u64$$(4, calldatasize())
                    let ret_0 := A2_M_test_array_u64(param_0)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint64$_$u64$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0xf03cf98d
                {
                    // test_u8(uint8[2])
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0 := abi_decode_tuple_$uint8_2_$_$vec$u8$$(4, calldatasize())
                    let ret_0 := A2_M_test_array_u8(param_0)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint8$_$u8$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x5bbb1b40
                {
                    // test_uint16_u64(uint16[2][])
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0 := abi_decode_tuple_$uint16_2___$_$vec$vec$u64$$$(4, calldatasize())
                    let ret_0 := A2_M_test_array_uint16_u64(param_0)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint16$_$u64$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0xaae0ca0b
                {
                    // test_uint72_u128(uint72[][2])
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0 := abi_decode_tuple_$uint72___2_$_$vec$vec$u128$$$(4, calldatasize())
                    let ret_0 := A2_M_test_array_uint72_u128(param_0)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint72$_$u128$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0xeb158528
                {
                    // test_uint8_U256(uint8[2][])
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0 := abi_decode_tuple_$uint8_2___$_$vec$vec$A2_U256_U256$$$(4, calldatasize())
                    let ret_0 := A2_M_test_array_uint8_U256(param_0)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint8$_$A2_U256_U256$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x2baf810d
                {
                    // test_uint8_u64(uint8[2])
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0 := abi_decode_tuple_$uint8_2_$_$vec$u64$$(4, calldatasize())
                    let ret_0 := A2_M_test_array_uint8_u64(param_0)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint8$_$u64$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x77689027
                {
                    // test_u64(uint64[2][2])
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0 := abi_decode_tuple_$uint64_2__2_$_$vec$vec$u64$$$(4, calldatasize())
                    let ret_0 := A2_M_test_one_elem_para_array_2_array_2_u64(param_0)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint64$_$u64$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0xecefc49c
                {
                    // test_u8(uint8[2][2])
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0 := abi_decode_tuple_$uint8_2__2_$_$vec$vec$u8$$$(4, calldatasize())
                    let ret_0 := A2_M_test_one_elem_para_array_2_array_2_u8(param_0)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint8$_$u8$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x4c976153
                {
                    // test_u256(uint256[][2])
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0 := abi_decode_tuple_$uint256___2_$_$vec$vec$A2_U256_U256$$$(4, calldatasize())
                    let ret_0 := A2_M_test_one_elem_para_array_2_array_dynamic_u256(param_0)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint256$_$A2_U256_U256$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x17041a2e
                {
                    // test_u64(uint64[][2])
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0 := abi_decode_tuple_$uint64___2_$_$vec$vec$u64$$$(4, calldatasize())
                    let ret_0 := A2_M_test_one_elem_para_array_2_array_dynamic_u64(param_0)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint64$_$u64$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x3b09967a
                {
                    // test_u8(uint8[][2])
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0 := abi_decode_tuple_$uint8___2_$_$vec$vec$u8$$$(4, calldatasize())
                    let ret_0 := A2_M_test_one_elem_para_array_2_array_dynamic_u8(param_0)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint8$_$u8$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x374cb568
                {
                    // test_u256(uint256[2][])
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0 := abi_decode_tuple_$uint256_2___$_$vec$vec$A2_U256_U256$$$(4, calldatasize())
                    let ret_0 := A2_M_test_one_elem_para_array_dynamic_array_2_u256(param_0)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint256$_$A2_U256_U256$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x6a829009
                {
                    // test_u64(uint64[2][])
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0 := abi_decode_tuple_$uint64_2___$_$vec$vec$u64$$$(4, calldatasize())
                    let ret_0 := A2_M_test_one_elem_para_array_dynamic_array_2_u64(param_0)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint64$_$u64$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x43ed1d2f
                {
                    // test_u8(uint8[2][])
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0 := abi_decode_tuple_$uint8_2___$_$vec$vec$u8$$$(4, calldatasize())
                    let ret_0 := A2_M_test_one_elem_para_array_dynamic_array_2_u8(param_0)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint8$_$u8$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x14fda38d
                {
                    // test_u128(uint128[][])
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0 := abi_decode_tuple_$uint128____$_$vec$vec$u128$$$(4, calldatasize())
                    let ret_0 := A2_M_test_one_elem_para_array_dynamic_array_u128(param_0)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint128$_$u128$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                default {}
            }
            $Abort(97)
            function A2_M_test_array_u64(v) -> $result {
                let val_1, val_2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11
                let $locals := $Malloc(32)
                mstore($locals, v)
                // $t3 := borrow_local($t0)
                $t3 := $MakePtr(false, $locals)
                // $t4 := 0
                $t4 := 0
                // $t5 := vector::borrow<u64>($t3, $t4)
                $t5 := A1_vector_borrow$u64$($t3, $t4)
                // $t6 := read_ref($t5)
                $t6 := $LoadU64($t5)
                // $t7 := borrow_local($t0)
                $t7 := $MakePtr(false, $locals)
                // $t8 := 1
                $t8 := 1
                // $t9 := vector::borrow<u64>($t7, $t8)
                $t9 := A1_vector_borrow$u64$($t7, $t8)
                // $t10 := read_ref($t9)
                $t10 := $LoadU64($t9)
                // $t11 := +($t6, $t10)
                $t11 := $AddU64($t6, $t10)
                // return $t11
                $result := $t11
                $Free($locals, 32)
            }

            function A2_M_test_array_u8(v) -> $result {
                let val_1, val_2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11
                let $locals := $Malloc(32)
                mstore($locals, v)
                // $t3 := borrow_local($t0)
                $t3 := $MakePtr(false, $locals)
                // $t4 := 0
                $t4 := 0
                // $t5 := vector::borrow<u8>($t3, $t4)
                $t5 := A1_vector_borrow$u8$($t3, $t4)
                // $t6 := read_ref($t5)
                $t6 := $LoadU8($t5)
                // $t7 := borrow_local($t0)
                $t7 := $MakePtr(false, $locals)
                // $t8 := 1
                $t8 := 1
                // $t9 := vector::borrow<u8>($t7, $t8)
                $t9 := A1_vector_borrow$u8$($t7, $t8)
                // $t10 := read_ref($t9)
                $t10 := $LoadU8($t9)
                // $t11 := +($t6, $t10)
                $t11 := $AddU8($t6, $t10)
                // return $t11
                $result := $t11
                $Free($locals, 32)
            }

            function A2_M_test_array_uint16_u64(v) -> $result {
                let i, len_v, sum, vec, vec_val_1, vec_val_2, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21
                let $locals := $Malloc(32)
                mstore($locals, v)
                let $block := 3
                for {} true {} {
                    switch $block
                    case 2 {
                        // label L3
                        // $t11 := <($t1, $t8)
                        $t11 := $Lt(i, $t8)
                        // if ($t11) goto L1 else goto L0
                        switch $t11
                        case 0  { $block := 5 }
                        default { $block := 4 }
                    }
                    case 3 {
                        // $t7 := borrow_local($t0)
                        $t7 := $MakePtr(false, $locals)
                        // $t8 := vector::length<vector<u64>>($t7)
                        $t8 := A1_vector_length$vec$u64$$($t7)
                        // $t9 := 0
                        $t9 := 0
                        // $t1 := $t9
                        i := $t9
                        // $t10 := 0
                        $t10 := 0
                        // $t3 := $t10
                        sum := $t10
                        // goto L3
                        $block := 2
                    }
                    case 4 {
                        // label L1
                        // goto L2
                        $block := 6
                    }
                    case 5 {
                        // label L0
                        // return $t3
                        $result := sum
                        $Free($locals, 32)
                        leave
                    }
                    case 6 {
                        // label L2
                        // $t12 := borrow_local($t0)
                        $t12 := $MakePtr(false, $locals)
                        // $t13 := vector::borrow<vector<u64>>($t12, $t1)
                        $t13 := A1_vector_borrow$vec$u64$$($t12, i)
                        // $t14 := 0
                        $t14 := 0
                        // $t15 := vector::borrow<u64>($t13, $t14)
                        $t15 := A1_vector_borrow$u64$($t13, $t14)
                        // $t16 := read_ref($t15)
                        $t16 := $LoadU64($t15)
                        // $t17 := 1
                        $t17 := 1
                        // $t18 := vector::borrow<u64>($t13, $t17)
                        $t18 := A1_vector_borrow$u64$($t13, $t17)
                        // $t19 := read_ref($t18)
                        $t19 := $LoadU64($t18)
                        // $t20 := +($t3, $t16)
                        $t20 := $AddU64(sum, $t16)
                        // $t3 := +($t20, $t19)
                        sum := $AddU64($t20, $t19)
                        // $t21 := 1
                        $t21 := 1
                        // $t1 := +($t1, $t21)
                        i := $AddU64(i, $t21)
                        // goto L3
                        $block := 2
                    }
                }
            }

            function A2_M_test_array_uint72_u128(v) -> $result {
                let i, j, len_vec, sum, vec, vec_val, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19
                let $locals := $Malloc(32)
                mstore($locals, v)
                let $block := 3
                for {} true {} {
                    switch $block
                    case 2 {
                        // label L7
                        // $t9 := 2
                        $t9 := 2
                        // $t10 := <($t1, $t9)
                        $t10 := $Lt(i, $t9)
                        // if ($t10) goto L1 else goto L0
                        switch $t10
                        case 0  { $block := 5 }
                        default { $block := 4 }
                    }
                    case 3 {
                        // $t7 := 0
                        $t7 := 0
                        // $t1 := $t7
                        i := $t7
                        // $t8 := 0
                        $t8 := 0
                        // $t4 := $t8
                        sum := $t8
                        // goto L7
                        $block := 2
                    }
                    case 4 {
                        // label L1
                        // goto L2
                        $block := 6
                    }
                    case 5 {
                        // label L0
                        // return $t4
                        $result := sum
                        $Free($locals, 32)
                        leave
                    }
                    case 6 {
                        // label L2
                        // $t11 := borrow_local($t0)
                        $t11 := $MakePtr(false, $locals)
                        // $t12 := vector::borrow<vector<u128>>($t11, $t1)
                        $t12 := A1_vector_borrow$vec$u128$$($t11, i)
                        // $t13 := vector::length<u128>($t12)
                        $t13 := A1_vector_length$u128$($t12)
                        // $t14 := 0
                        $t14 := 0
                        // $t2 := $t14
                        j := $t14
                        // goto L6
                        $block := 7
                    }
                    case 7 {
                        // label L6
                        // $t15 := <($t2, $t13)
                        $t15 := $Lt(j, $t13)
                        // if ($t15) goto L4 else goto L3
                        switch $t15
                        case 0  { $block := 9 }
                        default { $block := 8 }
                    }
                    case 8 {
                        // label L4
                        // goto L5
                        $block := 10
                    }
                    case 9 {
                        // label L3
                        // drop($t12)
                        // $t19 := 1
                        $t19 := 1
                        // $t1 := +($t1, $t19)
                        i := $AddU64(i, $t19)
                        // goto L7
                        $block := 2
                    }
                    case 10 {
                        // label L5
                        // $t16 := vector::borrow<u128>($t12, $t2)
                        $t16 := A1_vector_borrow$u128$($t12, j)
                        // $t17 := read_ref($t16)
                        $t17 := $LoadU128($t16)
                        // $t4 := +($t4, $t17)
                        sum := $AddU128(sum, $t17)
                        // $t18 := 1
                        $t18 := 1
                        // $t2 := +($t2, $t18)
                        j := $AddU64(j, $t18)
                        // goto L6
                        $block := 7
                    }
                }
            }

            function A2_M_test_array_uint8_U256(v) -> $result {
                let i, len_v, sum, vec, vec_val_1, vec_val_2, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20
                let $locals := $Malloc(32)
                mstore($locals, v)
                let $block := 3
                for {} true {} {
                    switch $block
                    case 2 {
                        // label L3
                        // $t10 := <($t1, $t8)
                        $t10 := $Lt(i, $t8)
                        // if ($t10) goto L1 else goto L0
                        switch $t10
                        case 0  { $block := 5 }
                        default { $block := 4 }
                    }
                    case 3 {
                        // $t7 := borrow_local($t0)
                        $t7 := $MakePtr(false, $locals)
                        // $t8 := vector::length<vector<0x2::U256::U256>>($t7)
                        $t8 := A1_vector_length$vec$A2_U256_U256$$($t7)
                        // $t9 := 0
                        $t9 := 0
                        // $t1 := $t9
                        i := $t9
                        // $t3 := U256::zero()
                        sum := A2_U256_zero()
                        // goto L3
                        $block := 2
                    }
                    case 4 {
                        // label L1
                        // goto L2
                        $block := 6
                    }
                    case 5 {
                        // label L0
                        // return $t3
                        $result := sum
                        $Free($locals, 32)
                        leave
                    }
                    case 6 {
                        // label L2
                        // $t11 := borrow_local($t0)
                        $t11 := $MakePtr(false, $locals)
                        // $t12 := vector::borrow<vector<0x2::U256::U256>>($t11, $t1)
                        $t12 := A1_vector_borrow$vec$A2_U256_U256$$($t11, i)
                        // $t13 := 0
                        $t13 := 0
                        // $t14 := vector::borrow<0x2::U256::U256>($t12, $t13)
                        $t14 := A1_vector_borrow$A2_U256_U256$($t12, $t13)
                        // $t15 := read_ref($t14)
                        $t15 := $LoadU256($t14)
                        // $t16 := 1
                        $t16 := 1
                        // $t17 := vector::borrow<0x2::U256::U256>($t12, $t16)
                        $t17 := A1_vector_borrow$A2_U256_U256$($t12, $t16)
                        // $t18 := read_ref($t17)
                        $t18 := $LoadU256($t17)
                        // $t19 := +($t15, $t18)
                        $t19 := $AddU256($t15, $t18)
                        // $t3 := +($t3, $t19)
                        sum := $AddU256(sum, $t19)
                        // $t20 := 1
                        $t20 := 1
                        // $t1 := +($t1, $t20)
                        i := $AddU64(i, $t20)
                        // goto L3
                        $block := 2
                    }
                }
            }

            function A2_M_test_array_uint8_u64(v) -> $result {
                let val_1, val_2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11
                let $locals := $Malloc(32)
                mstore($locals, v)
                // $t3 := borrow_local($t0)
                $t3 := $MakePtr(false, $locals)
                // $t4 := 0
                $t4 := 0
                // $t5 := vector::borrow<u64>($t3, $t4)
                $t5 := A1_vector_borrow$u64$($t3, $t4)
                // $t6 := read_ref($t5)
                $t6 := $LoadU64($t5)
                // $t7 := borrow_local($t0)
                $t7 := $MakePtr(false, $locals)
                // $t8 := 1
                $t8 := 1
                // $t9 := vector::borrow<u64>($t7, $t8)
                $t9 := A1_vector_borrow$u64$($t7, $t8)
                // $t10 := read_ref($t9)
                $t10 := $LoadU64($t9)
                // $t11 := +($t6, $t10)
                $t11 := $AddU64($t6, $t10)
                // return $t11
                $result := $t11
                $Free($locals, 32)
            }

            function A2_M_test_one_elem_para_array_2_array_2_u64(v) -> $result {
                let vec_1, vec_1_val_1, vec_1_val_2, vec_2, vec_2_val_1, vec_2_val_2, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27
                let $locals := $Malloc(32)
                mstore($locals, v)
                // $t7 := borrow_local($t0)
                $t7 := $MakePtr(false, $locals)
                // $t8 := 0
                $t8 := 0
                // $t9 := vector::borrow<vector<u64>>($t7, $t8)
                $t9 := A1_vector_borrow$vec$u64$$($t7, $t8)
                // $t10 := borrow_local($t0)
                $t10 := $MakePtr(false, $locals)
                // $t11 := 1
                $t11 := 1
                // $t12 := vector::borrow<vector<u64>>($t10, $t11)
                $t12 := A1_vector_borrow$vec$u64$$($t10, $t11)
                // $t13 := 0
                $t13 := 0
                // $t14 := vector::borrow<u64>($t9, $t13)
                $t14 := A1_vector_borrow$u64$($t9, $t13)
                // $t15 := read_ref($t14)
                $t15 := $LoadU64($t14)
                // $t16 := 1
                $t16 := 1
                // $t17 := vector::borrow<u64>($t9, $t16)
                $t17 := A1_vector_borrow$u64$($t9, $t16)
                // $t18 := read_ref($t17)
                $t18 := $LoadU64($t17)
                // $t19 := 0
                $t19 := 0
                // $t20 := vector::borrow<u64>($t12, $t19)
                $t20 := A1_vector_borrow$u64$($t12, $t19)
                // $t21 := read_ref($t20)
                $t21 := $LoadU64($t20)
                // $t22 := 1
                $t22 := 1
                // $t23 := vector::borrow<u64>($t12, $t22)
                $t23 := A1_vector_borrow$u64$($t12, $t22)
                // $t24 := read_ref($t23)
                $t24 := $LoadU64($t23)
                // $t25 := +($t15, $t18)
                $t25 := $AddU64($t15, $t18)
                // $t26 := +($t25, $t21)
                $t26 := $AddU64($t25, $t21)
                // $t27 := +($t26, $t24)
                $t27 := $AddU64($t26, $t24)
                // return $t27
                $result := $t27
                $Free($locals, 32)
            }

            function A2_M_test_one_elem_para_array_2_array_2_u8(v) -> $result {
                let vec_1, vec_1_val_1, vec_1_val_2, vec_2, vec_2_val_1, vec_2_val_2, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27
                let $locals := $Malloc(32)
                mstore($locals, v)
                // $t7 := borrow_local($t0)
                $t7 := $MakePtr(false, $locals)
                // $t8 := 0
                $t8 := 0
                // $t9 := vector::borrow<vector<u8>>($t7, $t8)
                $t9 := A1_vector_borrow$vec$u8$$($t7, $t8)
                // $t10 := borrow_local($t0)
                $t10 := $MakePtr(false, $locals)
                // $t11 := 1
                $t11 := 1
                // $t12 := vector::borrow<vector<u8>>($t10, $t11)
                $t12 := A1_vector_borrow$vec$u8$$($t10, $t11)
                // $t13 := 0
                $t13 := 0
                // $t14 := vector::borrow<u8>($t9, $t13)
                $t14 := A1_vector_borrow$u8$($t9, $t13)
                // $t15 := read_ref($t14)
                $t15 := $LoadU8($t14)
                // $t16 := 1
                $t16 := 1
                // $t17 := vector::borrow<u8>($t9, $t16)
                $t17 := A1_vector_borrow$u8$($t9, $t16)
                // $t18 := read_ref($t17)
                $t18 := $LoadU8($t17)
                // $t19 := 0
                $t19 := 0
                // $t20 := vector::borrow<u8>($t12, $t19)
                $t20 := A1_vector_borrow$u8$($t12, $t19)
                // $t21 := read_ref($t20)
                $t21 := $LoadU8($t20)
                // $t22 := 1
                $t22 := 1
                // $t23 := vector::borrow<u8>($t12, $t22)
                $t23 := A1_vector_borrow$u8$($t12, $t22)
                // $t24 := read_ref($t23)
                $t24 := $LoadU8($t23)
                // $t25 := +($t15, $t18)
                $t25 := $AddU8($t15, $t18)
                // $t26 := +($t25, $t21)
                $t26 := $AddU8($t25, $t21)
                // $t27 := -($t26, $t24)
                $t27 := $Sub($t26, $t24)
                // return $t27
                $result := $t27
                $Free($locals, 32)
            }

            function A2_M_test_one_elem_para_array_2_array_dynamic_u256(v) -> $result {
                let i, j, len_vec, sum, vec, vec_val, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18
                let $locals := $Malloc(32)
                mstore($locals, v)
                let $block := 3
                for {} true {} {
                    switch $block
                    case 2 {
                        // label L7
                        // $t8 := 2
                        $t8 := 2
                        // $t9 := <($t1, $t8)
                        $t9 := $Lt(i, $t8)
                        // if ($t9) goto L1 else goto L0
                        switch $t9
                        case 0  { $block := 5 }
                        default { $block := 4 }
                    }
                    case 3 {
                        // $t7 := 0
                        $t7 := 0
                        // $t1 := $t7
                        i := $t7
                        // $t4 := U256::zero()
                        sum := A2_U256_zero()
                        // goto L7
                        $block := 2
                    }
                    case 4 {
                        // label L1
                        // goto L2
                        $block := 6
                    }
                    case 5 {
                        // label L0
                        // return $t4
                        $result := sum
                        $Free($locals, 32)
                        leave
                    }
                    case 6 {
                        // label L2
                        // $t10 := borrow_local($t0)
                        $t10 := $MakePtr(false, $locals)
                        // $t11 := vector::borrow<vector<0x2::U256::U256>>($t10, $t1)
                        $t11 := A1_vector_borrow$vec$A2_U256_U256$$($t10, i)
                        // $t12 := vector::length<0x2::U256::U256>($t11)
                        $t12 := A1_vector_length$A2_U256_U256$($t11)
                        // $t13 := 0
                        $t13 := 0
                        // $t2 := $t13
                        j := $t13
                        // goto L6
                        $block := 7
                    }
                    case 7 {
                        // label L6
                        // $t14 := <($t2, $t12)
                        $t14 := $Lt(j, $t12)
                        // if ($t14) goto L4 else goto L3
                        switch $t14
                        case 0  { $block := 9 }
                        default { $block := 8 }
                    }
                    case 8 {
                        // label L4
                        // goto L5
                        $block := 10
                    }
                    case 9 {
                        // label L3
                        // drop($t11)
                        // $t18 := 1
                        $t18 := 1
                        // $t1 := +($t1, $t18)
                        i := $AddU64(i, $t18)
                        // goto L7
                        $block := 2
                    }
                    case 10 {
                        // label L5
                        // $t15 := vector::borrow<0x2::U256::U256>($t11, $t2)
                        $t15 := A1_vector_borrow$A2_U256_U256$($t11, j)
                        // $t16 := read_ref($t15)
                        $t16 := $LoadU256($t15)
                        // $t4 := +($t4, $t16)
                        sum := $AddU256(sum, $t16)
                        // $t17 := 1
                        $t17 := 1
                        // $t2 := +($t2, $t17)
                        j := $AddU64(j, $t17)
                        // goto L6
                        $block := 7
                    }
                }
            }

            function A2_M_test_one_elem_para_array_2_array_dynamic_u64(v) -> $result {
                let i, j, len_vec, sum, vec, vec_val, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19
                let $locals := $Malloc(32)
                mstore($locals, v)
                let $block := 3
                for {} true {} {
                    switch $block
                    case 2 {
                        // label L7
                        // $t9 := 2
                        $t9 := 2
                        // $t10 := <($t1, $t9)
                        $t10 := $Lt(i, $t9)
                        // if ($t10) goto L1 else goto L0
                        switch $t10
                        case 0  { $block := 5 }
                        default { $block := 4 }
                    }
                    case 3 {
                        // $t7 := 0
                        $t7 := 0
                        // $t1 := $t7
                        i := $t7
                        // $t8 := 0
                        $t8 := 0
                        // $t4 := $t8
                        sum := $t8
                        // goto L7
                        $block := 2
                    }
                    case 4 {
                        // label L1
                        // goto L2
                        $block := 6
                    }
                    case 5 {
                        // label L0
                        // return $t4
                        $result := sum
                        $Free($locals, 32)
                        leave
                    }
                    case 6 {
                        // label L2
                        // $t11 := borrow_local($t0)
                        $t11 := $MakePtr(false, $locals)
                        // $t12 := vector::borrow<vector<u64>>($t11, $t1)
                        $t12 := A1_vector_borrow$vec$u64$$($t11, i)
                        // $t13 := vector::length<u64>($t12)
                        $t13 := A1_vector_length$u64$($t12)
                        // $t14 := 0
                        $t14 := 0
                        // $t2 := $t14
                        j := $t14
                        // goto L6
                        $block := 7
                    }
                    case 7 {
                        // label L6
                        // $t15 := <($t2, $t13)
                        $t15 := $Lt(j, $t13)
                        // if ($t15) goto L4 else goto L3
                        switch $t15
                        case 0  { $block := 9 }
                        default { $block := 8 }
                    }
                    case 8 {
                        // label L4
                        // goto L5
                        $block := 10
                    }
                    case 9 {
                        // label L3
                        // drop($t12)
                        // $t19 := 1
                        $t19 := 1
                        // $t1 := +($t1, $t19)
                        i := $AddU64(i, $t19)
                        // goto L7
                        $block := 2
                    }
                    case 10 {
                        // label L5
                        // $t16 := vector::borrow<u64>($t12, $t2)
                        $t16 := A1_vector_borrow$u64$($t12, j)
                        // $t17 := read_ref($t16)
                        $t17 := $LoadU64($t16)
                        // $t4 := +($t4, $t17)
                        sum := $AddU64(sum, $t17)
                        // $t18 := 1
                        $t18 := 1
                        // $t2 := +($t2, $t18)
                        j := $AddU64(j, $t18)
                        // goto L6
                        $block := 7
                    }
                }
            }

            function A2_M_test_one_elem_para_array_2_array_dynamic_u8(v) -> $result {
                let i, j, len_vec, sum, vec, vec_val, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19
                let $locals := $Malloc(32)
                mstore($locals, v)
                let $block := 3
                for {} true {} {
                    switch $block
                    case 2 {
                        // label L7
                        // $t9 := 2
                        $t9 := 2
                        // $t10 := <($t1, $t9)
                        $t10 := $Lt(i, $t9)
                        // if ($t10) goto L1 else goto L0
                        switch $t10
                        case 0  { $block := 5 }
                        default { $block := 4 }
                    }
                    case 3 {
                        // $t7 := 0
                        $t7 := 0
                        // $t1 := $t7
                        i := $t7
                        // $t8 := 0
                        $t8 := 0
                        // $t4 := $t8
                        sum := $t8
                        // goto L7
                        $block := 2
                    }
                    case 4 {
                        // label L1
                        // goto L2
                        $block := 6
                    }
                    case 5 {
                        // label L0
                        // return $t4
                        $result := sum
                        $Free($locals, 32)
                        leave
                    }
                    case 6 {
                        // label L2
                        // $t11 := borrow_local($t0)
                        $t11 := $MakePtr(false, $locals)
                        // $t12 := vector::borrow<vector<u8>>($t11, $t1)
                        $t12 := A1_vector_borrow$vec$u8$$($t11, i)
                        // $t13 := vector::length<u8>($t12)
                        $t13 := A1_vector_length$u8$($t12)
                        // $t14 := 0
                        $t14 := 0
                        // $t2 := $t14
                        j := $t14
                        // goto L6
                        $block := 7
                    }
                    case 7 {
                        // label L6
                        // $t15 := <($t2, $t13)
                        $t15 := $Lt(j, $t13)
                        // if ($t15) goto L4 else goto L3
                        switch $t15
                        case 0  { $block := 9 }
                        default { $block := 8 }
                    }
                    case 8 {
                        // label L4
                        // goto L5
                        $block := 10
                    }
                    case 9 {
                        // label L3
                        // drop($t12)
                        // $t19 := 1
                        $t19 := 1
                        // $t1 := +($t1, $t19)
                        i := $AddU64(i, $t19)
                        // goto L7
                        $block := 2
                    }
                    case 10 {
                        // label L5
                        // $t16 := vector::borrow<u8>($t12, $t2)
                        $t16 := A1_vector_borrow$u8$($t12, j)
                        // $t17 := read_ref($t16)
                        $t17 := $LoadU8($t16)
                        // $t4 := +($t4, $t17)
                        sum := $AddU8(sum, $t17)
                        // $t18 := 1
                        $t18 := 1
                        // $t2 := +($t2, $t18)
                        j := $AddU64(j, $t18)
                        // goto L6
                        $block := 7
                    }
                }
            }

            function A2_M_test_one_elem_para_array_dynamic_array_2_u256(v) -> $result {
                let i, len_v, sum, vec, vec_val_1, vec_val_2, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20
                let $locals := $Malloc(32)
                mstore($locals, v)
                let $block := 3
                for {} true {} {
                    switch $block
                    case 2 {
                        // label L3
                        // $t10 := <($t1, $t8)
                        $t10 := $Lt(i, $t8)
                        // if ($t10) goto L1 else goto L0
                        switch $t10
                        case 0  { $block := 5 }
                        default { $block := 4 }
                    }
                    case 3 {
                        // $t7 := borrow_local($t0)
                        $t7 := $MakePtr(false, $locals)
                        // $t8 := vector::length<vector<0x2::U256::U256>>($t7)
                        $t8 := A1_vector_length$vec$A2_U256_U256$$($t7)
                        // $t9 := 0
                        $t9 := 0
                        // $t1 := $t9
                        i := $t9
                        // $t3 := U256::zero()
                        sum := A2_U256_zero()
                        // goto L3
                        $block := 2
                    }
                    case 4 {
                        // label L1
                        // goto L2
                        $block := 6
                    }
                    case 5 {
                        // label L0
                        // return $t3
                        $result := sum
                        $Free($locals, 32)
                        leave
                    }
                    case 6 {
                        // label L2
                        // $t11 := borrow_local($t0)
                        $t11 := $MakePtr(false, $locals)
                        // $t12 := vector::borrow<vector<0x2::U256::U256>>($t11, $t1)
                        $t12 := A1_vector_borrow$vec$A2_U256_U256$$($t11, i)
                        // $t13 := 0
                        $t13 := 0
                        // $t14 := vector::borrow<0x2::U256::U256>($t12, $t13)
                        $t14 := A1_vector_borrow$A2_U256_U256$($t12, $t13)
                        // $t15 := read_ref($t14)
                        $t15 := $LoadU256($t14)
                        // $t16 := 1
                        $t16 := 1
                        // $t17 := vector::borrow<0x2::U256::U256>($t12, $t16)
                        $t17 := A1_vector_borrow$A2_U256_U256$($t12, $t16)
                        // $t18 := read_ref($t17)
                        $t18 := $LoadU256($t17)
                        // $t19 := +($t15, $t18)
                        $t19 := $AddU256($t15, $t18)
                        // $t3 := +($t3, $t19)
                        sum := $AddU256(sum, $t19)
                        // $t20 := 1
                        $t20 := 1
                        // $t1 := +($t1, $t20)
                        i := $AddU64(i, $t20)
                        // goto L3
                        $block := 2
                    }
                }
            }

            function A2_M_test_one_elem_para_array_dynamic_array_2_u64(v) -> $result {
                let i, len_v, sum, vec, vec_val_1, vec_val_2, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21
                let $locals := $Malloc(32)
                mstore($locals, v)
                let $block := 3
                for {} true {} {
                    switch $block
                    case 2 {
                        // label L3
                        // $t11 := <($t1, $t8)
                        $t11 := $Lt(i, $t8)
                        // if ($t11) goto L1 else goto L0
                        switch $t11
                        case 0  { $block := 5 }
                        default { $block := 4 }
                    }
                    case 3 {
                        // $t7 := borrow_local($t0)
                        $t7 := $MakePtr(false, $locals)
                        // $t8 := vector::length<vector<u64>>($t7)
                        $t8 := A1_vector_length$vec$u64$$($t7)
                        // $t9 := 0
                        $t9 := 0
                        // $t1 := $t9
                        i := $t9
                        // $t10 := 0
                        $t10 := 0
                        // $t3 := $t10
                        sum := $t10
                        // goto L3
                        $block := 2
                    }
                    case 4 {
                        // label L1
                        // goto L2
                        $block := 6
                    }
                    case 5 {
                        // label L0
                        // return $t3
                        $result := sum
                        $Free($locals, 32)
                        leave
                    }
                    case 6 {
                        // label L2
                        // $t12 := borrow_local($t0)
                        $t12 := $MakePtr(false, $locals)
                        // $t13 := vector::borrow<vector<u64>>($t12, $t1)
                        $t13 := A1_vector_borrow$vec$u64$$($t12, i)
                        // $t14 := 0
                        $t14 := 0
                        // $t15 := vector::borrow<u64>($t13, $t14)
                        $t15 := A1_vector_borrow$u64$($t13, $t14)
                        // $t16 := read_ref($t15)
                        $t16 := $LoadU64($t15)
                        // $t17 := 1
                        $t17 := 1
                        // $t18 := vector::borrow<u64>($t13, $t17)
                        $t18 := A1_vector_borrow$u64$($t13, $t17)
                        // $t19 := read_ref($t18)
                        $t19 := $LoadU64($t18)
                        // $t20 := +($t3, $t16)
                        $t20 := $AddU64(sum, $t16)
                        // $t3 := +($t20, $t19)
                        sum := $AddU64($t20, $t19)
                        // $t21 := 1
                        $t21 := 1
                        // $t1 := +($t1, $t21)
                        i := $AddU64(i, $t21)
                        // goto L3
                        $block := 2
                    }
                }
            }

            function A2_M_test_one_elem_para_array_dynamic_array_2_u8(v) -> $result {
                let i, len_v, sum, vec, vec_val_1, vec_val_2, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21
                let $locals := $Malloc(32)
                mstore($locals, v)
                let $block := 3
                for {} true {} {
                    switch $block
                    case 2 {
                        // label L3
                        // $t11 := <($t1, $t8)
                        $t11 := $Lt(i, $t8)
                        // if ($t11) goto L1 else goto L0
                        switch $t11
                        case 0  { $block := 5 }
                        default { $block := 4 }
                    }
                    case 3 {
                        // $t7 := borrow_local($t0)
                        $t7 := $MakePtr(false, $locals)
                        // $t8 := vector::length<vector<u8>>($t7)
                        $t8 := A1_vector_length$vec$u8$$($t7)
                        // $t9 := 0
                        $t9 := 0
                        // $t1 := $t9
                        i := $t9
                        // $t10 := 0
                        $t10 := 0
                        // $t3 := $t10
                        sum := $t10
                        // goto L3
                        $block := 2
                    }
                    case 4 {
                        // label L1
                        // goto L2
                        $block := 6
                    }
                    case 5 {
                        // label L0
                        // return $t3
                        $result := sum
                        $Free($locals, 32)
                        leave
                    }
                    case 6 {
                        // label L2
                        // $t12 := borrow_local($t0)
                        $t12 := $MakePtr(false, $locals)
                        // $t13 := vector::borrow<vector<u8>>($t12, $t1)
                        $t13 := A1_vector_borrow$vec$u8$$($t12, i)
                        // $t14 := 0
                        $t14 := 0
                        // $t15 := vector::borrow<u8>($t13, $t14)
                        $t15 := A1_vector_borrow$u8$($t13, $t14)
                        // $t16 := read_ref($t15)
                        $t16 := $LoadU8($t15)
                        // $t17 := 1
                        $t17 := 1
                        // $t18 := vector::borrow<u8>($t13, $t17)
                        $t18 := A1_vector_borrow$u8$($t13, $t17)
                        // $t19 := read_ref($t18)
                        $t19 := $LoadU8($t18)
                        // $t20 := +($t3, $t16)
                        $t20 := $AddU8(sum, $t16)
                        // $t3 := +($t20, $t19)
                        sum := $AddU8($t20, $t19)
                        // $t21 := 1
                        $t21 := 1
                        // $t1 := +($t1, $t21)
                        i := $AddU64(i, $t21)
                        // goto L3
                        $block := 2
                    }
                }
            }

            function A2_M_test_one_elem_para_array_dynamic_array_u128(v) -> $result {
                let i, j, len_v, sum, vec, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19
                let $locals := $Malloc(32)
                mstore($locals, v)
                let $block := 3
                for {} true {} {
                    switch $block
                    case 2 {
                        // label L7
                        // $t10 := <($t1, $t7)
                        $t10 := $Lt(i, $t7)
                        // if ($t10) goto L1 else goto L0
                        switch $t10
                        case 0  { $block := 5 }
                        default { $block := 4 }
                    }
                    case 3 {
                        // $t6 := borrow_local($t0)
                        $t6 := $MakePtr(false, $locals)
                        // $t7 := vector::length<vector<u128>>($t6)
                        $t7 := A1_vector_length$vec$u128$$($t6)
                        // $t8 := 0
                        $t8 := 0
                        // $t1 := $t8
                        i := $t8
                        // $t9 := 0
                        $t9 := 0
                        // $t4 := $t9
                        sum := $t9
                        // goto L7
                        $block := 2
                    }
                    case 4 {
                        // label L1
                        // goto L2
                        $block := 6
                    }
                    case 5 {
                        // label L0
                        // return $t4
                        $result := sum
                        $Free($locals, 32)
                        leave
                    }
                    case 6 {
                        // label L2
                        // $t11 := borrow_local($t0)
                        $t11 := $MakePtr(false, $locals)
                        // $t12 := vector::borrow<vector<u128>>($t11, $t1)
                        $t12 := A1_vector_borrow$vec$u128$$($t11, i)
                        // $t13 := 0
                        $t13 := 0
                        // $t2 := $t13
                        j := $t13
                        // goto L6
                        $block := 7
                    }
                    case 7 {
                        // label L6
                        // $t14 := vector::length<u128>($t12)
                        $t14 := A1_vector_length$u128$($t12)
                        // $t15 := <($t2, $t14)
                        $t15 := $Lt(j, $t14)
                        // if ($t15) goto L4 else goto L3
                        switch $t15
                        case 0  { $block := 9 }
                        default { $block := 8 }
                    }
                    case 8 {
                        // label L4
                        // goto L5
                        $block := 10
                    }
                    case 9 {
                        // label L3
                        // drop($t12)
                        // $t19 := 1
                        $t19 := 1
                        // $t1 := +($t1, $t19)
                        i := $AddU64(i, $t19)
                        // goto L7
                        $block := 2
                    }
                    case 10 {
                        // label L5
                        // $t16 := vector::borrow<u128>($t12, $t2)
                        $t16 := A1_vector_borrow$u128$($t12, j)
                        // $t17 := read_ref($t16)
                        $t17 := $LoadU128($t16)
                        // $t4 := +($t4, $t17)
                        sum := $AddU128(sum, $t17)
                        // $t18 := 1
                        $t18 := 1
                        // $t2 := +($t2, $t18)
                        j := $AddU64(j, $t18)
                        // goto L6
                        $block := 7
                    }
                }
            }

            function A1_vector_borrow$u128$(v_ref, i) -> e_ptr {
                let v_offs := $LoadU256(v_ref)
                let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
                let size := $LoadU64(v_ptr)
                if $GtEq(i, size) { $AbortBuiltin() }
                e_ptr := $IndexPtr(v_ptr, add(32, mul(i, 16)))
            }
            function A1_vector_length$u128$(v_ref) -> len {
                let v_offs := $LoadU256(v_ref)
                let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
                len := $LoadU64(v_ptr)
            }
            function A1_vector_borrow$vec$u128$$(v_ref, i) -> e_ptr {
                let v_offs := $LoadU256(v_ref)
                let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
                let size := $LoadU64(v_ptr)
                if $GtEq(i, size) { $AbortBuiltin() }
                e_ptr := $IndexPtr(v_ptr, add(32, mul(i, 32)))
            }
            function A1_vector_length$vec$u128$$(v_ref) -> len {
                let v_offs := $LoadU256(v_ref)
                let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
                len := $LoadU64(v_ptr)
            }
            function A1_vector_borrow$u8$(v_ref, i) -> e_ptr {
                let v_offs := $LoadU256(v_ref)
                let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
                let size := $LoadU64(v_ptr)
                if $GtEq(i, size) { $AbortBuiltin() }
                e_ptr := $IndexPtr(v_ptr, add(32, mul(i, 1)))
            }
            function A1_vector_borrow$vec$u8$$(v_ref, i) -> e_ptr {
                let v_offs := $LoadU256(v_ref)
                let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
                let size := $LoadU64(v_ptr)
                if $GtEq(i, size) { $AbortBuiltin() }
                e_ptr := $IndexPtr(v_ptr, add(32, mul(i, 32)))
            }
            function A1_vector_length$vec$u8$$(v_ref) -> len {
                let v_offs := $LoadU256(v_ref)
                let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
                len := $LoadU64(v_ptr)
            }
            function A1_vector_borrow$u64$(v_ref, i) -> e_ptr {
                let v_offs := $LoadU256(v_ref)
                let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
                let size := $LoadU64(v_ptr)
                if $GtEq(i, size) { $AbortBuiltin() }
                e_ptr := $IndexPtr(v_ptr, add(32, mul(i, 8)))
            }
            function A1_vector_borrow$vec$u64$$(v_ref, i) -> e_ptr {
                let v_offs := $LoadU256(v_ref)
                let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
                let size := $LoadU64(v_ptr)
                if $GtEq(i, size) { $AbortBuiltin() }
                e_ptr := $IndexPtr(v_ptr, add(32, mul(i, 32)))
            }
            function A1_vector_length$vec$u64$$(v_ref) -> len {
                let v_offs := $LoadU256(v_ref)
                let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
                len := $LoadU64(v_ptr)
            }
            function A1_vector_borrow$A2_U256_U256$(v_ref, i) -> e_ptr {
                let v_offs := $LoadU256(v_ref)
                let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
                let size := $LoadU64(v_ptr)
                if $GtEq(i, size) { $AbortBuiltin() }
                e_ptr := $IndexPtr(v_ptr, add(32, mul(i, 32)))
            }
            function A1_vector_borrow$vec$A2_U256_U256$$(v_ref, i) -> e_ptr {
                let v_offs := $LoadU256(v_ref)
                let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
                let size := $LoadU64(v_ptr)
                if $GtEq(i, size) { $AbortBuiltin() }
                e_ptr := $IndexPtr(v_ptr, add(32, mul(i, 32)))
            }
            function A2_U256_zero() -> $result {
                let $t0
                // $t0 := 0
                $t0 := 0
                // return $t0
                $result := $t0
            }

            function A1_vector_length$vec$A2_U256_U256$$(v_ref) -> len {
                let v_offs := $LoadU256(v_ref)
                let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
                len := $LoadU64(v_ptr)
            }
            function A1_vector_length$u8$(v_ref) -> len {
                let v_offs := $LoadU256(v_ref)
                let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
                len := $LoadU64(v_ptr)
            }
            function A1_vector_length$u64$(v_ref) -> len {
                let v_offs := $LoadU256(v_ref)
                let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
                len := $LoadU64(v_ptr)
            }
            function A1_vector_length$A2_U256_U256$(v_ref) -> len {
                let v_offs := $LoadU256(v_ref)
                let v_ptr := $MakePtr($IsStoragePtr(v_ref), v_offs)
                len := $LoadU64(v_ptr)
            }
            function abi_encode_tuple_$uint128$_$u128$(headStart ,value_0) -> tail {
                tail := add(headStart, 32)
                abi_encode_uint128(value_0, add(headStart, 0))
            }
            function abi_encode_uint128(value, pos) {
                mstore(pos, cleanup_uint128(value))
            }
            function cleanup_uint128(value) -> cleaned {
                cleaned := and(value, 0xffffffffffffffffffffffffffffffff)
            }
            function abi_decode_tuple_$uint128____$_$vec$vec$u128$$$(headStart, dataEnd) -> value_0 {
                if slt(sub(dataEnd, headStart), 32) { $Abort(96) }
                {
                    let offset := calldataload(add(headStart, 0))
                    if gt(offset, 0xffffffffffffffff) { $Abort(96) }
                    value_0 := abi_decode_uint128_____vec$vec$u128$$(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_uint128_____vec$vec$u128$$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := calldataload(offset)
                let size := add(mul(32, length), 32)
                array := abi_decode_available_length__uint128_____vec$vec$u128$$(add(offset, 0x20), length, size, end)
            }
            function abi_decode_available_length__uint128_____vec$vec$u128$$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 32))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 32) }
                {
                    let innerOffset := calldataload(src)
                    if gt(innerOffset, 0xffffffffffffffff) { $Abort(94) }
                    let elementPos := add(offset, innerOffset)
                    let value := abi_decode_uint128___vec$u128$(elementPos, end)
                    $MemoryStoreU256(dst, value)
                    dst := add(dst, 32)
                }
            }
            function abi_decode_uint128___vec$u128$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := calldataload(offset)
                let size := add(mul(16, length), 32)
                array := abi_decode_available_length__uint128___vec$u128$(add(offset, 0x20), length, size, end)
            }
            function abi_decode_available_length__uint128___vec$u128$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 32))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 32) }
                {
                    let elementPos := src
                    let value := abi_decode_uint128(elementPos, end)
                    $MemoryStoreU128(dst, value)
                    dst := add(dst, 16)
                }
            }
            function abi_decode_uint128(offset, end) -> value {
                value := calldataload(offset)
                validator_uint128(value)
            }
            function validator_uint128(value) {
                if iszero(eq(value, cleanup_uint128(value))) { $Abort(95) }
            }
            function abi_encode_tuple_$uint8$_$u8$(headStart ,value_0) -> tail {
                tail := add(headStart, 32)
                abi_encode_uint8(value_0, add(headStart, 0))
            }
            function abi_encode_uint8(value, pos) {
                mstore(pos, cleanup_uint8(value))
            }
            function cleanup_uint8(value) -> cleaned {
                cleaned := and(value, 0xff)
            }
            function abi_decode_tuple_$uint8_2___$_$vec$vec$u8$$$(headStart, dataEnd) -> value_0 {
                if slt(sub(dataEnd, headStart), 32) { $Abort(96) }
                {
                    let offset := calldataload(add(headStart, 0))
                    if gt(offset, 0xffffffffffffffff) { $Abort(96) }
                    value_0 := abi_decode_uint8_2____vec$vec$u8$$(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_uint8_2____vec$vec$u8$$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := calldataload(offset)
                let size := add(mul(32, length), 32)
                array := abi_decode_available_length__uint8_2____vec$vec$u8$$(add(offset, 0x20), length, size, end)
            }
            function abi_decode_available_length__uint8_2____vec$vec$u8$$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 64))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 64) }
                {
                    let elementPos := src
                    let value := abi_decode_uint8_2__vec$u8$(elementPos, end)
                    $MemoryStoreU256(dst, value)
                    dst := add(dst, 32)
                }
            }
            function abi_decode_uint8_2__vec$u8$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := 2
                let size := 34
                array := abi_decode_available_length__uint8_2__vec$u8$(offset, length, size, end)
            }
            function abi_decode_available_length__uint8_2__vec$u8$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 32))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 32) }
                {
                    let elementPos := src
                    let value := abi_decode_uint8(elementPos, end)
                    $MemoryStoreU8(dst, value)
                    dst := add(dst, 1)
                }
            }
            function abi_decode_uint8(offset, end) -> value {
                value := calldataload(offset)
                validator_uint8(value)
            }
            function validator_uint8(value) {
                if iszero(eq(value, cleanup_uint8(value))) { $Abort(95) }
            }
            function abi_encode_tuple_$uint64$_$u64$(headStart ,value_0) -> tail {
                tail := add(headStart, 32)
                abi_encode_uint64(value_0, add(headStart, 0))
            }
            function abi_encode_uint64(value, pos) {
                mstore(pos, cleanup_uint64(value))
            }
            function cleanup_uint64(value) -> cleaned {
                cleaned := and(value, 0xffffffffffffffff)
            }
            function abi_decode_tuple_$uint64_2___$_$vec$vec$u64$$$(headStart, dataEnd) -> value_0 {
                if slt(sub(dataEnd, headStart), 32) { $Abort(96) }
                {
                    let offset := calldataload(add(headStart, 0))
                    if gt(offset, 0xffffffffffffffff) { $Abort(96) }
                    value_0 := abi_decode_uint64_2____vec$vec$u64$$(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_uint64_2____vec$vec$u64$$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := calldataload(offset)
                let size := add(mul(32, length), 32)
                array := abi_decode_available_length__uint64_2____vec$vec$u64$$(add(offset, 0x20), length, size, end)
            }
            function abi_decode_available_length__uint64_2____vec$vec$u64$$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 64))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 64) }
                {
                    let elementPos := src
                    let value := abi_decode_uint64_2__vec$u64$(elementPos, end)
                    $MemoryStoreU256(dst, value)
                    dst := add(dst, 32)
                }
            }
            function abi_decode_uint64_2__vec$u64$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := 2
                let size := 48
                array := abi_decode_available_length__uint64_2__vec$u64$(offset, length, size, end)
            }
            function abi_decode_available_length__uint64_2__vec$u64$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 32))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 32) }
                {
                    let elementPos := src
                    let value := abi_decode_uint64(elementPos, end)
                    $MemoryStoreU64(dst, value)
                    dst := add(dst, 8)
                }
            }
            function abi_decode_uint64(offset, end) -> value {
                value := calldataload(offset)
                validator_uint64(value)
            }
            function validator_uint64(value) {
                if iszero(eq(value, cleanup_uint64(value))) { $Abort(95) }
            }
            function abi_encode_tuple_$uint256$_$A2_U256_U256$(headStart ,value_0) -> tail {
                tail := add(headStart, 32)
                abi_encode_uint256(value_0, add(headStart, 0))
            }
            function abi_encode_uint256(value, pos) {
                mstore(pos, cleanup_uint256(value))
            }
            function cleanup_uint256(value) -> cleaned {
                cleaned := and(value, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
            }
            function abi_decode_tuple_$uint256_2___$_$vec$vec$A2_U256_U256$$$(headStart, dataEnd) -> value_0 {
                if slt(sub(dataEnd, headStart), 32) { $Abort(96) }
                {
                    let offset := calldataload(add(headStart, 0))
                    if gt(offset, 0xffffffffffffffff) { $Abort(96) }
                    value_0 := abi_decode_uint256_2____vec$vec$A2_U256_U256$$(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_uint256_2____vec$vec$A2_U256_U256$$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := calldataload(offset)
                let size := add(mul(32, length), 32)
                array := abi_decode_available_length__uint256_2____vec$vec$A2_U256_U256$$(add(offset, 0x20), length, size, end)
            }
            function abi_decode_available_length__uint256_2____vec$vec$A2_U256_U256$$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 64))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 64) }
                {
                    let elementPos := src
                    let value := abi_decode_uint256_2__vec$A2_U256_U256$(elementPos, end)
                    $MemoryStoreU256(dst, value)
                    dst := add(dst, 32)
                }
            }
            function abi_decode_uint256_2__vec$A2_U256_U256$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := 2
                let size := 96
                array := abi_decode_available_length__uint256_2__vec$A2_U256_U256$(offset, length, size, end)
            }
            function abi_decode_available_length__uint256_2__vec$A2_U256_U256$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 32))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 32) }
                {
                    let elementPos := src
                    let value := abi_decode_uint256(elementPos, end)
                    $MemoryStoreU256(dst, value)
                    dst := add(dst, 32)
                }
            }
            function abi_decode_uint256(offset, end) -> value {
                value := calldataload(offset)
                validator_uint256(value)
            }
            function validator_uint256(value) {
                if iszero(eq(value, cleanup_uint256(value))) { $Abort(95) }
            }
            function abi_decode_tuple_$uint8___2_$_$vec$vec$u8$$$(headStart, dataEnd) -> value_0 {
                if slt(sub(dataEnd, headStart), 32) { $Abort(96) }
                {
                    let offset := calldataload(add(headStart, 0))
                    if gt(offset, 0xffffffffffffffff) { $Abort(96) }
                    value_0 := abi_decode_uint8___2__vec$vec$u8$$(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_uint8___2__vec$vec$u8$$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := 2
                let size := 96
                array := abi_decode_available_length__uint8___2__vec$vec$u8$$(offset, length, size, end)
            }
            function abi_decode_available_length__uint8___2__vec$vec$u8$$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 32))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 32) }
                {
                    let innerOffset := calldataload(src)
                    if gt(innerOffset, 0xffffffffffffffff) { $Abort(94) }
                    let elementPos := add(offset, innerOffset)
                    let value := abi_decode_uint8___vec$u8$(elementPos, end)
                    $MemoryStoreU256(dst, value)
                    dst := add(dst, 32)
                }
            }
            function abi_decode_uint8___vec$u8$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := calldataload(offset)
                let size := add(mul(1, length), 32)
                array := abi_decode_available_length__uint8___vec$u8$(add(offset, 0x20), length, size, end)
            }
            function abi_decode_available_length__uint8___vec$u8$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 32))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 32) }
                {
                    let elementPos := src
                    let value := abi_decode_uint8(elementPos, end)
                    $MemoryStoreU8(dst, value)
                    dst := add(dst, 1)
                }
            }
            function abi_decode_tuple_$uint64___2_$_$vec$vec$u64$$$(headStart, dataEnd) -> value_0 {
                if slt(sub(dataEnd, headStart), 32) { $Abort(96) }
                {
                    let offset := calldataload(add(headStart, 0))
                    if gt(offset, 0xffffffffffffffff) { $Abort(96) }
                    value_0 := abi_decode_uint64___2__vec$vec$u64$$(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_uint64___2__vec$vec$u64$$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := 2
                let size := 96
                array := abi_decode_available_length__uint64___2__vec$vec$u64$$(offset, length, size, end)
            }
            function abi_decode_available_length__uint64___2__vec$vec$u64$$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 32))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 32) }
                {
                    let innerOffset := calldataload(src)
                    if gt(innerOffset, 0xffffffffffffffff) { $Abort(94) }
                    let elementPos := add(offset, innerOffset)
                    let value := abi_decode_uint64___vec$u64$(elementPos, end)
                    $MemoryStoreU256(dst, value)
                    dst := add(dst, 32)
                }
            }
            function abi_decode_uint64___vec$u64$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := calldataload(offset)
                let size := add(mul(8, length), 32)
                array := abi_decode_available_length__uint64___vec$u64$(add(offset, 0x20), length, size, end)
            }
            function abi_decode_available_length__uint64___vec$u64$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 32))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 32) }
                {
                    let elementPos := src
                    let value := abi_decode_uint64(elementPos, end)
                    $MemoryStoreU64(dst, value)
                    dst := add(dst, 8)
                }
            }
            function abi_decode_tuple_$uint256___2_$_$vec$vec$A2_U256_U256$$$(headStart, dataEnd) -> value_0 {
                if slt(sub(dataEnd, headStart), 32) { $Abort(96) }
                {
                    let offset := calldataload(add(headStart, 0))
                    if gt(offset, 0xffffffffffffffff) { $Abort(96) }
                    value_0 := abi_decode_uint256___2__vec$vec$A2_U256_U256$$(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_uint256___2__vec$vec$A2_U256_U256$$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := 2
                let size := 96
                array := abi_decode_available_length__uint256___2__vec$vec$A2_U256_U256$$(offset, length, size, end)
            }
            function abi_decode_available_length__uint256___2__vec$vec$A2_U256_U256$$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 32))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 32) }
                {
                    let innerOffset := calldataload(src)
                    if gt(innerOffset, 0xffffffffffffffff) { $Abort(94) }
                    let elementPos := add(offset, innerOffset)
                    let value := abi_decode_uint256___vec$A2_U256_U256$(elementPos, end)
                    $MemoryStoreU256(dst, value)
                    dst := add(dst, 32)
                }
            }
            function abi_decode_uint256___vec$A2_U256_U256$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := calldataload(offset)
                let size := add(mul(32, length), 32)
                array := abi_decode_available_length__uint256___vec$A2_U256_U256$(add(offset, 0x20), length, size, end)
            }
            function abi_decode_available_length__uint256___vec$A2_U256_U256$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 32))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 32) }
                {
                    let elementPos := src
                    let value := abi_decode_uint256(elementPos, end)
                    $MemoryStoreU256(dst, value)
                    dst := add(dst, 32)
                }
            }
            function abi_decode_tuple_$uint8_2__2_$_$vec$vec$u8$$$(headStart, dataEnd) -> value_0 {
                if slt(sub(dataEnd, headStart), 128) { $Abort(96) }
                {
                    let offset := 0
                    value_0 := abi_decode_uint8_2__2__vec$vec$u8$$(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_uint8_2__2__vec$vec$u8$$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := 2
                let size := 96
                array := abi_decode_available_length__uint8_2__2__vec$vec$u8$$(offset, length, size, end)
            }
            function abi_decode_available_length__uint8_2__2__vec$vec$u8$$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 64))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 64) }
                {
                    let elementPos := src
                    let value := abi_decode_uint8_2__vec$u8$(elementPos, end)
                    $MemoryStoreU256(dst, value)
                    dst := add(dst, 32)
                }
            }
            function abi_decode_tuple_$uint64_2__2_$_$vec$vec$u64$$$(headStart, dataEnd) -> value_0 {
                if slt(sub(dataEnd, headStart), 128) { $Abort(96) }
                {
                    let offset := 0
                    value_0 := abi_decode_uint64_2__2__vec$vec$u64$$(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_uint64_2__2__vec$vec$u64$$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := 2
                let size := 96
                array := abi_decode_available_length__uint64_2__2__vec$vec$u64$$(offset, length, size, end)
            }
            function abi_decode_available_length__uint64_2__2__vec$vec$u64$$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 64))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 64) }
                {
                    let elementPos := src
                    let value := abi_decode_uint64_2__vec$u64$(elementPos, end)
                    $MemoryStoreU256(dst, value)
                    dst := add(dst, 32)
                }
            }
            function abi_encode_tuple_$uint8$_$u64$(headStart ,value_0) -> tail {
                tail := add(headStart, 32)
                abi_encode_uint8(value_0, add(headStart, 0))
            }
            function abi_decode_tuple_$uint8_2_$_$vec$u64$$(headStart, dataEnd) -> value_0 {
                if slt(sub(dataEnd, headStart), 64) { $Abort(96) }
                {
                    let offset := 0
                    value_0 := abi_decode_uint8_2__vec$u64$(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_uint8_2__vec$u64$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := 2
                let size := 48
                array := abi_decode_available_length__uint8_2__vec$u64$(offset, length, size, end)
            }
            function abi_decode_available_length__uint8_2__vec$u64$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 32))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 32) }
                {
                    let elementPos := src
                    let value := abi_decode_uint8(elementPos, end)
                    $MemoryStoreU64(dst, value)
                    dst := add(dst, 8)
                }
            }
            function abi_encode_tuple_$uint8$_$A2_U256_U256$(headStart ,value_0) -> tail {
                tail := add(headStart, 32)
                abi_encode_uint8(value_0, add(headStart, 0))
            }
            function abi_decode_tuple_$uint8_2___$_$vec$vec$A2_U256_U256$$$(headStart, dataEnd) -> value_0 {
                if slt(sub(dataEnd, headStart), 32) { $Abort(96) }
                {
                    let offset := calldataload(add(headStart, 0))
                    if gt(offset, 0xffffffffffffffff) { $Abort(96) }
                    value_0 := abi_decode_uint8_2____vec$vec$A2_U256_U256$$(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_uint8_2____vec$vec$A2_U256_U256$$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := calldataload(offset)
                let size := add(mul(32, length), 32)
                array := abi_decode_available_length__uint8_2____vec$vec$A2_U256_U256$$(add(offset, 0x20), length, size, end)
            }
            function abi_decode_available_length__uint8_2____vec$vec$A2_U256_U256$$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 64))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 64) }
                {
                    let elementPos := src
                    let value := abi_decode_uint8_2__vec$A2_U256_U256$(elementPos, end)
                    $MemoryStoreU256(dst, value)
                    dst := add(dst, 32)
                }
            }
            function abi_decode_uint8_2__vec$A2_U256_U256$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := 2
                let size := 96
                array := abi_decode_available_length__uint8_2__vec$A2_U256_U256$(offset, length, size, end)
            }
            function abi_decode_available_length__uint8_2__vec$A2_U256_U256$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 32))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 32) }
                {
                    let elementPos := src
                    let value := abi_decode_uint8(elementPos, end)
                    $MemoryStoreU256(dst, value)
                    dst := add(dst, 32)
                }
            }
            function abi_encode_tuple_$uint72$_$u128$(headStart ,value_0) -> tail {
                tail := add(headStart, 32)
                abi_encode_uint72(value_0, add(headStart, 0))
            }
            function abi_encode_uint72(value, pos) {
                mstore(pos, cleanup_uint72(value))
            }
            function cleanup_uint72(value) -> cleaned {
                cleaned := and(value, 0xffffffffffffffffff)
            }
            function abi_decode_tuple_$uint72___2_$_$vec$vec$u128$$$(headStart, dataEnd) -> value_0 {
                if slt(sub(dataEnd, headStart), 32) { $Abort(96) }
                {
                    let offset := calldataload(add(headStart, 0))
                    if gt(offset, 0xffffffffffffffff) { $Abort(96) }
                    value_0 := abi_decode_uint72___2__vec$vec$u128$$(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_uint72___2__vec$vec$u128$$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := 2
                let size := 96
                array := abi_decode_available_length__uint72___2__vec$vec$u128$$(offset, length, size, end)
            }
            function abi_decode_available_length__uint72___2__vec$vec$u128$$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 32))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 32) }
                {
                    let innerOffset := calldataload(src)
                    if gt(innerOffset, 0xffffffffffffffff) { $Abort(94) }
                    let elementPos := add(offset, innerOffset)
                    let value := abi_decode_uint72___vec$u128$(elementPos, end)
                    $MemoryStoreU256(dst, value)
                    dst := add(dst, 32)
                }
            }
            function abi_decode_uint72___vec$u128$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := calldataload(offset)
                let size := add(mul(16, length), 32)
                array := abi_decode_available_length__uint72___vec$u128$(add(offset, 0x20), length, size, end)
            }
            function abi_decode_available_length__uint72___vec$u128$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 32))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 32) }
                {
                    let elementPos := src
                    let value := abi_decode_uint72(elementPos, end)
                    $MemoryStoreU128(dst, value)
                    dst := add(dst, 16)
                }
            }
            function abi_decode_uint72(offset, end) -> value {
                value := calldataload(offset)
                validator_uint72(value)
            }
            function validator_uint72(value) {
                if iszero(eq(value, cleanup_uint72(value))) { $Abort(95) }
            }
            function abi_encode_tuple_$uint16$_$u64$(headStart ,value_0) -> tail {
                tail := add(headStart, 32)
                abi_encode_uint16(value_0, add(headStart, 0))
            }
            function abi_encode_uint16(value, pos) {
                mstore(pos, cleanup_uint16(value))
            }
            function cleanup_uint16(value) -> cleaned {
                cleaned := and(value, 0xffff)
            }
            function abi_decode_tuple_$uint16_2___$_$vec$vec$u64$$$(headStart, dataEnd) -> value_0 {
                if slt(sub(dataEnd, headStart), 32) { $Abort(96) }
                {
                    let offset := calldataload(add(headStart, 0))
                    if gt(offset, 0xffffffffffffffff) { $Abort(96) }
                    value_0 := abi_decode_uint16_2____vec$vec$u64$$(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_uint16_2____vec$vec$u64$$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := calldataload(offset)
                let size := add(mul(32, length), 32)
                array := abi_decode_available_length__uint16_2____vec$vec$u64$$(add(offset, 0x20), length, size, end)
            }
            function abi_decode_available_length__uint16_2____vec$vec$u64$$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 64))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 64) }
                {
                    let elementPos := src
                    let value := abi_decode_uint16_2__vec$u64$(elementPos, end)
                    $MemoryStoreU256(dst, value)
                    dst := add(dst, 32)
                }
            }
            function abi_decode_uint16_2__vec$u64$(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
                let length := 2
                let size := 48
                array := abi_decode_available_length__uint16_2__vec$u64$(offset, length, size, end)
            }
            function abi_decode_available_length__uint16_2__vec$u64$(offset, length, size, end) -> array {
                array := $Malloc($CheckMemorySize(size))
                $MemoryStoreU64(array, length)
                $MemoryStoreU64(add(array, 8), $ClosestGreaterPowerOfTwo(length))
                let dst := add(array, 32)
                let srcEnd := add(offset, mul(length, 32))
                if gt(srcEnd, end) { $Abort(94) }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 32) }
                {
                    let elementPos := src
                    let value := abi_decode_uint16(elementPos, end)
                    $MemoryStoreU64(dst, value)
                    dst := add(dst, 8)
                }
            }
            function abi_decode_uint16(offset, end) -> value {
                value := calldataload(offset)
                validator_uint16(value)
            }
            function validator_uint16(value) {
                if iszero(eq(value, cleanup_uint16(value))) { $Abort(95) }
            }
            function abi_decode_tuple_$uint8_2_$_$vec$u8$$(headStart, dataEnd) -> value_0 {
                if slt(sub(dataEnd, headStart), 64) { $Abort(96) }
                {
                    let offset := 0
                    value_0 := abi_decode_uint8_2__vec$u8$(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_tuple_$uint64_2_$_$vec$u64$$(headStart, dataEnd) -> value_0 {
                if slt(sub(dataEnd, headStart), 64) { $Abort(96) }
                {
                    let offset := 0
                    value_0 := abi_decode_uint64_2__vec$u64$(add(headStart, offset), dataEnd)
                }
            }
            function $Abort(code) {
                mstore(0, code)
                revert(24, 8) // TODO: store code as a string?
            }
            function $AbortBuiltin() {
                $Abort(sub(0, 1))
            }
            function $Malloc(size) -> offs {
                offs := mload(0)
                // pad to word size
                mstore(0, add(offs, shl(5, shr(5, add(size, 31)))))
            }
            function $Free(offs, size) {
            }
            function $MakePtr(is_storage, offs) -> ptr {
              ptr := or(is_storage, shl(1, offs))
            }
            function $IsStoragePtr(ptr) -> b {
              b := and(ptr, 0x1)
            }
            function $OffsetPtr(ptr) -> offs {
              offs := shr(1, ptr)
            }
            function $MaskForSize(size) -> mask {
              mask := sub(shl(shl(3, size), 1), 1)
            }
            function $ExtractBytes(word, start, size) -> bytes {
               switch size
               case 1 {
                  // use the faster byte primitive
                  bytes := byte(start, word)
               }
               default {
                  // As we have big endian, we need to right shift the value from
                  // where the highest byte starts in the word (32 - start), minus
                  // the size.
                  let shift_bits := shl(3, sub(sub(32, start), size))
                  bytes := and(shr(shift_bits, word), $MaskForSize(size))
               }
            }
            function $ToWordOffs(offs) -> word_offs, byte_offset {
              word_offs := shr(5, offs)
              byte_offset := and(offs, 0x1F)
            }
            function $OverflowBytes(byte_offset, size) -> overflow_bytes {
              let available_bytes := sub(32, byte_offset)
              switch gt(size, available_bytes)
              case 0 {
                overflow_bytes := 0
              }
              default {
                overflow_bytes := sub(size, available_bytes)
              }
            }
            function $MemoryLoadBytes(offs, size) -> val {
              // Lower bit where the value in the higher bytes ends
              let bit_end := shl(3, sub(32, size))
              val := shr(bit_end, mload(offs))
            }
            function $MemoryStoreBytes(offs, size, val) {
              let bit_end := shl(3, sub(32, size))
              let mask := shl(bit_end, $MaskForSize(size))
              mstore(offs, or(and(mload(offs), not(mask)), shl(bit_end, val)))
            }
            function $StorageLoadBytes(offs, size) -> val {
              let word_offs, byte_offs := $ToWordOffs(offs)
              let key := $StorageKey(0, word_offs)
              val := $ExtractBytes(sload(key), byte_offs, size)
              let overflow_bytes := $OverflowBytes(byte_offs, size)
              if $LogicalNot(iszero(overflow_bytes)) {
                key := $StorageKey(0, add(word_offs, 1))
                let extra_bytes := $ExtractBytes(sload(key), 0, overflow_bytes)
                val := or(shl(shl(3, overflow_bytes), val), extra_bytes)
              }
            }
            function $StorageKey(group, word) -> key {
              mstore(32, word)
              mstore(64, shl(224, group))
              key := keccak256(32, 36)
            }
            function $IndexPtr(ptr, offs) -> new_ptr {
              new_ptr := $MakePtr($IsStoragePtr(ptr), add($OffsetPtr(ptr), offs))
            }
            function $LoadU8(ptr) -> val {
              let offs := $OffsetPtr(ptr)
              switch $IsStoragePtr(ptr)
              case 0 {
                val := $MemoryLoadU8(offs)
              }
              default {
                val := $StorageLoadU8(offs)
              }
            }
            function $MemoryLoadU8(offs) -> val {
              val := $MemoryLoadBytes(offs, 1)
            }
            function $StorageLoadU8(offs) -> val {
              val := $StorageLoadBytes(offs, 1)
            }
            function $MemoryStoreU8(offs, val) {
              // Shortcut via special instruction
              mstore8(offs, val)
            }
            function $LoadU64(ptr) -> val {
              let offs := $OffsetPtr(ptr)
              switch $IsStoragePtr(ptr)
              case 0 {
                val := $MemoryLoadU64(offs)
              }
              default {
                val := $StorageLoadU64(offs)
              }
            }
            function $MemoryLoadU64(offs) -> val {
              val := $MemoryLoadBytes(offs, 8)
            }
            function $StorageLoadU64(offs) -> val {
              val := $StorageLoadBytes(offs, 8)
            }
            function $MemoryStoreU64(offs, val) {
              $MemoryStoreBytes(offs, 8, val)
            }
            function $LoadU128(ptr) -> val {
              let offs := $OffsetPtr(ptr)
              switch $IsStoragePtr(ptr)
              case 0 {
                val := $MemoryLoadU128(offs)
              }
              default {
                val := $StorageLoadU128(offs)
              }
            }
            function $MemoryLoadU128(offs) -> val {
              val := $MemoryLoadBytes(offs, 16)
            }
            function $StorageLoadU128(offs) -> val {
              val := $StorageLoadBytes(offs, 16)
            }
            function $MemoryStoreU128(offs, val) {
              $MemoryStoreBytes(offs, 16, val)
            }
            function $LoadU256(ptr) -> val {
              let offs := $OffsetPtr(ptr)
              switch $IsStoragePtr(ptr)
              case 0 {
                val := $MemoryLoadU256(offs)
              }
              default {
                val := $StorageLoadU256(offs)
              }
            }
            function $MemoryLoadU256(offs) -> val {
              val := $MemoryLoadBytes(offs, 32)
            }
            function $StorageLoadU256(offs) -> val {
              val := $StorageLoadBytes(offs, 32)
            }
            function $MemoryStoreU256(offs, val) {
              $MemoryStoreBytes(offs, 32, val)
            }
            function $CheckMemorySize(len) -> checked_len {
                if gt(len, 0xffffffffffffffff) { $AbortBuiltin() }
                checked_len := len
            }
            function $AddU64(x, y) -> r {
                if lt(sub(0xffffffffffffffff, x), y) { $AbortBuiltin() }
                r := add(x, y)
            }
            function $AddU8(x, y) -> r {
                if lt(sub(0xff, x), y) { $AbortBuiltin() }
                r := add(x, y)
            }
            function $AddU128(x, y) -> r {
                if lt(sub(0xffffffffffffffffffffffffffffffff, x), y) { $AbortBuiltin() }
                r := add(x, y)
            }
            function $AddU256(x, y) -> r {
                if lt(sub(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, x), y) { $AbortBuiltin() }
                r := add(x, y)
            }
            function $Sub(x, y) -> r {
                if lt(x, y) { $AbortBuiltin() }
                r := sub(x, y)
            }
            function $Shr(x, y) -> r {
                r := shr(y, x)
            }
            function $Lt(x, y) -> r {
                r := lt(x, y)
            }
            function $GtEq(x, y) -> r {
                r := or(gt(x, y), eq(x, y))
            }
            function $LogicalNot(x) -> r {
                r := iszero(x)
            }
            function $ClosestGreaterPowerOfTwo(x) -> r {
                r := or(r, shr(1, x))
                r := or(r, shr(2, r))
                r := or(r, shr(4, r))
                r := or(r, shr(8, r))
                r := or(r, shr(16, r))
                r := or(r, shr(32, r))
                r := add(x, 1)
            }
        }
    }
}


!! Succeeded compiling Yul
