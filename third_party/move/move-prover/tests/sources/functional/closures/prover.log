[INFO move_compiler_v2] Move Compiler v2
[INFO move_compiler_v2] type checking
[DEBUG move_compiler_v2::env_pipeline::spec_checker] checking specifications
[DEBUG move_compiler_v2::env_pipeline::spec_rewriter] rewriting specifications
[DEBUG move_compiler_v2] Stackless bytecode Generation
[DEBUG move_stackless_bytecode::function_target_pipeline] transforming bytecode
[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step0_stackless:
============ after processor `stackless` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
  3: $t1 := infer($t2)                        # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: u64
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
  6: $t9 := infer($t6)                        # at closure_in_code_spec_expr.move:15:13+1
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
  8: if ($t8) goto 9 else goto 27             # at closure_in_code_spec_expr.move:9:9+384
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
 10: $t12 := infer($t0)                       # at closure_in_code_spec_expr.move:17:34+1
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
 12: $t10 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
 13: if ($t10) goto 14 else goto 20           # at closure_in_code_spec_expr.move:17:13+128
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
 15: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
 16: $t4 := infer($t13)                       # at closure_in_code_spec_expr.move:18:17+11
 17: $t5 := infer($t6)                        # at closure_in_code_spec_expr.move:19:17+15
 18: goto 31                                  # at closure_in_code_spec_expr.move:20:17+5
 19: goto 21                                  # at closure_in_code_spec_expr.move:17:42+99
 20: label L6                                 # at closure_in_code_spec_expr.move:17:13+128
 21: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
 22: $t15 := infer($t6)                       # at closure_in_code_spec_expr.move:22:17+1
 23: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 24: $t14 := +($t15, $t16)                    # at closure_in_code_spec_expr.move:22:17+5
 25: $t6 := infer($t14)                       # at closure_in_code_spec_expr.move:22:13+9
 26: goto 29                                  # at closure_in_code_spec_expr.move:16:12+176
 27: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
 28: goto 31                                  # at closure_in_code_spec_expr.move:9:9+384
 29: label L4                                 # at closure_in_code_spec_expr.move:9:9+384
 30: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
 31: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
 32: $t2 := infer($t4)                        # at closure_in_code_spec_expr.move:24:10+4
 33: $t3 := infer($t5)                        # at closure_in_code_spec_expr.move:24:16+11
 34: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool
     var $t1: vector<u64>
     var $t2: u64
     var $t3: u64
     var $t4: u64
     var $t5: bool
     var $t6: u64
     var $t7: &vector<u64>
     var $t8: |&u64|bool has copy + drop
  0: $t2 := 1                                 # at closure_in_code_spec_expr.move:37:24+1
  1: $t3 := 2                                 # at closure_in_code_spec_expr.move:37:27+1
  2: $t4 := 3                                 # at closure_in_code_spec_expr.move:37:30+1
  3: $t1 := vector($t2, $t3, $t4)             # at closure_in_code_spec_expr.move:37:17+6
  4: $t7 := borrow_local($t1)                 # at closure_in_code_spec_expr.move:38:34+2
  5: $t8 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  6: ($t5, $t6) := test::find<u64>($t7, $t8)  # at closure_in_code_spec_expr.move:38:29+14
  7: $t0 := infer($t5)                        # at closure_in_code_spec_expr.move:39:9+5
  8: return $t0                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step1_SplitCriticalEdgesProcessor:
============ after processor `SplitCriticalEdgesProcessor` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
  3: $t1 := infer($t2)                        # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: u64
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
  6: $t9 := infer($t6)                        # at closure_in_code_spec_expr.move:15:13+1
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
  8: if ($t8) goto 9 else goto 27             # at closure_in_code_spec_expr.move:9:9+384
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
 10: $t12 := infer($t0)                       # at closure_in_code_spec_expr.move:17:34+1
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
 12: $t10 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
 13: if ($t10) goto 14 else goto 20           # at closure_in_code_spec_expr.move:17:13+128
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
 15: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
 16: $t4 := infer($t13)                       # at closure_in_code_spec_expr.move:18:17+11
 17: $t5 := infer($t6)                        # at closure_in_code_spec_expr.move:19:17+15
 18: goto 31                                  # at closure_in_code_spec_expr.move:20:17+5
 19: goto 21                                  # at closure_in_code_spec_expr.move:17:42+99
 20: label L6                                 # at closure_in_code_spec_expr.move:17:13+128
 21: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
 22: $t15 := infer($t6)                       # at closure_in_code_spec_expr.move:22:17+1
 23: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 24: $t14 := +($t15, $t16)                    # at closure_in_code_spec_expr.move:22:17+5
 25: $t6 := infer($t14)                       # at closure_in_code_spec_expr.move:22:13+9
 26: goto 29                                  # at closure_in_code_spec_expr.move:16:12+176
 27: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
 28: goto 31                                  # at closure_in_code_spec_expr.move:9:9+384
 29: label L4                                 # at closure_in_code_spec_expr.move:9:9+384
 30: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
 31: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
 32: $t2 := infer($t4)                        # at closure_in_code_spec_expr.move:24:10+4
 33: $t3 := infer($t5)                        # at closure_in_code_spec_expr.move:24:16+11
 34: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool
     var $t1: vector<u64>
     var $t2: u64
     var $t3: u64
     var $t4: u64
     var $t5: bool
     var $t6: u64
     var $t7: &vector<u64>
     var $t8: |&u64|bool has copy + drop
  0: $t2 := 1                                 # at closure_in_code_spec_expr.move:37:24+1
  1: $t3 := 2                                 # at closure_in_code_spec_expr.move:37:27+1
  2: $t4 := 3                                 # at closure_in_code_spec_expr.move:37:30+1
  3: $t1 := vector($t2, $t3, $t4)             # at closure_in_code_spec_expr.move:37:17+6
  4: $t7 := borrow_local($t1)                 # at closure_in_code_spec_expr.move:38:34+2
  5: $t8 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  6: ($t5, $t6) := test::find<u64>($t7, $t8)  # at closure_in_code_spec_expr.move:38:29+14
  7: $t0 := infer($t5)                        # at closure_in_code_spec_expr.move:39:9+5
  8: return $t0                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step2_uninitialized_use_checker:
============ after processor `uninitialized_use_checker` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
  3: $t1 := infer($t2)                        # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: u64
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
  6: $t9 := infer($t6)                        # at closure_in_code_spec_expr.move:15:13+1
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
  8: if ($t8) goto 9 else goto 27             # at closure_in_code_spec_expr.move:9:9+384
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
 10: $t12 := infer($t0)                       # at closure_in_code_spec_expr.move:17:34+1
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
 12: $t10 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
 13: if ($t10) goto 14 else goto 20           # at closure_in_code_spec_expr.move:17:13+128
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
 15: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
 16: $t4 := infer($t13)                       # at closure_in_code_spec_expr.move:18:17+11
 17: $t5 := infer($t6)                        # at closure_in_code_spec_expr.move:19:17+15
 18: goto 31                                  # at closure_in_code_spec_expr.move:20:17+5
 19: goto 21                                  # at closure_in_code_spec_expr.move:17:42+99
 20: label L6                                 # at closure_in_code_spec_expr.move:17:13+128
 21: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
 22: $t15 := infer($t6)                       # at closure_in_code_spec_expr.move:22:17+1
 23: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 24: $t14 := +($t15, $t16)                    # at closure_in_code_spec_expr.move:22:17+5
 25: $t6 := infer($t14)                       # at closure_in_code_spec_expr.move:22:13+9
 26: goto 29                                  # at closure_in_code_spec_expr.move:16:12+176
 27: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
 28: goto 31                                  # at closure_in_code_spec_expr.move:9:9+384
 29: label L4                                 # at closure_in_code_spec_expr.move:9:9+384
 30: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
 31: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
 32: $t2 := infer($t4)                        # at closure_in_code_spec_expr.move:24:10+4
 33: $t3 := infer($t5)                        # at closure_in_code_spec_expr.move:24:16+11
 34: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool
     var $t1: vector<u64>
     var $t2: u64
     var $t3: u64
     var $t4: u64
     var $t5: bool
     var $t6: u64
     var $t7: &vector<u64>
     var $t8: |&u64|bool has copy + drop
  0: $t2 := 1                                 # at closure_in_code_spec_expr.move:37:24+1
  1: $t3 := 2                                 # at closure_in_code_spec_expr.move:37:27+1
  2: $t4 := 3                                 # at closure_in_code_spec_expr.move:37:30+1
  3: $t1 := vector($t2, $t3, $t4)             # at closure_in_code_spec_expr.move:37:17+6
  4: $t7 := borrow_local($t1)                 # at closure_in_code_spec_expr.move:38:34+2
  5: $t8 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  6: ($t5, $t6) := test::find<u64>($t7, $t8)  # at closure_in_code_spec_expr.move:38:29+14
  7: $t0 := infer($t5)                        # at closure_in_code_spec_expr.move:39:9+5
  8: return $t0                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step3_LiveVarAnalysisProcessor:
============ after processor `LiveVarAnalysisProcessor` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
     # live vars: $t0
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
     # live vars: $t0, $t2
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
     # live vars: $t0, $t2, $t3
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
     # live vars: $t2
  3: $t1 := infer($t2)                        # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
     # live vars: $t1
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: u64
     # live vars: $t0, $t1
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
     # live vars: $t0, $t1, $t4
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
     # live vars: $t0, $t1, $t4, $t5
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
     # live vars: $t0, $t1, $t4, $t5, $t6
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  6: $t9 := infer($t6)                        # at closure_in_code_spec_expr.move:15:13+1
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t9
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t8
  8: if ($t8) goto 9 else goto 27             # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 10: $t12 := infer($t0)                       # at closure_in_code_spec_expr.move:17:34+1
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t12
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t11
 12: $t10 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t10
 13: if ($t10) goto 14 else goto 20           # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
     # live vars: $t6
 15: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
     # live vars: $t6, $t13
 16: $t4 := infer($t13)                       # at closure_in_code_spec_expr.move:18:17+11
     # live vars: $t4, $t6
 17: $t5 := infer($t6)                        # at closure_in_code_spec_expr.move:19:17+15
     # live vars: $t4, $t5
 18: goto 31                                  # at closure_in_code_spec_expr.move:20:17+5
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 19: goto 21                                  # at closure_in_code_spec_expr.move:17:42+99
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 20: label L6                                 # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 21: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 22: $t15 := infer($t6)                       # at closure_in_code_spec_expr.move:22:17+1
     # live vars: $t0, $t1, $t4, $t5, $t7, $t15
 23: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
     # live vars: $t0, $t1, $t4, $t5, $t7, $t15, $t16
 24: $t14 := +($t15, $t16)                    # at closure_in_code_spec_expr.move:22:17+5
     # live vars: $t0, $t1, $t4, $t5, $t7, $t14
 25: $t6 := infer($t14)                       # at closure_in_code_spec_expr.move:22:13+9
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 26: goto 29                                  # at closure_in_code_spec_expr.move:16:12+176
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 27: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
 28: goto 31                                  # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 29: label L4                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 30: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
 31: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
 32: $t2 := infer($t4)                        # at closure_in_code_spec_expr.move:24:10+4
     # live vars: $t2, $t5
 33: $t3 := infer($t5)                        # at closure_in_code_spec_expr.move:24:16+11
     # live vars: $t2, $t3
 34: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool
     var $t1: vector<u64>
     var $t2: u64
     var $t3: u64
     var $t4: u64
     var $t5: bool
     var $t6: u64
     var $t7: &vector<u64>
     var $t8: |&u64|bool has copy + drop
     # live vars:
  0: $t2 := 1                                 # at closure_in_code_spec_expr.move:37:24+1
     # live vars: $t2
  1: $t3 := 2                                 # at closure_in_code_spec_expr.move:37:27+1
     # live vars: $t2, $t3
  2: $t4 := 3                                 # at closure_in_code_spec_expr.move:37:30+1
     # live vars: $t2, $t3, $t4
  3: $t1 := vector($t2, $t3, $t4)             # at closure_in_code_spec_expr.move:37:17+6
     # live vars: $t1
  4: $t7 := borrow_local($t1)                 # at closure_in_code_spec_expr.move:38:34+2
     # live vars: $t7
  5: $t8 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
     # live vars: $t7, $t8
  6: ($t5, $t6) := test::find<u64>($t7, $t8)  # at closure_in_code_spec_expr.move:38:29+14
     # live vars: $t5
  7: $t0 := infer($t5)                        # at closure_in_code_spec_expr.move:39:9+5
     # live vars: $t0
  8: return $t0                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
     # live vars: $t2
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
     # live vars: $t2, $t3
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
     # live vars: $t1
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step4_UnusedAssignmentChecker:
============ after processor `UnusedAssignmentChecker` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
     # live vars: $t0
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
     # live vars: $t0, $t2
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
     # live vars: $t0, $t2, $t3
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
     # live vars: $t2
  3: $t1 := infer($t2)                        # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
     # live vars: $t1
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: u64
     # live vars: $t0, $t1
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
     # live vars: $t0, $t1, $t4
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
     # live vars: $t0, $t1, $t4, $t5
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
     # live vars: $t0, $t1, $t4, $t5, $t6
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  6: $t9 := infer($t6)                        # at closure_in_code_spec_expr.move:15:13+1
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t9
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t8
  8: if ($t8) goto 9 else goto 27             # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 10: $t12 := infer($t0)                       # at closure_in_code_spec_expr.move:17:34+1
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t12
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t11
 12: $t10 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t10
 13: if ($t10) goto 14 else goto 20           # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
     # live vars: $t6
 15: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
     # live vars: $t6, $t13
 16: $t4 := infer($t13)                       # at closure_in_code_spec_expr.move:18:17+11
     # live vars: $t4, $t6
 17: $t5 := infer($t6)                        # at closure_in_code_spec_expr.move:19:17+15
     # live vars: $t4, $t5
 18: goto 31                                  # at closure_in_code_spec_expr.move:20:17+5
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 19: goto 21                                  # at closure_in_code_spec_expr.move:17:42+99
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 20: label L6                                 # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 21: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 22: $t15 := infer($t6)                       # at closure_in_code_spec_expr.move:22:17+1
     # live vars: $t0, $t1, $t4, $t5, $t7, $t15
 23: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
     # live vars: $t0, $t1, $t4, $t5, $t7, $t15, $t16
 24: $t14 := +($t15, $t16)                    # at closure_in_code_spec_expr.move:22:17+5
     # live vars: $t0, $t1, $t4, $t5, $t7, $t14
 25: $t6 := infer($t14)                       # at closure_in_code_spec_expr.move:22:13+9
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 26: goto 29                                  # at closure_in_code_spec_expr.move:16:12+176
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 27: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
 28: goto 31                                  # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 29: label L4                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 30: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
 31: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
 32: $t2 := infer($t4)                        # at closure_in_code_spec_expr.move:24:10+4
     # live vars: $t2, $t5
 33: $t3 := infer($t5)                        # at closure_in_code_spec_expr.move:24:16+11
     # live vars: $t2, $t3
 34: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool
     var $t1: vector<u64>
     var $t2: u64
     var $t3: u64
     var $t4: u64
     var $t5: bool
     var $t6: u64
     var $t7: &vector<u64>
     var $t8: |&u64|bool has copy + drop
     # live vars:
  0: $t2 := 1                                 # at closure_in_code_spec_expr.move:37:24+1
     # live vars: $t2
  1: $t3 := 2                                 # at closure_in_code_spec_expr.move:37:27+1
     # live vars: $t2, $t3
  2: $t4 := 3                                 # at closure_in_code_spec_expr.move:37:30+1
     # live vars: $t2, $t3, $t4
  3: $t1 := vector($t2, $t3, $t4)             # at closure_in_code_spec_expr.move:37:17+6
     # live vars: $t1
  4: $t7 := borrow_local($t1)                 # at closure_in_code_spec_expr.move:38:34+2
     # live vars: $t7
  5: $t8 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
     # live vars: $t7, $t8
  6: ($t5, $t6) := test::find<u64>($t7, $t8)  # at closure_in_code_spec_expr.move:38:29+14
     # live vars: $t5
  7: $t0 := infer($t5)                        # at closure_in_code_spec_expr.move:39:9+5
     # live vars: $t0
  8: return $t0                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
     # live vars: $t2
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
     # live vars: $t2, $t3
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
     # live vars: $t1
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step5_LiveVarAnalysisProcessor:
============ after processor `LiveVarAnalysisProcessor` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
     # live vars: $t0
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
     # live vars: $t0, $t2
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
     # live vars: $t0, $t2, $t3
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
     # live vars: $t2
  3: $t1 := infer($t2)                        # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
     # live vars: $t1
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: u64
     # live vars: $t0, $t1
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
     # live vars: $t0, $t1, $t4
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
     # live vars: $t0, $t1, $t4, $t5
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
     # live vars: $t0, $t1, $t4, $t5, $t6
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  6: $t9 := infer($t6)                        # at closure_in_code_spec_expr.move:15:13+1
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t9
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t8
  8: if ($t8) goto 9 else goto 27             # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 10: $t12 := infer($t0)                       # at closure_in_code_spec_expr.move:17:34+1
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t12
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t11
 12: $t10 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t10
 13: if ($t10) goto 14 else goto 20           # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
     # live vars: $t6
 15: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
     # live vars: $t6, $t13
 16: $t4 := infer($t13)                       # at closure_in_code_spec_expr.move:18:17+11
     # live vars: $t4, $t6
 17: $t5 := infer($t6)                        # at closure_in_code_spec_expr.move:19:17+15
     # live vars: $t4, $t5
 18: goto 31                                  # at closure_in_code_spec_expr.move:20:17+5
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 19: goto 21                                  # at closure_in_code_spec_expr.move:17:42+99
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 20: label L6                                 # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 21: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 22: $t15 := infer($t6)                       # at closure_in_code_spec_expr.move:22:17+1
     # live vars: $t0, $t1, $t4, $t5, $t7, $t15
 23: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
     # live vars: $t0, $t1, $t4, $t5, $t7, $t15, $t16
 24: $t14 := +($t15, $t16)                    # at closure_in_code_spec_expr.move:22:17+5
     # live vars: $t0, $t1, $t4, $t5, $t7, $t14
 25: $t6 := infer($t14)                       # at closure_in_code_spec_expr.move:22:13+9
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 26: goto 29                                  # at closure_in_code_spec_expr.move:16:12+176
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 27: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
 28: goto 31                                  # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 29: label L4                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 30: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
 31: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
 32: $t2 := infer($t4)                        # at closure_in_code_spec_expr.move:24:10+4
     # live vars: $t2, $t5
 33: $t3 := infer($t5)                        # at closure_in_code_spec_expr.move:24:16+11
     # live vars: $t2, $t3
 34: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool
     var $t1: vector<u64>
     var $t2: u64
     var $t3: u64
     var $t4: u64
     var $t5: bool
     var $t6: u64
     var $t7: &vector<u64>
     var $t8: |&u64|bool has copy + drop
     # live vars:
  0: $t2 := 1                                 # at closure_in_code_spec_expr.move:37:24+1
     # live vars: $t2
  1: $t3 := 2                                 # at closure_in_code_spec_expr.move:37:27+1
     # live vars: $t2, $t3
  2: $t4 := 3                                 # at closure_in_code_spec_expr.move:37:30+1
     # live vars: $t2, $t3, $t4
  3: $t1 := vector($t2, $t3, $t4)             # at closure_in_code_spec_expr.move:37:17+6
     # live vars: $t1
  4: $t7 := borrow_local($t1)                 # at closure_in_code_spec_expr.move:38:34+2
     # live vars: $t7
  5: $t8 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
     # live vars: $t7, $t8
  6: ($t5, $t6) := test::find<u64>($t7, $t8)  # at closure_in_code_spec_expr.move:38:29+14
     # live vars: $t5
  7: $t0 := infer($t5)                        # at closure_in_code_spec_expr.move:39:9+5
     # live vars: $t0
  8: return $t0                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
     # live vars: $t2
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
     # live vars: $t2, $t3
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
     # live vars: $t1
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step6_ReferenceSafetyProcessor:
============ after processor `ReferenceSafetyProcessor` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
     # live vars: $t0
     # refs: []
     #
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
     # live vars: $t0, $t2
     # refs: []
     #
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
     # live vars: $t0, $t2, $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => (mut) #3 via [local `v`] at line 56
     #
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
     # live vars: $t2
     # refs: []
     #
  3: $t1 := infer($t2)                        # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
     # live vars: $t1
     # refs: []
     #
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: u64
     # live vars: $t0, $t1
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
     # live vars: $t0, $t1, $t4
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
     # live vars: $t0, $t1, $t4, $t5
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
     # live vars: $t0, $t1, $t4, $t5, $t6
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  6: $t9 := infer($t6)                        # at closure_in_code_spec_expr.move:15:13+1
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t9
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t8
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  8: if ($t8) goto 9 else goto 27             # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 10: $t12 := infer($t0)                       # at closure_in_code_spec_expr.move:17:34+1
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t12
     # refs: [$t0 => #0, $t12 => #12]
     # #0
     #   => #12 via [] at line 17
     # #12
     #   <no edges>
     # #root
     #   <no edges>
     #
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t11
     # refs: [$t0 => #0, $t11 => #11]
     # #0
     #   -> #11 via [] at line 17
     # #11
     #   <no edges>
     # #root
     #   <no edges>
     #
 12: $t10 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t10
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 13: if ($t10) goto 14 else goto 20           # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
     # live vars: $t6
     # refs: []
     #
 15: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
     # live vars: $t6, $t13
     # refs: []
     #
 16: $t4 := infer($t13)                       # at closure_in_code_spec_expr.move:18:17+11
     # live vars: $t4, $t6
     # refs: []
     #
 17: $t5 := infer($t6)                        # at closure_in_code_spec_expr.move:19:17+15
     # live vars: $t4, $t5
     # refs: []
     #
 18: goto 31                                  # at closure_in_code_spec_expr.move:20:17+5
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 19: goto 21                                  # at closure_in_code_spec_expr.move:17:42+99
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 20: label L6                                 # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 21: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 22: $t15 := infer($t6)                       # at closure_in_code_spec_expr.move:22:17+1
     # live vars: $t0, $t1, $t4, $t5, $t7, $t15
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 23: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
     # live vars: $t0, $t1, $t4, $t5, $t7, $t15, $t16
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 24: $t14 := +($t15, $t16)                    # at closure_in_code_spec_expr.move:22:17+5
     # live vars: $t0, $t1, $t4, $t5, $t7, $t14
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 25: $t6 := infer($t14)                       # at closure_in_code_spec_expr.move:22:13+9
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 26: goto 29                                  # at closure_in_code_spec_expr.move:16:12+176
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 27: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
     # refs: []
     #
 28: goto 31                                  # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 29: label L4                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 30: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
     # refs: []
     #
 31: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
     # refs: []
     #
 32: $t2 := infer($t4)                        # at closure_in_code_spec_expr.move:24:10+4
     # live vars: $t2, $t5
     # refs: []
     #
 33: $t3 := infer($t5)                        # at closure_in_code_spec_expr.move:24:16+11
     # live vars: $t2, $t3
     # refs: []
     #
 34: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool
     var $t1: vector<u64>
     var $t2: u64
     var $t3: u64
     var $t4: u64
     var $t5: bool
     var $t6: u64
     var $t7: &vector<u64>
     var $t8: |&u64|bool has copy + drop
     # live vars:
     # refs: []
     #
  0: $t2 := 1                                 # at closure_in_code_spec_expr.move:37:24+1
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 2                                 # at closure_in_code_spec_expr.move:37:27+1
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t4 := 3                                 # at closure_in_code_spec_expr.move:37:30+1
     # live vars: $t2, $t3, $t4
     # refs: []
     #
  3: $t1 := vector($t2, $t3, $t4)             # at closure_in_code_spec_expr.move:37:17+6
     # live vars: $t1
     # refs: []
     #
  4: $t7 := borrow_local($t1)                 # at closure_in_code_spec_expr.move:38:34+2
     # live vars: $t7
     # refs: [$t7 => #7]
     # #7
     #   <no edges>
     # #root
     #   => #7 via [local `s`] at line 38
     #
  5: $t8 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
     # live vars: $t7, $t8
     # refs: [$t7 => #7]
     # #7
     #   <no edges>
     # #root
     #   => #7 via [local `s`] at line 38
     #
  6: ($t5, $t6) := test::find<u64>($t7, $t8)  # at closure_in_code_spec_expr.move:38:29+14
     # live vars: $t5
     # refs: []
     #
  7: $t0 := infer($t5)                        # at closure_in_code_spec_expr.move:39:9+5
     # live vars: $t0
     # refs: []
     #
  8: return $t0                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
     # live vars: $t0
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
     # live vars: $t1
     # refs: []
     #
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step7_AbortAnalysisProcessor:
============ after processor `AbortAnalysisProcessor` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
     # abort state: {returns,aborts}
     # live vars: $t0, $t2
     # refs: []
     #
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
     # abort state: {returns,aborts}
     # live vars: $t0, $t2, $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => (mut) #3 via [local `v`] at line 56
     #
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  3: $t1 := infer($t2)                        # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: u64
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  6: $t9 := infer($t6)                        # at closure_in_code_spec_expr.move:15:13+1
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t9
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t8
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  8: if ($t8) goto 9 else goto 27             # at closure_in_code_spec_expr.move:9:9+384
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 10: $t12 := infer($t0)                       # at closure_in_code_spec_expr.move:17:34+1
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t12
     # refs: [$t0 => #0, $t12 => #12]
     # #0
     #   => #12 via [] at line 17
     # #12
     #   <no edges>
     # #root
     #   <no edges>
     #
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t11
     # refs: [$t0 => #0, $t11 => #11]
     # #0
     #   -> #11 via [] at line 17
     # #11
     #   <no edges>
     # #root
     #   <no edges>
     #
 12: $t10 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t10
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 13: if ($t10) goto 14 else goto 20           # at closure_in_code_spec_expr.move:17:13+128
     # abort state: {returns}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
     # abort state: {returns}
     # live vars: $t6
     # refs: []
     #
 15: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
     # abort state: {returns}
     # live vars: $t6, $t13
     # refs: []
     #
 16: $t4 := infer($t13)                       # at closure_in_code_spec_expr.move:18:17+11
     # abort state: {returns}
     # live vars: $t4, $t6
     # refs: []
     #
 17: $t5 := infer($t6)                        # at closure_in_code_spec_expr.move:19:17+15
     # abort state: {returns}
     # live vars: $t4, $t5
     # refs: []
     #
 18: goto 31                                  # at closure_in_code_spec_expr.move:20:17+5
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 19: goto 21                                  # at closure_in_code_spec_expr.move:17:42+99
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 20: label L6                                 # at closure_in_code_spec_expr.move:17:13+128
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 21: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 22: $t15 := infer($t6)                       # at closure_in_code_spec_expr.move:22:17+1
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t7, $t15
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 23: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t7, $t15, $t16
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 24: $t14 := +($t15, $t16)                    # at closure_in_code_spec_expr.move:22:17+5
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t7, $t14
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 25: $t6 := infer($t14)                       # at closure_in_code_spec_expr.move:22:13+9
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 26: goto 29                                  # at closure_in_code_spec_expr.move:16:12+176
     # abort state: {returns}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 27: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
     # abort state: {returns}
     # live vars: $t4, $t5
     # refs: []
     #
 28: goto 31                                  # at closure_in_code_spec_expr.move:9:9+384
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 29: label L4                                 # at closure_in_code_spec_expr.move:9:9+384
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 30: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
     # abort state: {returns}
     # live vars: $t4, $t5
     # refs: []
     #
 31: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
     # abort state: {returns}
     # live vars: $t4, $t5
     # refs: []
     #
 32: $t2 := infer($t4)                        # at closure_in_code_spec_expr.move:24:10+4
     # abort state: {returns}
     # live vars: $t2, $t5
     # refs: []
     #
 33: $t3 := infer($t5)                        # at closure_in_code_spec_expr.move:24:16+11
     # abort state: {returns}
     # live vars: $t2, $t3
     # refs: []
     #
 34: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool
     var $t1: vector<u64>
     var $t2: u64
     var $t3: u64
     var $t4: u64
     var $t5: bool
     var $t6: u64
     var $t7: &vector<u64>
     var $t8: |&u64|bool has copy + drop
     # abort state: {returns,aborts}
     # live vars:
     # refs: []
     #
  0: $t2 := 1                                 # at closure_in_code_spec_expr.move:37:24+1
     # abort state: {returns,aborts}
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 2                                 # at closure_in_code_spec_expr.move:37:27+1
     # abort state: {returns,aborts}
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t4 := 3                                 # at closure_in_code_spec_expr.move:37:30+1
     # abort state: {returns,aborts}
     # live vars: $t2, $t3, $t4
     # refs: []
     #
  3: $t1 := vector($t2, $t3, $t4)             # at closure_in_code_spec_expr.move:37:17+6
     # abort state: {returns,aborts}
     # live vars: $t1
     # refs: []
     #
  4: $t7 := borrow_local($t1)                 # at closure_in_code_spec_expr.move:38:34+2
     # abort state: {returns,aborts}
     # live vars: $t7
     # refs: [$t7 => #7]
     # #7
     #   <no edges>
     # #root
     #   => #7 via [local `s`] at line 38
     #
  5: $t8 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
     # abort state: {returns,aborts}
     # live vars: $t7, $t8
     # refs: [$t7 => #7]
     # #7
     #   <no edges>
     # #root
     #   => #7 via [local `s`] at line 38
     #
  6: ($t5, $t6) := test::find<u64>($t7, $t8)  # at closure_in_code_spec_expr.move:38:29+14
     # abort state: {returns}
     # live vars: $t5
     # refs: []
     #
  7: $t0 := infer($t5)                        # at closure_in_code_spec_expr.move:39:9+5
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  8: return $t0                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
     # abort state: {returns}
     # live vars: $t0
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
     # abort state: {returns}
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step8_AbilityProcessor:
============ after processor `AbilityProcessor` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
  3: $t1 := move($t2)                         # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: u64
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
  6: $t9 := copy($t6)                         # at closure_in_code_spec_expr.move:15:13+1
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
  8: if ($t8) goto 9 else goto 28             # at closure_in_code_spec_expr.move:9:9+384
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
 10: $t12 := copy($t0)                        # at closure_in_code_spec_expr.move:17:34+1
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
 12: $t10 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
 13: if ($t10) goto 14 else goto 21           # at closure_in_code_spec_expr.move:17:13+128
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
 15: drop($t0)                                # at closure_in_code_spec_expr.move:17:42+99
 16: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
 17: $t4 := move($t13)                        # at closure_in_code_spec_expr.move:18:17+11
 18: $t5 := move($t6)                         # at closure_in_code_spec_expr.move:19:17+15
 19: goto 33                                  # at closure_in_code_spec_expr.move:20:17+5
 20: goto 22                                  # at closure_in_code_spec_expr.move:17:42+99
 21: label L6                                 # at closure_in_code_spec_expr.move:17:13+128
 22: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
 23: $t15 := move($t6)                        # at closure_in_code_spec_expr.move:22:17+1
 24: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 25: $t14 := +($t15, $t16)                    # at closure_in_code_spec_expr.move:22:17+5
 26: $t6 := move($t14)                        # at closure_in_code_spec_expr.move:22:13+9
 27: goto 31                                  # at closure_in_code_spec_expr.move:16:12+176
 28: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
 29: drop($t0)                                # at closure_in_code_spec_expr.move:9:9+384
 30: goto 33                                  # at closure_in_code_spec_expr.move:9:9+384
 31: label L4                                 # at closure_in_code_spec_expr.move:9:9+384
 32: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
 33: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
 34: $t2 := move($t4)                         # at closure_in_code_spec_expr.move:24:10+4
 35: $t3 := move($t5)                         # at closure_in_code_spec_expr.move:24:16+11
 36: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool
     var $t1: vector<u64>
     var $t2: u64
     var $t3: u64
     var $t4: u64
     var $t5: bool
     var $t6: u64
     var $t7: &vector<u64>
     var $t8: |&u64|bool has copy + drop
  0: $t2 := 1                                 # at closure_in_code_spec_expr.move:37:24+1
  1: $t3 := 2                                 # at closure_in_code_spec_expr.move:37:27+1
  2: $t4 := 3                                 # at closure_in_code_spec_expr.move:37:30+1
  3: $t1 := vector($t2, $t3, $t4)             # at closure_in_code_spec_expr.move:37:17+6
  4: $t7 := borrow_local($t1)                 # at closure_in_code_spec_expr.move:38:34+2
  5: $t8 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  6: ($t5, $t6) := test::find<u64>($t7, $t8)  # at closure_in_code_spec_expr.move:38:29+14
  7: $t0 := move($t5)                         # at closure_in_code_spec_expr.move:39:9+5
  8: return $t0                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_compiler_v2] Stackless bytecode Generation
[DEBUG move_stackless_bytecode::function_target_pipeline] transforming bytecode
[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step0_stackless:
============ after processor `stackless` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
  3: $t1 := infer($t2)                        # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: u64
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
  6: $t9 := infer($t6)                        # at closure_in_code_spec_expr.move:15:13+1
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
  8: if ($t8) goto 9 else goto 27             # at closure_in_code_spec_expr.move:9:9+384
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
 10: $t12 := infer($t0)                       # at closure_in_code_spec_expr.move:17:34+1
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
 12: $t10 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
 13: if ($t10) goto 14 else goto 20           # at closure_in_code_spec_expr.move:17:13+128
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
 15: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
 16: $t4 := infer($t13)                       # at closure_in_code_spec_expr.move:18:17+11
 17: $t5 := infer($t6)                        # at closure_in_code_spec_expr.move:19:17+15
 18: goto 31                                  # at closure_in_code_spec_expr.move:20:17+5
 19: goto 21                                  # at closure_in_code_spec_expr.move:17:42+99
 20: label L6                                 # at closure_in_code_spec_expr.move:17:13+128
 21: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
 22: $t15 := infer($t6)                       # at closure_in_code_spec_expr.move:22:17+1
 23: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 24: $t14 := +($t15, $t16)                    # at closure_in_code_spec_expr.move:22:17+5
 25: $t6 := infer($t14)                       # at closure_in_code_spec_expr.move:22:13+9
 26: goto 29                                  # at closure_in_code_spec_expr.move:16:12+176
 27: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
 28: goto 31                                  # at closure_in_code_spec_expr.move:9:9+384
 29: label L4                                 # at closure_in_code_spec_expr.move:9:9+384
 30: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
 31: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
 32: $t2 := infer($t4)                        # at closure_in_code_spec_expr.move:24:10+4
 33: $t3 := infer($t5)                        # at closure_in_code_spec_expr.move:24:16+11
 34: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool
     var $t1: bool
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: vector<u64>
     var $t5: |&u64|bool has copy + drop
  0: $t4 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: $t3 := borrow_local($t4)                 # at closure_in_code_spec_expr.move:38:34+2
  2: $t5 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  3: ($t1, $t2) := test::find<u64>($t3, $t5)  # at closure_in_code_spec_expr.move:38:29+14
  4: $t0 := infer($t1)                        # at closure_in_code_spec_expr.move:39:9+5
  5: return $t0                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step1_SplitCriticalEdgesProcessor:
============ after processor `SplitCriticalEdgesProcessor` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
  3: $t1 := infer($t2)                        # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: u64
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
  6: $t9 := infer($t6)                        # at closure_in_code_spec_expr.move:15:13+1
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
  8: if ($t8) goto 9 else goto 27             # at closure_in_code_spec_expr.move:9:9+384
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
 10: $t12 := infer($t0)                       # at closure_in_code_spec_expr.move:17:34+1
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
 12: $t10 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
 13: if ($t10) goto 14 else goto 20           # at closure_in_code_spec_expr.move:17:13+128
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
 15: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
 16: $t4 := infer($t13)                       # at closure_in_code_spec_expr.move:18:17+11
 17: $t5 := infer($t6)                        # at closure_in_code_spec_expr.move:19:17+15
 18: goto 31                                  # at closure_in_code_spec_expr.move:20:17+5
 19: goto 21                                  # at closure_in_code_spec_expr.move:17:42+99
 20: label L6                                 # at closure_in_code_spec_expr.move:17:13+128
 21: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
 22: $t15 := infer($t6)                       # at closure_in_code_spec_expr.move:22:17+1
 23: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 24: $t14 := +($t15, $t16)                    # at closure_in_code_spec_expr.move:22:17+5
 25: $t6 := infer($t14)                       # at closure_in_code_spec_expr.move:22:13+9
 26: goto 29                                  # at closure_in_code_spec_expr.move:16:12+176
 27: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
 28: goto 31                                  # at closure_in_code_spec_expr.move:9:9+384
 29: label L4                                 # at closure_in_code_spec_expr.move:9:9+384
 30: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
 31: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
 32: $t2 := infer($t4)                        # at closure_in_code_spec_expr.move:24:10+4
 33: $t3 := infer($t5)                        # at closure_in_code_spec_expr.move:24:16+11
 34: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool
     var $t1: bool
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: vector<u64>
     var $t5: |&u64|bool has copy + drop
  0: $t4 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: $t3 := borrow_local($t4)                 # at closure_in_code_spec_expr.move:38:34+2
  2: $t5 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  3: ($t1, $t2) := test::find<u64>($t3, $t5)  # at closure_in_code_spec_expr.move:38:29+14
  4: $t0 := infer($t1)                        # at closure_in_code_spec_expr.move:39:9+5
  5: return $t0                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step2_LiveVarAnalysisProcessor:
============ after processor `LiveVarAnalysisProcessor` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
     # live vars: $t0
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
     # live vars: $t0, $t2
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
     # live vars: $t0, $t2, $t3
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
     # live vars: $t2
  3: $t1 := infer($t2)                        # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
     # live vars: $t1
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: u64
     # live vars: $t0, $t1
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
     # live vars: $t0, $t1, $t4
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
     # live vars: $t0, $t1, $t4, $t5
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
     # live vars: $t0, $t1, $t4, $t5, $t6
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  6: $t9 := infer($t6)                        # at closure_in_code_spec_expr.move:15:13+1
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t9
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t8
  8: if ($t8) goto 9 else goto 27             # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 10: $t12 := infer($t0)                       # at closure_in_code_spec_expr.move:17:34+1
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t12
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t11
 12: $t10 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t10
 13: if ($t10) goto 14 else goto 20           # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
     # live vars: $t6
 15: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
     # live vars: $t6, $t13
 16: $t4 := infer($t13)                       # at closure_in_code_spec_expr.move:18:17+11
     # live vars: $t4, $t6
 17: $t5 := infer($t6)                        # at closure_in_code_spec_expr.move:19:17+15
     # live vars: $t4, $t5
 18: goto 31                                  # at closure_in_code_spec_expr.move:20:17+5
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 19: goto 21                                  # at closure_in_code_spec_expr.move:17:42+99
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 20: label L6                                 # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 21: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 22: $t15 := infer($t6)                       # at closure_in_code_spec_expr.move:22:17+1
     # live vars: $t0, $t1, $t4, $t5, $t7, $t15
 23: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
     # live vars: $t0, $t1, $t4, $t5, $t7, $t15, $t16
 24: $t14 := +($t15, $t16)                    # at closure_in_code_spec_expr.move:22:17+5
     # live vars: $t0, $t1, $t4, $t5, $t7, $t14
 25: $t6 := infer($t14)                       # at closure_in_code_spec_expr.move:22:13+9
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 26: goto 29                                  # at closure_in_code_spec_expr.move:16:12+176
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 27: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
 28: goto 31                                  # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 29: label L4                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 30: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
 31: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
 32: $t2 := infer($t4)                        # at closure_in_code_spec_expr.move:24:10+4
     # live vars: $t2, $t5
 33: $t3 := infer($t5)                        # at closure_in_code_spec_expr.move:24:16+11
     # live vars: $t2, $t3
 34: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool
     var $t1: bool
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: vector<u64>
     var $t5: |&u64|bool has copy + drop
     # live vars:
  0: $t4 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
     # live vars: $t4
  1: $t3 := borrow_local($t4)                 # at closure_in_code_spec_expr.move:38:34+2
     # live vars: $t3
  2: $t5 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
     # live vars: $t3, $t5
  3: ($t1, $t2) := test::find<u64>($t3, $t5)  # at closure_in_code_spec_expr.move:38:29+14
     # live vars: $t1
  4: $t0 := infer($t1)                        # at closure_in_code_spec_expr.move:39:9+5
     # live vars: $t0
  5: return $t0                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
     # live vars: $t2
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
     # live vars: $t2, $t3
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
     # live vars: $t1
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step3_ReferenceSafetyProcessor:
============ after processor `ReferenceSafetyProcessor` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
     # live vars: $t0
     # refs: []
     #
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
     # live vars: $t0, $t2
     # refs: []
     #
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
     # live vars: $t0, $t2, $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => (mut) #3 via [local `v`] at line 56
     #
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
     # live vars: $t2
     # refs: []
     #
  3: $t1 := infer($t2)                        # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
     # live vars: $t1
     # refs: []
     #
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: u64
     # live vars: $t0, $t1
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
     # live vars: $t0, $t1, $t4
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
     # live vars: $t0, $t1, $t4, $t5
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
     # live vars: $t0, $t1, $t4, $t5, $t6
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  6: $t9 := infer($t6)                        # at closure_in_code_spec_expr.move:15:13+1
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t9
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t8
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  8: if ($t8) goto 9 else goto 27             # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 10: $t12 := infer($t0)                       # at closure_in_code_spec_expr.move:17:34+1
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t12
     # refs: [$t0 => #0, $t12 => #12]
     # #0
     #   => #12 via [] at line 17
     # #12
     #   <no edges>
     # #root
     #   <no edges>
     #
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t11
     # refs: [$t0 => #0, $t11 => #11]
     # #0
     #   -> #11 via [] at line 17
     # #11
     #   <no edges>
     # #root
     #   <no edges>
     #
 12: $t10 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t10
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 13: if ($t10) goto 14 else goto 20           # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
     # live vars: $t6
     # refs: []
     #
 15: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
     # live vars: $t6, $t13
     # refs: []
     #
 16: $t4 := infer($t13)                       # at closure_in_code_spec_expr.move:18:17+11
     # live vars: $t4, $t6
     # refs: []
     #
 17: $t5 := infer($t6)                        # at closure_in_code_spec_expr.move:19:17+15
     # live vars: $t4, $t5
     # refs: []
     #
 18: goto 31                                  # at closure_in_code_spec_expr.move:20:17+5
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 19: goto 21                                  # at closure_in_code_spec_expr.move:17:42+99
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 20: label L6                                 # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 21: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 22: $t15 := infer($t6)                       # at closure_in_code_spec_expr.move:22:17+1
     # live vars: $t0, $t1, $t4, $t5, $t7, $t15
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 23: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
     # live vars: $t0, $t1, $t4, $t5, $t7, $t15, $t16
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 24: $t14 := +($t15, $t16)                    # at closure_in_code_spec_expr.move:22:17+5
     # live vars: $t0, $t1, $t4, $t5, $t7, $t14
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 25: $t6 := infer($t14)                       # at closure_in_code_spec_expr.move:22:13+9
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 26: goto 29                                  # at closure_in_code_spec_expr.move:16:12+176
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 27: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
     # refs: []
     #
 28: goto 31                                  # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 29: label L4                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 30: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
     # refs: []
     #
 31: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
     # refs: []
     #
 32: $t2 := infer($t4)                        # at closure_in_code_spec_expr.move:24:10+4
     # live vars: $t2, $t5
     # refs: []
     #
 33: $t3 := infer($t5)                        # at closure_in_code_spec_expr.move:24:16+11
     # live vars: $t2, $t3
     # refs: []
     #
 34: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool
     var $t1: bool
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: vector<u64>
     var $t5: |&u64|bool has copy + drop
     # live vars:
     # refs: []
     #
  0: $t4 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
     # live vars: $t4
     # refs: []
     #
  1: $t3 := borrow_local($t4)                 # at closure_in_code_spec_expr.move:38:34+2
     # live vars: $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [value] at line 38
     #
  2: $t5 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
     # live vars: $t3, $t5
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [value] at line 38
     #
  3: ($t1, $t2) := test::find<u64>($t3, $t5)  # at closure_in_code_spec_expr.move:38:29+14
     # live vars: $t1
     # refs: []
     #
  4: $t0 := infer($t1)                        # at closure_in_code_spec_expr.move:39:9+5
     # live vars: $t0
     # refs: []
     #
  5: return $t0                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
     # live vars: $t0
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
     # live vars: $t1
     # refs: []
     #
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step4_AbortAnalysisProcessor:
============ after processor `AbortAnalysisProcessor` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
     # abort state: {returns,aborts}
     # live vars: $t0, $t2
     # refs: []
     #
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
     # abort state: {returns,aborts}
     # live vars: $t0, $t2, $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => (mut) #3 via [local `v`] at line 56
     #
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  3: $t1 := infer($t2)                        # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: u64
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  6: $t9 := infer($t6)                        # at closure_in_code_spec_expr.move:15:13+1
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t9
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t8
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  8: if ($t8) goto 9 else goto 27             # at closure_in_code_spec_expr.move:9:9+384
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 10: $t12 := infer($t0)                       # at closure_in_code_spec_expr.move:17:34+1
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t12
     # refs: [$t0 => #0, $t12 => #12]
     # #0
     #   => #12 via [] at line 17
     # #12
     #   <no edges>
     # #root
     #   <no edges>
     #
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t11
     # refs: [$t0 => #0, $t11 => #11]
     # #0
     #   -> #11 via [] at line 17
     # #11
     #   <no edges>
     # #root
     #   <no edges>
     #
 12: $t10 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t10
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 13: if ($t10) goto 14 else goto 20           # at closure_in_code_spec_expr.move:17:13+128
     # abort state: {returns}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
     # abort state: {returns}
     # live vars: $t6
     # refs: []
     #
 15: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
     # abort state: {returns}
     # live vars: $t6, $t13
     # refs: []
     #
 16: $t4 := infer($t13)                       # at closure_in_code_spec_expr.move:18:17+11
     # abort state: {returns}
     # live vars: $t4, $t6
     # refs: []
     #
 17: $t5 := infer($t6)                        # at closure_in_code_spec_expr.move:19:17+15
     # abort state: {returns}
     # live vars: $t4, $t5
     # refs: []
     #
 18: goto 31                                  # at closure_in_code_spec_expr.move:20:17+5
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 19: goto 21                                  # at closure_in_code_spec_expr.move:17:42+99
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 20: label L6                                 # at closure_in_code_spec_expr.move:17:13+128
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 21: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 22: $t15 := infer($t6)                       # at closure_in_code_spec_expr.move:22:17+1
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t7, $t15
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 23: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t7, $t15, $t16
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 24: $t14 := +($t15, $t16)                    # at closure_in_code_spec_expr.move:22:17+5
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t7, $t14
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 25: $t6 := infer($t14)                       # at closure_in_code_spec_expr.move:22:13+9
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 26: goto 29                                  # at closure_in_code_spec_expr.move:16:12+176
     # abort state: {returns}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 27: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
     # abort state: {returns}
     # live vars: $t4, $t5
     # refs: []
     #
 28: goto 31                                  # at closure_in_code_spec_expr.move:9:9+384
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 29: label L4                                 # at closure_in_code_spec_expr.move:9:9+384
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
 30: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
     # abort state: {returns}
     # live vars: $t4, $t5
     # refs: []
     #
 31: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
     # abort state: {returns}
     # live vars: $t4, $t5
     # refs: []
     #
 32: $t2 := infer($t4)                        # at closure_in_code_spec_expr.move:24:10+4
     # abort state: {returns}
     # live vars: $t2, $t5
     # refs: []
     #
 33: $t3 := infer($t5)                        # at closure_in_code_spec_expr.move:24:16+11
     # abort state: {returns}
     # live vars: $t2, $t3
     # refs: []
     #
 34: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool
     var $t1: bool
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: vector<u64>
     var $t5: |&u64|bool has copy + drop
     # abort state: {returns,aborts}
     # live vars:
     # refs: []
     #
  0: $t4 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
     # abort state: {returns,aborts}
     # live vars: $t4
     # refs: []
     #
  1: $t3 := borrow_local($t4)                 # at closure_in_code_spec_expr.move:38:34+2
     # abort state: {returns,aborts}
     # live vars: $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [value] at line 38
     #
  2: $t5 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
     # abort state: {returns,aborts}
     # live vars: $t3, $t5
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [value] at line 38
     #
  3: ($t1, $t2) := test::find<u64>($t3, $t5)  # at closure_in_code_spec_expr.move:38:29+14
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  4: $t0 := infer($t1)                        # at closure_in_code_spec_expr.move:39:9+5
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  5: return $t0                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
     # abort state: {returns}
     # live vars: $t0
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
     # abort state: {returns}
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step5_AbilityProcessor:
============ after processor `AbilityProcessor` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
  3: $t1 := move($t2)                         # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: u64
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
  6: $t9 := copy($t6)                         # at closure_in_code_spec_expr.move:15:13+1
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
  8: if ($t8) goto 9 else goto 28             # at closure_in_code_spec_expr.move:9:9+384
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
 10: $t12 := copy($t0)                        # at closure_in_code_spec_expr.move:17:34+1
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
 12: $t10 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
 13: if ($t10) goto 14 else goto 21           # at closure_in_code_spec_expr.move:17:13+128
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
 15: drop($t0)                                # at closure_in_code_spec_expr.move:17:42+99
 16: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
 17: $t4 := move($t13)                        # at closure_in_code_spec_expr.move:18:17+11
 18: $t5 := move($t6)                         # at closure_in_code_spec_expr.move:19:17+15
 19: goto 33                                  # at closure_in_code_spec_expr.move:20:17+5
 20: goto 22                                  # at closure_in_code_spec_expr.move:17:42+99
 21: label L6                                 # at closure_in_code_spec_expr.move:17:13+128
 22: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
 23: $t15 := move($t6)                        # at closure_in_code_spec_expr.move:22:17+1
 24: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 25: $t14 := +($t15, $t16)                    # at closure_in_code_spec_expr.move:22:17+5
 26: $t6 := move($t14)                        # at closure_in_code_spec_expr.move:22:13+9
 27: goto 31                                  # at closure_in_code_spec_expr.move:16:12+176
 28: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
 29: drop($t0)                                # at closure_in_code_spec_expr.move:9:9+384
 30: goto 33                                  # at closure_in_code_spec_expr.move:9:9+384
 31: label L4                                 # at closure_in_code_spec_expr.move:9:9+384
 32: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
 33: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
 34: $t2 := move($t4)                         # at closure_in_code_spec_expr.move:24:10+4
 35: $t3 := move($t5)                         # at closure_in_code_spec_expr.move:24:16+11
 36: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool
     var $t1: bool
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: vector<u64>
     var $t5: |&u64|bool has copy + drop
  0: $t4 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: $t3 := borrow_local($t4)                 # at closure_in_code_spec_expr.move:38:34+2
  2: $t5 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  3: ($t1, $t2) := test::find<u64>($t3, $t5)  # at closure_in_code_spec_expr.move:38:29+14
  4: $t0 := move($t1)                         # at closure_in_code_spec_expr.move:39:9+5
  5: return $t0                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step6_ControlFlowGraphSimplifier:
============ after processor `ControlFlowGraphSimplifier` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
  3: $t1 := move($t2)                         # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: u64
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
  6: $t9 := copy($t6)                         # at closure_in_code_spec_expr.move:15:13+1
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
  8: if ($t8) goto 9 else goto 29             # at closure_in_code_spec_expr.move:9:9+384
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
 10: $t12 := copy($t0)                        # at closure_in_code_spec_expr.move:17:34+1
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
 12: $t10 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
 13: if ($t10) goto 14 else goto 23           # at closure_in_code_spec_expr.move:17:13+128
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
 15: drop($t0)                                # at closure_in_code_spec_expr.move:17:42+99
 16: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
 17: $t4 := move($t13)                        # at closure_in_code_spec_expr.move:18:17+11
 18: $t5 := move($t6)                         # at closure_in_code_spec_expr.move:19:17+15
 19: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
 20: $t2 := move($t4)                         # at closure_in_code_spec_expr.move:24:10+4
 21: $t3 := move($t5)                         # at closure_in_code_spec_expr.move:24:16+11
 22: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
 23: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
 24: $t15 := move($t6)                        # at closure_in_code_spec_expr.move:22:17+1
 25: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 26: $t14 := +($t15, $t16)                    # at closure_in_code_spec_expr.move:22:17+5
 27: $t6 := move($t14)                        # at closure_in_code_spec_expr.move:22:13+9
 28: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
 29: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
 30: drop($t0)                                # at closure_in_code_spec_expr.move:9:9+384
 31: goto 19                                  # at closure_in_code_spec_expr.move:9:9+384
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool
     var $t1: bool
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: vector<u64>
     var $t5: |&u64|bool has copy + drop
  0: $t4 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: $t3 := borrow_local($t4)                 # at closure_in_code_spec_expr.move:38:34+2
  2: $t5 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  3: ($t1, $t2) := test::find<u64>($t3, $t5)  # at closure_in_code_spec_expr.move:38:29+14
  4: $t0 := move($t1)                         # at closure_in_code_spec_expr.move:39:9+5
  5: return $t0                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step7_SplitCriticalEdgesProcessor:
============ after processor `SplitCriticalEdgesProcessor` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
  3: $t1 := move($t2)                         # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: u64
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
  6: $t9 := copy($t6)                         # at closure_in_code_spec_expr.move:15:13+1
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
  8: if ($t8) goto 9 else goto 29             # at closure_in_code_spec_expr.move:9:9+384
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
 10: $t12 := copy($t0)                        # at closure_in_code_spec_expr.move:17:34+1
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
 12: $t10 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
 13: if ($t10) goto 14 else goto 23           # at closure_in_code_spec_expr.move:17:13+128
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
 15: drop($t0)                                # at closure_in_code_spec_expr.move:17:42+99
 16: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
 17: $t4 := move($t13)                        # at closure_in_code_spec_expr.move:18:17+11
 18: $t5 := move($t6)                         # at closure_in_code_spec_expr.move:19:17+15
 19: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
 20: $t2 := move($t4)                         # at closure_in_code_spec_expr.move:24:10+4
 21: $t3 := move($t5)                         # at closure_in_code_spec_expr.move:24:16+11
 22: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
 23: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
 24: $t15 := move($t6)                        # at closure_in_code_spec_expr.move:22:17+1
 25: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 26: $t14 := +($t15, $t16)                    # at closure_in_code_spec_expr.move:22:17+5
 27: $t6 := move($t14)                        # at closure_in_code_spec_expr.move:22:13+9
 28: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
 29: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
 30: drop($t0)                                # at closure_in_code_spec_expr.move:9:9+384
 31: goto 19                                  # at closure_in_code_spec_expr.move:9:9+384
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool
     var $t1: bool
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: vector<u64>
     var $t5: |&u64|bool has copy + drop
  0: $t4 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: $t3 := borrow_local($t4)                 # at closure_in_code_spec_expr.move:38:34+2
  2: $t5 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  3: ($t1, $t2) := test::find<u64>($t3, $t5)  # at closure_in_code_spec_expr.move:38:29+14
  4: $t0 := move($t1)                         # at closure_in_code_spec_expr.move:39:9+5
  5: return $t0                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step8_UnreachableCodeProcessor:
============ after processor `UnreachableCodeProcessor` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
     # maybe
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
     # maybe
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
     # maybe
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
     # maybe
  3: $t1 := move($t2)                         # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
     # maybe
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: u64
     # maybe
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
     # maybe
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
     # maybe
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
     # maybe
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
     # maybe
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
     # maybe
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
     # maybe
  6: $t9 := copy($t6)                         # at closure_in_code_spec_expr.move:15:13+1
     # maybe
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
     # maybe
  8: if ($t8) goto 9 else goto 29             # at closure_in_code_spec_expr.move:9:9+384
     # maybe
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
     # maybe
 10: $t12 := copy($t0)                        # at closure_in_code_spec_expr.move:17:34+1
     # maybe
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
     # maybe
 12: $t10 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
     # maybe
 13: if ($t10) goto 14 else goto 23           # at closure_in_code_spec_expr.move:17:13+128
     # maybe
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
     # maybe
 15: drop($t0)                                # at closure_in_code_spec_expr.move:17:42+99
     # maybe
 16: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
     # maybe
 17: $t4 := move($t13)                        # at closure_in_code_spec_expr.move:18:17+11
     # maybe
 18: $t5 := move($t6)                         # at closure_in_code_spec_expr.move:19:17+15
     # maybe
 19: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
     # maybe
 20: $t2 := move($t4)                         # at closure_in_code_spec_expr.move:24:10+4
     # maybe
 21: $t3 := move($t5)                         # at closure_in_code_spec_expr.move:24:16+11
     # maybe
 22: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
     # maybe
 23: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
     # maybe
 24: $t15 := move($t6)                        # at closure_in_code_spec_expr.move:22:17+1
     # maybe
 25: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
     # maybe
 26: $t14 := +($t15, $t16)                    # at closure_in_code_spec_expr.move:22:17+5
     # maybe
 27: $t6 := move($t14)                        # at closure_in_code_spec_expr.move:22:13+9
     # maybe
 28: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
     # maybe
 29: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
     # maybe
 30: drop($t0)                                # at closure_in_code_spec_expr.move:9:9+384
     # maybe
 31: goto 19                                  # at closure_in_code_spec_expr.move:9:9+384
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool
     var $t1: bool
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: vector<u64>
     var $t5: |&u64|bool has copy + drop
     # maybe
  0: $t4 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
     # maybe
  1: $t3 := borrow_local($t4)                 # at closure_in_code_spec_expr.move:38:34+2
     # maybe
  2: $t5 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
     # maybe
  3: ($t1, $t2) := test::find<u64>($t3, $t5)  # at closure_in_code_spec_expr.move:38:29+14
     # maybe
  4: $t0 := move($t1)                         # at closure_in_code_spec_expr.move:39:9+5
     # maybe
  5: return $t0                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
     # maybe
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
     # maybe
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
     # maybe
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
     # maybe
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step9_UnreachableCodeRemover:
============ after processor `UnreachableCodeRemover` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
  3: $t1 := move($t2)                         # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: u64
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
  6: $t9 := copy($t6)                         # at closure_in_code_spec_expr.move:15:13+1
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
  8: if ($t8) goto 9 else goto 29             # at closure_in_code_spec_expr.move:9:9+384
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
 10: $t12 := copy($t0)                        # at closure_in_code_spec_expr.move:17:34+1
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
 12: $t10 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
 13: if ($t10) goto 14 else goto 23           # at closure_in_code_spec_expr.move:17:13+128
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
 15: drop($t0)                                # at closure_in_code_spec_expr.move:17:42+99
 16: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
 17: $t4 := move($t13)                        # at closure_in_code_spec_expr.move:18:17+11
 18: $t5 := move($t6)                         # at closure_in_code_spec_expr.move:19:17+15
 19: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
 20: $t2 := move($t4)                         # at closure_in_code_spec_expr.move:24:10+4
 21: $t3 := move($t5)                         # at closure_in_code_spec_expr.move:24:16+11
 22: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
 23: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
 24: $t15 := move($t6)                        # at closure_in_code_spec_expr.move:22:17+1
 25: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 26: $t14 := +($t15, $t16)                    # at closure_in_code_spec_expr.move:22:17+5
 27: $t6 := move($t14)                        # at closure_in_code_spec_expr.move:22:13+9
 28: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
 29: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
 30: drop($t0)                                # at closure_in_code_spec_expr.move:9:9+384
 31: goto 19                                  # at closure_in_code_spec_expr.move:9:9+384
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool
     var $t1: bool
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: vector<u64>
     var $t5: |&u64|bool has copy + drop
  0: $t4 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: $t3 := borrow_local($t4)                 # at closure_in_code_spec_expr.move:38:34+2
  2: $t5 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  3: ($t1, $t2) := test::find<u64>($t3, $t5)  # at closure_in_code_spec_expr.move:38:29+14
  4: $t0 := move($t1)                         # at closure_in_code_spec_expr.move:39:9+5
  5: return $t0                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step10_LiveVarAnalysisProcessor:
============ after processor `LiveVarAnalysisProcessor` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
     # live vars: $t0
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
     # live vars: $t0, $t2
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
     # live vars: $t0, $t2, $t3
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
     # live vars: $t2
  3: $t1 := move($t2)                         # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
     # live vars: $t1
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: u64
     # live vars: $t0, $t1
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
     # live vars: $t0, $t1, $t4
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
     # live vars: $t0, $t1, $t4, $t5
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
     # live vars: $t0, $t1, $t4, $t5, $t6
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  6: $t9 := copy($t6)                         # at closure_in_code_spec_expr.move:15:13+1
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t9
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t8
  8: if ($t8) goto 9 else goto 29             # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 10: $t12 := copy($t0)                        # at closure_in_code_spec_expr.move:17:34+1
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t12
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t11
 12: $t10 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t10
 13: if ($t10) goto 14 else goto 23           # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
     # live vars: $t0, $t6
 15: drop($t0)                                # at closure_in_code_spec_expr.move:17:42+99
     # live vars: $t6
 16: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
     # live vars: $t6, $t13
 17: $t4 := move($t13)                        # at closure_in_code_spec_expr.move:18:17+11
     # live vars: $t4, $t6
 18: $t5 := move($t6)                         # at closure_in_code_spec_expr.move:19:17+15
     # live vars: $t4, $t5
 19: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
 20: $t2 := move($t4)                         # at closure_in_code_spec_expr.move:24:10+4
     # live vars: $t2, $t5
 21: $t3 := move($t5)                         # at closure_in_code_spec_expr.move:24:16+11
     # live vars: $t2, $t3
 22: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 23: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 24: $t15 := move($t6)                        # at closure_in_code_spec_expr.move:22:17+1
     # live vars: $t0, $t1, $t4, $t5, $t7, $t15
 25: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
     # live vars: $t0, $t1, $t4, $t5, $t7, $t15, $t16
 26: $t14 := +($t15, $t16)                    # at closure_in_code_spec_expr.move:22:17+5
     # live vars: $t0, $t1, $t4, $t5, $t7, $t14
 27: $t6 := move($t14)                        # at closure_in_code_spec_expr.move:22:13+9
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 28: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 29: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t4, $t5
 30: drop($t0)                                # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
 31: goto 19                                  # at closure_in_code_spec_expr.move:9:9+384
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool
     var $t1: bool
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: vector<u64>
     var $t5: |&u64|bool has copy + drop
     # live vars:
  0: $t4 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
     # live vars: $t4
  1: $t3 := borrow_local($t4)                 # at closure_in_code_spec_expr.move:38:34+2
     # live vars: $t3
  2: $t5 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
     # live vars: $t3, $t5
  3: ($t1, $t2) := test::find<u64>($t3, $t5)  # at closure_in_code_spec_expr.move:38:29+14
     # live vars: $t1
  4: $t0 := move($t1)                         # at closure_in_code_spec_expr.move:39:9+5
     # live vars: $t0
  5: return $t0                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
     # live vars: $t2
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
     # live vars: $t2, $t3
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
     # live vars: $t1
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step11_DeadStoreElimination:
============ after processor `DeadStoreElimination` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
  3: $t1 := move($t2)                         # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: u64
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
  6: $t9 := copy($t6)                         # at closure_in_code_spec_expr.move:15:13+1
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
  8: if ($t8) goto 9 else goto 29             # at closure_in_code_spec_expr.move:9:9+384
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
 10: $t12 := copy($t0)                        # at closure_in_code_spec_expr.move:17:34+1
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
 12: $t10 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
 13: if ($t10) goto 14 else goto 23           # at closure_in_code_spec_expr.move:17:13+128
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
 15: drop($t0)                                # at closure_in_code_spec_expr.move:17:42+99
 16: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
 17: $t4 := move($t13)                        # at closure_in_code_spec_expr.move:18:17+11
 18: $t5 := move($t6)                         # at closure_in_code_spec_expr.move:19:17+15
 19: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
 20: $t2 := move($t4)                         # at closure_in_code_spec_expr.move:24:10+4
 21: $t3 := move($t5)                         # at closure_in_code_spec_expr.move:24:16+11
 22: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
 23: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
 24: $t15 := move($t6)                        # at closure_in_code_spec_expr.move:22:17+1
 25: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 26: $t14 := +($t15, $t16)                    # at closure_in_code_spec_expr.move:22:17+5
 27: $t6 := move($t14)                        # at closure_in_code_spec_expr.move:22:13+9
 28: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
 29: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
 30: drop($t0)                                # at closure_in_code_spec_expr.move:9:9+384
 31: goto 19                                  # at closure_in_code_spec_expr.move:9:9+384
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool
     var $t1: bool
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: vector<u64>
     var $t5: |&u64|bool has copy + drop
  0: $t4 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: $t3 := borrow_local($t4)                 # at closure_in_code_spec_expr.move:38:34+2
  2: $t5 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  3: ($t1, $t2) := test::find<u64>($t3, $t5)  # at closure_in_code_spec_expr.move:38:29+14
  4: $t0 := move($t1)                         # at closure_in_code_spec_expr.move:39:9+5
  5: return $t0                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step12_LiveVarAnalysisProcessor:
============ after processor `LiveVarAnalysisProcessor` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
     # live vars: $t0
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
     # live vars: $t0, $t2
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
     # live vars: $t0, $t2, $t3
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
     # live vars: $t2
  3: $t1 := move($t2)                         # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
     # live vars: $t1
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: u64
     # live vars: $t0, $t1
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
     # live vars: $t0, $t1, $t4
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
     # live vars: $t0, $t1, $t4, $t5
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
     # live vars: $t0, $t1, $t4, $t5, $t6
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  6: $t9 := copy($t6)                         # at closure_in_code_spec_expr.move:15:13+1
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t9
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t8
  8: if ($t8) goto 9 else goto 29             # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 10: $t12 := copy($t0)                        # at closure_in_code_spec_expr.move:17:34+1
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t12
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t11
 12: $t10 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t10
 13: if ($t10) goto 14 else goto 23           # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
     # live vars: $t0, $t6
 15: drop($t0)                                # at closure_in_code_spec_expr.move:17:42+99
     # live vars: $t6
 16: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
     # live vars: $t6, $t13
 17: $t4 := move($t13)                        # at closure_in_code_spec_expr.move:18:17+11
     # live vars: $t4, $t6
 18: $t5 := move($t6)                         # at closure_in_code_spec_expr.move:19:17+15
     # live vars: $t4, $t5
 19: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
 20: $t2 := move($t4)                         # at closure_in_code_spec_expr.move:24:10+4
     # live vars: $t2, $t5
 21: $t3 := move($t5)                         # at closure_in_code_spec_expr.move:24:16+11
     # live vars: $t2, $t3
 22: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 23: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 24: $t15 := move($t6)                        # at closure_in_code_spec_expr.move:22:17+1
     # live vars: $t0, $t1, $t4, $t5, $t7, $t15
 25: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
     # live vars: $t0, $t1, $t4, $t5, $t7, $t15, $t16
 26: $t14 := +($t15, $t16)                    # at closure_in_code_spec_expr.move:22:17+5
     # live vars: $t0, $t1, $t4, $t5, $t7, $t14
 27: $t6 := move($t14)                        # at closure_in_code_spec_expr.move:22:13+9
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 28: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 29: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t4, $t5
 30: drop($t0)                                # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
 31: goto 19                                  # at closure_in_code_spec_expr.move:9:9+384
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool
     var $t1: bool
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: vector<u64>
     var $t5: |&u64|bool has copy + drop
     # live vars:
  0: $t4 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
     # live vars: $t4
  1: $t3 := borrow_local($t4)                 # at closure_in_code_spec_expr.move:38:34+2
     # live vars: $t3
  2: $t5 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
     # live vars: $t3, $t5
  3: ($t1, $t2) := test::find<u64>($t3, $t5)  # at closure_in_code_spec_expr.move:38:29+14
     # live vars: $t1
  4: $t0 := move($t1)                         # at closure_in_code_spec_expr.move:39:9+5
     # live vars: $t0
  5: return $t0                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
     # live vars: $t2
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
     # live vars: $t2, $t3
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
     # live vars: $t1
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step13_VariableCoalescingTransformer:
============ after processor `VariableCoalescingTransformer` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
  3: $t1 := move($t2)                         # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool [unused]
     var $t3: u64 [unused]
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool [unused]
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool [unused]
     var $t14: u64 [unused]
     var $t15: u64 [unused]
     var $t16: u64
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
  6: $t9 := copy($t6)                         # at closure_in_code_spec_expr.move:15:13+1
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
  8: if ($t8) goto 9 else goto 29             # at closure_in_code_spec_expr.move:9:9+384
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
 10: $t12 := copy($t0)                        # at closure_in_code_spec_expr.move:17:34+1
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
 12: $t8 := invoke($t11, $t1)                 # at closure_in_code_spec_expr.move:17:17+23
 13: if ($t8) goto 14 else goto 23            # at closure_in_code_spec_expr.move:17:13+128
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
 15: drop($t0)                                # at closure_in_code_spec_expr.move:17:42+99
 16: $t8 := true                              # at closure_in_code_spec_expr.move:18:24+4
 17: $t4 := move($t8)                         # at closure_in_code_spec_expr.move:18:17+11
 18: $t5 := move($t6)                         # at closure_in_code_spec_expr.move:19:17+15
 19: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
 20: $t8 := move($t4)                         # at closure_in_code_spec_expr.move:24:10+4
 21: $t9 := move($t5)                         # at closure_in_code_spec_expr.move:24:16+11
 22: return ($t8, $t9)                        # at closure_in_code_spec_expr.move:4:90+540
 23: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
 24: $t9 := move($t6)                         # at closure_in_code_spec_expr.move:22:17+1
 25: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 26: $t9 := +($t9, $t16)                      # at closure_in_code_spec_expr.move:22:17+5
 27: $t6 := move($t9)                         # at closure_in_code_spec_expr.move:22:13+9
 28: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
 29: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
 30: drop($t0)                                # at closure_in_code_spec_expr.move:9:9+384
 31: goto 19                                  # at closure_in_code_spec_expr.move:9:9+384
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool [unused]
     var $t1: bool
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: vector<u64>
     var $t5: |&u64|bool has copy + drop
  0: $t4 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: $t3 := borrow_local($t4)                 # at closure_in_code_spec_expr.move:38:34+2
  2: $t5 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  3: ($t1, $t2) := test::find<u64>($t3, $t5)  # at closure_in_code_spec_expr.move:38:29+14
  4: $t1 := move($t1)                         # at closure_in_code_spec_expr.move:39:9+5
  5: return $t1                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step14_LiveVarAnalysisProcessor:
============ after processor `LiveVarAnalysisProcessor` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
     # live vars: $t0
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
     # live vars: $t0, $t2
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
     # live vars: $t0, $t2, $t3
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
     # live vars: $t2
  3: $t1 := move($t2)                         # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
     # live vars: $t1
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool [unused]
     var $t3: u64 [unused]
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool [unused]
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool [unused]
     var $t14: u64 [unused]
     var $t15: u64 [unused]
     var $t16: u64
     # live vars: $t0, $t1
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
     # live vars: $t0, $t1, $t4
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
     # live vars: $t0, $t1, $t4, $t5
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
     # live vars: $t0, $t1, $t4, $t5, $t6
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  6: $t9 := copy($t6)                         # at closure_in_code_spec_expr.move:15:13+1
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t9
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t8
  8: if ($t8) goto 9 else goto 29             # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 10: $t12 := copy($t0)                        # at closure_in_code_spec_expr.move:17:34+1
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t12
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t11
 12: $t8 := invoke($t11, $t1)                 # at closure_in_code_spec_expr.move:17:17+23
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t8
 13: if ($t8) goto 14 else goto 23            # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
     # live vars: $t0, $t6
 15: drop($t0)                                # at closure_in_code_spec_expr.move:17:42+99
     # live vars: $t6
 16: $t8 := true                              # at closure_in_code_spec_expr.move:18:24+4
     # live vars: $t6, $t8
 17: $t4 := move($t8)                         # at closure_in_code_spec_expr.move:18:17+11
     # live vars: $t4, $t6
 18: $t5 := move($t6)                         # at closure_in_code_spec_expr.move:19:17+15
     # live vars: $t4, $t5
 19: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
 20: $t8 := move($t4)                         # at closure_in_code_spec_expr.move:24:10+4
     # live vars: $t5, $t8
 21: $t9 := move($t5)                         # at closure_in_code_spec_expr.move:24:16+11
     # live vars: $t8, $t9
 22: return ($t8, $t9)                        # at closure_in_code_spec_expr.move:4:90+540
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 23: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 24: $t9 := move($t6)                         # at closure_in_code_spec_expr.move:22:17+1
     # live vars: $t0, $t1, $t4, $t5, $t7, $t9
 25: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
     # live vars: $t0, $t1, $t4, $t5, $t7, $t9, $t16
 26: $t9 := +($t9, $t16)                      # at closure_in_code_spec_expr.move:22:17+5
     # live vars: $t0, $t1, $t4, $t5, $t7, $t9
 27: $t6 := move($t9)                         # at closure_in_code_spec_expr.move:22:13+9
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 28: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 29: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t4, $t5
 30: drop($t0)                                # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
 31: goto 19                                  # at closure_in_code_spec_expr.move:9:9+384
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool [unused]
     var $t1: bool
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: vector<u64>
     var $t5: |&u64|bool has copy + drop
     # live vars:
  0: $t4 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
     # live vars: $t4
  1: $t3 := borrow_local($t4)                 # at closure_in_code_spec_expr.move:38:34+2
     # live vars: $t3
  2: $t5 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
     # live vars: $t3, $t5
  3: ($t1, $t2) := test::find<u64>($t3, $t5)  # at closure_in_code_spec_expr.move:38:29+14
     # live vars: $t1
  4: $t1 := move($t1)                         # at closure_in_code_spec_expr.move:39:9+5
     # live vars: $t1
  5: return $t1                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
     # live vars: $t2
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
     # live vars: $t2, $t3
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
     # live vars: $t1
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step15_DeadStoreElimination:
============ after processor `DeadStoreElimination` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
  3: $t1 := move($t2)                         # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool [unused]
     var $t3: u64 [unused]
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool [unused]
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool [unused]
     var $t14: u64 [unused]
     var $t15: u64 [unused]
     var $t16: u64
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
  6: $t9 := copy($t6)                         # at closure_in_code_spec_expr.move:15:13+1
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
  8: if ($t8) goto 9 else goto 29             # at closure_in_code_spec_expr.move:9:9+384
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
 10: $t12 := copy($t0)                        # at closure_in_code_spec_expr.move:17:34+1
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
 12: $t8 := invoke($t11, $t1)                 # at closure_in_code_spec_expr.move:17:17+23
 13: if ($t8) goto 14 else goto 23            # at closure_in_code_spec_expr.move:17:13+128
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
 15: drop($t0)                                # at closure_in_code_spec_expr.move:17:42+99
 16: $t8 := true                              # at closure_in_code_spec_expr.move:18:24+4
 17: $t4 := move($t8)                         # at closure_in_code_spec_expr.move:18:17+11
 18: $t5 := move($t6)                         # at closure_in_code_spec_expr.move:19:17+15
 19: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
 20: $t8 := move($t4)                         # at closure_in_code_spec_expr.move:24:10+4
 21: $t9 := move($t5)                         # at closure_in_code_spec_expr.move:24:16+11
 22: return ($t8, $t9)                        # at closure_in_code_spec_expr.move:4:90+540
 23: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
 24: $t9 := move($t6)                         # at closure_in_code_spec_expr.move:22:17+1
 25: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 26: $t9 := +($t9, $t16)                      # at closure_in_code_spec_expr.move:22:17+5
 27: $t6 := move($t9)                         # at closure_in_code_spec_expr.move:22:13+9
 28: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
 29: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
 30: drop($t0)                                # at closure_in_code_spec_expr.move:9:9+384
 31: goto 19                                  # at closure_in_code_spec_expr.move:9:9+384
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool [unused]
     var $t1: bool
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: vector<u64>
     var $t5: |&u64|bool has copy + drop
  0: $t4 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: $t3 := borrow_local($t4)                 # at closure_in_code_spec_expr.move:38:34+2
  2: $t5 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  3: ($t1, $t2) := test::find<u64>($t3, $t5)  # at closure_in_code_spec_expr.move:38:29+14
  4: return $t1                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step16_LiveVarAnalysisProcessor:
============ after processor `LiveVarAnalysisProcessor` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
     # live vars: $t0
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
     # live vars: $t0, $t2
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
     # live vars: $t0, $t2, $t3
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
     # live vars: $t2
  3: $t1 := move($t2)                         # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
     # live vars: $t1
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool [unused]
     var $t3: u64 [unused]
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool [unused]
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool [unused]
     var $t14: u64 [unused]
     var $t15: u64 [unused]
     var $t16: u64
     # live vars: $t0, $t1
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
     # live vars: $t0, $t1, $t4
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
     # live vars: $t0, $t1, $t4, $t5
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
     # live vars: $t0, $t1, $t4, $t5, $t6
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  6: $t9 := copy($t6)                         # at closure_in_code_spec_expr.move:15:13+1
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t9
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t8
  8: if ($t8) goto 9 else goto 29             # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 10: $t12 := copy($t0)                        # at closure_in_code_spec_expr.move:17:34+1
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t12
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t11
 12: $t8 := invoke($t11, $t1)                 # at closure_in_code_spec_expr.move:17:17+23
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t8
 13: if ($t8) goto 14 else goto 23            # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
     # live vars: $t0, $t6
 15: drop($t0)                                # at closure_in_code_spec_expr.move:17:42+99
     # live vars: $t6
 16: $t8 := true                              # at closure_in_code_spec_expr.move:18:24+4
     # live vars: $t6, $t8
 17: $t4 := move($t8)                         # at closure_in_code_spec_expr.move:18:17+11
     # live vars: $t4, $t6
 18: $t5 := move($t6)                         # at closure_in_code_spec_expr.move:19:17+15
     # live vars: $t4, $t5
 19: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
 20: $t8 := move($t4)                         # at closure_in_code_spec_expr.move:24:10+4
     # live vars: $t5, $t8
 21: $t9 := move($t5)                         # at closure_in_code_spec_expr.move:24:16+11
     # live vars: $t8, $t9
 22: return ($t8, $t9)                        # at closure_in_code_spec_expr.move:4:90+540
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 23: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 24: $t9 := move($t6)                         # at closure_in_code_spec_expr.move:22:17+1
     # live vars: $t0, $t1, $t4, $t5, $t7, $t9
 25: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
     # live vars: $t0, $t1, $t4, $t5, $t7, $t9, $t16
 26: $t9 := +($t9, $t16)                      # at closure_in_code_spec_expr.move:22:17+5
     # live vars: $t0, $t1, $t4, $t5, $t7, $t9
 27: $t6 := move($t9)                         # at closure_in_code_spec_expr.move:22:13+9
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 28: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 29: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t4, $t5
 30: drop($t0)                                # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
 31: goto 19                                  # at closure_in_code_spec_expr.move:9:9+384
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool [unused]
     var $t1: bool
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: vector<u64>
     var $t5: |&u64|bool has copy + drop
     # live vars:
  0: $t4 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
     # live vars: $t4
  1: $t3 := borrow_local($t4)                 # at closure_in_code_spec_expr.move:38:34+2
     # live vars: $t3
  2: $t5 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
     # live vars: $t3, $t5
  3: ($t1, $t2) := test::find<u64>($t3, $t5)  # at closure_in_code_spec_expr.move:38:29+14
     # live vars: $t1
  4: return $t1                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
     # live vars: $t2
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
     # live vars: $t2, $t3
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
     # live vars: $t1
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step17_FlushWritesProcessor:
============ after processor `FlushWritesProcessor` ================

[variant baseline]
public intrinsic fun vector::contains<#0>($t0: &vector<#0>, $t1: &#0): bool;


[variant baseline]
public intrinsic fun vector::index_of<#0>($t0: &vector<#0>, $t1: &#0): (bool, u64);


[variant baseline]
public intrinsic fun vector::append<#0>($t0: &mut vector<#0>, $t1: vector<#0>);


[variant baseline]
public native fun vector::borrow<#0>($t0: &vector<#0>, $t1: u64): &#0;


[variant baseline]
public native fun vector::borrow_mut<#0>($t0: &mut vector<#0>, $t1: u64): &mut #0;


[variant baseline]
public native fun vector::destroy_empty<#0>($t0: vector<#0>);


[variant baseline]
public native fun vector::empty<#0>(): vector<#0>;


[variant baseline]
public intrinsic fun vector::is_empty<#0>($t0: &vector<#0>): bool;


[variant baseline]
public native fun vector::length<#0>($t0: &vector<#0>): u64;


[variant baseline]
public native fun vector::pop_back<#0>($t0: &mut vector<#0>): #0;


[variant baseline]
public native fun vector::push_back<#0>($t0: &mut vector<#0>, $t1: #0);


[variant baseline]
public intrinsic fun vector::remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
public intrinsic fun vector::reverse<#0>($t0: &mut vector<#0>);


[variant baseline]
public fun vector::singleton<#0>($t0: #0): vector<#0> {
     var $t1: vector<#0>
     var $t2: vector<#0>
     var $t3: &mut vector<#0>
     # flush: $t2
     # live vars: $t0
  0: $t2 := vector::empty<#0>()               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:55:17+7
     # live vars: $t0, $t2
  1: $t3 := borrow_local($t2)                 # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:19+6
     # live vars: $t0, $t2, $t3
  2: vector::push_back<#0>($t3, $t0)          # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:56:9+20
     # live vars: $t2
  3: $t1 := move($t2)                         # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:57:9+1
     # live vars: $t1
  4: return $t1                               # at /Users/wrwg/aptos-core/third_party/move/move-stdlib/sources/vector.move:54:64+72
}


[variant baseline]
public native fun vector::swap<#0>($t0: &mut vector<#0>, $t1: u64, $t2: u64);


[variant baseline]
public intrinsic fun vector::swap_remove<#0>($t0: &mut vector<#0>, $t1: u64): #0;


[variant baseline]
fun test::find<#0>($t0: &vector<#0>, $t1: |&#0|bool has copy + drop): (bool, u64) {
     var $t2: bool [unused]
     var $t3: u64 [unused]
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: bool
     var $t9: u64
     var $t10: bool [unused]
     var $t11: &#0
     var $t12: &vector<#0>
     var $t13: bool [unused]
     var $t14: u64 [unused]
     var $t15: u64 [unused]
     var $t16: u64
     # flush: $t4
     # live vars: $t0, $t1
  0: $t4 := false                             # at closure_in_code_spec_expr.move:5:20+5
     # flush: $t5
     # live vars: $t0, $t1, $t4
  1: $t5 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
     # flush: $t6
     # live vars: $t0, $t1, $t4, $t5
  2: $t6 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
     # flush: $t7
     # live vars: $t0, $t1, $t4, $t5, $t6
  3: $t7 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  4: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  5: spec {
  invariant Le($t6, $t7);
  invariant Eq<u64>($t5, 0);
  invariant forall j: num: Range(0, $t6): Not(($t1)(Index($t0, j)));
}
 # at closure_in_code_spec_expr.move:10:13+154
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  6: $t9 := copy($t6)                         # at closure_in_code_spec_expr.move:15:13+1
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t9
  7: $t8 := <($t9, $t7)                       # at closure_in_code_spec_expr.move:15:13+7
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t8
  8: if ($t8) goto 9 else goto 29             # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
  9: label L2                                 # at closure_in_code_spec_expr.move:16:12+176
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 10: $t12 := copy($t0)                        # at closure_in_code_spec_expr.move:17:34+1
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t12
 11: $t11 := vector::borrow<#0>($t12, $t6)    # at closure_in_code_spec_expr.move:17:19+20
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t11
 12: $t8 := invoke($t11, $t1)                 # at closure_in_code_spec_expr.move:17:17+23
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7, $t8
 13: if ($t8) goto 14 else goto 23            # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 14: label L5                                 # at closure_in_code_spec_expr.move:17:42+99
     # live vars: $t0, $t6
 15: drop($t0)                                # at closure_in_code_spec_expr.move:17:42+99
     # live vars: $t6
 16: $t8 := true                              # at closure_in_code_spec_expr.move:18:24+4
     # flush: $t4
     # live vars: $t6, $t8
 17: $t4 := move($t8)                         # at closure_in_code_spec_expr.move:18:17+11
     # flush: $t5
     # live vars: $t4, $t6
 18: $t5 := move($t6)                         # at closure_in_code_spec_expr.move:19:17+15
     # live vars: $t4, $t5
 19: label L1                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
 20: $t8 := move($t4)                         # at closure_in_code_spec_expr.move:24:10+4
     # live vars: $t5, $t8
 21: $t9 := move($t5)                         # at closure_in_code_spec_expr.move:24:16+11
     # live vars: $t8, $t9
 22: return ($t8, $t9)                        # at closure_in_code_spec_expr.move:4:90+540
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 23: label L7                                 # at closure_in_code_spec_expr.move:17:13+128
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 24: $t9 := move($t6)                         # at closure_in_code_spec_expr.move:22:17+1
     # live vars: $t0, $t1, $t4, $t5, $t7, $t9
 25: $t16 := 1                                # at closure_in_code_spec_expr.move:22:21+1
     # live vars: $t0, $t1, $t4, $t5, $t7, $t9, $t16
 26: $t9 := +($t9, $t16)                      # at closure_in_code_spec_expr.move:22:17+5
     # flush: $t6
     # live vars: $t0, $t1, $t4, $t5, $t7, $t9
 27: $t6 := move($t9)                         # at closure_in_code_spec_expr.move:22:13+9
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 28: goto 4                                   # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t1, $t4, $t5, $t6, $t7
 29: label L3                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t0, $t4, $t5
 30: drop($t0)                                # at closure_in_code_spec_expr.move:9:9+384
     # live vars: $t4, $t5
 31: goto 19                                  # at closure_in_code_spec_expr.move:9:9+384
}


[variant baseline]
fun test::call_find(): bool {
     var $t0: bool [unused]
     var $t1: bool
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: vector<u64>
     var $t5: |&u64|bool has copy + drop
     # live vars:
  0: $t4 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
     # live vars: $t4
  1: $t3 := borrow_local($t4)                 # at closure_in_code_spec_expr.move:38:34+2
     # live vars: $t3
  2: $t5 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
     # flush: $t2
     # live vars: $t3, $t5
  3: ($t1, $t2) := test::find<u64>($t3, $t5)  # at closure_in_code_spec_expr.move:38:29+14
     # live vars: $t1
  4: return $t1                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0: &u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := read_ref($t0)                     # at closure_in_code_spec_expr.move:33:9+2
     # live vars: $t2
  1: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
     # live vars: $t2, $t3
  2: $t1 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
     # live vars: $t1
  3: return $t1                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_compiler_v2] File Format Generation
[DEBUG move_prover] disassembled bytecode:
// Bytecode version v9
module 0x1::vector
// Function definition at index 0
#[persistent] public fun contains<T0>(l0: &vector<T0>, l1: &T0): bool
    local l2: u64
    local l3: u64
    ld_u64 0
    st_loc l2
    copy_loc l0
    vec_len <T0>
    st_loc l3
    // @5
l2: copy_loc l2
    copy_loc l3
    lt
    br_false l0
    copy_loc l0
    // @10
    copy_loc l2
    vec_borrow <T0>
    copy_loc l1
    eq
    br_false l1
    // @15
    move_loc l0
    pop
    move_loc l1
    pop
    ld_true
    // @20
    ret
l1: move_loc l2
    ld_u64 1
    add
    st_loc l2
    // @25
    branch l2
l0: move_loc l0
    pop
    move_loc l1
    pop
    // @30
    ld_false
    ret

// Function definition at index 1
#[persistent] public fun index_of<T0>(l0: &vector<T0>, l1: &T0): (bool, u64)
    local l2: u64
    local l3: u64
    ld_u64 0
    st_loc l2
    copy_loc l0
    vec_len <T0>
    st_loc l3
    // @5
l2: copy_loc l2
    copy_loc l3
    lt
    br_false l0
    copy_loc l0
    // @10
    copy_loc l2
    vec_borrow <T0>
    copy_loc l1
    eq
    br_false l1
    // @15
    move_loc l0
    pop
    move_loc l1
    pop
    ld_true
    // @20
    move_loc l2
    ret
l1: move_loc l2
    ld_u64 1
    add
    // @25
    st_loc l2
    branch l2
l0: move_loc l0
    pop
    move_loc l1
    // @30
    pop
    ld_false
    ld_u64 0
    ret

// Function definition at index 2
#[persistent] public fun append<T0>(l0: &mut vector<T0>, l1: vector<T0>)
    mut_borrow_loc l1
    call reverse<T0>
l1: borrow_loc l1
    call is_empty<T0>
    br_true l0
    // @5
    copy_loc l0
    mut_borrow_loc l1
    vec_pop_back <T0>
    vec_push_back <T0>
    branch l1
    // @10
l0: move_loc l0
    pop
    move_loc l1
    vec_unpack <T0>, 0
    ret

// Function definition at index 3
#[persistent] public fun borrow<T0>(l0: &vector<T0>, l1: u64): &T0

// Function definition at index 4
#[persistent] public fun borrow_mut<T0>(l0: &mut vector<T0>, l1: u64): &mut T0

// Function definition at index 5
#[persistent] public fun destroy_empty<T0>(l0: vector<T0>)

// Function definition at index 6
#[persistent] public fun empty<T0>(): vector<T0>

// Function definition at index 7
#[persistent] public fun is_empty<T0>(l0: &vector<T0>): bool
    move_loc l0
    vec_len <T0>
    ld_u64 0
    eq
    ret

// Function definition at index 8
#[persistent] public fun length<T0>(l0: &vector<T0>): u64

// Function definition at index 9
#[persistent] public fun pop_back<T0>(l0: &mut vector<T0>): T0

// Function definition at index 10
#[persistent] public fun push_back<T0>(l0: &mut vector<T0>, l1: T0)

// Function definition at index 11
#[persistent] public fun remove<T0>(l0: &mut vector<T0>, l1: u64): T0
    local l2: u64
    copy_loc l0
    freeze_ref
    vec_len <T0>
    st_loc l2
    copy_loc l1
    // @5
    copy_loc l2
    ge
    br_false l0
    move_loc l0
    pop
    // @10
    ld_u64 131072
    abort
l0: move_loc l2
    ld_u64 1
    sub
    // @15
    st_loc l2
l2: copy_loc l1
    copy_loc l2
    lt
    br_false l1
    // @20
    copy_loc l0
    copy_loc l1
    move_loc l1
    ld_u64 1
    add
    // @25
    st_loc l1
    copy_loc l1
    vec_swap <T0>
    branch l2
l1: move_loc l0
    // @30
    vec_pop_back <T0>
    ret

// Function definition at index 12
#[persistent] public fun reverse<T0>(l0: &mut vector<T0>)
    local l1: u64
    local l2: u64
    copy_loc l0
    freeze_ref
    vec_len <T0>
    st_loc l1
    copy_loc l1
    // @5
    ld_u64 0
    eq
    br_false l0
    move_loc l0
    pop
    // @10
    ret
l0: ld_u64 0
    st_loc l2
    move_loc l1
    ld_u64 1
    // @15
    sub
    st_loc l1
l2: copy_loc l2
    copy_loc l1
    lt
    // @20
    br_false l1
    copy_loc l0
    copy_loc l2
    copy_loc l1
    vec_swap <T0>
    // @25
    move_loc l2
    ld_u64 1
    add
    st_loc l2
    move_loc l1
    // @30
    ld_u64 1
    sub
    st_loc l1
    branch l2
l1: move_loc l0
    // @35
    pop
    ret

// Function definition at index 13
#[persistent] public fun singleton<T0>(l0: T0): vector<T0>
    local l1: vector<T0>
    vec_pack <T0>, 0
    st_loc l1
    mut_borrow_loc l1
    move_loc l0
    vec_push_back <T0>
    // @5
    move_loc l1
    ret

// Function definition at index 14
#[persistent] public fun swap<T0>(l0: &mut vector<T0>, l1: u64, l2: u64)

// Function definition at index 15
#[persistent] public fun swap_remove<T0>(l0: &mut vector<T0>, l1: u64): T0
    local l2: u64
    copy_loc l0
    freeze_ref
    call is_empty<T0>
    br_true l0
    copy_loc l0
    // @5
    freeze_ref
    vec_len <T0>
    ld_u64 1
    sub
    st_loc l2
    // @10
    copy_loc l0
    move_loc l1
    move_loc l2
    vec_swap <T0>
    move_loc l0
    // @15
    vec_pop_back <T0>
    ret
l0: move_loc l0
    pop
    ld_u64 131072
    // @20
    abort


[INFO move_prover] preparing module 0x42::test
[DEBUG move_prover] disassembled bytecode:
// Bytecode version v9
module 0x42::test
// Function definition at index 0
fun find<T0>(l0: &vector<T0>, l1: |&T0|bool has copy + drop): (bool, u64)
    local l2: bool
    local l3: u64
    local l4: u64
    local l5: u64
    ld_false
    st_loc l2
    ld_u64 0
    st_loc l3
    ld_u64 0
    // @5
    st_loc l4
    copy_loc l0
    vec_len <T0>
    st_loc l5
l2: nop
    // @10
    copy_loc l4
    copy_loc l5
    lt
    br_false l0
    copy_loc l0
    // @15
    copy_loc l4
    vec_borrow <T0>
    copy_loc l1
    call_closure <|&T0|bool has copy + drop>
    br_false l1
    // @20
    move_loc l0
    pop
    ld_true
    st_loc l2
    move_loc l4
    // @25
    st_loc l3
l3: move_loc l2
    move_loc l3
    ret
l1: move_loc l4
    // @30
    ld_u64 1
    add
    st_loc l4
    branch l2
l0: move_loc l0
    // @35
    pop
    branch l3

// Function definition at index 1
fun call_find(): bool
    local l0: vector<u64>
    ld_const<vector<u64>> [1, 2, 3]
    st_loc l0
    borrow_loc l0
    pack_closure pred, 0
    call find<u64>
    // @5
    pop
    ret

// Function definition at index 2
fun pred(l0: &u64): bool
    move_loc l0
    read_ref
    ld_u64 1
    gt
    ret


[DEBUG move_stackless_bytecode::function_target_pipeline] transforming bytecode
[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step0_stackless:
============ after processor `stackless` ================

[variant baseline]
fun test::find<#0>($t0|s: &vector<#0>, $t1|f: |&#0|(bool) has copy + drop): (bool, u64) {
     var $t2|find: bool
     var $t3|found_index: u64
     var $t4|i: u64
     var $t5|len: u64
     var $t6: bool
     var $t7: u64
     var $t8: u64
     var $t9: &vector<#0>
     var $t10: u64
     var $t11: u64
     var $t12: u64
     var $t13: bool
     var $t14: &vector<#0>
     var $t15: u64
     var $t16: &#0
     var $t17: |&#0|(bool) has copy + drop
     var $t18: bool
     var $t19: &vector<#0>
     var $t20: bool
     var $t21: u64
     var $t22: bool
     var $t23: u64
     var $t24: u64
     var $t25: u64
     var $t26: u64
     var $t27: &vector<#0>
  0: $t6 := false                             # at closure_in_code_spec_expr.move:5:20+5
  1: $t2 := $t6                               # at closure_in_code_spec_expr.move:5:20+5
  2: $t7 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  3: $t3 := $t7                               # at closure_in_code_spec_expr.move:6:27+1
  4: $t8 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  5: $t4 := $t8                               # at closure_in_code_spec_expr.move:7:17+1
  6: $t9 := copy($t0)                         # at closure_in_code_spec_expr.move:8:19+17
  7: $t10 := vector::length<#0>($t9)          # at closure_in_code_spec_expr.move:8:19+17
  8: $t5 := $t10                              # at closure_in_code_spec_expr.move:8:19+17
  9: goto 10                                  # at closure_in_code_spec_expr.move:10:13+154
 10: label L4                                 # at closure_in_code_spec_expr.move:10:13+154
 11: assert Le($t4, $t5)                      # at closure_in_code_spec_expr.move:11:17+19
 12: assert Eq<u64>($t3, 0)                   # at closure_in_code_spec_expr.move:12:17+27
 13: assert forall j: num: Range(0, $t4): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 14: $t11 := copy($t4)                        # at closure_in_code_spec_expr.move:15:13+1
 15: $t12 := copy($t5)                        # at closure_in_code_spec_expr.move:15:13+7
 16: $t13 := <($t11, $t12)                    # at closure_in_code_spec_expr.move:15:13+7
 17: if ($t13) goto 18 else goto 43           # at closure_in_code_spec_expr.move:9:9+384
 18: label L1                                 # at closure_in_code_spec_expr.move:17:34+1
 19: $t14 := copy($t0)                        # at closure_in_code_spec_expr.move:17:34+1
 20: $t15 := copy($t4)                        # at closure_in_code_spec_expr.move:17:19+20
 21: $t16 := vector::borrow<#0>($t14, $t15)   # at closure_in_code_spec_expr.move:17:19+20
 22: $t17 := copy($t1)                        # at closure_in_code_spec_expr.move:17:17+23
 23: $t18 := invoke($t16, $t17)               # at closure_in_code_spec_expr.move:17:17+23
 24: if ($t18) goto 25 else goto 37           # at closure_in_code_spec_expr.move:17:13+128
 25: label L3                                 # at closure_in_code_spec_expr.move:17:42+99
 26: $t19 := move($t0)                        # at closure_in_code_spec_expr.move:17:42+99
 27: drop($t19)                               # at closure_in_code_spec_expr.move:17:42+99
 28: $t20 := true                             # at closure_in_code_spec_expr.move:18:24+4
 29: $t2 := $t20                              # at closure_in_code_spec_expr.move:18:17+11
 30: $t21 := move($t4)                        # at closure_in_code_spec_expr.move:19:17+15
 31: $t3 := $t21                              # at closure_in_code_spec_expr.move:19:17+15
 32: goto 33                                  # at closure_in_code_spec_expr.move:24:10+4
 33: label L5                                 # at closure_in_code_spec_expr.move:24:10+4
 34: $t22 := move($t2)                        # at closure_in_code_spec_expr.move:24:10+4
 35: $t23 := move($t3)                        # at closure_in_code_spec_expr.move:24:16+11
 36: return ($t22, $t23)                      # at closure_in_code_spec_expr.move:4:90+540
 37: label L2                                 # at closure_in_code_spec_expr.move:22:17+1
 38: $t24 := move($t4)                        # at closure_in_code_spec_expr.move:22:17+1
 39: $t25 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 40: $t26 := +($t24, $t25)                    # at closure_in_code_spec_expr.move:22:17+5
 41: $t4 := $t26                              # at closure_in_code_spec_expr.move:22:13+9
 42: goto 10                                  # at closure_in_code_spec_expr.move:9:9+384
 43: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
 44: $t27 := move($t0)                        # at closure_in_code_spec_expr.move:9:9+384
 45: drop($t27)                               # at closure_in_code_spec_expr.move:9:9+384
 46: goto 33                                  # at closure_in_code_spec_expr.move:9:9+384
}


[variant baseline]
fun test::call_find(): bool {
     var $t0|$t4: vector<u64>
     var $t1: vector<u64>
     var $t2: &vector<u64>
     var $t3: |&u64|bool has copy + drop
     var $t4: bool
     var $t5: u64
  0: $t1 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: $t0 := $t1                               # at closure_in_code_spec_expr.move:38:35+1
  2: $t2 := borrow_local($t0)                 # at closure_in_code_spec_expr.move:38:34+2
  3: $t3 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  4: ($t4, $t5) := test::find<u64>($t2, $t3)  # at closure_in_code_spec_expr.move:38:29+14
  5: drop($t5)                                # at closure_in_code_spec_expr.move:38:29+14
  6: return $t4                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0|x: &u64): bool {
     var $t1: &u64
     var $t2: u64
     var $t3: u64
     var $t4: bool
  0: $t1 := move($t0)                         # at closure_in_code_spec_expr.move:33:9+2
  1: $t2 := read_ref($t1)                     # at closure_in_code_spec_expr.move:33:9+2
  2: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  3: $t4 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
  4: return $t4                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step1_debug_instrumenter:
============ after processor `debug_instrumenter` ================

[variant baseline]
fun test::find<#0>($t0|s: &vector<#0>, $t1|f: |&#0|(bool) has copy + drop): (bool, u64) {
     var $t2|find: bool
     var $t3|found_index: u64
     var $t4|i: u64
     var $t5|len: u64
     var $t6: bool
     var $t7: u64
     var $t8: u64
     var $t9: &vector<#0>
     var $t10: u64
     var $t11: u64
     var $t12: u64
     var $t13: bool
     var $t14: &vector<#0>
     var $t15: u64
     var $t16: &#0
     var $t17: |&#0|(bool) has copy + drop
     var $t18: bool
     var $t19: &vector<#0>
     var $t20: bool
     var $t21: u64
     var $t22: bool
     var $t23: u64
     var $t24: u64
     var $t25: u64
     var $t26: u64
     var $t27: &vector<#0>
  0: trace_local[s]($t0)                      # at closure_in_code_spec_expr.move:4:5+1
  1: trace_local[f]($t1)                      # at closure_in_code_spec_expr.move:4:5+1
  2: $t6 := false                             # at closure_in_code_spec_expr.move:5:20+5
  3: $t2 := $t6                               # at closure_in_code_spec_expr.move:5:20+5
  4: trace_local[find]($t2)                   # at closure_in_code_spec_expr.move:5:20+5
  5: $t7 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  6: $t3 := $t7                               # at closure_in_code_spec_expr.move:6:27+1
  7: trace_local[found_index]($t3)            # at closure_in_code_spec_expr.move:6:27+1
  8: $t8 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  9: $t4 := $t8                               # at closure_in_code_spec_expr.move:7:17+1
 10: trace_local[i]($t4)                      # at closure_in_code_spec_expr.move:7:17+1
 11: $t9 := copy($t0)                         # at closure_in_code_spec_expr.move:8:19+17
 12: $t10 := vector::length<#0>($t9)          # at closure_in_code_spec_expr.move:8:19+17
 13: $t5 := $t10                              # at closure_in_code_spec_expr.move:8:19+17
 14: trace_local[len]($t5)                    # at closure_in_code_spec_expr.move:8:19+17
 15: label L4                                 # at closure_in_code_spec_expr.move:10:13+154
 16: assert Le($t4, $t5)                      # at closure_in_code_spec_expr.move:11:17+19
 17: assert Eq<u64>($t3, 0)                   # at closure_in_code_spec_expr.move:12:17+27
 18: assert forall j: num: Range(0, $t4): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 19: $t11 := copy($t4)                        # at closure_in_code_spec_expr.move:15:13+1
 20: $t12 := copy($t5)                        # at closure_in_code_spec_expr.move:15:13+7
 21: $t13 := <($t11, $t12)                    # at closure_in_code_spec_expr.move:15:13+7
 22: if ($t13) goto 23 else goto 52           # at closure_in_code_spec_expr.move:9:9+384
 23: label L1                                 # at closure_in_code_spec_expr.move:17:34+1
 24: $t14 := copy($t0)                        # at closure_in_code_spec_expr.move:17:34+1
 25: $t15 := copy($t4)                        # at closure_in_code_spec_expr.move:17:19+20
 26: $t16 := vector::borrow<#0>($t14, $t15)   # at closure_in_code_spec_expr.move:17:19+20
 27: $t17 := copy($t1)                        # at closure_in_code_spec_expr.move:17:17+23
 28: $t18 := invoke($t16, $t17)               # at closure_in_code_spec_expr.move:17:17+23
 29: if ($t18) goto 30 else goto 45           # at closure_in_code_spec_expr.move:17:13+128
 30: label L3                                 # at closure_in_code_spec_expr.move:17:42+99
 31: $t19 := move($t0)                        # at closure_in_code_spec_expr.move:17:42+99
 32: drop($t19)                               # at closure_in_code_spec_expr.move:17:42+99
 33: $t20 := true                             # at closure_in_code_spec_expr.move:18:24+4
 34: $t2 := $t20                              # at closure_in_code_spec_expr.move:18:17+11
 35: trace_local[find]($t2)                   # at closure_in_code_spec_expr.move:18:17+11
 36: $t21 := move($t4)                        # at closure_in_code_spec_expr.move:19:17+15
 37: $t3 := $t21                              # at closure_in_code_spec_expr.move:19:17+15
 38: trace_local[found_index]($t3)            # at closure_in_code_spec_expr.move:19:17+15
 39: label L5                                 # at closure_in_code_spec_expr.move:24:10+4
 40: $t22 := move($t2)                        # at closure_in_code_spec_expr.move:24:10+4
 41: $t23 := move($t3)                        # at closure_in_code_spec_expr.move:24:16+11
 42: trace_return[0]($t22)                    # at closure_in_code_spec_expr.move:4:90+540
 43: trace_return[1]($t23)                    # at closure_in_code_spec_expr.move:4:90+540
 44: return ($t22, $t23)                      # at closure_in_code_spec_expr.move:4:90+540
 45: label L2                                 # at closure_in_code_spec_expr.move:22:17+1
 46: $t24 := move($t4)                        # at closure_in_code_spec_expr.move:22:17+1
 47: $t25 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 48: $t26 := +($t24, $t25)                    # at closure_in_code_spec_expr.move:22:17+5
 49: $t4 := $t26                              # at closure_in_code_spec_expr.move:22:13+9
 50: trace_local[i]($t4)                      # at closure_in_code_spec_expr.move:22:13+9
 51: goto 15                                  # at closure_in_code_spec_expr.move:9:9+384
 52: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
 53: $t27 := move($t0)                        # at closure_in_code_spec_expr.move:9:9+384
 54: drop($t27)                               # at closure_in_code_spec_expr.move:9:9+384
 55: goto 39                                  # at closure_in_code_spec_expr.move:9:9+384
}


[variant baseline]
fun test::call_find(): bool {
     var $t0|$t4: vector<u64>
     var $t1: vector<u64>
     var $t2: &vector<u64>
     var $t3: |&u64|bool has copy + drop
     var $t4: bool
     var $t5: u64
  0: $t1 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: $t0 := $t1                               # at closure_in_code_spec_expr.move:38:35+1
  2: trace_local[$t4]($t0)                    # at closure_in_code_spec_expr.move:38:35+1
  3: $t2 := borrow_local($t0)                 # at closure_in_code_spec_expr.move:38:34+2
  4: $t3 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  5: ($t4, $t5) := test::find<u64>($t2, $t3)  # at closure_in_code_spec_expr.move:38:29+14
  6: drop($t5)                                # at closure_in_code_spec_expr.move:38:29+14
  7: trace_return[0]($t4)                     # at closure_in_code_spec_expr.move:39:9+5
  8: return $t4                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0|x: &u64): bool {
     var $t1: &u64
     var $t2: u64
     var $t3: u64
     var $t4: bool
  0: trace_local[x]($t0)                      # at closure_in_code_spec_expr.move:32:5+1
  1: $t1 := move($t0)                         # at closure_in_code_spec_expr.move:33:9+2
  2: $t2 := read_ref($t1)                     # at closure_in_code_spec_expr.move:33:9+2
  3: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  4: $t4 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
  5: trace_return[0]($t4)                     # at closure_in_code_spec_expr.move:33:9+6
  6: return $t4                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step2_eliminate_imm_refs:
============ after processor `eliminate_imm_refs` ================

[variant baseline]
fun test::find<#0>($t0|s: vector<#0>, $t1|f: |&#0|(bool) has copy + drop): (bool, u64) {
     var $t2|find: bool
     var $t3|found_index: u64
     var $t4|i: u64
     var $t5|len: u64
     var $t6: bool
     var $t7: u64
     var $t8: u64
     var $t9: vector<#0>
     var $t10: u64
     var $t11: u64
     var $t12: u64
     var $t13: bool
     var $t14: vector<#0>
     var $t15: u64
     var $t16: #0
     var $t17: |&#0|(bool) has copy + drop
     var $t18: bool
     var $t19: vector<#0>
     var $t20: bool
     var $t21: u64
     var $t22: bool
     var $t23: u64
     var $t24: u64
     var $t25: u64
     var $t26: u64
     var $t27: vector<#0>
  0: trace_local[s]($t0)                      # at closure_in_code_spec_expr.move:4:5+1
  1: trace_local[f]($t1)                      # at closure_in_code_spec_expr.move:4:5+1
  2: $t6 := false                             # at closure_in_code_spec_expr.move:5:20+5
  3: $t2 := $t6                               # at closure_in_code_spec_expr.move:5:20+5
  4: trace_local[find]($t2)                   # at closure_in_code_spec_expr.move:5:20+5
  5: $t7 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  6: $t3 := $t7                               # at closure_in_code_spec_expr.move:6:27+1
  7: trace_local[found_index]($t3)            # at closure_in_code_spec_expr.move:6:27+1
  8: $t8 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  9: $t4 := $t8                               # at closure_in_code_spec_expr.move:7:17+1
 10: trace_local[i]($t4)                      # at closure_in_code_spec_expr.move:7:17+1
 11: $t9 := copy($t0)                         # at closure_in_code_spec_expr.move:8:19+17
 12: $t10 := vector::length<#0>($t9)          # at closure_in_code_spec_expr.move:8:19+17
 13: $t5 := $t10                              # at closure_in_code_spec_expr.move:8:19+17
 14: trace_local[len]($t5)                    # at closure_in_code_spec_expr.move:8:19+17
 15: label L4                                 # at closure_in_code_spec_expr.move:10:13+154
 16: assert Le($t4, $t5)                      # at closure_in_code_spec_expr.move:11:17+19
 17: assert Eq<u64>($t3, 0)                   # at closure_in_code_spec_expr.move:12:17+27
 18: assert forall j: num: Range(0, $t4): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 19: $t11 := copy($t4)                        # at closure_in_code_spec_expr.move:15:13+1
 20: $t12 := copy($t5)                        # at closure_in_code_spec_expr.move:15:13+7
 21: $t13 := <($t11, $t12)                    # at closure_in_code_spec_expr.move:15:13+7
 22: if ($t13) goto 23 else goto 51           # at closure_in_code_spec_expr.move:9:9+384
 23: label L1                                 # at closure_in_code_spec_expr.move:17:34+1
 24: $t14 := copy($t0)                        # at closure_in_code_spec_expr.move:17:34+1
 25: $t15 := copy($t4)                        # at closure_in_code_spec_expr.move:17:19+20
 26: $t16 := vector::borrow<#0>($t14, $t15)   # at closure_in_code_spec_expr.move:17:19+20
 27: $t17 := copy($t1)                        # at closure_in_code_spec_expr.move:17:17+23
 28: $t18 := invoke($t16, $t17)               # at closure_in_code_spec_expr.move:17:17+23
 29: if ($t18) goto 30 else goto 44           # at closure_in_code_spec_expr.move:17:13+128
 30: label L3                                 # at closure_in_code_spec_expr.move:17:42+99
 31: $t19 := move($t0)                        # at closure_in_code_spec_expr.move:17:42+99
 32: $t20 := true                             # at closure_in_code_spec_expr.move:18:24+4
 33: $t2 := $t20                              # at closure_in_code_spec_expr.move:18:17+11
 34: trace_local[find]($t2)                   # at closure_in_code_spec_expr.move:18:17+11
 35: $t21 := move($t4)                        # at closure_in_code_spec_expr.move:19:17+15
 36: $t3 := $t21                              # at closure_in_code_spec_expr.move:19:17+15
 37: trace_local[found_index]($t3)            # at closure_in_code_spec_expr.move:19:17+15
 38: label L5                                 # at closure_in_code_spec_expr.move:24:10+4
 39: $t22 := move($t2)                        # at closure_in_code_spec_expr.move:24:10+4
 40: $t23 := move($t3)                        # at closure_in_code_spec_expr.move:24:16+11
 41: trace_return[0]($t22)                    # at closure_in_code_spec_expr.move:4:90+540
 42: trace_return[1]($t23)                    # at closure_in_code_spec_expr.move:4:90+540
 43: return ($t22, $t23)                      # at closure_in_code_spec_expr.move:4:90+540
 44: label L2                                 # at closure_in_code_spec_expr.move:22:17+1
 45: $t24 := move($t4)                        # at closure_in_code_spec_expr.move:22:17+1
 46: $t25 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 47: $t26 := +($t24, $t25)                    # at closure_in_code_spec_expr.move:22:17+5
 48: $t4 := $t26                              # at closure_in_code_spec_expr.move:22:13+9
 49: trace_local[i]($t4)                      # at closure_in_code_spec_expr.move:22:13+9
 50: goto 15                                  # at closure_in_code_spec_expr.move:9:9+384
 51: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
 52: $t27 := move($t0)                        # at closure_in_code_spec_expr.move:9:9+384
 53: goto 38                                  # at closure_in_code_spec_expr.move:9:9+384
}


[variant baseline]
fun test::call_find(): bool {
     var $t0|$t4: vector<u64>
     var $t1: vector<u64>
     var $t2: vector<u64>
     var $t3: |&u64|bool has copy + drop
     var $t4: bool
     var $t5: u64
  0: $t1 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: $t0 := $t1                               # at closure_in_code_spec_expr.move:38:35+1
  2: trace_local[$t4]($t0)                    # at closure_in_code_spec_expr.move:38:35+1
  3: $t2 := copy($t0)                         # at closure_in_code_spec_expr.move:38:34+2
  4: $t3 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  5: ($t4, $t5) := test::find<u64>($t2, $t3)  # at closure_in_code_spec_expr.move:38:29+14
  6: drop($t5)                                # at closure_in_code_spec_expr.move:38:29+14
  7: trace_return[0]($t4)                     # at closure_in_code_spec_expr.move:39:9+5
  8: return $t4                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0|x: u64): bool {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     var $t4: bool
  0: trace_local[x]($t0)                      # at closure_in_code_spec_expr.move:32:5+1
  1: $t1 := move($t0)                         # at closure_in_code_spec_expr.move:33:9+2
  2: $t2 := move($t1)                         # at closure_in_code_spec_expr.move:33:9+2
  3: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  4: $t4 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
  5: trace_return[0]($t4)                     # at closure_in_code_spec_expr.move:33:9+6
  6: return $t4                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step3_mut_ref_instrumentation:
============ after processor `mut_ref_instrumentation` ================

[variant baseline]
fun test::find<#0>($t0|s: vector<#0>, $t1|f: |&#0|(bool) has copy + drop): (bool, u64) {
     var $t2|find: bool
     var $t3|found_index: u64
     var $t4|i: u64
     var $t5|len: u64
     var $t6: bool
     var $t7: u64
     var $t8: u64
     var $t9: vector<#0>
     var $t10: u64
     var $t11: u64
     var $t12: u64
     var $t13: bool
     var $t14: vector<#0>
     var $t15: u64
     var $t16: #0
     var $t17: |&#0|(bool) has copy + drop
     var $t18: bool
     var $t19: vector<#0>
     var $t20: bool
     var $t21: u64
     var $t22: bool
     var $t23: u64
     var $t24: u64
     var $t25: u64
     var $t26: u64
     var $t27: vector<#0>
  0: trace_local[s]($t0)                      # at closure_in_code_spec_expr.move:4:5+1
  1: trace_local[f]($t1)                      # at closure_in_code_spec_expr.move:4:5+1
  2: $t6 := false                             # at closure_in_code_spec_expr.move:5:20+5
  3: $t2 := $t6                               # at closure_in_code_spec_expr.move:5:20+5
  4: trace_local[find]($t2)                   # at closure_in_code_spec_expr.move:5:20+5
  5: $t7 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  6: $t3 := $t7                               # at closure_in_code_spec_expr.move:6:27+1
  7: trace_local[found_index]($t3)            # at closure_in_code_spec_expr.move:6:27+1
  8: $t8 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  9: $t4 := $t8                               # at closure_in_code_spec_expr.move:7:17+1
 10: trace_local[i]($t4)                      # at closure_in_code_spec_expr.move:7:17+1
 11: $t9 := copy($t0)                         # at closure_in_code_spec_expr.move:8:19+17
 12: $t10 := vector::length<#0>($t9)          # at closure_in_code_spec_expr.move:8:19+17
 13: $t5 := $t10                              # at closure_in_code_spec_expr.move:8:19+17
 14: trace_local[len]($t5)                    # at closure_in_code_spec_expr.move:8:19+17
 15: label L4                                 # at closure_in_code_spec_expr.move:10:13+154
 16: assert Le($t4, $t5)                      # at closure_in_code_spec_expr.move:11:17+19
 17: assert Eq<u64>($t3, 0)                   # at closure_in_code_spec_expr.move:12:17+27
 18: assert forall j: num: Range(0, $t4): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 19: $t11 := copy($t4)                        # at closure_in_code_spec_expr.move:15:13+1
 20: $t12 := copy($t5)                        # at closure_in_code_spec_expr.move:15:13+7
 21: $t13 := <($t11, $t12)                    # at closure_in_code_spec_expr.move:15:13+7
 22: if ($t13) goto 23 else goto 51           # at closure_in_code_spec_expr.move:9:9+384
 23: label L1                                 # at closure_in_code_spec_expr.move:17:34+1
 24: $t14 := copy($t0)                        # at closure_in_code_spec_expr.move:17:34+1
 25: $t15 := copy($t4)                        # at closure_in_code_spec_expr.move:17:19+20
 26: $t16 := vector::borrow<#0>($t14, $t15)   # at closure_in_code_spec_expr.move:17:19+20
 27: $t17 := copy($t1)                        # at closure_in_code_spec_expr.move:17:17+23
 28: $t18 := invoke($t16, $t17)               # at closure_in_code_spec_expr.move:17:17+23
 29: if ($t18) goto 30 else goto 44           # at closure_in_code_spec_expr.move:17:13+128
 30: label L3                                 # at closure_in_code_spec_expr.move:17:42+99
 31: $t19 := move($t0)                        # at closure_in_code_spec_expr.move:17:42+99
 32: $t20 := true                             # at closure_in_code_spec_expr.move:18:24+4
 33: $t2 := $t20                              # at closure_in_code_spec_expr.move:18:17+11
 34: trace_local[find]($t2)                   # at closure_in_code_spec_expr.move:18:17+11
 35: $t21 := move($t4)                        # at closure_in_code_spec_expr.move:19:17+15
 36: $t3 := $t21                              # at closure_in_code_spec_expr.move:19:17+15
 37: trace_local[found_index]($t3)            # at closure_in_code_spec_expr.move:19:17+15
 38: label L5                                 # at closure_in_code_spec_expr.move:24:10+4
 39: $t22 := move($t2)                        # at closure_in_code_spec_expr.move:24:10+4
 40: $t23 := move($t3)                        # at closure_in_code_spec_expr.move:24:16+11
 41: trace_return[0]($t22)                    # at closure_in_code_spec_expr.move:4:90+540
 42: trace_return[1]($t23)                    # at closure_in_code_spec_expr.move:4:90+540
 43: return ($t22, $t23)                      # at closure_in_code_spec_expr.move:4:90+540
 44: label L2                                 # at closure_in_code_spec_expr.move:22:17+1
 45: $t24 := move($t4)                        # at closure_in_code_spec_expr.move:22:17+1
 46: $t25 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 47: $t26 := +($t24, $t25)                    # at closure_in_code_spec_expr.move:22:17+5
 48: $t4 := $t26                              # at closure_in_code_spec_expr.move:22:13+9
 49: trace_local[i]($t4)                      # at closure_in_code_spec_expr.move:22:13+9
 50: goto 15                                  # at closure_in_code_spec_expr.move:9:9+384
 51: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
 52: $t27 := move($t0)                        # at closure_in_code_spec_expr.move:9:9+384
 53: goto 38                                  # at closure_in_code_spec_expr.move:9:9+384
}


[variant baseline]
fun test::call_find(): bool {
     var $t0|$t4: vector<u64>
     var $t1: vector<u64>
     var $t2: vector<u64>
     var $t3: |&u64|bool has copy + drop
     var $t4: bool
     var $t5: u64
  0: $t1 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: $t0 := $t1                               # at closure_in_code_spec_expr.move:38:35+1
  2: trace_local[$t4]($t0)                    # at closure_in_code_spec_expr.move:38:35+1
  3: $t2 := copy($t0)                         # at closure_in_code_spec_expr.move:38:34+2
  4: $t3 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  5: ($t4, $t5) := test::find<u64>($t2, $t3)  # at closure_in_code_spec_expr.move:38:29+14
  6: drop($t5)                                # at closure_in_code_spec_expr.move:38:29+14
  7: trace_return[0]($t4)                     # at closure_in_code_spec_expr.move:39:9+5
  8: return $t4                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0|x: u64): bool {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     var $t4: bool
  0: trace_local[x]($t0)                      # at closure_in_code_spec_expr.move:32:5+1
  1: $t1 := move($t0)                         # at closure_in_code_spec_expr.move:33:9+2
  2: $t2 := move($t1)                         # at closure_in_code_spec_expr.move:33:9+2
  3: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  4: $t4 := >($t2, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
  5: trace_return[0]($t4)                     # at closure_in_code_spec_expr.move:33:9+6
  6: return $t4                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step4_reaching_def_analysis:
============ after processor `reaching_def_analysis` ================

[variant baseline]
fun test::find<#0>($t0|s: vector<#0>, $t1|f: |&#0|(bool) has copy + drop): (bool, u64) {
     var $t2|find: bool
     var $t3|found_index: u64
     var $t4|i: u64
     var $t5|len: u64
     var $t6: bool
     var $t7: u64
     var $t8: u64
     var $t9: vector<#0>
     var $t10: u64
     var $t11: u64
     var $t12: u64
     var $t13: bool
     var $t14: vector<#0>
     var $t15: u64
     var $t16: #0
     var $t17: |&#0|(bool) has copy + drop
     var $t18: bool
     var $t19: vector<#0>
     var $t20: bool
     var $t21: u64
     var $t22: bool
     var $t23: u64
     var $t24: u64
     var $t25: u64
     var $t26: u64
     var $t27: vector<#0>
  0: trace_local[s]($t0)                      # at closure_in_code_spec_expr.move:4:5+1
  1: trace_local[f]($t1)                      # at closure_in_code_spec_expr.move:4:5+1
  2: $t6 := false                             # at closure_in_code_spec_expr.move:5:20+5
  3: $t2 := $t6                               # at closure_in_code_spec_expr.move:5:20+5
  4: trace_local[find]($t6)                   # at closure_in_code_spec_expr.move:5:20+5
  5: $t7 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  6: $t3 := $t7                               # at closure_in_code_spec_expr.move:6:27+1
  7: trace_local[found_index]($t7)            # at closure_in_code_spec_expr.move:6:27+1
  8: $t8 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  9: $t4 := $t8                               # at closure_in_code_spec_expr.move:7:17+1
 10: trace_local[i]($t8)                      # at closure_in_code_spec_expr.move:7:17+1
 11: $t9 := copy($t0)                         # at closure_in_code_spec_expr.move:8:19+17
 12: $t10 := vector::length<#0>($t0)          # at closure_in_code_spec_expr.move:8:19+17
 13: $t5 := $t10                              # at closure_in_code_spec_expr.move:8:19+17
 14: trace_local[len]($t10)                   # at closure_in_code_spec_expr.move:8:19+17
 15: label L4                                 # at closure_in_code_spec_expr.move:10:13+154
 16: assert Le($t4, $t10)                     # at closure_in_code_spec_expr.move:11:17+19
 17: assert Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
 18: assert forall j: num: Range(0, $t4): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 19: $t11 := copy($t4)                        # at closure_in_code_spec_expr.move:15:13+1
 20: $t12 := copy($t10)                       # at closure_in_code_spec_expr.move:15:13+7
 21: $t13 := <($t4, $t10)                     # at closure_in_code_spec_expr.move:15:13+7
 22: if ($t13) goto 23 else goto 51           # at closure_in_code_spec_expr.move:9:9+384
 23: label L1                                 # at closure_in_code_spec_expr.move:17:34+1
 24: $t14 := copy($t0)                        # at closure_in_code_spec_expr.move:17:34+1
 25: $t15 := copy($t4)                        # at closure_in_code_spec_expr.move:17:19+20
 26: $t16 := vector::borrow<#0>($t0, $t4)     # at closure_in_code_spec_expr.move:17:19+20
 27: $t17 := copy($t1)                        # at closure_in_code_spec_expr.move:17:17+23
 28: $t18 := invoke($t16, $t1)                # at closure_in_code_spec_expr.move:17:17+23
 29: if ($t18) goto 30 else goto 44           # at closure_in_code_spec_expr.move:17:13+128
 30: label L3                                 # at closure_in_code_spec_expr.move:17:42+99
 31: $t19 := move($t0)                        # at closure_in_code_spec_expr.move:17:42+99
 32: $t20 := true                             # at closure_in_code_spec_expr.move:18:24+4
 33: $t2 := $t20                              # at closure_in_code_spec_expr.move:18:17+11
 34: trace_local[find]($t20)                  # at closure_in_code_spec_expr.move:18:17+11
 35: $t21 := move($t4)                        # at closure_in_code_spec_expr.move:19:17+15
 36: $t3 := $t4                               # at closure_in_code_spec_expr.move:19:17+15
 37: trace_local[found_index]($t4)            # at closure_in_code_spec_expr.move:19:17+15
 38: label L5                                 # at closure_in_code_spec_expr.move:24:10+4
 39: $t22 := move($t2)                        # at closure_in_code_spec_expr.move:24:10+4
 40: $t23 := move($t3)                        # at closure_in_code_spec_expr.move:24:16+11
 41: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:4:90+540
 42: trace_return[1]($t3)                     # at closure_in_code_spec_expr.move:4:90+540
 43: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
 44: label L2                                 # at closure_in_code_spec_expr.move:22:17+1
 45: $t24 := move($t4)                        # at closure_in_code_spec_expr.move:22:17+1
 46: $t25 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 47: $t26 := +($t4, $t25)                     # at closure_in_code_spec_expr.move:22:17+5
 48: $t4 := $t26                              # at closure_in_code_spec_expr.move:22:13+9
 49: trace_local[i]($t26)                     # at closure_in_code_spec_expr.move:22:13+9
 50: goto 15                                  # at closure_in_code_spec_expr.move:9:9+384
 51: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
 52: $t27 := move($t0)                        # at closure_in_code_spec_expr.move:9:9+384
 53: goto 38                                  # at closure_in_code_spec_expr.move:9:9+384
}


[variant baseline]
fun test::call_find(): bool {
     var $t0|$t4: vector<u64>
     var $t1: vector<u64>
     var $t2: vector<u64>
     var $t3: |&u64|bool has copy + drop
     var $t4: bool
     var $t5: u64
  0: $t1 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: $t0 := $t1                               # at closure_in_code_spec_expr.move:38:35+1
  2: trace_local[$t4]($t1)                    # at closure_in_code_spec_expr.move:38:35+1
  3: $t2 := copy($t1)                         # at closure_in_code_spec_expr.move:38:34+2
  4: $t3 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  5: ($t4, $t5) := test::find<u64>($t1, $t3)  # at closure_in_code_spec_expr.move:38:29+14
  6: drop($t5)                                # at closure_in_code_spec_expr.move:38:29+14
  7: trace_return[0]($t4)                     # at closure_in_code_spec_expr.move:39:9+5
  8: return $t4                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0|x: u64): bool {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     var $t4: bool
  0: trace_local[x]($t0)                      # at closure_in_code_spec_expr.move:32:5+1
  1: $t1 := move($t0)                         # at closure_in_code_spec_expr.move:33:9+2
  2: $t2 := move($t0)                         # at closure_in_code_spec_expr.move:33:9+2
  3: $t3 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  4: $t4 := >($t0, $t3)                       # at closure_in_code_spec_expr.move:33:9+6
  5: trace_return[0]($t4)                     # at closure_in_code_spec_expr.move:33:9+6
  6: return $t4                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step5_livevar_analysis:
============ after processor `livevar_analysis` ================

[variant baseline]
fun test::find<#0>($t0|s: vector<#0>, $t1|f: |&#0|(bool) has copy + drop): (bool, u64) {
     var $t2|find: bool
     var $t3|found_index: u64
     var $t4|i: u64
     var $t5|len: u64 [unused]
     var $t6: bool
     var $t7: u64
     var $t8: u64
     var $t9: u64
     var $t10: bool
     var $t11: #0
     var $t12: bool
     var $t13: bool
     var $t14: u64
     var $t15: u64
     # live vars: s, f
  0: trace_local[s]($t0)                      # at closure_in_code_spec_expr.move:4:5+1
     # live vars: s, f
  1: trace_local[f]($t1)                      # at closure_in_code_spec_expr.move:4:5+1
     # live vars: s, f
  2: $t6 := false                             # at closure_in_code_spec_expr.move:5:20+5
     # live vars: s, f, $t6
  3: $t2 := $t6                               # at closure_in_code_spec_expr.move:5:20+5
     # live vars: s, f, find, $t6
  4: trace_local[find]($t6)                   # at closure_in_code_spec_expr.move:5:20+5
     # live vars: s, f, find
  5: $t7 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
     # live vars: s, f, find, $t7
  6: $t3 := $t7                               # at closure_in_code_spec_expr.move:6:27+1
     # live vars: s, f, find, found_index, $t7
  7: trace_local[found_index]($t7)            # at closure_in_code_spec_expr.move:6:27+1
     # live vars: s, f, find, found_index, $t7
  8: $t8 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
     # live vars: s, f, find, found_index, $t7, $t8
  9: $t4 := $t8                               # at closure_in_code_spec_expr.move:7:17+1
     # live vars: s, f, find, found_index, i, $t7, $t8
 10: trace_local[i]($t8)                      # at closure_in_code_spec_expr.move:7:17+1
     # live vars: s, f, find, found_index, i, $t7
 11: $t9 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
     # live vars: s, f, find, found_index, i, $t7, $t9
 12: trace_local[len]($t9)                    # at closure_in_code_spec_expr.move:8:19+17
     # live vars: s, f, find, found_index, i, $t7, $t9
 13: label L4                                 # at closure_in_code_spec_expr.move:10:13+154
     # live vars: s, f, find, found_index, i, $t7, $t9
 14: assert Le($t4, $t9)                      # at closure_in_code_spec_expr.move:11:17+19
     # live vars: s, f, find, found_index, i, $t7, $t9
 15: assert Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
     # live vars: s, f, find, found_index, i, $t7, $t9
 16: assert forall j: num: Range(0, $t4): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
     # live vars: s, f, find, found_index, i, $t7, $t9
 17: $t10 := <($t4, $t9)                      # at closure_in_code_spec_expr.move:15:13+7
     # live vars: s, f, find, found_index, i, $t7, $t9, $t10
 18: if ($t10) goto 19 else goto 39           # at closure_in_code_spec_expr.move:9:9+384
     # live vars: s, f, find, found_index, i, $t7, $t9
 19: label L1                                 # at closure_in_code_spec_expr.move:17:34+1
     # live vars: s, f, find, found_index, i, $t7, $t9
 20: $t11 := vector::borrow<#0>($t0, $t4)     # at closure_in_code_spec_expr.move:17:19+20
     # live vars: s, f, find, found_index, i, $t7, $t9, $t11
 21: $t12 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
     # live vars: s, f, find, found_index, i, $t7, $t9, $t12
 22: if ($t12) goto 23 else goto 33           # at closure_in_code_spec_expr.move:17:13+128
     # live vars: i
 23: label L3                                 # at closure_in_code_spec_expr.move:17:42+99
     # live vars: i
 24: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
     # live vars: i, $t13
 25: $t2 := $t13                              # at closure_in_code_spec_expr.move:18:17+11
     # live vars: find, i, $t13
 26: trace_local[find]($t13)                  # at closure_in_code_spec_expr.move:18:17+11
     # live vars: find, i
 27: $t3 := $t4                               # at closure_in_code_spec_expr.move:19:17+15
     # live vars: find, found_index, i
 28: trace_local[found_index]($t4)            # at closure_in_code_spec_expr.move:19:17+15
     # live vars: find, found_index
 29: label L5                                 # at closure_in_code_spec_expr.move:24:10+4
     # live vars: find, found_index
 30: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:4:90+540
     # live vars: find, found_index
 31: trace_return[1]($t3)                     # at closure_in_code_spec_expr.move:4:90+540
     # live vars: find, found_index
 32: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
     # live vars: s, f, find, found_index, i, $t7, $t9
 33: label L2                                 # at closure_in_code_spec_expr.move:22:17+1
     # live vars: s, f, find, found_index, i, $t7, $t9
 34: $t14 := 1                                # at closure_in_code_spec_expr.move:22:21+1
     # live vars: s, f, find, found_index, i, $t7, $t9, $t14
 35: $t15 := +($t4, $t14)                     # at closure_in_code_spec_expr.move:22:17+5
     # live vars: s, f, find, found_index, $t7, $t9, $t15
 36: $t4 := $t15                              # at closure_in_code_spec_expr.move:22:13+9
     # live vars: s, f, find, found_index, i, $t7, $t9, $t15
 37: trace_local[i]($t15)                     # at closure_in_code_spec_expr.move:22:13+9
     # live vars: s, f, find, found_index, i, $t7, $t9
 38: goto 13                                  # at closure_in_code_spec_expr.move:9:9+384
     # live vars: find, found_index
 39: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
     # live vars: find, found_index
 40: goto 29                                  # at closure_in_code_spec_expr.move:9:9+384
}


[variant baseline]
fun test::call_find(): bool {
     var $t0|$t4: vector<u64> [unused]
     var $t1: vector<u64>
     var $t2: |&u64|bool has copy + drop
     var $t3: bool
     var $t4: u64
     # live vars:
  0: $t1 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
     # live vars: $t1
  1: trace_local[$t4]($t1)                    # at closure_in_code_spec_expr.move:38:35+1
     # live vars: $t1
  2: $t2 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
     # live vars: $t1, $t2
  3: ($t3, $t4) := test::find<u64>($t1, $t2)  # at closure_in_code_spec_expr.move:38:29+14
     # live vars: $t3, $t4
  4: drop($t4)                                # at closure_in_code_spec_expr.move:38:29+14
     # live vars: $t3
  5: trace_return[0]($t3)                     # at closure_in_code_spec_expr.move:39:9+5
     # live vars: $t3
  6: return $t3                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0|x: u64): bool {
     var $t1: u64
     var $t2: bool
     # live vars: x
  0: trace_local[x]($t0)                      # at closure_in_code_spec_expr.move:32:5+1
     # live vars: x
  1: $t1 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
     # live vars: x, $t1
  2: $t2 := >($t0, $t1)                       # at closure_in_code_spec_expr.move:33:9+6
     # live vars: $t2
  3: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:33:9+6
     # live vars: $t2
  4: return $t2                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step6_borrow_analysis:
==== borrow analysis summaries ====

fun vector::borrow_mut[baseline]
borrowed_by: Reference($t0) -> {([], Return(0))}
borrows_from: Return(0) -> {([], Reference($t0))}

============ after processor `borrow_analysis` ================

[variant baseline]
fun test::find<#0>($t0|s: vector<#0>, $t1|f: |&#0|(bool) has copy + drop): (bool, u64) {
     var $t2|find: bool
     var $t3|found_index: u64
     var $t4|i: u64
     var $t5|len: u64 [unused]
     var $t6: bool
     var $t7: u64
     var $t8: u64
     var $t9: u64
     var $t10: bool
     var $t11: #0
     var $t12: bool
     var $t13: bool
     var $t14: u64
     var $t15: u64
     # live_nodes: LocalRoot($t0), LocalRoot($t1)
  0: trace_local[s]($t0)                      # at closure_in_code_spec_expr.move:4:5+1
     # live_nodes: LocalRoot($t0), LocalRoot($t1)
  1: trace_local[f]($t1)                      # at closure_in_code_spec_expr.move:4:5+1
     # live_nodes: LocalRoot($t0), LocalRoot($t1)
  2: $t6 := false                             # at closure_in_code_spec_expr.move:5:20+5
     # live_nodes: LocalRoot($t0), LocalRoot($t1)
  3: $t2 := $t6                               # at closure_in_code_spec_expr.move:5:20+5
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2)
  4: trace_local[find]($t6)                   # at closure_in_code_spec_expr.move:5:20+5
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2)
  5: $t7 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2)
  6: $t3 := $t7                               # at closure_in_code_spec_expr.move:6:27+1
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3)
  7: trace_local[found_index]($t7)            # at closure_in_code_spec_expr.move:6:27+1
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3)
  8: $t8 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3)
  9: $t4 := $t8                               # at closure_in_code_spec_expr.move:7:17+1
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 10: trace_local[i]($t8)                      # at closure_in_code_spec_expr.move:7:17+1
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 11: $t9 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 12: trace_local[len]($t9)                    # at closure_in_code_spec_expr.move:8:19+17
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 13: label L4                                 # at closure_in_code_spec_expr.move:10:13+154
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 14: assert Le($t4, $t9)                      # at closure_in_code_spec_expr.move:11:17+19
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 15: assert Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 16: assert forall j: num: Range(0, $t4): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 17: $t10 := <($t4, $t9)                      # at closure_in_code_spec_expr.move:15:13+7
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 18: if ($t10) goto 19 else goto 39           # at closure_in_code_spec_expr.move:9:9+384
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 19: label L1                                 # at closure_in_code_spec_expr.move:17:34+1
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 20: $t11 := vector::borrow<#0>($t0, $t4)     # at closure_in_code_spec_expr.move:17:19+20
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 21: $t12 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 22: if ($t12) goto 23 else goto 33           # at closure_in_code_spec_expr.move:17:13+128
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 23: label L3                                 # at closure_in_code_spec_expr.move:17:42+99
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 24: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 25: $t2 := $t13                              # at closure_in_code_spec_expr.move:18:17+11
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 26: trace_local[find]($t13)                  # at closure_in_code_spec_expr.move:18:17+11
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 27: $t3 := $t4                               # at closure_in_code_spec_expr.move:19:17+15
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 28: trace_local[found_index]($t4)            # at closure_in_code_spec_expr.move:19:17+15
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 29: label L5                                 # at closure_in_code_spec_expr.move:24:10+4
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 30: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:4:90+540
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 31: trace_return[1]($t3)                     # at closure_in_code_spec_expr.move:4:90+540
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 32: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 33: label L2                                 # at closure_in_code_spec_expr.move:22:17+1
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 34: $t14 := 1                                # at closure_in_code_spec_expr.move:22:21+1
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 35: $t15 := +($t4, $t14)                     # at closure_in_code_spec_expr.move:22:17+5
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 36: $t4 := $t15                              # at closure_in_code_spec_expr.move:22:13+9
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 37: trace_local[i]($t15)                     # at closure_in_code_spec_expr.move:22:13+9
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 38: goto 13                                  # at closure_in_code_spec_expr.move:9:9+384
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 39: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
     # live_nodes: LocalRoot($t0), LocalRoot($t1), LocalRoot($t2), LocalRoot($t3), LocalRoot($t4)
 40: goto 29                                  # at closure_in_code_spec_expr.move:9:9+384
}


[variant baseline]
fun test::call_find(): bool {
     var $t0|$t4: vector<u64> [unused]
     var $t1: vector<u64>
     var $t2: |&u64|bool has copy + drop
     var $t3: bool
     var $t4: u64
  0: $t1 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: trace_local[$t4]($t1)                    # at closure_in_code_spec_expr.move:38:35+1
  2: $t2 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  3: ($t3, $t4) := test::find<u64>($t1, $t2)  # at closure_in_code_spec_expr.move:38:29+14
  4: drop($t4)                                # at closure_in_code_spec_expr.move:38:29+14
  5: trace_return[0]($t3)                     # at closure_in_code_spec_expr.move:39:9+5
  6: return $t3                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0|x: u64): bool {
     var $t1: u64
     var $t2: bool
     # live_nodes: LocalRoot($t0)
  0: trace_local[x]($t0)                      # at closure_in_code_spec_expr.move:32:5+1
     # live_nodes: LocalRoot($t0)
  1: $t1 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
     # live_nodes: LocalRoot($t0)
  2: $t2 := >($t0, $t1)                       # at closure_in_code_spec_expr.move:33:9+6
     # live_nodes: LocalRoot($t0)
  3: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:33:9+6
     # live_nodes: LocalRoot($t0)
  4: return $t2                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step7_memory_instr:
============ after processor `memory_instr` ================

[variant baseline]
fun test::find<#0>($t0|s: vector<#0>, $t1|f: |&#0|(bool) has copy + drop): (bool, u64) {
     var $t2|find: bool
     var $t3|found_index: u64
     var $t4|i: u64
     var $t5|len: u64 [unused]
     var $t6: bool
     var $t7: u64
     var $t8: u64
     var $t9: u64
     var $t10: bool
     var $t11: #0
     var $t12: bool
     var $t13: bool
     var $t14: u64
     var $t15: u64
  0: trace_local[s]($t0)                      # at closure_in_code_spec_expr.move:4:5+1
  1: trace_local[f]($t1)                      # at closure_in_code_spec_expr.move:4:5+1
  2: $t6 := false                             # at closure_in_code_spec_expr.move:5:20+5
  3: $t2 := $t6                               # at closure_in_code_spec_expr.move:5:20+5
  4: trace_local[find]($t6)                   # at closure_in_code_spec_expr.move:5:20+5
  5: $t7 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  6: $t3 := $t7                               # at closure_in_code_spec_expr.move:6:27+1
  7: trace_local[found_index]($t7)            # at closure_in_code_spec_expr.move:6:27+1
  8: $t8 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  9: $t4 := $t8                               # at closure_in_code_spec_expr.move:7:17+1
 10: trace_local[i]($t8)                      # at closure_in_code_spec_expr.move:7:17+1
 11: $t9 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
 12: trace_local[len]($t9)                    # at closure_in_code_spec_expr.move:8:19+17
 13: label L4                                 # at closure_in_code_spec_expr.move:10:13+154
 14: assert Le($t4, $t9)                      # at closure_in_code_spec_expr.move:11:17+19
 15: assert Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
 16: assert forall j: num: Range(0, $t4): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 17: $t10 := <($t4, $t9)                      # at closure_in_code_spec_expr.move:15:13+7
 18: if ($t10) goto 19 else goto 39           # at closure_in_code_spec_expr.move:9:9+384
 19: label L1                                 # at closure_in_code_spec_expr.move:17:34+1
 20: $t11 := vector::borrow<#0>($t0, $t4)     # at closure_in_code_spec_expr.move:17:19+20
 21: $t12 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
 22: if ($t12) goto 23 else goto 33           # at closure_in_code_spec_expr.move:17:13+128
 23: label L3                                 # at closure_in_code_spec_expr.move:17:42+99
 24: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
 25: $t2 := $t13                              # at closure_in_code_spec_expr.move:18:17+11
 26: trace_local[find]($t13)                  # at closure_in_code_spec_expr.move:18:17+11
 27: $t3 := $t4                               # at closure_in_code_spec_expr.move:19:17+15
 28: trace_local[found_index]($t4)            # at closure_in_code_spec_expr.move:19:17+15
 29: label L5                                 # at closure_in_code_spec_expr.move:24:10+4
 30: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:4:90+540
 31: trace_return[1]($t3)                     # at closure_in_code_spec_expr.move:4:90+540
 32: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
 33: label L2                                 # at closure_in_code_spec_expr.move:22:17+1
 34: $t14 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 35: $t15 := +($t4, $t14)                     # at closure_in_code_spec_expr.move:22:17+5
 36: $t4 := $t15                              # at closure_in_code_spec_expr.move:22:13+9
 37: trace_local[i]($t15)                     # at closure_in_code_spec_expr.move:22:13+9
 38: goto 13                                  # at closure_in_code_spec_expr.move:9:9+384
 39: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
 40: goto 29                                  # at closure_in_code_spec_expr.move:9:9+384
}


[variant baseline]
fun test::call_find(): bool {
     var $t0|$t4: vector<u64> [unused]
     var $t1: vector<u64>
     var $t2: |&u64|bool has copy + drop
     var $t3: bool
     var $t4: u64
  0: $t1 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: trace_local[$t4]($t1)                    # at closure_in_code_spec_expr.move:38:35+1
  2: $t2 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  3: ($t3, $t4) := test::find<u64>($t1, $t2)  # at closure_in_code_spec_expr.move:38:29+14
  4: drop($t4)                                # at closure_in_code_spec_expr.move:38:29+14
  5: trace_return[0]($t3)                     # at closure_in_code_spec_expr.move:39:9+5
  6: return $t3                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0|x: u64): bool {
     var $t1: u64
     var $t2: bool
  0: trace_local[x]($t0)                      # at closure_in_code_spec_expr.move:32:5+1
  1: $t1 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t2 := >($t0, $t1)                       # at closure_in_code_spec_expr.move:33:9+6
  3: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:33:9+6
  4: return $t2                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step8_clean_and_optimize:
============ after processor `clean_and_optimize` ================

[variant baseline]
fun test::find<#0>($t0|s: vector<#0>, $t1|f: |&#0|(bool) has copy + drop): (bool, u64) {
     var $t2|find: bool
     var $t3|found_index: u64
     var $t4|i: u64
     var $t5|len: u64 [unused]
     var $t6: bool
     var $t7: u64
     var $t8: u64
     var $t9: u64
     var $t10: bool
     var $t11: #0
     var $t12: bool
     var $t13: bool
     var $t14: u64
     var $t15: u64
  0: trace_local[s]($t0)                      # at closure_in_code_spec_expr.move:4:5+1
  1: trace_local[f]($t1)                      # at closure_in_code_spec_expr.move:4:5+1
  2: $t6 := false                             # at closure_in_code_spec_expr.move:5:20+5
  3: $t2 := $t6                               # at closure_in_code_spec_expr.move:5:20+5
  4: trace_local[find]($t6)                   # at closure_in_code_spec_expr.move:5:20+5
  5: $t7 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  6: $t3 := $t7                               # at closure_in_code_spec_expr.move:6:27+1
  7: trace_local[found_index]($t7)            # at closure_in_code_spec_expr.move:6:27+1
  8: $t8 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  9: $t4 := $t8                               # at closure_in_code_spec_expr.move:7:17+1
 10: trace_local[i]($t8)                      # at closure_in_code_spec_expr.move:7:17+1
 11: $t9 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
 12: trace_local[len]($t9)                    # at closure_in_code_spec_expr.move:8:19+17
 13: label L4                                 # at closure_in_code_spec_expr.move:10:13+154
 14: assert Le($t4, $t9)                      # at closure_in_code_spec_expr.move:11:17+19
 15: assert Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
 16: assert forall j: num: Range(0, $t4): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 17: $t10 := <($t4, $t9)                      # at closure_in_code_spec_expr.move:15:13+7
 18: if ($t10) goto 19 else goto 39           # at closure_in_code_spec_expr.move:9:9+384
 19: label L1                                 # at closure_in_code_spec_expr.move:17:34+1
 20: $t11 := vector::borrow<#0>($t0, $t4)     # at closure_in_code_spec_expr.move:17:19+20
 21: $t12 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
 22: if ($t12) goto 23 else goto 33           # at closure_in_code_spec_expr.move:17:13+128
 23: label L3                                 # at closure_in_code_spec_expr.move:17:42+99
 24: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
 25: $t2 := $t13                              # at closure_in_code_spec_expr.move:18:17+11
 26: trace_local[find]($t13)                  # at closure_in_code_spec_expr.move:18:17+11
 27: $t3 := $t4                               # at closure_in_code_spec_expr.move:19:17+15
 28: trace_local[found_index]($t4)            # at closure_in_code_spec_expr.move:19:17+15
 29: label L5                                 # at closure_in_code_spec_expr.move:24:10+4
 30: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:4:90+540
 31: trace_return[1]($t3)                     # at closure_in_code_spec_expr.move:4:90+540
 32: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
 33: label L2                                 # at closure_in_code_spec_expr.move:22:17+1
 34: $t14 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 35: $t15 := +($t4, $t14)                     # at closure_in_code_spec_expr.move:22:17+5
 36: $t4 := $t15                              # at closure_in_code_spec_expr.move:22:13+9
 37: trace_local[i]($t15)                     # at closure_in_code_spec_expr.move:22:13+9
 38: goto 13                                  # at closure_in_code_spec_expr.move:9:9+384
 39: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
 40: goto 29                                  # at closure_in_code_spec_expr.move:9:9+384
}


[variant baseline]
fun test::call_find(): bool {
     var $t0|$t4: vector<u64> [unused]
     var $t1: vector<u64>
     var $t2: |&u64|bool has copy + drop
     var $t3: bool
     var $t4: u64
  0: $t1 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: trace_local[$t4]($t1)                    # at closure_in_code_spec_expr.move:38:35+1
  2: $t2 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  3: ($t3, $t4) := test::find<u64>($t1, $t2)  # at closure_in_code_spec_expr.move:38:29+14
  4: drop($t4)                                # at closure_in_code_spec_expr.move:38:29+14
  5: trace_return[0]($t3)                     # at closure_in_code_spec_expr.move:39:9+5
  6: return $t3                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0|x: u64): bool {
     var $t1: u64
     var $t2: bool
  0: trace_local[x]($t0)                      # at closure_in_code_spec_expr.move:32:5+1
  1: $t1 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t2 := >($t0, $t1)                       # at closure_in_code_spec_expr.move:33:9+6
  3: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:33:9+6
  4: return $t2                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step9_usage_analysis:
********* Result of usage analysis *********


function test::find [baseline] {
  accessed = {}
  directly accessed = {}
  modified = {}
  directly modified = {}
  assumed = {}
  directly assumed = {}
  asserted = {}
  directly asserted = {}
}
function test::call_find [baseline] {
  accessed = {}
  directly accessed = {}
  modified = {}
  directly modified = {}
  assumed = {}
  directly assumed = {}
  asserted = {}
  directly asserted = {}
}
function test::pred [baseline] {
  accessed = {}
  directly accessed = {}
  modified = {}
  directly modified = {}
  assumed = {}
  directly assumed = {}
  asserted = {}
  directly asserted = {}
}

============ after processor `usage_analysis` ================

[variant baseline]
fun test::find<#0>($t0|s: vector<#0>, $t1|f: |&#0|(bool) has copy + drop): (bool, u64) {
     var $t2|find: bool
     var $t3|found_index: u64
     var $t4|i: u64
     var $t5|len: u64 [unused]
     var $t6: bool
     var $t7: u64
     var $t8: u64
     var $t9: u64
     var $t10: bool
     var $t11: #0
     var $t12: bool
     var $t13: bool
     var $t14: u64
     var $t15: u64
  0: trace_local[s]($t0)                      # at closure_in_code_spec_expr.move:4:5+1
  1: trace_local[f]($t1)                      # at closure_in_code_spec_expr.move:4:5+1
  2: $t6 := false                             # at closure_in_code_spec_expr.move:5:20+5
  3: $t2 := $t6                               # at closure_in_code_spec_expr.move:5:20+5
  4: trace_local[find]($t6)                   # at closure_in_code_spec_expr.move:5:20+5
  5: $t7 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  6: $t3 := $t7                               # at closure_in_code_spec_expr.move:6:27+1
  7: trace_local[found_index]($t7)            # at closure_in_code_spec_expr.move:6:27+1
  8: $t8 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  9: $t4 := $t8                               # at closure_in_code_spec_expr.move:7:17+1
 10: trace_local[i]($t8)                      # at closure_in_code_spec_expr.move:7:17+1
 11: $t9 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
 12: trace_local[len]($t9)                    # at closure_in_code_spec_expr.move:8:19+17
 13: label L4                                 # at closure_in_code_spec_expr.move:10:13+154
 14: assert Le($t4, $t9)                      # at closure_in_code_spec_expr.move:11:17+19
 15: assert Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
 16: assert forall j: num: Range(0, $t4): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 17: $t10 := <($t4, $t9)                      # at closure_in_code_spec_expr.move:15:13+7
 18: if ($t10) goto 19 else goto 39           # at closure_in_code_spec_expr.move:9:9+384
 19: label L1                                 # at closure_in_code_spec_expr.move:17:34+1
 20: $t11 := vector::borrow<#0>($t0, $t4)     # at closure_in_code_spec_expr.move:17:19+20
 21: $t12 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
 22: if ($t12) goto 23 else goto 33           # at closure_in_code_spec_expr.move:17:13+128
 23: label L3                                 # at closure_in_code_spec_expr.move:17:42+99
 24: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
 25: $t2 := $t13                              # at closure_in_code_spec_expr.move:18:17+11
 26: trace_local[find]($t13)                  # at closure_in_code_spec_expr.move:18:17+11
 27: $t3 := $t4                               # at closure_in_code_spec_expr.move:19:17+15
 28: trace_local[found_index]($t4)            # at closure_in_code_spec_expr.move:19:17+15
 29: label L5                                 # at closure_in_code_spec_expr.move:24:10+4
 30: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:4:90+540
 31: trace_return[1]($t3)                     # at closure_in_code_spec_expr.move:4:90+540
 32: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
 33: label L2                                 # at closure_in_code_spec_expr.move:22:17+1
 34: $t14 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 35: $t15 := +($t4, $t14)                     # at closure_in_code_spec_expr.move:22:17+5
 36: $t4 := $t15                              # at closure_in_code_spec_expr.move:22:13+9
 37: trace_local[i]($t15)                     # at closure_in_code_spec_expr.move:22:13+9
 38: goto 13                                  # at closure_in_code_spec_expr.move:9:9+384
 39: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
 40: goto 29                                  # at closure_in_code_spec_expr.move:9:9+384
}


[variant baseline]
fun test::call_find(): bool {
     var $t0|$t4: vector<u64> [unused]
     var $t1: vector<u64>
     var $t2: |&u64|bool has copy + drop
     var $t3: bool
     var $t4: u64
  0: $t1 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: trace_local[$t4]($t1)                    # at closure_in_code_spec_expr.move:38:35+1
  2: $t2 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  3: ($t3, $t4) := test::find<u64>($t1, $t2)  # at closure_in_code_spec_expr.move:38:29+14
  4: drop($t4)                                # at closure_in_code_spec_expr.move:38:29+14
  5: trace_return[0]($t3)                     # at closure_in_code_spec_expr.move:39:9+5
  6: return $t3                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0|x: u64): bool {
     var $t1: u64
     var $t2: bool
  0: trace_local[x]($t0)                      # at closure_in_code_spec_expr.move:32:5+1
  1: $t1 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t2 := >($t0, $t1)                       # at closure_in_code_spec_expr.move:33:9+6
  3: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:33:9+6
  4: return $t2                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step10_verification_analysis:
********* Result of verification analysis *********

functions that defer invariant checking at return: [
]

functions that delegate invariants to its callers: [
]

invariant applicability: [
  vector::contains: {
    accessed: []
    modified: []
    directly accessed: []
    directly modified: []
  }
  vector::index_of: {
    accessed: []
    modified: []
    directly accessed: []
    directly modified: []
  }
  vector::append: {
    accessed: []
    modified: []
    directly accessed: []
    directly modified: []
  }
  vector::borrow: {
    accessed: []
    modified: []
    directly accessed: []
    directly modified: []
  }
  vector::borrow_mut: {
    accessed: []
    modified: []
    directly accessed: []
    directly modified: []
  }
  vector::destroy_empty: {
    accessed: []
    modified: []
    directly accessed: []
    directly modified: []
  }
  vector::empty: {
    accessed: []
    modified: []
    directly accessed: []
    directly modified: []
  }
  vector::is_empty: {
    accessed: []
    modified: []
    directly accessed: []
    directly modified: []
  }
  vector::length: {
    accessed: []
    modified: []
    directly accessed: []
    directly modified: []
  }
  vector::pop_back: {
    accessed: []
    modified: []
    directly accessed: []
    directly modified: []
  }
  vector::push_back: {
    accessed: []
    modified: []
    directly accessed: []
    directly modified: []
  }
  vector::remove: {
    accessed: []
    modified: []
    directly accessed: []
    directly modified: []
  }
  vector::reverse: {
    accessed: []
    modified: []
    directly accessed: []
    directly modified: []
  }
  vector::singleton: {
    accessed: []
    modified: []
    directly accessed: []
    directly modified: []
  }
  vector::swap: {
    accessed: []
    modified: []
    directly accessed: []
    directly modified: []
  }
  vector::swap_remove: {
    accessed: []
    modified: []
    directly accessed: []
    directly modified: []
  }
  test::find: {
    accessed: []
    modified: []
    directly accessed: []
    directly modified: []
  }
  test::call_find: {
    accessed: []
    modified: []
    directly accessed: []
    directly modified: []
  }
  test::pred: {
    accessed: []
    modified: []
    directly accessed: []
    directly modified: []
  }
]

verification analysis: [
  vector::contains: inlined
  vector::index_of: inlined
  vector::append: inlined
  vector::borrow: inlined
  vector::borrow_mut: inlined
  vector::destroy_empty: inlined
  vector::empty: inlined
  vector::is_empty: inlined
  vector::length: inlined
  vector::pop_back: inlined
  vector::push_back: inlined
  vector::remove: inlined
  vector::reverse: inlined
  vector::singleton: inlined
  vector::swap: inlined
  vector::swap_remove: inlined
  test::find: verified
  test::call_find: verified
  test::pred: verified + inlined
]
============ after processor `verification_analysis` ================

[variant baseline]
fun test::find<#0>($t0|s: vector<#0>, $t1|f: |&#0|(bool) has copy + drop): (bool, u64) {
     var $t2|find: bool
     var $t3|found_index: u64
     var $t4|i: u64
     var $t5|len: u64 [unused]
     var $t6: bool
     var $t7: u64
     var $t8: u64
     var $t9: u64
     var $t10: bool
     var $t11: #0
     var $t12: bool
     var $t13: bool
     var $t14: u64
     var $t15: u64
  0: trace_local[s]($t0)                      # at closure_in_code_spec_expr.move:4:5+1
  1: trace_local[f]($t1)                      # at closure_in_code_spec_expr.move:4:5+1
  2: $t6 := false                             # at closure_in_code_spec_expr.move:5:20+5
  3: $t2 := $t6                               # at closure_in_code_spec_expr.move:5:20+5
  4: trace_local[find]($t6)                   # at closure_in_code_spec_expr.move:5:20+5
  5: $t7 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  6: $t3 := $t7                               # at closure_in_code_spec_expr.move:6:27+1
  7: trace_local[found_index]($t7)            # at closure_in_code_spec_expr.move:6:27+1
  8: $t8 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  9: $t4 := $t8                               # at closure_in_code_spec_expr.move:7:17+1
 10: trace_local[i]($t8)                      # at closure_in_code_spec_expr.move:7:17+1
 11: $t9 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
 12: trace_local[len]($t9)                    # at closure_in_code_spec_expr.move:8:19+17
 13: label L4                                 # at closure_in_code_spec_expr.move:10:13+154
 14: assert Le($t4, $t9)                      # at closure_in_code_spec_expr.move:11:17+19
 15: assert Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
 16: assert forall j: num: Range(0, $t4): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 17: $t10 := <($t4, $t9)                      # at closure_in_code_spec_expr.move:15:13+7
 18: if ($t10) goto 19 else goto 39           # at closure_in_code_spec_expr.move:9:9+384
 19: label L1                                 # at closure_in_code_spec_expr.move:17:34+1
 20: $t11 := vector::borrow<#0>($t0, $t4)     # at closure_in_code_spec_expr.move:17:19+20
 21: $t12 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
 22: if ($t12) goto 23 else goto 33           # at closure_in_code_spec_expr.move:17:13+128
 23: label L3                                 # at closure_in_code_spec_expr.move:17:42+99
 24: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
 25: $t2 := $t13                              # at closure_in_code_spec_expr.move:18:17+11
 26: trace_local[find]($t13)                  # at closure_in_code_spec_expr.move:18:17+11
 27: $t3 := $t4                               # at closure_in_code_spec_expr.move:19:17+15
 28: trace_local[found_index]($t4)            # at closure_in_code_spec_expr.move:19:17+15
 29: label L5                                 # at closure_in_code_spec_expr.move:24:10+4
 30: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:4:90+540
 31: trace_return[1]($t3)                     # at closure_in_code_spec_expr.move:4:90+540
 32: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
 33: label L2                                 # at closure_in_code_spec_expr.move:22:17+1
 34: $t14 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 35: $t15 := +($t4, $t14)                     # at closure_in_code_spec_expr.move:22:17+5
 36: $t4 := $t15                              # at closure_in_code_spec_expr.move:22:13+9
 37: trace_local[i]($t15)                     # at closure_in_code_spec_expr.move:22:13+9
 38: goto 13                                  # at closure_in_code_spec_expr.move:9:9+384
 39: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
 40: goto 29                                  # at closure_in_code_spec_expr.move:9:9+384
}


[variant baseline]
fun test::call_find(): bool {
     var $t0|$t4: vector<u64> [unused]
     var $t1: vector<u64>
     var $t2: |&u64|bool has copy + drop
     var $t3: bool
     var $t4: u64
  0: $t1 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: trace_local[$t4]($t1)                    # at closure_in_code_spec_expr.move:38:35+1
  2: $t2 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  3: ($t3, $t4) := test::find<u64>($t1, $t2)  # at closure_in_code_spec_expr.move:38:29+14
  4: drop($t4)                                # at closure_in_code_spec_expr.move:38:29+14
  5: trace_return[0]($t3)                     # at closure_in_code_spec_expr.move:39:9+5
  6: return $t3                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0|x: u64): bool {
     var $t1: u64
     var $t2: bool
  0: trace_local[x]($t0)                      # at closure_in_code_spec_expr.move:32:5+1
  1: $t1 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t2 := >($t0, $t1)                       # at closure_in_code_spec_expr.move:33:9+6
  3: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:33:9+6
  4: return $t2                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step11_loop_analysis:
============ after processor `loop_analysis` ================

[variant baseline]
fun test::find<#0>($t0|s: vector<#0>, $t1|f: |&#0|(bool) has copy + drop): (bool, u64) {
     var $t2|find: bool
     var $t3|found_index: u64
     var $t4|i: u64
     var $t5|len: u64 [unused]
     var $t6: bool
     var $t7: u64
     var $t8: u64
     var $t9: u64
     var $t10: bool
     var $t11: #0
     var $t12: bool
     var $t13: bool
     var $t14: u64
     var $t15: u64
  0: trace_local[s]($t0)                      # at closure_in_code_spec_expr.move:4:5+1
  1: trace_local[f]($t1)                      # at closure_in_code_spec_expr.move:4:5+1
  2: $t6 := false                             # at closure_in_code_spec_expr.move:5:20+5
  3: $t2 := $t6                               # at closure_in_code_spec_expr.move:5:20+5
  4: trace_local[find]($t6)                   # at closure_in_code_spec_expr.move:5:20+5
  5: $t7 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  6: $t3 := $t7                               # at closure_in_code_spec_expr.move:6:27+1
  7: trace_local[found_index]($t7)            # at closure_in_code_spec_expr.move:6:27+1
  8: $t8 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  9: $t4 := $t8                               # at closure_in_code_spec_expr.move:7:17+1
 10: trace_local[i]($t8)                      # at closure_in_code_spec_expr.move:7:17+1
 11: $t9 := vector::length<#0>($t0)           # at closure_in_code_spec_expr.move:8:19+17
 12: trace_local[len]($t9)                    # at closure_in_code_spec_expr.move:8:19+17
 13: label L4                                 # at closure_in_code_spec_expr.move:10:13+154
     # VC: base case of the loop invariant does not hold at closure_in_code_spec_expr.move:11:17+19
 14: assert Le($t4, $t9)                      # at closure_in_code_spec_expr.move:11:17+19
     # VC: base case of the loop invariant does not hold at closure_in_code_spec_expr.move:12:17+27
 15: assert Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
     # VC: base case of the loop invariant does not hold at closure_in_code_spec_expr.move:13:17+37
 16: assert forall j: num: Range(0, $t4): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 17: $t4 := havoc[val]()                      # at closure_in_code_spec_expr.move:13:17+37
 18: assume WellFormed($t4)                   # at closure_in_code_spec_expr.move:13:17+37
 19: $t10 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 20: assume WellFormed($t10)                  # at closure_in_code_spec_expr.move:13:17+37
 21: $t11 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 22: assume WellFormed($t11)                  # at closure_in_code_spec_expr.move:13:17+37
 23: $t12 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 24: assume WellFormed($t12)                  # at closure_in_code_spec_expr.move:13:17+37
 25: $t14 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 26: assume WellFormed($t14)                  # at closure_in_code_spec_expr.move:13:17+37
 27: $t15 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 28: assume WellFormed($t15)                  # at closure_in_code_spec_expr.move:13:17+37
     # info: enter loop, variable(s) i havocked and reassigned
 29: trace_local[i]($t4)                      # at closure_in_code_spec_expr.move:13:17+37
     # info: loop invariant holds at current state
 30: assume Not(AbortFlag())                  # at closure_in_code_spec_expr.move:13:17+37
 31: assume Le($t4, $t9)                      # at closure_in_code_spec_expr.move:11:17+19
 32: assume Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
 33: assume forall j: num: Range(0, $t4): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 34: $t10 := <($t4, $t9)                      # at closure_in_code_spec_expr.move:15:13+7
 35: if ($t10) goto 36 else goto 56           # at closure_in_code_spec_expr.move:9:9+384
 36: label L1                                 # at closure_in_code_spec_expr.move:17:34+1
 37: $t11 := vector::borrow<#0>($t0, $t4)     # at closure_in_code_spec_expr.move:17:19+20
 38: $t12 := invoke($t11, $t1)                # at closure_in_code_spec_expr.move:17:17+23
 39: if ($t12) goto 40 else goto 50           # at closure_in_code_spec_expr.move:17:13+128
 40: label L3                                 # at closure_in_code_spec_expr.move:17:42+99
 41: $t13 := true                             # at closure_in_code_spec_expr.move:18:24+4
 42: $t2 := $t13                              # at closure_in_code_spec_expr.move:18:17+11
 43: trace_local[find]($t13)                  # at closure_in_code_spec_expr.move:18:17+11
 44: $t3 := $t4                               # at closure_in_code_spec_expr.move:19:17+15
 45: trace_local[found_index]($t4)            # at closure_in_code_spec_expr.move:19:17+15
 46: label L5                                 # at closure_in_code_spec_expr.move:24:10+4
 47: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:4:90+540
 48: trace_return[1]($t3)                     # at closure_in_code_spec_expr.move:4:90+540
 49: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:4:90+540
 50: label L2                                 # at closure_in_code_spec_expr.move:22:17+1
 51: $t14 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 52: $t15 := +($t4, $t14)                     # at closure_in_code_spec_expr.move:22:17+5
 53: $t4 := $t15                              # at closure_in_code_spec_expr.move:22:13+9
 54: trace_local[i]($t15)                     # at closure_in_code_spec_expr.move:22:13+9
 55: goto 58                                  # at closure_in_code_spec_expr.move:9:9+384
 56: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
 57: goto 46                                  # at closure_in_code_spec_expr.move:9:9+384
     # Loop invariant checking block for the loop started with header: L4
 58: label L6                                 # at closure_in_code_spec_expr.move:9:9+384
     # VC: induction case of the loop invariant does not hold at closure_in_code_spec_expr.move:11:17+19
 59: assert Le($t4, $t9)                      # at closure_in_code_spec_expr.move:11:17+19
     # VC: induction case of the loop invariant does not hold at closure_in_code_spec_expr.move:12:17+27
 60: assert Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
     # VC: induction case of the loop invariant does not hold at closure_in_code_spec_expr.move:13:17+37
 61: assert forall j: num: Range(0, $t4): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 62: stop()                                   # at closure_in_code_spec_expr.move:13:17+37
}


[variant baseline]
fun test::call_find(): bool {
     var $t0|$t4: vector<u64> [unused]
     var $t1: vector<u64>
     var $t2: |&u64|bool has copy + drop
     var $t3: bool
     var $t4: u64
  0: $t1 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: trace_local[$t4]($t1)                    # at closure_in_code_spec_expr.move:38:35+1
  2: $t2 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  3: ($t3, $t4) := test::find<u64>($t1, $t2)  # at closure_in_code_spec_expr.move:38:29+14
  4: drop($t4)                                # at closure_in_code_spec_expr.move:38:29+14
  5: trace_return[0]($t3)                     # at closure_in_code_spec_expr.move:39:9+5
  6: return $t3                               # at closure_in_code_spec_expr.move:39:9+5
}


[variant baseline]
fun test::pred($t0|x: u64): bool {
     var $t1: u64
     var $t2: bool
  0: trace_local[x]($t0)                      # at closure_in_code_spec_expr.move:32:5+1
  1: $t1 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t2 := >($t0, $t1)                       # at closure_in_code_spec_expr.move:33:9+6
  3: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:33:9+6
  4: return $t2                               # at closure_in_code_spec_expr.move:33:9+6
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step12_spec_instrumenter:
==== spec-instrumenter input specs ====

fun test::find[baseline]
spec {
  ensures Iff(result0(), exists i: num: RangeVec<#0>($t0): ($t1)(Index($t0, i)));
  ensures Implies(result0(), And(($t1)(Index($t0, result1())), forall i: num: Range(0, result1()): Not(($t1)(Index($t0, i)))));
}
9 -> spec {
  invariant Le($t4, $t5);
  invariant Eq<u64>($t3, 0);
  invariant forall j: num: Range(0, $t4): Not(($t1)(Index($t0, j)));
}


fun test::find[verification]
spec {
  ensures Iff(result0(), exists i: num: RangeVec<#0>($t0): ($t1)(Index($t0, i)));
  ensures Implies(result0(), And(($t1)(Index($t0, result1())), forall i: num: Range(0, result1()): Not(($t1)(Index($t0, i)))));
}
9 -> spec {
  invariant Le($t4, $t5);
  invariant Eq<u64>($t3, 0);
  invariant forall j: num: Range(0, $t4): Not(($t1)(Index($t0, j)));
}


fun test::call_find[baseline]
spec {
  ensures Not(result0());
}

fun test::call_find[verification]
spec {
  ensures Not(result0());
}

============ after processor `spec_instrumenter` ================

[variant verification]
fun test::find<#0>($t0|s: vector<#0>, $t1|f: |&#0|(bool) has copy + drop): (bool, u64) {
     var $t2|find: bool
     var $t3|found_index: u64
     var $t4|i: u64
     var $t5|len: u64
     var $t6: bool
     var $t7: u64
     var $t8: u64
     var $t9: u64
     var $t10: num
     var $t11: bool
     var $t12: #0
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: bool
  0: trace_local[s]($t0)                      # at closure_in_code_spec_expr.move:4:5+1
  1: trace_local[f]($t1)                      # at closure_in_code_spec_expr.move:4:5+1
  2: $t6 := false                             # at closure_in_code_spec_expr.move:5:20+5
  3: $t2 := $t6                               # at closure_in_code_spec_expr.move:5:20+5
  4: trace_local[find]($t6)                   # at closure_in_code_spec_expr.move:5:20+5
  5: $t7 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  6: $t3 := $t7                               # at closure_in_code_spec_expr.move:6:27+1
  7: trace_local[found_index]($t7)            # at closure_in_code_spec_expr.move:6:27+1
  8: $t8 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  9: trace_local[i]($t8)                      # at closure_in_code_spec_expr.move:7:17+1
 10: $t9 := vector::length<#0>($t0) on_abort goto 65 with $t10 # at closure_in_code_spec_expr.move:8:19+17
 11: trace_local[len]($t9)                    # at closure_in_code_spec_expr.move:8:19+17
 12: label L4                                 # at closure_in_code_spec_expr.move:10:13+154
     # VC: base case of the loop invariant does not hold at closure_in_code_spec_expr.move:11:17+19
 13: assert Le($t8, $t9)                      # at closure_in_code_spec_expr.move:11:17+19
     # VC: base case of the loop invariant does not hold at closure_in_code_spec_expr.move:12:17+27
 14: assert Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
     # VC: base case of the loop invariant does not hold at closure_in_code_spec_expr.move:13:17+37
 15: assert forall j: num: Range(0, $t8): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 16: $t4 := havoc[val]()                      # at closure_in_code_spec_expr.move:13:17+37
 17: assume WellFormed($t4)                   # at closure_in_code_spec_expr.move:13:17+37
 18: $t11 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 19: assume WellFormed($t11)                  # at closure_in_code_spec_expr.move:13:17+37
 20: $t12 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 21: assume WellFormed($t12)                  # at closure_in_code_spec_expr.move:13:17+37
 22: $t13 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 23: assume WellFormed($t13)                  # at closure_in_code_spec_expr.move:13:17+37
 24: $t14 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 25: assume WellFormed($t14)                  # at closure_in_code_spec_expr.move:13:17+37
 26: $t15 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 27: assume WellFormed($t15)                  # at closure_in_code_spec_expr.move:13:17+37
     # info: enter loop, variable(s) i havocked and reassigned
 28: trace_local[i]($t4)                      # at closure_in_code_spec_expr.move:13:17+37
     # info: loop invariant holds at current state
 29: assume Not(AbortFlag())                  # at closure_in_code_spec_expr.move:13:17+37
 30: assume Le($t4, $t9)                      # at closure_in_code_spec_expr.move:11:17+19
 31: assume Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
 32: assume forall j: num: Range(0, $t4): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 33: $t11 := <($t4, $t9)                      # at closure_in_code_spec_expr.move:15:13+7
 34: if ($t11) goto 35 else goto 54           # at closure_in_code_spec_expr.move:9:9+384
 35: label L1                                 # at closure_in_code_spec_expr.move:17:34+1
 36: $t12 := vector::borrow<#0>($t0, $t4) on_abort goto 65 with $t10 # at closure_in_code_spec_expr.move:17:19+20
 37: $t13 := invoke($t12, $t1) on_abort goto 65 with $t10 # at closure_in_code_spec_expr.move:17:17+23
 38: if ($t13) goto 39 else goto 49           # at closure_in_code_spec_expr.move:17:13+128
 39: label L3                                 # at closure_in_code_spec_expr.move:17:42+99
 40: $t16 := true                             # at closure_in_code_spec_expr.move:18:24+4
 41: $t2 := $t16                              # at closure_in_code_spec_expr.move:18:17+11
 42: trace_local[find]($t16)                  # at closure_in_code_spec_expr.move:18:17+11
 43: $t3 := $t4                               # at closure_in_code_spec_expr.move:19:17+15
 44: trace_local[found_index]($t4)            # at closure_in_code_spec_expr.move:19:17+15
 45: label L5                                 # at closure_in_code_spec_expr.move:24:10+4
 46: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:4:90+540
 47: trace_return[1]($t3)                     # at closure_in_code_spec_expr.move:4:90+540
 48: goto 61                                  # at closure_in_code_spec_expr.move:4:90+540
 49: label L2                                 # at closure_in_code_spec_expr.move:22:17+1
 50: $t14 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 51: $t15 := +($t4, $t14) on_abort goto 65 with $t10 # at closure_in_code_spec_expr.move:22:17+5
 52: trace_local[i]($t15)                     # at closure_in_code_spec_expr.move:22:13+9
 53: goto 56                                  # at closure_in_code_spec_expr.move:9:9+384
 54: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
 55: goto 45                                  # at closure_in_code_spec_expr.move:9:9+384
     # Loop invariant checking block for the loop started with header: L4
 56: label L6                                 # at closure_in_code_spec_expr.move:9:9+384
     # VC: induction case of the loop invariant does not hold at closure_in_code_spec_expr.move:11:17+19
 57: assert Le($t15, $t9)                     # at closure_in_code_spec_expr.move:11:17+19
     # VC: induction case of the loop invariant does not hold at closure_in_code_spec_expr.move:12:17+27
 58: assert Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
     # VC: induction case of the loop invariant does not hold at closure_in_code_spec_expr.move:13:17+37
 59: assert forall j: num: Range(0, $t15): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 60: stop()                                   # at closure_in_code_spec_expr.move:13:17+37
 61: label L7                                 # at closure_in_code_spec_expr.move:25:5+1
     # VC: post-condition does not hold at closure_in_code_spec_expr.move:28:9+54
 62: assert Iff($t2, exists i: num: RangeVec<#0>($t0): ($t1)(Index($t0, i))) # at closure_in_code_spec_expr.move:28:9+54
     # VC: post-condition does not hold at closure_in_code_spec_expr.move:29:9+75
 63: assert Implies($t2, And(($t1)(Index($t0, $t3)), forall i: num: Range(0, $t3): Not(($t1)(Index($t0, i))))) # at closure_in_code_spec_expr.move:29:9+75
 64: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:29:9+75
 65: label L8                                 # at closure_in_code_spec_expr.move:25:5+1
 66: abort($t10)                              # at closure_in_code_spec_expr.move:25:5+1
}


[variant verification]
fun test::call_find(): bool {
     var $t0|$t4: vector<u64>
     var $t1: vector<u64>
     var $t2: |&u64|bool has copy + drop
     var $t3: bool
     var $t4: u64
     var $t5: bool
     var $t6: num
  0: $t1 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: trace_local[$t4]($t1)                    # at closure_in_code_spec_expr.move:38:35+1
  2: $t2 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  3: ($t3, $t4) := opaque begin: test::find<u64>($t1, $t2) # at closure_in_code_spec_expr.move:38:29+14
  4: $t5 := havoc[val]()                      # at closure_in_code_spec_expr.move:38:29+14
  5: if ($t5) goto 6 else goto 9              # at closure_in_code_spec_expr.move:38:29+14
  6: label L4                                 # at closure_in_code_spec_expr.move:38:29+14
  7: trace_abort($t6)                         # at closure_in_code_spec_expr.move:38:29+14
  8: goto 20                                  # at closure_in_code_spec_expr.move:38:29+14
  9: label L3                                 # at closure_in_code_spec_expr.move:38:29+14
 10: assume WellFormed($t3)                   # at closure_in_code_spec_expr.move:38:29+14
 11: assume WellFormed($t4)                   # at closure_in_code_spec_expr.move:38:29+14
 12: assume Iff($t3, exists i: num: RangeVec<u64>($t1): ($t2)(Index($t1, i))) # at closure_in_code_spec_expr.move:38:29+14
 13: assume Implies($t3, And(($t2)(Index($t1, $t4)), forall i: num: Range(0, $t4): Not(($t2)(Index($t1, i))))) # at closure_in_code_spec_expr.move:38:29+14
 14: ($t3, $t4) := opaque end: test::find<u64>($t1, $t2) # at closure_in_code_spec_expr.move:38:29+14
 15: drop($t4)                                # at closure_in_code_spec_expr.move:38:29+14
 16: trace_return[0]($t3)                     # at closure_in_code_spec_expr.move:39:9+5
 17: label L1                                 # at closure_in_code_spec_expr.move:40:5+1
     # VC: post-condition does not hold at closure_in_code_spec_expr.move:42:9+16
 18: assert Not($t3)                          # at closure_in_code_spec_expr.move:42:9+16
 19: return $t3                               # at closure_in_code_spec_expr.move:42:9+16
 20: label L2                                 # at closure_in_code_spec_expr.move:40:5+1
 21: abort($t6)                               # at closure_in_code_spec_expr.move:40:5+1
}


[variant baseline]
fun test::pred($t0|x: u64): bool {
     var $t1: u64
     var $t2: bool
  0: trace_local[x]($t0)                      # at closure_in_code_spec_expr.move:32:5+1
  1: $t1 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t2 := >($t0, $t1)                       # at closure_in_code_spec_expr.move:33:9+6
  3: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:33:9+6
  4: label L1                                 # at closure_in_code_spec_expr.move:34:5+1
  5: return $t2                               # at closure_in_code_spec_expr.move:34:5+1
}


[variant verification]
fun test::pred($t0|x: u64): bool {
     var $t1: u64
     var $t2: bool
  0: trace_local[x]($t0)                      # at closure_in_code_spec_expr.move:32:5+1
  1: $t1 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t2 := >($t0, $t1)                       # at closure_in_code_spec_expr.move:33:9+6
  3: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:33:9+6
  4: label L1                                 # at closure_in_code_spec_expr.move:34:5+1
  5: return $t2                               # at closure_in_code_spec_expr.move:34:5+1
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step13_global_invariant_analysis:
********* Result of global invariant instrumentation *********

test::find: [
  entrypoint {}
  10: $t9 := vector::length<#0>($t0) on_abort goto L8 with $t10 {}
  13: assert Le($t8, $t9) {}
  14: assert Eq<u64>($t7, 0) {}
  15: assert forall j: num: Range(0, $t8): Not(($t1)(Index($t0, j))) {}
  17: assume WellFormed($t4) {}
  19: assume WellFormed($t11) {}
  21: assume WellFormed($t12) {}
  23: assume WellFormed($t13) {}
  25: assume WellFormed($t14) {}
  27: assume WellFormed($t15) {}
  29: assume Not(AbortFlag()) {}
  30: assume Le($t4, $t9) {}
  31: assume Eq<u64>($t7, 0) {}
  32: assume forall j: num: Range(0, $t4): Not(($t1)(Index($t0, j))) {}
  36: $t12 := vector::borrow<#0>($t0, $t4) on_abort goto L8 with $t10 {}
  57: assert Le($t15, $t9) {}
  58: assert Eq<u64>($t7, 0) {}
  59: assert forall j: num: Range(0, $t15): Not(($t1)(Index($t0, j))) {}
  62: assert Iff($t2, exists i: num: RangeVec<#0>($t0): ($t1)(Index($t0, i))) {}
  63: assert Implies($t2, And(($t1)(Index($t0, $t3)), forall i: num: Range(0, $t3): Not(($t1)(Index($t0, i))))) {}
  exitpoint {}
]
test::call_find: [
  entrypoint {}
  3: ($t3, $t4) := opaque begin: test::find<u64>($t1, $t2) {}
  10: assume WellFormed($t3) {}
  11: assume WellFormed($t4) {}
  12: assume Iff($t3, exists i: num: RangeVec<u64>($t1): ($t2)(Index($t1, i))) {}
  13: assume Implies($t3, And(($t2)(Index($t1, $t4)), forall i: num: Range(0, $t4): Not(($t2)(Index($t1, i))))) {}
  14: ($t3, $t4) := opaque end: test::find<u64>($t1, $t2) {}
  18: assert Not($t3) {}
  exitpoint {}
]
test::pred: [
  entrypoint {}
  exitpoint {}
]

********* Global invariants by ID *********


============ after processor `global_invariant_analysis` ================

[variant verification]
fun test::find<#0>($t0|s: vector<#0>, $t1|f: |&#0|(bool) has copy + drop): (bool, u64) {
     var $t2|find: bool
     var $t3|found_index: u64
     var $t4|i: u64
     var $t5|len: u64
     var $t6: bool
     var $t7: u64
     var $t8: u64
     var $t9: u64
     var $t10: num
     var $t11: bool
     var $t12: #0
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: bool
  0: trace_local[s]($t0)                      # at closure_in_code_spec_expr.move:4:5+1
  1: trace_local[f]($t1)                      # at closure_in_code_spec_expr.move:4:5+1
  2: $t6 := false                             # at closure_in_code_spec_expr.move:5:20+5
  3: $t2 := $t6                               # at closure_in_code_spec_expr.move:5:20+5
  4: trace_local[find]($t6)                   # at closure_in_code_spec_expr.move:5:20+5
  5: $t7 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  6: $t3 := $t7                               # at closure_in_code_spec_expr.move:6:27+1
  7: trace_local[found_index]($t7)            # at closure_in_code_spec_expr.move:6:27+1
  8: $t8 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  9: trace_local[i]($t8)                      # at closure_in_code_spec_expr.move:7:17+1
 10: $t9 := vector::length<#0>($t0) on_abort goto 65 with $t10 # at closure_in_code_spec_expr.move:8:19+17
 11: trace_local[len]($t9)                    # at closure_in_code_spec_expr.move:8:19+17
 12: label L4                                 # at closure_in_code_spec_expr.move:10:13+154
     # VC: base case of the loop invariant does not hold at closure_in_code_spec_expr.move:11:17+19
 13: assert Le($t8, $t9)                      # at closure_in_code_spec_expr.move:11:17+19
     # VC: base case of the loop invariant does not hold at closure_in_code_spec_expr.move:12:17+27
 14: assert Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
     # VC: base case of the loop invariant does not hold at closure_in_code_spec_expr.move:13:17+37
 15: assert forall j: num: Range(0, $t8): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 16: $t4 := havoc[val]()                      # at closure_in_code_spec_expr.move:13:17+37
 17: assume WellFormed($t4)                   # at closure_in_code_spec_expr.move:13:17+37
 18: $t11 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 19: assume WellFormed($t11)                  # at closure_in_code_spec_expr.move:13:17+37
 20: $t12 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 21: assume WellFormed($t12)                  # at closure_in_code_spec_expr.move:13:17+37
 22: $t13 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 23: assume WellFormed($t13)                  # at closure_in_code_spec_expr.move:13:17+37
 24: $t14 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 25: assume WellFormed($t14)                  # at closure_in_code_spec_expr.move:13:17+37
 26: $t15 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 27: assume WellFormed($t15)                  # at closure_in_code_spec_expr.move:13:17+37
     # info: enter loop, variable(s) i havocked and reassigned
 28: trace_local[i]($t4)                      # at closure_in_code_spec_expr.move:13:17+37
     # info: loop invariant holds at current state
 29: assume Not(AbortFlag())                  # at closure_in_code_spec_expr.move:13:17+37
 30: assume Le($t4, $t9)                      # at closure_in_code_spec_expr.move:11:17+19
 31: assume Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
 32: assume forall j: num: Range(0, $t4): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 33: $t11 := <($t4, $t9)                      # at closure_in_code_spec_expr.move:15:13+7
 34: if ($t11) goto 35 else goto 54           # at closure_in_code_spec_expr.move:9:9+384
 35: label L1                                 # at closure_in_code_spec_expr.move:17:34+1
 36: $t12 := vector::borrow<#0>($t0, $t4) on_abort goto 65 with $t10 # at closure_in_code_spec_expr.move:17:19+20
 37: $t13 := invoke($t12, $t1) on_abort goto 65 with $t10 # at closure_in_code_spec_expr.move:17:17+23
 38: if ($t13) goto 39 else goto 49           # at closure_in_code_spec_expr.move:17:13+128
 39: label L3                                 # at closure_in_code_spec_expr.move:17:42+99
 40: $t16 := true                             # at closure_in_code_spec_expr.move:18:24+4
 41: $t2 := $t16                              # at closure_in_code_spec_expr.move:18:17+11
 42: trace_local[find]($t16)                  # at closure_in_code_spec_expr.move:18:17+11
 43: $t3 := $t4                               # at closure_in_code_spec_expr.move:19:17+15
 44: trace_local[found_index]($t4)            # at closure_in_code_spec_expr.move:19:17+15
 45: label L5                                 # at closure_in_code_spec_expr.move:24:10+4
 46: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:4:90+540
 47: trace_return[1]($t3)                     # at closure_in_code_spec_expr.move:4:90+540
 48: goto 61                                  # at closure_in_code_spec_expr.move:4:90+540
 49: label L2                                 # at closure_in_code_spec_expr.move:22:17+1
 50: $t14 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 51: $t15 := +($t4, $t14) on_abort goto 65 with $t10 # at closure_in_code_spec_expr.move:22:17+5
 52: trace_local[i]($t15)                     # at closure_in_code_spec_expr.move:22:13+9
 53: goto 56                                  # at closure_in_code_spec_expr.move:9:9+384
 54: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
 55: goto 45                                  # at closure_in_code_spec_expr.move:9:9+384
     # Loop invariant checking block for the loop started with header: L4
 56: label L6                                 # at closure_in_code_spec_expr.move:9:9+384
     # VC: induction case of the loop invariant does not hold at closure_in_code_spec_expr.move:11:17+19
 57: assert Le($t15, $t9)                     # at closure_in_code_spec_expr.move:11:17+19
     # VC: induction case of the loop invariant does not hold at closure_in_code_spec_expr.move:12:17+27
 58: assert Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
     # VC: induction case of the loop invariant does not hold at closure_in_code_spec_expr.move:13:17+37
 59: assert forall j: num: Range(0, $t15): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 60: stop()                                   # at closure_in_code_spec_expr.move:13:17+37
 61: label L7                                 # at closure_in_code_spec_expr.move:25:5+1
     # VC: post-condition does not hold at closure_in_code_spec_expr.move:28:9+54
 62: assert Iff($t2, exists i: num: RangeVec<#0>($t0): ($t1)(Index($t0, i))) # at closure_in_code_spec_expr.move:28:9+54
     # VC: post-condition does not hold at closure_in_code_spec_expr.move:29:9+75
 63: assert Implies($t2, And(($t1)(Index($t0, $t3)), forall i: num: Range(0, $t3): Not(($t1)(Index($t0, i))))) # at closure_in_code_spec_expr.move:29:9+75
 64: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:29:9+75
 65: label L8                                 # at closure_in_code_spec_expr.move:25:5+1
 66: abort($t10)                              # at closure_in_code_spec_expr.move:25:5+1
}


[variant verification]
fun test::call_find(): bool {
     var $t0|$t4: vector<u64>
     var $t1: vector<u64>
     var $t2: |&u64|bool has copy + drop
     var $t3: bool
     var $t4: u64
     var $t5: bool
     var $t6: num
  0: $t1 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: trace_local[$t4]($t1)                    # at closure_in_code_spec_expr.move:38:35+1
  2: $t2 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  3: ($t3, $t4) := opaque begin: test::find<u64>($t1, $t2) # at closure_in_code_spec_expr.move:38:29+14
  4: $t5 := havoc[val]()                      # at closure_in_code_spec_expr.move:38:29+14
  5: if ($t5) goto 6 else goto 9              # at closure_in_code_spec_expr.move:38:29+14
  6: label L4                                 # at closure_in_code_spec_expr.move:38:29+14
  7: trace_abort($t6)                         # at closure_in_code_spec_expr.move:38:29+14
  8: goto 20                                  # at closure_in_code_spec_expr.move:38:29+14
  9: label L3                                 # at closure_in_code_spec_expr.move:38:29+14
 10: assume WellFormed($t3)                   # at closure_in_code_spec_expr.move:38:29+14
 11: assume WellFormed($t4)                   # at closure_in_code_spec_expr.move:38:29+14
 12: assume Iff($t3, exists i: num: RangeVec<u64>($t1): ($t2)(Index($t1, i))) # at closure_in_code_spec_expr.move:38:29+14
 13: assume Implies($t3, And(($t2)(Index($t1, $t4)), forall i: num: Range(0, $t4): Not(($t2)(Index($t1, i))))) # at closure_in_code_spec_expr.move:38:29+14
 14: ($t3, $t4) := opaque end: test::find<u64>($t1, $t2) # at closure_in_code_spec_expr.move:38:29+14
 15: drop($t4)                                # at closure_in_code_spec_expr.move:38:29+14
 16: trace_return[0]($t3)                     # at closure_in_code_spec_expr.move:39:9+5
 17: label L1                                 # at closure_in_code_spec_expr.move:40:5+1
     # VC: post-condition does not hold at closure_in_code_spec_expr.move:42:9+16
 18: assert Not($t3)                          # at closure_in_code_spec_expr.move:42:9+16
 19: return $t3                               # at closure_in_code_spec_expr.move:42:9+16
 20: label L2                                 # at closure_in_code_spec_expr.move:40:5+1
 21: abort($t6)                               # at closure_in_code_spec_expr.move:40:5+1
}


[variant baseline]
fun test::pred($t0|x: u64): bool {
     var $t1: u64
     var $t2: bool
  0: trace_local[x]($t0)                      # at closure_in_code_spec_expr.move:32:5+1
  1: $t1 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t2 := >($t0, $t1)                       # at closure_in_code_spec_expr.move:33:9+6
  3: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:33:9+6
  4: label L1                                 # at closure_in_code_spec_expr.move:34:5+1
  5: return $t2                               # at closure_in_code_spec_expr.move:34:5+1
}


[variant verification]
fun test::pred($t0|x: u64): bool {
     var $t1: u64
     var $t2: bool
  0: trace_local[x]($t0)                      # at closure_in_code_spec_expr.move:32:5+1
  1: $t1 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t2 := >($t0, $t1)                       # at closure_in_code_spec_expr.move:33:9+6
  3: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:33:9+6
  4: label L1                                 # at closure_in_code_spec_expr.move:34:5+1
  5: return $t2                               # at closure_in_code_spec_expr.move:34:5+1
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step14_global_invariant_instrumentation:
============ after processor `global_invariant_instrumentation` ================

[variant verification]
fun test::find<#0>($t0|s: vector<#0>, $t1|f: |&#0|(bool) has copy + drop): (bool, u64) {
     var $t2|find: bool
     var $t3|found_index: u64
     var $t4|i: u64
     var $t5|len: u64
     var $t6: bool
     var $t7: u64
     var $t8: u64
     var $t9: u64
     var $t10: num
     var $t11: bool
     var $t12: #0
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: bool
  0: trace_local[s]($t0)                      # at closure_in_code_spec_expr.move:4:5+1
  1: trace_local[f]($t1)                      # at closure_in_code_spec_expr.move:4:5+1
  2: $t6 := false                             # at closure_in_code_spec_expr.move:5:20+5
  3: $t2 := $t6                               # at closure_in_code_spec_expr.move:5:20+5
  4: trace_local[find]($t6)                   # at closure_in_code_spec_expr.move:5:20+5
  5: $t7 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  6: $t3 := $t7                               # at closure_in_code_spec_expr.move:6:27+1
  7: trace_local[found_index]($t7)            # at closure_in_code_spec_expr.move:6:27+1
  8: $t8 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
  9: trace_local[i]($t8)                      # at closure_in_code_spec_expr.move:7:17+1
 10: $t9 := vector::length<#0>($t0) on_abort goto 65 with $t10 # at closure_in_code_spec_expr.move:8:19+17
 11: trace_local[len]($t9)                    # at closure_in_code_spec_expr.move:8:19+17
 12: label L4                                 # at closure_in_code_spec_expr.move:10:13+154
     # VC: base case of the loop invariant does not hold at closure_in_code_spec_expr.move:11:17+19
 13: assert Le($t8, $t9)                      # at closure_in_code_spec_expr.move:11:17+19
     # VC: base case of the loop invariant does not hold at closure_in_code_spec_expr.move:12:17+27
 14: assert Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
     # VC: base case of the loop invariant does not hold at closure_in_code_spec_expr.move:13:17+37
 15: assert forall j: num: Range(0, $t8): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 16: $t4 := havoc[val]()                      # at closure_in_code_spec_expr.move:13:17+37
 17: assume WellFormed($t4)                   # at closure_in_code_spec_expr.move:13:17+37
 18: $t11 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 19: assume WellFormed($t11)                  # at closure_in_code_spec_expr.move:13:17+37
 20: $t12 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 21: assume WellFormed($t12)                  # at closure_in_code_spec_expr.move:13:17+37
 22: $t13 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 23: assume WellFormed($t13)                  # at closure_in_code_spec_expr.move:13:17+37
 24: $t14 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 25: assume WellFormed($t14)                  # at closure_in_code_spec_expr.move:13:17+37
 26: $t15 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 27: assume WellFormed($t15)                  # at closure_in_code_spec_expr.move:13:17+37
     # info: enter loop, variable(s) i havocked and reassigned
 28: trace_local[i]($t4)                      # at closure_in_code_spec_expr.move:13:17+37
     # info: loop invariant holds at current state
 29: assume Not(AbortFlag())                  # at closure_in_code_spec_expr.move:13:17+37
 30: assume Le($t4, $t9)                      # at closure_in_code_spec_expr.move:11:17+19
 31: assume Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
 32: assume forall j: num: Range(0, $t4): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 33: $t11 := <($t4, $t9)                      # at closure_in_code_spec_expr.move:15:13+7
 34: if ($t11) goto 35 else goto 54           # at closure_in_code_spec_expr.move:9:9+384
 35: label L1                                 # at closure_in_code_spec_expr.move:17:34+1
 36: $t12 := vector::borrow<#0>($t0, $t4) on_abort goto 65 with $t10 # at closure_in_code_spec_expr.move:17:19+20
 37: $t13 := invoke($t12, $t1) on_abort goto 65 with $t10 # at closure_in_code_spec_expr.move:17:17+23
 38: if ($t13) goto 39 else goto 49           # at closure_in_code_spec_expr.move:17:13+128
 39: label L3                                 # at closure_in_code_spec_expr.move:17:42+99
 40: $t16 := true                             # at closure_in_code_spec_expr.move:18:24+4
 41: $t2 := $t16                              # at closure_in_code_spec_expr.move:18:17+11
 42: trace_local[find]($t16)                  # at closure_in_code_spec_expr.move:18:17+11
 43: $t3 := $t4                               # at closure_in_code_spec_expr.move:19:17+15
 44: trace_local[found_index]($t4)            # at closure_in_code_spec_expr.move:19:17+15
 45: label L5                                 # at closure_in_code_spec_expr.move:24:10+4
 46: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:4:90+540
 47: trace_return[1]($t3)                     # at closure_in_code_spec_expr.move:4:90+540
 48: goto 61                                  # at closure_in_code_spec_expr.move:4:90+540
 49: label L2                                 # at closure_in_code_spec_expr.move:22:17+1
 50: $t14 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 51: $t15 := +($t4, $t14) on_abort goto 65 with $t10 # at closure_in_code_spec_expr.move:22:17+5
 52: trace_local[i]($t15)                     # at closure_in_code_spec_expr.move:22:13+9
 53: goto 56                                  # at closure_in_code_spec_expr.move:9:9+384
 54: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
 55: goto 45                                  # at closure_in_code_spec_expr.move:9:9+384
     # Loop invariant checking block for the loop started with header: L4
 56: label L6                                 # at closure_in_code_spec_expr.move:9:9+384
     # VC: induction case of the loop invariant does not hold at closure_in_code_spec_expr.move:11:17+19
 57: assert Le($t15, $t9)                     # at closure_in_code_spec_expr.move:11:17+19
     # VC: induction case of the loop invariant does not hold at closure_in_code_spec_expr.move:12:17+27
 58: assert Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
     # VC: induction case of the loop invariant does not hold at closure_in_code_spec_expr.move:13:17+37
 59: assert forall j: num: Range(0, $t15): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 60: stop()                                   # at closure_in_code_spec_expr.move:13:17+37
 61: label L7                                 # at closure_in_code_spec_expr.move:25:5+1
     # VC: post-condition does not hold at closure_in_code_spec_expr.move:28:9+54
 62: assert Iff($t2, exists i: num: RangeVec<#0>($t0): ($t1)(Index($t0, i))) # at closure_in_code_spec_expr.move:28:9+54
     # VC: post-condition does not hold at closure_in_code_spec_expr.move:29:9+75
 63: assert Implies($t2, And(($t1)(Index($t0, $t3)), forall i: num: Range(0, $t3): Not(($t1)(Index($t0, i))))) # at closure_in_code_spec_expr.move:29:9+75
 64: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:29:9+75
 65: label L8                                 # at closure_in_code_spec_expr.move:25:5+1
 66: abort($t10)                              # at closure_in_code_spec_expr.move:25:5+1
}


[variant verification]
fun test::call_find(): bool {
     var $t0|$t4: vector<u64>
     var $t1: vector<u64>
     var $t2: |&u64|bool has copy + drop
     var $t3: bool
     var $t4: u64
     var $t5: bool
     var $t6: num
  0: $t1 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: trace_local[$t4]($t1)                    # at closure_in_code_spec_expr.move:38:35+1
  2: $t2 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  3: ($t3, $t4) := opaque begin: test::find<u64>($t1, $t2) # at closure_in_code_spec_expr.move:38:29+14
  4: $t5 := havoc[val]()                      # at closure_in_code_spec_expr.move:38:29+14
  5: if ($t5) goto 6 else goto 9              # at closure_in_code_spec_expr.move:38:29+14
  6: label L4                                 # at closure_in_code_spec_expr.move:38:29+14
  7: trace_abort($t6)                         # at closure_in_code_spec_expr.move:38:29+14
  8: goto 20                                  # at closure_in_code_spec_expr.move:38:29+14
  9: label L3                                 # at closure_in_code_spec_expr.move:38:29+14
 10: assume WellFormed($t3)                   # at closure_in_code_spec_expr.move:38:29+14
 11: assume WellFormed($t4)                   # at closure_in_code_spec_expr.move:38:29+14
 12: assume Iff($t3, exists i: num: RangeVec<u64>($t1): ($t2)(Index($t1, i))) # at closure_in_code_spec_expr.move:38:29+14
 13: assume Implies($t3, And(($t2)(Index($t1, $t4)), forall i: num: Range(0, $t4): Not(($t2)(Index($t1, i))))) # at closure_in_code_spec_expr.move:38:29+14
 14: ($t3, $t4) := opaque end: test::find<u64>($t1, $t2) # at closure_in_code_spec_expr.move:38:29+14
 15: drop($t4)                                # at closure_in_code_spec_expr.move:38:29+14
 16: trace_return[0]($t3)                     # at closure_in_code_spec_expr.move:39:9+5
 17: label L1                                 # at closure_in_code_spec_expr.move:40:5+1
     # VC: post-condition does not hold at closure_in_code_spec_expr.move:42:9+16
 18: assert Not($t3)                          # at closure_in_code_spec_expr.move:42:9+16
 19: return $t3                               # at closure_in_code_spec_expr.move:42:9+16
 20: label L2                                 # at closure_in_code_spec_expr.move:40:5+1
 21: abort($t6)                               # at closure_in_code_spec_expr.move:40:5+1
}


[variant baseline]
fun test::pred($t0|x: u64): bool {
     var $t1: u64
     var $t2: bool
  0: trace_local[x]($t0)                      # at closure_in_code_spec_expr.move:32:5+1
  1: $t1 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t2 := >($t0, $t1)                       # at closure_in_code_spec_expr.move:33:9+6
  3: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:33:9+6
  4: label L1                                 # at closure_in_code_spec_expr.move:34:5+1
  5: return $t2                               # at closure_in_code_spec_expr.move:34:5+1
}


[variant verification]
fun test::pred($t0|x: u64): bool {
     var $t1: u64
     var $t2: bool
  0: trace_local[x]($t0)                      # at closure_in_code_spec_expr.move:32:5+1
  1: $t1 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t2 := >($t0, $t1)                       # at closure_in_code_spec_expr.move:33:9+6
  3: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:33:9+6
  4: label L1                                 # at closure_in_code_spec_expr.move:34:5+1
  5: return $t2                               # at closure_in_code_spec_expr.move:34:5+1
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step15_entry_point_instrumenter:
============ after processor `entry_point_instrumenter` ================

[variant verification]
fun test::find<#0>($t0|s: vector<#0>, $t1|f: |&#0|(bool) has copy + drop): (bool, u64) {
     var $t2|find: bool
     var $t3|found_index: u64
     var $t4|i: u64
     var $t5|len: u64
     var $t6: bool
     var $t7: u64
     var $t8: u64
     var $t9: u64
     var $t10: num
     var $t11: bool
     var $t12: #0
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: bool
  0: assume WellFormed($t0)                   # at closure_in_code_spec_expr.move:4:5+1
  1: assume WellFormed($t1)                   # at closure_in_code_spec_expr.move:4:5+1
  2: trace_local[s]($t0)                      # at closure_in_code_spec_expr.move:4:5+1
  3: trace_local[f]($t1)                      # at closure_in_code_spec_expr.move:4:5+1
  4: $t6 := false                             # at closure_in_code_spec_expr.move:5:20+5
  5: $t2 := $t6                               # at closure_in_code_spec_expr.move:5:20+5
  6: trace_local[find]($t6)                   # at closure_in_code_spec_expr.move:5:20+5
  7: $t7 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  8: $t3 := $t7                               # at closure_in_code_spec_expr.move:6:27+1
  9: trace_local[found_index]($t7)            # at closure_in_code_spec_expr.move:6:27+1
 10: $t8 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
 11: trace_local[i]($t8)                      # at closure_in_code_spec_expr.move:7:17+1
 12: $t9 := vector::length<#0>($t0) on_abort goto 67 with $t10 # at closure_in_code_spec_expr.move:8:19+17
 13: trace_local[len]($t9)                    # at closure_in_code_spec_expr.move:8:19+17
 14: label L4                                 # at closure_in_code_spec_expr.move:10:13+154
     # VC: base case of the loop invariant does not hold at closure_in_code_spec_expr.move:11:17+19
 15: assert Le($t8, $t9)                      # at closure_in_code_spec_expr.move:11:17+19
     # VC: base case of the loop invariant does not hold at closure_in_code_spec_expr.move:12:17+27
 16: assert Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
     # VC: base case of the loop invariant does not hold at closure_in_code_spec_expr.move:13:17+37
 17: assert forall j: num: Range(0, $t8): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 18: $t4 := havoc[val]()                      # at closure_in_code_spec_expr.move:13:17+37
 19: assume WellFormed($t4)                   # at closure_in_code_spec_expr.move:13:17+37
 20: $t11 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 21: assume WellFormed($t11)                  # at closure_in_code_spec_expr.move:13:17+37
 22: $t12 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 23: assume WellFormed($t12)                  # at closure_in_code_spec_expr.move:13:17+37
 24: $t13 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 25: assume WellFormed($t13)                  # at closure_in_code_spec_expr.move:13:17+37
 26: $t14 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 27: assume WellFormed($t14)                  # at closure_in_code_spec_expr.move:13:17+37
 28: $t15 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 29: assume WellFormed($t15)                  # at closure_in_code_spec_expr.move:13:17+37
     # info: enter loop, variable(s) i havocked and reassigned
 30: trace_local[i]($t4)                      # at closure_in_code_spec_expr.move:13:17+37
     # info: loop invariant holds at current state
 31: assume Not(AbortFlag())                  # at closure_in_code_spec_expr.move:13:17+37
 32: assume Le($t4, $t9)                      # at closure_in_code_spec_expr.move:11:17+19
 33: assume Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
 34: assume forall j: num: Range(0, $t4): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 35: $t11 := <($t4, $t9)                      # at closure_in_code_spec_expr.move:15:13+7
 36: if ($t11) goto 37 else goto 56           # at closure_in_code_spec_expr.move:9:9+384
 37: label L1                                 # at closure_in_code_spec_expr.move:17:34+1
 38: $t12 := vector::borrow<#0>($t0, $t4) on_abort goto 67 with $t10 # at closure_in_code_spec_expr.move:17:19+20
 39: $t13 := invoke($t12, $t1) on_abort goto 67 with $t10 # at closure_in_code_spec_expr.move:17:17+23
 40: if ($t13) goto 41 else goto 51           # at closure_in_code_spec_expr.move:17:13+128
 41: label L3                                 # at closure_in_code_spec_expr.move:17:42+99
 42: $t16 := true                             # at closure_in_code_spec_expr.move:18:24+4
 43: $t2 := $t16                              # at closure_in_code_spec_expr.move:18:17+11
 44: trace_local[find]($t16)                  # at closure_in_code_spec_expr.move:18:17+11
 45: $t3 := $t4                               # at closure_in_code_spec_expr.move:19:17+15
 46: trace_local[found_index]($t4)            # at closure_in_code_spec_expr.move:19:17+15
 47: label L5                                 # at closure_in_code_spec_expr.move:24:10+4
 48: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:4:90+540
 49: trace_return[1]($t3)                     # at closure_in_code_spec_expr.move:4:90+540
 50: goto 63                                  # at closure_in_code_spec_expr.move:4:90+540
 51: label L2                                 # at closure_in_code_spec_expr.move:22:17+1
 52: $t14 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 53: $t15 := +($t4, $t14) on_abort goto 67 with $t10 # at closure_in_code_spec_expr.move:22:17+5
 54: trace_local[i]($t15)                     # at closure_in_code_spec_expr.move:22:13+9
 55: goto 58                                  # at closure_in_code_spec_expr.move:9:9+384
 56: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
 57: goto 47                                  # at closure_in_code_spec_expr.move:9:9+384
     # Loop invariant checking block for the loop started with header: L4
 58: label L6                                 # at closure_in_code_spec_expr.move:9:9+384
     # VC: induction case of the loop invariant does not hold at closure_in_code_spec_expr.move:11:17+19
 59: assert Le($t15, $t9)                     # at closure_in_code_spec_expr.move:11:17+19
     # VC: induction case of the loop invariant does not hold at closure_in_code_spec_expr.move:12:17+27
 60: assert Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
     # VC: induction case of the loop invariant does not hold at closure_in_code_spec_expr.move:13:17+37
 61: assert forall j: num: Range(0, $t15): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 62: stop()                                   # at closure_in_code_spec_expr.move:13:17+37
 63: label L7                                 # at closure_in_code_spec_expr.move:25:5+1
     # VC: post-condition does not hold at closure_in_code_spec_expr.move:28:9+54
 64: assert Iff($t2, exists i: num: RangeVec<#0>($t0): ($t1)(Index($t0, i))) # at closure_in_code_spec_expr.move:28:9+54
     # VC: post-condition does not hold at closure_in_code_spec_expr.move:29:9+75
 65: assert Implies($t2, And(($t1)(Index($t0, $t3)), forall i: num: Range(0, $t3): Not(($t1)(Index($t0, i))))) # at closure_in_code_spec_expr.move:29:9+75
 66: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:29:9+75
 67: label L8                                 # at closure_in_code_spec_expr.move:25:5+1
 68: abort($t10)                              # at closure_in_code_spec_expr.move:25:5+1
}


[variant verification]
fun test::call_find(): bool {
     var $t0|$t4: vector<u64>
     var $t1: vector<u64>
     var $t2: |&u64|bool has copy + drop
     var $t3: bool
     var $t4: u64
     var $t5: bool
     var $t6: num
  0: $t1 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: trace_local[$t4]($t1)                    # at closure_in_code_spec_expr.move:38:35+1
  2: $t2 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  3: ($t3, $t4) := opaque begin: test::find<u64>($t1, $t2) # at closure_in_code_spec_expr.move:38:29+14
  4: $t5 := havoc[val]()                      # at closure_in_code_spec_expr.move:38:29+14
  5: if ($t5) goto 6 else goto 9              # at closure_in_code_spec_expr.move:38:29+14
  6: label L4                                 # at closure_in_code_spec_expr.move:38:29+14
  7: trace_abort($t6)                         # at closure_in_code_spec_expr.move:38:29+14
  8: goto 20                                  # at closure_in_code_spec_expr.move:38:29+14
  9: label L3                                 # at closure_in_code_spec_expr.move:38:29+14
 10: assume WellFormed($t3)                   # at closure_in_code_spec_expr.move:38:29+14
 11: assume WellFormed($t4)                   # at closure_in_code_spec_expr.move:38:29+14
 12: assume Iff($t3, exists i: num: RangeVec<u64>($t1): ($t2)(Index($t1, i))) # at closure_in_code_spec_expr.move:38:29+14
 13: assume Implies($t3, And(($t2)(Index($t1, $t4)), forall i: num: Range(0, $t4): Not(($t2)(Index($t1, i))))) # at closure_in_code_spec_expr.move:38:29+14
 14: ($t3, $t4) := opaque end: test::find<u64>($t1, $t2) # at closure_in_code_spec_expr.move:38:29+14
 15: drop($t4)                                # at closure_in_code_spec_expr.move:38:29+14
 16: trace_return[0]($t3)                     # at closure_in_code_spec_expr.move:39:9+5
 17: label L1                                 # at closure_in_code_spec_expr.move:40:5+1
     # VC: post-condition does not hold at closure_in_code_spec_expr.move:42:9+16
 18: assert Not($t3)                          # at closure_in_code_spec_expr.move:42:9+16
 19: return $t3                               # at closure_in_code_spec_expr.move:42:9+16
 20: label L2                                 # at closure_in_code_spec_expr.move:40:5+1
 21: abort($t6)                               # at closure_in_code_spec_expr.move:40:5+1
}


[variant baseline]
fun test::pred($t0|x: u64): bool {
     var $t1: u64
     var $t2: bool
  0: trace_local[x]($t0)                      # at closure_in_code_spec_expr.move:32:5+1
  1: $t1 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t2 := >($t0, $t1)                       # at closure_in_code_spec_expr.move:33:9+6
  3: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:33:9+6
  4: label L1                                 # at closure_in_code_spec_expr.move:34:5+1
  5: return $t2                               # at closure_in_code_spec_expr.move:34:5+1
}


[variant verification]
fun test::pred($t0|x: u64): bool {
     var $t1: u64
     var $t2: bool
  0: assume WellFormed($t0)                   # at closure_in_code_spec_expr.move:32:5+1
  1: trace_local[x]($t0)                      # at closure_in_code_spec_expr.move:32:5+1
  2: $t1 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  3: $t2 := >($t0, $t1)                       # at closure_in_code_spec_expr.move:33:9+6
  4: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:33:9+6
  5: label L1                                 # at closure_in_code_spec_expr.move:34:5+1
  6: return $t2                               # at closure_in_code_spec_expr.move:34:5+1
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step16_data_invariant_instrumenter:
============ after processor `data_invariant_instrumenter` ================

[variant verification]
fun test::find<#0>($t0|s: vector<#0>, $t1|f: |&#0|(bool) has copy + drop): (bool, u64) {
     var $t2|find: bool
     var $t3|found_index: u64
     var $t4|i: u64
     var $t5|len: u64
     var $t6: bool
     var $t7: u64
     var $t8: u64
     var $t9: u64
     var $t10: num
     var $t11: bool
     var $t12: #0
     var $t13: bool
     var $t14: u64
     var $t15: u64
     var $t16: bool
  0: assume WellFormed($t0)                   # at closure_in_code_spec_expr.move:4:5+1
  1: assume WellFormed($t1)                   # at closure_in_code_spec_expr.move:4:5+1
  2: trace_local[s]($t0)                      # at closure_in_code_spec_expr.move:4:5+1
  3: trace_local[f]($t1)                      # at closure_in_code_spec_expr.move:4:5+1
  4: $t6 := false                             # at closure_in_code_spec_expr.move:5:20+5
  5: $t2 := $t6                               # at closure_in_code_spec_expr.move:5:20+5
  6: trace_local[find]($t6)                   # at closure_in_code_spec_expr.move:5:20+5
  7: $t7 := 0                                 # at closure_in_code_spec_expr.move:6:27+1
  8: $t3 := $t7                               # at closure_in_code_spec_expr.move:6:27+1
  9: trace_local[found_index]($t7)            # at closure_in_code_spec_expr.move:6:27+1
 10: $t8 := 0                                 # at closure_in_code_spec_expr.move:7:17+1
 11: trace_local[i]($t8)                      # at closure_in_code_spec_expr.move:7:17+1
 12: $t9 := vector::length<#0>($t0) on_abort goto 67 with $t10 # at closure_in_code_spec_expr.move:8:19+17
 13: trace_local[len]($t9)                    # at closure_in_code_spec_expr.move:8:19+17
 14: label L4                                 # at closure_in_code_spec_expr.move:10:13+154
     # VC: base case of the loop invariant does not hold at closure_in_code_spec_expr.move:11:17+19
 15: assert Le($t8, $t9)                      # at closure_in_code_spec_expr.move:11:17+19
     # VC: base case of the loop invariant does not hold at closure_in_code_spec_expr.move:12:17+27
 16: assert Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
     # VC: base case of the loop invariant does not hold at closure_in_code_spec_expr.move:13:17+37
 17: assert forall j: num: Range(0, $t8): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 18: $t4 := havoc[val]()                      # at closure_in_code_spec_expr.move:13:17+37
 19: assume WellFormed($t4)                   # at closure_in_code_spec_expr.move:13:17+37
 20: $t11 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 21: assume WellFormed($t11)                  # at closure_in_code_spec_expr.move:13:17+37
 22: $t12 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 23: assume WellFormed($t12)                  # at closure_in_code_spec_expr.move:13:17+37
 24: $t13 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 25: assume WellFormed($t13)                  # at closure_in_code_spec_expr.move:13:17+37
 26: $t14 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 27: assume WellFormed($t14)                  # at closure_in_code_spec_expr.move:13:17+37
 28: $t15 := havoc[val]()                     # at closure_in_code_spec_expr.move:13:17+37
 29: assume WellFormed($t15)                  # at closure_in_code_spec_expr.move:13:17+37
     # info: enter loop, variable(s) i havocked and reassigned
 30: trace_local[i]($t4)                      # at closure_in_code_spec_expr.move:13:17+37
     # info: loop invariant holds at current state
 31: assume Not(AbortFlag())                  # at closure_in_code_spec_expr.move:13:17+37
 32: assume Le($t4, $t9)                      # at closure_in_code_spec_expr.move:11:17+19
 33: assume Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
 34: assume forall j: num: Range(0, $t4): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 35: $t11 := <($t4, $t9)                      # at closure_in_code_spec_expr.move:15:13+7
 36: if ($t11) goto 37 else goto 56           # at closure_in_code_spec_expr.move:9:9+384
 37: label L1                                 # at closure_in_code_spec_expr.move:17:34+1
 38: $t12 := vector::borrow<#0>($t0, $t4) on_abort goto 67 with $t10 # at closure_in_code_spec_expr.move:17:19+20
 39: $t13 := invoke($t12, $t1) on_abort goto 67 with $t10 # at closure_in_code_spec_expr.move:17:17+23
 40: if ($t13) goto 41 else goto 51           # at closure_in_code_spec_expr.move:17:13+128
 41: label L3                                 # at closure_in_code_spec_expr.move:17:42+99
 42: $t16 := true                             # at closure_in_code_spec_expr.move:18:24+4
 43: $t2 := $t16                              # at closure_in_code_spec_expr.move:18:17+11
 44: trace_local[find]($t16)                  # at closure_in_code_spec_expr.move:18:17+11
 45: $t3 := $t4                               # at closure_in_code_spec_expr.move:19:17+15
 46: trace_local[found_index]($t4)            # at closure_in_code_spec_expr.move:19:17+15
 47: label L5                                 # at closure_in_code_spec_expr.move:24:10+4
 48: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:4:90+540
 49: trace_return[1]($t3)                     # at closure_in_code_spec_expr.move:4:90+540
 50: goto 63                                  # at closure_in_code_spec_expr.move:4:90+540
 51: label L2                                 # at closure_in_code_spec_expr.move:22:17+1
 52: $t14 := 1                                # at closure_in_code_spec_expr.move:22:21+1
 53: $t15 := +($t4, $t14) on_abort goto 67 with $t10 # at closure_in_code_spec_expr.move:22:17+5
 54: trace_local[i]($t15)                     # at closure_in_code_spec_expr.move:22:13+9
 55: goto 58                                  # at closure_in_code_spec_expr.move:9:9+384
 56: label L0                                 # at closure_in_code_spec_expr.move:9:9+384
 57: goto 47                                  # at closure_in_code_spec_expr.move:9:9+384
     # Loop invariant checking block for the loop started with header: L4
 58: label L6                                 # at closure_in_code_spec_expr.move:9:9+384
     # VC: induction case of the loop invariant does not hold at closure_in_code_spec_expr.move:11:17+19
 59: assert Le($t15, $t9)                     # at closure_in_code_spec_expr.move:11:17+19
     # VC: induction case of the loop invariant does not hold at closure_in_code_spec_expr.move:12:17+27
 60: assert Eq<u64>($t7, 0)                   # at closure_in_code_spec_expr.move:12:17+27
     # VC: induction case of the loop invariant does not hold at closure_in_code_spec_expr.move:13:17+37
 61: assert forall j: num: Range(0, $t15): Not(($t1)(Index($t0, j))) # at closure_in_code_spec_expr.move:13:17+37
 62: stop()                                   # at closure_in_code_spec_expr.move:13:17+37
 63: label L7                                 # at closure_in_code_spec_expr.move:25:5+1
     # VC: post-condition does not hold at closure_in_code_spec_expr.move:28:9+54
 64: assert Iff($t2, exists i: num: RangeVec<#0>($t0): ($t1)(Index($t0, i))) # at closure_in_code_spec_expr.move:28:9+54
     # VC: post-condition does not hold at closure_in_code_spec_expr.move:29:9+75
 65: assert Implies($t2, And(($t1)(Index($t0, $t3)), forall i: num: Range(0, $t3): Not(($t1)(Index($t0, i))))) # at closure_in_code_spec_expr.move:29:9+75
 66: return ($t2, $t3)                        # at closure_in_code_spec_expr.move:29:9+75
 67: label L8                                 # at closure_in_code_spec_expr.move:25:5+1
 68: abort($t10)                              # at closure_in_code_spec_expr.move:25:5+1
}


[variant verification]
fun test::call_find(): bool {
     var $t0|$t4: vector<u64>
     var $t1: vector<u64>
     var $t2: |&u64|bool has copy + drop
     var $t3: bool
     var $t4: u64
     var $t5: bool
     var $t6: num
  0: $t1 := ["1", "2", "3"]                   # at closure_in_code_spec_expr.move:38:35+1
  1: trace_local[$t4]($t1)                    # at closure_in_code_spec_expr.move:38:35+1
  2: $t2 := closure#0 test::pred()            # at closure_in_code_spec_expr.move:38:38+4
  3: ($t3, $t4) := opaque begin: test::find<u64>($t1, $t2) # at closure_in_code_spec_expr.move:38:29+14
  4: $t5 := havoc[val]()                      # at closure_in_code_spec_expr.move:38:29+14
  5: if ($t5) goto 6 else goto 9              # at closure_in_code_spec_expr.move:38:29+14
  6: label L4                                 # at closure_in_code_spec_expr.move:38:29+14
  7: trace_abort($t6)                         # at closure_in_code_spec_expr.move:38:29+14
  8: goto 20                                  # at closure_in_code_spec_expr.move:38:29+14
  9: label L3                                 # at closure_in_code_spec_expr.move:38:29+14
 10: assume WellFormed($t3)                   # at closure_in_code_spec_expr.move:38:29+14
 11: assume WellFormed($t4)                   # at closure_in_code_spec_expr.move:38:29+14
 12: assume Iff($t3, exists i: num: RangeVec<u64>($t1): ($t2)(Index($t1, i))) # at closure_in_code_spec_expr.move:38:29+14
 13: assume Implies($t3, And(($t2)(Index($t1, $t4)), forall i: num: Range(0, $t4): Not(($t2)(Index($t1, i))))) # at closure_in_code_spec_expr.move:38:29+14
 14: ($t3, $t4) := opaque end: test::find<u64>($t1, $t2) # at closure_in_code_spec_expr.move:38:29+14
 15: drop($t4)                                # at closure_in_code_spec_expr.move:38:29+14
 16: trace_return[0]($t3)                     # at closure_in_code_spec_expr.move:39:9+5
 17: label L1                                 # at closure_in_code_spec_expr.move:40:5+1
     # VC: post-condition does not hold at closure_in_code_spec_expr.move:42:9+16
 18: assert Not($t3)                          # at closure_in_code_spec_expr.move:42:9+16
 19: return $t3                               # at closure_in_code_spec_expr.move:42:9+16
 20: label L2                                 # at closure_in_code_spec_expr.move:40:5+1
 21: abort($t6)                               # at closure_in_code_spec_expr.move:40:5+1
}


[variant baseline]
fun test::pred($t0|x: u64): bool {
     var $t1: u64
     var $t2: bool
  0: trace_local[x]($t0)                      # at closure_in_code_spec_expr.move:32:5+1
  1: $t1 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  2: $t2 := >($t0, $t1)                       # at closure_in_code_spec_expr.move:33:9+6
  3: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:33:9+6
  4: label L1                                 # at closure_in_code_spec_expr.move:34:5+1
  5: return $t2                               # at closure_in_code_spec_expr.move:34:5+1
}


[variant verification]
fun test::pred($t0|x: u64): bool {
     var $t1: u64
     var $t2: bool
  0: assume WellFormed($t0)                   # at closure_in_code_spec_expr.move:32:5+1
  1: trace_local[x]($t0)                      # at closure_in_code_spec_expr.move:32:5+1
  2: $t1 := 1                                 # at closure_in_code_spec_expr.move:33:14+1
  3: $t2 := >($t0, $t1)                       # at closure_in_code_spec_expr.move:33:9+6
  4: trace_return[0]($t2)                     # at closure_in_code_spec_expr.move:33:9+6
  5: label L1                                 # at closure_in_code_spec_expr.move:34:5+1
  6: return $t2                               # at closure_in_code_spec_expr.move:34:5+1
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step17_mono_analysis:
==== mono-analysis result ====

fun test::pred [baseline] = {
  <>
}
module 0x1::vector = {
  <#0>
}

[DEBUG move_stackless_bytecode::function_target_pipeline] bytecode of closure_in_code_spec_expr.move#step18_number_operation_analysis:


[INFO move_prover_boogie_backend::bytecode_translator] generating verification conditions
[DEBUG move_prover_boogie_backend::bytecode_translator] will verify primary function `test::find`
[DEBUG move_prover_boogie_backend::bytecode_translator] will verify primary function `test::call_find`
[DEBUG move_prover_boogie_backend::bytecode_translator] will verify primary function `test::pred`
[INFO move_prover_boogie_backend::bytecode_translator] 3 verification conditions
[DEBUG move_prover] writing boogie to `output.bpl`
[INFO move_prover_boogie_backend::boogie_wrapper] running solver
[DEBUG move_prover_boogie_backend::boogie_wrapper] command line: /Users/wrwg/.dotnet/tools/boogie -printVerifiedProceduresCount:0 -printModel:1 -enhancedErrorMessages:1 -proverOpt:O:model_validate=true -inferModifies -proverOpt:PROVER_PATH=/Users/wrwg/bin/z3 -useArrayAxioms -proverOpt:O:smt.QI.EAGER_THRESHOLD=100 -proverOpt:O:smt.QI.LAZY_THRESHOLD=100 -vcsCores:4 output.bpl
[DEBUG move_prover_boogie_backend::prover_task_runner] running Boogie command with seed 1
[DEBUG move_prover_boogie_backend::boogie_wrapper] analyzing boogie output
[DEBUG move_prover_boogie_backend::boogie_wrapper] writing boogie log to output.bpl.log
[INFO move_prover] 0.12s build, 0.03s trafo, 0.06s gen, 0.77s verify, total 0.98s
