// Purpose: swapping nested vectors should not invalidate borrowed payload when untouched.
// Flow:
//   (1) build outer = [[Foo::A(1)], [Foo::B(2)]]
//   (2) borrow payload_ref = &outer[0][0].A::x through vec_borrow chain
//   (3) vec_swap outer[0] <-> outer[1] while ref lives
//   (4) read payload_ref; succeeds because Foo::A payload unchanged
// Diagram (step 2)                             Diagram (step 3)
//   outer[0] ──▶ [Foo::A { x:1 }] ◀── payload_ref   outer[0] ──▶ [Foo::B { x:2 }]
//   outer[1] ──▶ [Foo::B { x:2 }]                  outer[1] ──▶ [Foo::A { x:1 }] ◀── payload_ref

//# publish
module 0xc0ffe5::nested_swap_confusion

enum Foo has drop
  A
    x: u64
  B
    x: u64

public fun stale_nested_swap()
    local outer: vector<vector<Foo>>
    local payload_ref: &u64

    // Build [[Foo::A {1}], [Foo::B {2}]]
    ld_u64 1
    pack_variant Foo, A
    vec_pack<Foo> 1
    ld_u64 2
    pack_variant Foo, B
    vec_pack<Foo> 1
    vec_pack<vector<Foo>> 2
    st_loc outer

    // Borrow Foo::A::x from outer[0][0]
    borrow_loc outer
    ld_u64 0
    vec_borrow<vector<Foo>>
    ld_u64 0
    vec_borrow<Foo>
    borrow_variant_field Foo, A::x
    st_loc payload_ref

    // Swap outer[0] and outer[1] while stale ref exists
    mut_borrow_loc outer
    ld_u64 0
    ld_u64 1
    vec_swap<vector<Foo>>

// Reading the ref should succeed (no tag mismatch)
    move_loc payload_ref
    read_ref
    pop
    ret

//# run 0xc0ffe5::nested_swap_confusion::stale_nested_swap --verbose

