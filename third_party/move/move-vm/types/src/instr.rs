// Copyright (c) Aptos Foundation
// SPDX-License-Identifier: Apache-2.0

use move_binary_format::file_format::{
    Bytecode, CodeOffset, ConstantPoolIndex, FieldHandleIndex, FieldInstantiationIndex,
    FunctionHandleIndex, FunctionInstantiationIndex, LocalIndex, SignatureIndex,
    StructDefInstantiationIndex, StructDefinitionIndex, StructVariantHandleIndex,
    StructVariantInstantiationIndex, VariantFieldHandleIndex, VariantFieldInstantiationIndex,
};
use move_core_types::{
    function::ClosureMask,
    int256::{I256, U256},
};

/// The VM's internal representation of instructions.
///
/// Currently, it is an exact mirror of the Move bytecode, but can be extended with more
/// instructions in the future.
///
/// This provides path for incremental performance optimizations, while making it less painful to
/// maintain backward compatibility.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Instruction {
    Pop,
    Ret,
    BrTrue(CodeOffset),
    BrFalse(CodeOffset),
    Branch(CodeOffset),
    LdU8(u8),
    LdU64(u64),
    LdU128(Box<u128>),
    CastU8,
    CastU64,
    CastU128,
    LdConst(ConstantPoolIndex),
    LdTrue,
    LdFalse,
    CopyLoc(LocalIndex),
    MoveLoc(LocalIndex),
    StLoc(LocalIndex),
    Call(FunctionHandleIndex),
    CallGeneric(FunctionInstantiationIndex),
    Pack(StructDefinitionIndex),
    PackGeneric(StructDefInstantiationIndex),
    PackVariant(StructVariantHandleIndex),
    PackVariantGeneric(StructVariantInstantiationIndex),
    Unpack(StructDefinitionIndex),
    UnpackGeneric(StructDefInstantiationIndex),
    UnpackVariant(StructVariantHandleIndex),
    UnpackVariantGeneric(StructVariantInstantiationIndex),
    TestVariant(StructVariantHandleIndex),
    TestVariantGeneric(StructVariantInstantiationIndex),
    ReadRef,
    WriteRef,
    FreezeRef,
    MutBorrowLoc(LocalIndex),
    ImmBorrowLoc(LocalIndex),
    MutBorrowField(FieldHandleIndex),
    MutBorrowVariantField(VariantFieldHandleIndex),
    MutBorrowFieldGeneric(FieldInstantiationIndex),
    MutBorrowVariantFieldGeneric(VariantFieldInstantiationIndex),
    ImmBorrowField(FieldHandleIndex),
    ImmBorrowVariantField(VariantFieldHandleIndex),
    ImmBorrowFieldGeneric(FieldInstantiationIndex),
    ImmBorrowVariantFieldGeneric(VariantFieldInstantiationIndex),
    MutBorrowGlobal(StructDefinitionIndex),
    MutBorrowGlobalGeneric(StructDefInstantiationIndex),
    ImmBorrowGlobal(StructDefinitionIndex),
    ImmBorrowGlobalGeneric(StructDefInstantiationIndex),
    Add,
    Sub,
    Mul,
    Mod,
    Div,
    BitOr,
    BitAnd,
    Xor,
    Or,
    And,
    Not,
    Eq,
    Neq,
    Lt,
    Gt,
    Le,
    Ge,
    Abort,
    Nop,
    Exists(StructDefinitionIndex),
    ExistsGeneric(StructDefInstantiationIndex),
    MoveFrom(StructDefinitionIndex),
    MoveFromGeneric(StructDefInstantiationIndex),
    MoveTo(StructDefinitionIndex),
    MoveToGeneric(StructDefInstantiationIndex),
    Shl,
    Shr,
    VecPack(SignatureIndex, u64),
    VecLen(SignatureIndex),
    VecImmBorrow(SignatureIndex),
    VecMutBorrow(SignatureIndex),
    VecPushBack(SignatureIndex),
    VecPopBack(SignatureIndex),
    VecUnpack(SignatureIndex, u64),
    VecSwap(SignatureIndex),
    PackClosure(FunctionHandleIndex, ClosureMask),
    PackClosureGeneric(FunctionInstantiationIndex, ClosureMask),
    CallClosure(SignatureIndex),
    LdU16(u16),
    LdU32(u32),
    LdU256(Box<U256>),
    CastU16,
    CastU32,
    CastU256,
    LdI8(i8),
    LdI16(i16),
    LdI32(i32),
    LdI64(i64),
    LdI128(Box<i128>),
    LdI256(Box<I256>),
    CastI8,
    CastI16,
    CastI32,
    CastI64,
    CastI128,
    CastI256,
    Negate,
}

impl From<Bytecode> for Instruction {
    fn from(bytecode: Bytecode) -> Self {
        use Bytecode as B;
        use Instruction as O;

        match bytecode {
            B::Pop => O::Pop,
            B::Ret => O::Ret,
            B::BrTrue(offset) => O::BrTrue(offset),
            B::BrFalse(offset) => O::BrFalse(offset),
            B::Branch(offset) => O::Branch(offset),
            B::LdU8(val) => O::LdU8(val),
            B::LdU64(val) => O::LdU64(val),
            B::LdU128(val) => O::LdU128(Box::new(val)),
            B::CastU8 => O::CastU8,
            B::CastU64 => O::CastU64,
            B::CastU128 => O::CastU128,
            B::LdConst(idx) => O::LdConst(idx),
            B::LdTrue => O::LdTrue,
            B::LdFalse => O::LdFalse,
            B::CopyLoc(idx) => O::CopyLoc(idx),
            B::MoveLoc(idx) => O::MoveLoc(idx),
            B::StLoc(idx) => O::StLoc(idx),
            B::Call(idx) => O::Call(idx),
            B::CallGeneric(idx) => O::CallGeneric(idx),
            B::Pack(idx) => O::Pack(idx),
            B::PackGeneric(idx) => O::PackGeneric(idx),
            B::PackVariant(idx) => O::PackVariant(idx),
            B::PackVariantGeneric(idx) => O::PackVariantGeneric(idx),
            B::Unpack(idx) => O::Unpack(idx),
            B::UnpackGeneric(idx) => O::UnpackGeneric(idx),
            B::UnpackVariant(idx) => O::UnpackVariant(idx),
            B::UnpackVariantGeneric(idx) => O::UnpackVariantGeneric(idx),
            B::TestVariant(idx) => O::TestVariant(idx),
            B::TestVariantGeneric(idx) => O::TestVariantGeneric(idx),
            B::ReadRef => O::ReadRef,
            B::WriteRef => O::WriteRef,
            B::FreezeRef => O::FreezeRef,
            B::MutBorrowLoc(idx) => O::MutBorrowLoc(idx),
            B::ImmBorrowLoc(idx) => O::ImmBorrowLoc(idx),
            B::MutBorrowField(idx) => O::MutBorrowField(idx),
            B::MutBorrowVariantField(idx) => O::MutBorrowVariantField(idx),
            B::MutBorrowFieldGeneric(idx) => O::MutBorrowFieldGeneric(idx),
            B::MutBorrowVariantFieldGeneric(idx) => O::MutBorrowVariantFieldGeneric(idx),
            B::ImmBorrowField(idx) => O::ImmBorrowField(idx),
            B::ImmBorrowVariantField(idx) => O::ImmBorrowVariantField(idx),
            B::ImmBorrowFieldGeneric(idx) => O::ImmBorrowFieldGeneric(idx),
            B::ImmBorrowVariantFieldGeneric(idx) => O::ImmBorrowVariantFieldGeneric(idx),
            B::MutBorrowGlobal(idx) => O::MutBorrowGlobal(idx),
            B::MutBorrowGlobalGeneric(idx) => O::MutBorrowGlobalGeneric(idx),
            B::ImmBorrowGlobal(idx) => O::ImmBorrowGlobal(idx),
            B::ImmBorrowGlobalGeneric(idx) => O::ImmBorrowGlobalGeneric(idx),
            B::Add => O::Add,
            B::Sub => O::Sub,
            B::Mul => O::Mul,
            B::Mod => O::Mod,
            B::Div => O::Div,
            B::BitOr => O::BitOr,
            B::BitAnd => O::BitAnd,
            B::Xor => O::Xor,
            B::Or => O::Or,
            B::And => O::And,
            B::Not => O::Not,
            B::Eq => O::Eq,
            B::Neq => O::Neq,
            B::Lt => O::Lt,
            B::Gt => O::Gt,
            B::Le => O::Le,
            B::Ge => O::Ge,
            B::Abort => O::Abort,
            B::Nop => O::Nop,
            B::Exists(idx) => O::Exists(idx),
            B::ExistsGeneric(idx) => O::ExistsGeneric(idx),
            B::MoveFrom(idx) => O::MoveFrom(idx),
            B::MoveFromGeneric(idx) => O::MoveFromGeneric(idx),
            B::MoveTo(idx) => O::MoveTo(idx),
            B::MoveToGeneric(idx) => O::MoveToGeneric(idx),
            B::Shl => O::Shl,
            B::Shr => O::Shr,
            B::VecPack(idx, n) => O::VecPack(idx, n),
            B::VecLen(idx) => O::VecLen(idx),
            B::VecImmBorrow(idx) => O::VecImmBorrow(idx),
            B::VecMutBorrow(idx) => O::VecMutBorrow(idx),
            B::VecPushBack(idx) => O::VecPushBack(idx),
            B::VecPopBack(idx) => O::VecPopBack(idx),
            B::VecUnpack(idx, n) => O::VecUnpack(idx, n),
            B::VecSwap(idx) => O::VecSwap(idx),
            B::PackClosure(idx, mask) => O::PackClosure(idx, mask),
            B::PackClosureGeneric(idx, mask) => O::PackClosureGeneric(idx, mask),
            B::CallClosure(idx) => O::CallClosure(idx),
            B::LdU16(val) => O::LdU16(val),
            B::LdU32(val) => O::LdU32(val),
            B::LdU256(val) => O::LdU256(Box::new(val)),
            B::CastU16 => O::CastU16,
            B::CastU32 => O::CastU32,
            B::CastU256 => O::CastU256,
            B::LdI8(val) => O::LdI8(val),
            B::LdI16(val) => O::LdI16(val),
            B::LdI32(val) => O::LdI32(val),
            B::LdI64(val) => O::LdI64(val),
            B::LdI128(val) => O::LdI128(Box::new(val)),
            B::LdI256(val) => O::LdI256(Box::new(val)),
            B::CastI8 => O::CastI8,
            B::CastI16 => O::CastI16,
            B::CastI32 => O::CastI32,
            B::CastI64 => O::CastI64,
            B::CastI128 => O::CastI128,
            B::CastI256 => O::CastI256,
            B::Negate => O::Negate,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::mem::size_of;

    #[test]
    fn test_vm_operation_size() {
        let size = size_of::<Instruction>();

        assert_eq!(
            size, 16,
            "VMOperation size should be exactly 16 bytes, but got {} bytes",
            size
        );
    }
}
