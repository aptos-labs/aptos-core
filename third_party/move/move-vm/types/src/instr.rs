// Copyright (c) Aptos Foundation
// SPDX-License-Identifier: Apache-2.0

use move_binary_format::file_format::{
    Bytecode, CodeOffset, ConstantPoolIndex, FieldHandleIndex, FieldInstantiationIndex,
    FunctionHandleIndex, FunctionInstantiationIndex, LocalIndex, SignatureIndex,
    StructDefInstantiationIndex, StructDefinitionIndex, StructVariantHandleIndex,
    StructVariantInstantiationIndex, VariantFieldHandleIndex, VariantFieldInstantiationIndex,
};
use move_core_types::{
    function::ClosureMask,
    int256::{I256, U256},
};

/// The VM's internal representation of instructions.
///
/// Currently, it is an exact mirror of the Move bytecode, but can be extended with more
/// instructions in the future.
///
/// This provides path for incremental performance optimizations, while making it less painful to
/// maintain backward compatibility.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Instruction {
    Pop,
    Ret,
    BrTrue(CodeOffset),
    BrFalse(CodeOffset),
    Branch(CodeOffset),
    LdU8(u8),
    LdU64(u64),
    LdU128(Box<u128>),
    CastU8,
    CastU64,
    CastU128,
    LdConst(ConstantPoolIndex),
    LdTrue,
    LdFalse,
    CopyLoc(LocalIndex),
    MoveLoc(LocalIndex),
    StLoc(LocalIndex),
    Call(FunctionHandleIndex),
    CallGeneric(FunctionInstantiationIndex),
    Pack(StructDefinitionIndex),
    PackGeneric(StructDefInstantiationIndex),
    PackVariant(StructVariantHandleIndex),
    PackVariantGeneric(StructVariantInstantiationIndex),
    Unpack(StructDefinitionIndex),
    UnpackGeneric(StructDefInstantiationIndex),
    UnpackVariant(StructVariantHandleIndex),
    UnpackVariantGeneric(StructVariantInstantiationIndex),
    TestVariant(StructVariantHandleIndex),
    TestVariantGeneric(StructVariantInstantiationIndex),
    ReadRef,
    WriteRef,
    FreezeRef,
    MutBorrowLoc(LocalIndex),
    ImmBorrowLoc(LocalIndex),
    MutBorrowField(FieldHandleIndex),
    MutBorrowVariantField(VariantFieldHandleIndex),
    MutBorrowFieldGeneric(FieldInstantiationIndex),
    MutBorrowVariantFieldGeneric(VariantFieldInstantiationIndex),
    ImmBorrowField(FieldHandleIndex),
    ImmBorrowVariantField(VariantFieldHandleIndex),
    ImmBorrowFieldGeneric(FieldInstantiationIndex),
    ImmBorrowVariantFieldGeneric(VariantFieldInstantiationIndex),
    MutBorrowGlobal(StructDefinitionIndex),
    MutBorrowGlobalGeneric(StructDefInstantiationIndex),
    ImmBorrowGlobal(StructDefinitionIndex),
    ImmBorrowGlobalGeneric(StructDefInstantiationIndex),
    Add,
    Sub,
    Mul,
    Mod,
    Div,
    BitOr,
    BitAnd,
    Xor,
    Or,
    And,
    Not,
    Eq,
    Neq,
    Lt,
    Gt,
    Le,
    Ge,
    Abort,
    Nop,
    Exists(StructDefinitionIndex),
    ExistsGeneric(StructDefInstantiationIndex),
    MoveFrom(StructDefinitionIndex),
    MoveFromGeneric(StructDefInstantiationIndex),
    MoveTo(StructDefinitionIndex),
    MoveToGeneric(StructDefInstantiationIndex),
    Shl,
    Shr,
    VecPack(SignatureIndex, u64),
    VecLen(SignatureIndex),
    VecImmBorrow(SignatureIndex),
    VecMutBorrow(SignatureIndex),
    VecPushBack(SignatureIndex),
    VecPopBack(SignatureIndex),
    VecUnpack(SignatureIndex, u64),
    VecSwap(SignatureIndex),
    PackClosure(FunctionHandleIndex, ClosureMask),
    PackClosureGeneric(FunctionInstantiationIndex, ClosureMask),
    CallClosure(SignatureIndex),
    LdU16(u16),
    LdU32(u32),
    LdU256(Box<U256>),
    CastU16,
    CastU32,
    CastU256,
    LdI8(i8),
    LdI16(i16),
    LdI32(i32),
    LdI64(i64),
    LdI128(Box<i128>),
    LdI256(Box<I256>),
    CastI8,
    CastI16,
    CastI32,
    CastI64,
    CastI128,
    CastI256,
    Negate,
    AbortMsg,
}

impl Instruction {
    pub fn name(&self) -> &str {
        match self {
            Instruction::Pop => "pop",
            Instruction::Ret => "ret",
            Instruction::BrTrue(_) => "br_true",
            Instruction::BrFalse(_) => "br_false",
            Instruction::Branch(_) => "branch",
            Instruction::LdU8(_) => "ld_u8",
            Instruction::LdU64(_) => "ld_u64",
            Instruction::LdU128(_) => "ld_u128",
            Instruction::CastU8 => "cast_u8",
            Instruction::CastU64 => "cast_u64",
            Instruction::CastU128 => "cast_u128",
            Instruction::LdConst(_) => "ld_const",
            Instruction::LdTrue => "ld_true",
            Instruction::LdFalse => "ld_false",
            Instruction::CopyLoc(_) => "copy_loc",
            Instruction::MoveLoc(_) => "move_loc",
            Instruction::StLoc(_) => "st_loc",
            Instruction::Call(_) => "call",
            Instruction::CallGeneric(_) => "call_generic",
            Instruction::Pack(_) => "pack",
            Instruction::PackGeneric(_) => "pack_generic",
            Instruction::PackVariant(_) => "pack_variant",
            Instruction::PackVariantGeneric(_) => "pack_variant_generic",
            Instruction::Unpack(_) => "unpack",
            Instruction::UnpackGeneric(_) => "unpack_generic",
            Instruction::UnpackVariant(_) => "unpack_variant",
            Instruction::UnpackVariantGeneric(_) => "unpack_variant_generic",
            Instruction::TestVariant(_) => "test_variant",
            Instruction::TestVariantGeneric(_) => "test_variant_generic",
            Instruction::ReadRef => "read_ref",
            Instruction::WriteRef => "write_ref",
            Instruction::FreezeRef => "freeze_ref",
            Instruction::MutBorrowLoc(_) => "mut_borrow_loc",
            Instruction::ImmBorrowLoc(_) => "imm_borrow_loc",
            Instruction::MutBorrowField(_) => "mut_borrow_field",
            Instruction::MutBorrowVariantField(_) => "mut_borrow_variant_field",
            Instruction::MutBorrowFieldGeneric(_) => "mut_borrow_field_generic",
            Instruction::MutBorrowVariantFieldGeneric(_) => "mut_borrow_variant_field_generic",
            Instruction::ImmBorrowField(_) => "imm_borrow_field",
            Instruction::ImmBorrowVariantField(_) => "imm_borrow_variant_field",
            Instruction::ImmBorrowFieldGeneric(_) => "imm_borrow_field_generic",
            Instruction::ImmBorrowVariantFieldGeneric(_) => "imm_borrow_variant_field_generic",
            Instruction::MutBorrowGlobal(_) => "mut_borrow_global",
            Instruction::MutBorrowGlobalGeneric(_) => "mut_borrow_global_generic",
            Instruction::ImmBorrowGlobal(_) => "imm_borrow_global",
            Instruction::ImmBorrowGlobalGeneric(_) => "imm_borrow_global_generic",
            Instruction::Add => "add",
            Instruction::Sub => "sub",
            Instruction::Mul => "mul",
            Instruction::Mod => "mod",
            Instruction::Div => "div",
            Instruction::BitOr => "bit_or",
            Instruction::BitAnd => "bit_and",
            Instruction::Xor => "xor",
            Instruction::Or => "or",
            Instruction::And => "and",
            Instruction::Not => "not",
            Instruction::Eq => "eq",
            Instruction::Neq => "neq",
            Instruction::Lt => "lt",
            Instruction::Gt => "gt",
            Instruction::Le => "le",
            Instruction::Ge => "ge",
            Instruction::Abort => "abort",
            Instruction::AbortMsg => "abort_msg",
            Instruction::Nop => "nop",
            Instruction::Exists(_) => "exists",
            Instruction::ExistsGeneric(_) => "exists_generic",
            Instruction::MoveFrom(_) => "move_from",
            Instruction::MoveFromGeneric(_) => "move_from_generic",
            Instruction::MoveTo(_) => "move_to",
            Instruction::MoveToGeneric(_) => "move_to_generic",
            Instruction::Shl => "shl",
            Instruction::Shr => "shr",
            Instruction::VecPack(_, _) => "vec_pack",
            Instruction::VecLen(_) => "vec_len",
            Instruction::VecImmBorrow(_) => "vec_imm_borrow",
            Instruction::VecMutBorrow(_) => "vec_mut_borrow",
            Instruction::VecPushBack(_) => "vec_push_back",
            Instruction::VecPopBack(_) => "vec_pop_back",
            Instruction::VecUnpack(_, _) => "vec_unpack",
            Instruction::VecSwap(_) => "vec_swap",
            Instruction::PackClosure(_, _) => "pack_closure",
            Instruction::PackClosureGeneric(_, _) => "pack_closure_generic",
            Instruction::CallClosure(_) => "call_closure",
            Instruction::LdU16(_) => "ld_u16",
            Instruction::LdU32(_) => "ld_u32",
            Instruction::LdU256(_) => "ld_u256",
            Instruction::CastU16 => "cast_u16",
            Instruction::CastU32 => "cast_u32",
            Instruction::CastU256 => "cast_u256",
            Instruction::LdI8(_) => "ld_i8",
            Instruction::LdI16(_) => "ld_i16",
            Instruction::LdI32(_) => "ld_i32",
            Instruction::LdI64(_) => "ld_i64",
            Instruction::LdI128(_) => "ld_i128",
            Instruction::LdI256(_) => "ld_i256",
            Instruction::CastI8 => "cast_i8",
            Instruction::CastI16 => "cast_i16",
            Instruction::CastI32 => "cast_i32",
            Instruction::CastI64 => "cast_i64",
            Instruction::CastI128 => "cast_i128",
            Instruction::CastI256 => "cast_i256",
            Instruction::Negate => "negate",
        }
    }
}

impl From<Bytecode> for Instruction {
    fn from(bytecode: Bytecode) -> Self {
        use Bytecode as B;
        use Instruction as O;

        match bytecode {
            B::Pop => O::Pop,
            B::Ret => O::Ret,
            B::BrTrue(offset) => O::BrTrue(offset),
            B::BrFalse(offset) => O::BrFalse(offset),
            B::Branch(offset) => O::Branch(offset),
            B::LdU8(val) => O::LdU8(val),
            B::LdU64(val) => O::LdU64(val),
            B::LdU128(val) => O::LdU128(Box::new(val)),
            B::CastU8 => O::CastU8,
            B::CastU64 => O::CastU64,
            B::CastU128 => O::CastU128,
            B::LdConst(idx) => O::LdConst(idx),
            B::LdTrue => O::LdTrue,
            B::LdFalse => O::LdFalse,
            B::CopyLoc(idx) => O::CopyLoc(idx),
            B::MoveLoc(idx) => O::MoveLoc(idx),
            B::StLoc(idx) => O::StLoc(idx),
            B::Call(idx) => O::Call(idx),
            B::CallGeneric(idx) => O::CallGeneric(idx),
            B::Pack(idx) => O::Pack(idx),
            B::PackGeneric(idx) => O::PackGeneric(idx),
            B::PackVariant(idx) => O::PackVariant(idx),
            B::PackVariantGeneric(idx) => O::PackVariantGeneric(idx),
            B::Unpack(idx) => O::Unpack(idx),
            B::UnpackGeneric(idx) => O::UnpackGeneric(idx),
            B::UnpackVariant(idx) => O::UnpackVariant(idx),
            B::UnpackVariantGeneric(idx) => O::UnpackVariantGeneric(idx),
            B::TestVariant(idx) => O::TestVariant(idx),
            B::TestVariantGeneric(idx) => O::TestVariantGeneric(idx),
            B::ReadRef => O::ReadRef,
            B::WriteRef => O::WriteRef,
            B::FreezeRef => O::FreezeRef,
            B::MutBorrowLoc(idx) => O::MutBorrowLoc(idx),
            B::ImmBorrowLoc(idx) => O::ImmBorrowLoc(idx),
            B::MutBorrowField(idx) => O::MutBorrowField(idx),
            B::MutBorrowVariantField(idx) => O::MutBorrowVariantField(idx),
            B::MutBorrowFieldGeneric(idx) => O::MutBorrowFieldGeneric(idx),
            B::MutBorrowVariantFieldGeneric(idx) => O::MutBorrowVariantFieldGeneric(idx),
            B::ImmBorrowField(idx) => O::ImmBorrowField(idx),
            B::ImmBorrowVariantField(idx) => O::ImmBorrowVariantField(idx),
            B::ImmBorrowFieldGeneric(idx) => O::ImmBorrowFieldGeneric(idx),
            B::ImmBorrowVariantFieldGeneric(idx) => O::ImmBorrowVariantFieldGeneric(idx),
            B::MutBorrowGlobal(idx) => O::MutBorrowGlobal(idx),
            B::MutBorrowGlobalGeneric(idx) => O::MutBorrowGlobalGeneric(idx),
            B::ImmBorrowGlobal(idx) => O::ImmBorrowGlobal(idx),
            B::ImmBorrowGlobalGeneric(idx) => O::ImmBorrowGlobalGeneric(idx),
            B::Add => O::Add,
            B::Sub => O::Sub,
            B::Mul => O::Mul,
            B::Mod => O::Mod,
            B::Div => O::Div,
            B::BitOr => O::BitOr,
            B::BitAnd => O::BitAnd,
            B::Xor => O::Xor,
            B::Or => O::Or,
            B::And => O::And,
            B::Not => O::Not,
            B::Eq => O::Eq,
            B::Neq => O::Neq,
            B::Lt => O::Lt,
            B::Gt => O::Gt,
            B::Le => O::Le,
            B::Ge => O::Ge,
            B::Abort => O::Abort,
            B::AbortMsg => O::AbortMsg,
            B::Nop => O::Nop,
            B::Exists(idx) => O::Exists(idx),
            B::ExistsGeneric(idx) => O::ExistsGeneric(idx),
            B::MoveFrom(idx) => O::MoveFrom(idx),
            B::MoveFromGeneric(idx) => O::MoveFromGeneric(idx),
            B::MoveTo(idx) => O::MoveTo(idx),
            B::MoveToGeneric(idx) => O::MoveToGeneric(idx),
            B::Shl => O::Shl,
            B::Shr => O::Shr,
            B::VecPack(idx, n) => O::VecPack(idx, n),
            B::VecLen(idx) => O::VecLen(idx),
            B::VecImmBorrow(idx) => O::VecImmBorrow(idx),
            B::VecMutBorrow(idx) => O::VecMutBorrow(idx),
            B::VecPushBack(idx) => O::VecPushBack(idx),
            B::VecPopBack(idx) => O::VecPopBack(idx),
            B::VecUnpack(idx, n) => O::VecUnpack(idx, n),
            B::VecSwap(idx) => O::VecSwap(idx),
            B::PackClosure(idx, mask) => O::PackClosure(idx, mask),
            B::PackClosureGeneric(idx, mask) => O::PackClosureGeneric(idx, mask),
            B::CallClosure(idx) => O::CallClosure(idx),
            B::LdU16(val) => O::LdU16(val),
            B::LdU32(val) => O::LdU32(val),
            B::LdU256(val) => O::LdU256(Box::new(val)),
            B::CastU16 => O::CastU16,
            B::CastU32 => O::CastU32,
            B::CastU256 => O::CastU256,
            B::LdI8(val) => O::LdI8(val),
            B::LdI16(val) => O::LdI16(val),
            B::LdI32(val) => O::LdI32(val),
            B::LdI64(val) => O::LdI64(val),
            B::LdI128(val) => O::LdI128(Box::new(val)),
            B::LdI256(val) => O::LdI256(Box::new(val)),
            B::CastI8 => O::CastI8,
            B::CastI16 => O::CastI16,
            B::CastI32 => O::CastI32,
            B::CastI64 => O::CastI64,
            B::CastI128 => O::CastI128,
            B::CastI256 => O::CastI256,
            B::Negate => O::Negate,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::mem::size_of;

    #[test]
    fn test_vm_operation_size() {
        let size = size_of::<Instruction>();

        assert_eq!(
            size, 16,
            "VMOperation size should be exactly 16 bytes, but got {} bytes",
            size
        );
    }
}
