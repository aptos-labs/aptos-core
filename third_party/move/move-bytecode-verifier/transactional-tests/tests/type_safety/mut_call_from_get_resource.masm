//# publish
module 0x42::Token
use 0x1::signer
struct T has key
  balance: u64

public fun new(l0: u64): T
    copy_loc l0
    pack T
    ret

public fun value(l0: &T): u64
    local l1: u64
    local l2: &u64
    move_loc l0
    borrow_field T, balance
    st_loc l2
    move_loc l2
    read_ref
    st_loc l1
    move_loc l1
    ret

public fun bump(l0: &mut T)
    local l1: &mut u64
    local l2: u64
    move_loc l0
    mut_borrow_field T, balance
    st_loc l1
    copy_loc l1
    read_ref
    ld_u64 1
    add
    st_loc l2
    copy_loc l2
    move_loc l1
    write_ref
    ret

public fun publish(l0: &signer, l1: T)
    move_loc l0
    move_loc l1
    move_to T
    ret

public fun test(l0: &signer) acquires T
    local l1: T
    local l2: address
    local l3: &mut T
    local l4: &T
    local l5: u64
    local l6: u64
    ld_u64 0
    call new
    st_loc l1
    copy_loc l0
    move_loc l1
    call publish
    move_loc l0
    call signer::address_of
    st_loc l2
    copy_loc l2
    mut_borrow_global T
    st_loc l3
    copy_loc l3
    freeze_ref
    st_loc l4
    move_loc l4
    call value
    st_loc l5
    move_loc l5
    ld_u64 0
    eq
    not
    br_false l0
    ld_u64 42
    abort
l0: copy_loc l3
    call bump
    move_loc l3
    freeze_ref
    st_loc l4
    move_loc l4
    call value
    st_loc l6
    move_loc l6
    ld_u64 1
    eq
    not
    br_false l1
    ld_u64 43
    abort
l1: ret



//# run --signers 0x43
script
use 0x42::Token
entry public fun main(l0: signer)
    borrow_loc l0
    call Token::test
    ret