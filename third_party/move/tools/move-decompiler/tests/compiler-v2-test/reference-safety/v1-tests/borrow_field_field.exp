module 0x8675309::M {
    struct Inner has copy, drop {
        f1: u64,
        f2: u64,
    }
    struct Outer has copy, drop {
        s1: Inner,
        s2: Inner,
    }
    fun id<T>(r: &T): &T {
        r
    }
    fun id_mut<T>(r: &mut T): &mut T {
        r
    }
    fun t0(outer: &mut Outer) {
        let _t1 = &outer.s1;
        let _t2 = &_t1.f1;
        *_t2;
        *_t1;
        *&_t1.f1;
        *_t1;
        *_t2;
        _t1 = &outer.s1;
        _t2 = id<u64>(&_t1.f1);
        *_t2;
        *_t1;
        *&_t1.f1;
        *_t1;
        *_t2;
        let _t3 = &mut outer.s1;
        _t2 = &_t3.f1;
        *_t2;
        *_t3;
        *&_t3.f1;
        *_t3;
        *_t2;
        _t3 = &mut outer.s1;
        _t2 = id<u64>(&_t3.f1);
        *_t2;
        *_t3;
        *&_t3.f1;
        *_t3;
        *_t2;
        _t3 = &mut outer.s1;
        let _t4 = &mut _t3.f1;
        *&mut _t3.f1;
        *_t4;
        *_t3;
        _t3 = &mut outer.s1;
        *id_mut<u64>(&mut _t3.f1);
        *&mut _t3.f1;
        *_t3;
    }
}

--- unable to recompile the decompiled code:
exiting with stackless-bytecode checks failed
error: cannot borrow field `f1` of value which is already mutably borrowed
   ┌─ borrow_field_field.move:47:15
   │
46 │         let _t4 = &mut _t3.f1;
   │                   ----------- field `f1` previously mutably borrowed here
47 │         *&mut _t3.f1;
   │               ^^^^^^ borrow attempted here
48 │         *_t4;
   │         ---- conflicting reference `_t4` used here
