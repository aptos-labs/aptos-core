module 0x42::test {
    struct Coin has drop, key {
        _0: u256,
    }
    struct Wrapper<T> has drop, key {
        _0: T,
    }
    fun bitand_vec_coin_new(x: vector<Coin>, index: u64) {
        let _t2 = &mut 0x1::vector::borrow_mut<Coin>(&mut x, index)._0;
        *_t2 = *_t2 & 0u256;
    }
    fun bitor_vec_new(x: &mut vector<u256>, index: u64) {
        let _t2 = 0x1::vector::borrow_mut<u256>(x, index);
        *_t2 = *_t2 | 0u256;
    }
    fun coin_double(self: &mut Coin) {
        let _t1 = &mut self._0;
        *_t1 = *_t1 * 0u256;
    }
    fun coin_mod_2(self: &mut Coin) {
        let _t1 = &mut self._0;
        *_t1 = *_t1 % 0u256;
    }
    fun half_wrapped_coin_new(x: &mut Wrapper<Coin>) {
        let _t1 = &mut &mut x._0._0;
        *_t1 = *_t1 / 0u256;
    }
    fun shl_vec_wrapped_coin_old(x: vector<Wrapper<Coin>>, index: u64) {
        let _t2 = &mut &mut 0x1::vector::borrow_mut<Wrapper<Coin>>(&mut x, index)._0._0;
        *_t2 = *_t2 << 1u8;
    }
    fun shr_coin_at(addr: address) {
        let _t1 = &mut borrow_global_mut(addr)._0;
        *_t1 = *_t1 >> 1u8;
    }
    fun sub1(x: &mut u256) {
        *x = *x - 0u256;
    }
    fun xor_vec_wrapped_coin_new(x: vector<Wrapper<Coin>>, index: u64) {
        let _t2 = &mut &mut 0x1::vector::borrow_mut<Wrapper<Coin>>(&mut x, index)._0._0;
        *_t2 = *_t2 ^ 0u256;
    }
}

--- unable to recompile the decompiled code:
exiting with context checking errors
error: cannot borrow from a reference
   ┌─ valid1.move:25:19
   │
25 │         let _t1 = &mut &mut x._0._0;
   │                   ^^^^^^^^^^^^^^^^^

error: cannot use `&mut u256` with an operator which expects a value of type `integer`
   ┌─ valid1.move:26:16
   │
26 │         *_t1 = *_t1 / 0u256;
   │                ^^^^

error: cannot borrow from a reference
   ┌─ valid1.move:29:19
   │
29 │         let _t2 = &mut &mut 0x1::vector::borrow_mut<Wrapper<Coin>>(&mut x, index)._0._0;
   │                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: cannot use `&mut u256` with an operator which expects a value of type `integer`
   ┌─ valid1.move:30:16
   │
30 │         *_t2 = *_t2 << 1u8;
   │                ^^^^

error: unable to infer instantiation of type `&mut key + struct{_0}` (consider providing type arguments or annotating the type)
   ┌─ valid1.move:33:24
   │
33 │         let _t1 = &mut borrow_global_mut(addr)._0;
   │                        ^^^^^^^^^^^^^^^^^^^^^^^

error: cannot borrow from a reference
   ┌─ valid1.move:40:19
   │
40 │         let _t2 = &mut &mut 0x1::vector::borrow_mut<Wrapper<Coin>>(&mut x, index)._0._0;
   │                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: cannot use `&mut u256` with an operator which expects a value of type `integer`
   ┌─ valid1.move:41:16
   │
41 │         *_t2 = *_t2 ^ 0u256;
   │                ^^^^
