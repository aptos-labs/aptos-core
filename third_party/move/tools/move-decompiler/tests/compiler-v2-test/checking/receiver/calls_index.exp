module 0x42::m {
    struct T has drop, store, key {
        w: W,
    }
    struct W has drop, store, key {
        x: u64,
    }
    struct S has drop, key {
        t: T,
    }
    struct Wrapper<T: copy> has copy, drop, store, key {
        inner: T,
    }
    fun boo(v: vector<S>, w: W) {
        merge(&mut &mut 0x1::vector::borrow_mut<S>(&mut v, 0).t.w, w);
    }
    fun merge(self: &mut W, s: W) {
        let _t3 = &mut self.x;
        *_t3 = *_t3 + *&(&s).x;
    }
    fun boo_(v: vector<S>, w: W) {
        merge(&mut &mut 0x1::vector::borrow_mut<S>(&mut v, 0).t.w, w);
    }
    fun boo_greater(v: vector<S>, w: W): bool {
        greater(&&0x1::vector::borrow<S>(&v, 0).t.w, w)
    }
    fun greater(self: &W, s: W): bool {
        *&self.x > *&(&s).x
    }
    fun boo_greater_(v: vector<S>, w: W): bool {
        greater(/*freeze*/&mut &mut 0x1::vector::borrow_mut<S>(&mut v, 0).t.w, w)
    }
    fun boo_greater_2(v: vector<W>, w: W): bool {
        greater(0x1::vector::borrow<W>(&v, 0), w)
    }
    fun boo_greater_2_(v: vector<W>, w: W): bool {
        greater(0x1::vector::borrow<W>(&v, 0), w)
    }
    fun dispatch<T: copy + store>(account: address): T {
        unwrap<T>(borrow_global<T>(account))
    }
    fun unwrap<T: copy>(self: &Wrapper<T>): T {
        *&self.inner
    }
    fun foo(account: address, w: W) {
        merge(&mut &mut borrow_global_mut(account).t.w, w);
    }
    fun foo_(account: address, w: W) {
        merge(&mut &mut borrow_global_mut(account).t.w, w);
    }
    fun foo_2(account: address, w: W) {
        merge(borrow_global_mut(account), w);
    }
    fun foo_3(account: address, w: W) {
        merge(borrow_global_mut(account), w);
    }
    fun foo_greater(account: address, w: W): bool {
        greater(&&borrow_global(account).t.w, w)
    }
    fun foo_greater_(account: address, w: W): bool {
        greater(/*freeze*/&mut &mut borrow_global_mut(account).t.w, w)
    }
    fun foo_greater_2(account: address, w: W): bool {
        greater(borrow_global(account), w)
    }
}

--- unable to recompile the decompiled code:
exiting with context checking errors
error: unexpected token
   ┌─ calls_index.move:25:17
   │
25 │         greater(&&0x1::vector::borrow<S>(&v, 0).t.w, w)
   │                 ^^
   │                 │
   │                 Unexpected '&&'
   │                 Expected an expression term
