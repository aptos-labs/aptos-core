module 0x8675::M {
    struct S {
        f: u64,
        g: u64,
    }
    fun id<T>(r: &T): &T {
        r
    }
    fun id_mut<T>(r: &mut T): &mut T {
        r
    }
    fun t0() {
        let _t0 = 0;
        let _t1 = &mut _t0;
        *&mut _t0;
        *_t1;
        if (_t0 == 0) _t0 = 3 else _t0 = 2;
        *id_mut<u64>(&mut _t0);
        *&mut _t0;
        let _t2 = &mut _t0;
        *_t2;
        *&_t0;
        *_t2;
        let _t3 = &_t0;
        *_t3;
        *&_t0;
        *_t3;
        _t3 = id<u64>(&_t0);
        *_t3;
        *&_t0;
        *_t3;
    }
    fun test1(r: u64): u64 {
        let _t2 = 0;
        while (r > 0) {
            r = r - 1;
            _t2 = _t2 + r
        };
        r + r + _t2
    }
    fun test1a(x: u64, r: &u64): u64 {
        let _t2 = *r;
        let _t3 = r;
        while (x > 0) x = x - *_t3;
        *r + _t2 + (x + 3 + x) + _t2
    }
}

--- unable to recompile the decompiled code:
exiting with stackless-bytecode checks failed
error: cannot copy local `_t0` which is still mutably borrowed
   ┌─ random.move:15:15
   │
14 │         let _t1 = &mut _t0;
   │                   -------- local `_t0` previously mutably borrowed here
15 │         *&mut _t0;
   │               ^^^ copy attempted here
16 │         *_t1;
   │         ---- conflicting reference `_t1` used here

error: cannot copy local `_t0` which is still mutably borrowed
   ┌─ random.move:22:11
   │
20 │         let _t2 = &mut _t0;
   │                   -------- local `_t0` previously mutably borrowed here
21 │         *_t2;
22 │         *&_t0;
   │           ^^^ copy attempted here
23 │         *_t2;
   │         ---- conflicting reference `_t2` used here
