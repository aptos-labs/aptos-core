module 0x1::option {
    use 0x1::vector;
    struct Option<Element> has copy, drop, store {
        vec: vector<Element>,
    }
    public fun borrow<Element>(self: &Option<Element>): &Element {
        assert!(is_some<Element>(self), 262145);
        vector::borrow<Element>(&self.vec, 0)
    }
    public fun borrow_mut<Element>(self: &mut Option<Element>): &mut Element {
        assert!(is_some<Element>(freeze(self)), 262145);
        vector::borrow_mut<Element>(&mut self.vec, 0)
    }
    public fun swap<Element>(self: &mut Option<Element>, e: Element): Element {
        assert!(is_some<Element>(freeze(self)), 262145);
        let _v0 = &mut self.vec;
        let _v1 = vector::pop_back<Element>(_v0);
        vector::push_back<Element>(_v0, e);
        _v1
    }
    public fun contains<Element>(self: &Option<Element>, e_ref: &Element): bool {
        vector::contains<Element>(&self.vec, e_ref)
    }
    public fun is_some<Element>(self: &Option<Element>): bool {
        !vector::is_empty<Element>(&self.vec)
    }
    public fun borrow_with_default<Element>(self: &Option<Element>, default_ref: &Element): &Element {
        let _v0;
        let _v1 = &self.vec;
        if (vector::is_empty<Element>(_v1)) _v0 = default_ref else _v0 = vector::borrow<Element>(_v1, 0);
        _v0
    }
    public fun destroy_none<Element>(self: Option<Element>) {
        assert!(is_none<Element>(&self), 262144);
        let Option<Element>{vec: _v0} = self;
        vector::destroy_empty<Element>(_v0);
    }
    public fun is_none<Element>(self: &Option<Element>): bool {
        vector::is_empty<Element>(&self.vec)
    }
    public fun destroy_some<Element>(self: Option<Element>): Element {
        assert!(is_some<Element>(&self), 262145);
        let Option<Element>{vec: _v0} = self;
        let _v1 = _v0;
        let _v2 = vector::pop_back<Element>(&mut _v1);
        vector::destroy_empty<Element>(_v1);
        _v2
    }
    public fun destroy_with_default<Element: drop>(self: Option<Element>, default: Element): Element {
        let _v0;
        let Option<Element>{vec: _v1} = self;
        let _v2 = _v1;
        if (vector::is_empty<Element>(freeze(&mut _v2))) _v0 = default else _v0 = vector::pop_back<Element>(&mut _v2);
        _v0
    }
    public fun extract<Element>(self: &mut Option<Element>): Element {
        assert!(is_some<Element>(freeze(self)), 262145);
        vector::pop_back<Element>(&mut self.vec)
    }
    public fun fill<Element>(self: &mut Option<Element>, e: Element) {
        let _v0 = &mut self.vec;
        assert!(vector::is_empty<Element>(freeze(_v0)), 262144);
        vector::push_back<Element>(_v0, e);
    }
    public fun from_vec<Element>(vec: vector<Element>): Option<Element> {
        assert!(vector::length<Element>(&vec) <= 1, 262146);
        Option<Element>{vec: vec}
    }
    public fun get_with_default<Element: copy + drop>(self: &Option<Element>, default: Element): Element {
        let _v0;
        let _v1 = &self.vec;
        if (vector::is_empty<Element>(_v1)) _v0 = default else _v0 = *vector::borrow<Element>(_v1, 0);
        _v0
    }
    public fun none<Element>(): Option<Element> {
        Option<Element>{vec: vector::empty<Element>()}
    }
    public fun some<Element>(e: Element): Option<Element> {
        Option<Element>{vec: vector::singleton<Element>(e)}
    }
    public fun swap_or_fill<Element>(self: &mut Option<Element>, e: Element): Option<Element> {
        let _v0;
        let _v1 = &mut self.vec;
        if (vector::is_empty<Element>(freeze(_v1))) _v0 = none<Element>() else _v0 = some<Element>(vector::pop_back<Element>(_v1));
        vector::push_back<Element>(_v1, e);
        _v0
    }
    public fun to_vec<Element>(self: Option<Element>): vector<Element> {
        let Option<Element>{vec: _v0} = self;
        _v0
    }
}

============ recompilation succeeded ========
