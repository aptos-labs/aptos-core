module 0x1::simple_map {
    use 0x1::option;
    use 0x1::error;
    use 0x1::vector;
    struct Element<Key, Value> has copy, drop, store {
        key: Key,
        value: Value,
    }
    struct SimpleMap<Key, Value> has copy, drop, store {
        data: vector<Element<Key, Value>>,
    }
    public fun length<Key: store, Value: store>(self: &SimpleMap<Key, Value>): u64 {
        vector::length<Element<Key, Value>>(&self.data)
    }
    public fun borrow<Key: store, Value: store>(self: &SimpleMap<Key, Value>, key: &Key): &Value {
        let _t2 = find<Key,Value>(self, key);
        if (!option::is_some<u64>(&_t2)) {
            let _t18 = error::invalid_argument(2);
            abort _t18
        };
        let _t3 = option::extract<u64>(&mut _t2);
        &vector::borrow<Element<Key, Value>>(&self.data, _t3).value
    }
    public fun borrow_mut<Key: store, Value: store>(self: &mut SimpleMap<Key, Value>, key: &Key): &mut Value {
        let _t2 = find<Key,Value>(freeze(self), key);
        if (!option::is_some<u64>(&_t2)) {
            let _t19 = error::invalid_argument(2);
            abort _t19
        };
        let _t3 = option::extract<u64>(&mut _t2);
        &mut vector::borrow_mut<Element<Key, Value>>(&mut self.data, _t3).value
    }
    public fun destroy_empty<Key: store, Value: store>(self: SimpleMap<Key, Value>) {
        let SimpleMap<Key,Value>{data: _t2} = self;
        vector::destroy_empty<Element<Key, Value>>(_t2);
    }
    fun find<Key: store, Value: store>(self: &SimpleMap<Key, Value>, key: &Key): option::Option<u64> {
        let _t2 = vector::length<Element<Key, Value>>(&self.data);
        let _t3 = 0;
        'l0: loop {
            loop {
                if (!(_t3 < _t2)) break 'l0;
                if (&vector::borrow<Element<Key, Value>>(&self.data, _t3).key == key) break;
                _t3 = _t3 + 1
            };
            return option::some<u64>(_t3)
        };
        option::none<u64>()
    }
    public fun remove<Key: store, Value: store>(self: &mut SimpleMap<Key, Value>, key: &Key): (Key, Value) {
        let _t2 = find<Key,Value>(freeze(self), key);
        if (!option::is_some<u64>(&_t2)) {
            let _t22 = error::invalid_argument(2);
            abort _t22
        };
        let _t3 = option::extract<u64>(&mut _t2);
        let Element<Key,Value>{key: _t18,value: _t19} = vector::swap_remove<Element<Key, Value>>(&mut self.data, _t3);
        (_t18, _t19)
    }
    public fun add<Key: store, Value: store>(self: &mut SimpleMap<Key, Value>, key: Key, value: Value) {
        let _t5 = freeze(self);
        let _t6 = &key;
        if (!option::is_none<u64>(&find<Key,Value>(_t5, _t6))) {
            let _t17 = error::invalid_argument(1);
            abort _t17
        };
        let _t11 = &mut self.data;
        let _t14 = Element<Key,Value>{key: key,value: value};
        vector::push_back<Element<Key, Value>>(_t11, _t14);
    }
    public fun add_all<Key: store, Value: store>(self: &mut SimpleMap<Key, Value>, keys: vector<Key>, values: vector<Value>) {
        let _t3 = keys;
        let _t4 = values;
        vector::reverse<Key>(&mut _t3);
        vector::reverse<Value>(&mut _t4);
        let _t5 = _t3;
        let _t6 = _t4;
        let _t7 = vector::length<Key>(&_t5);
        if (!(_t7 == vector::length<Value>(&_t6))) abort 131074;
        while (_t7 > 0) {
            let _t8 = vector::pop_back<Key>(&mut _t5);
            let _t9 = vector::pop_back<Value>(&mut _t6);
            add<Key,Value>(self, _t8, _t9);
            _t7 = _t7 - 1;
            continue
        };
        vector::destroy_empty<Key>(_t5);
        vector::destroy_empty<Value>(_t6);
    }
    public fun keys<Key: copy, Value>(self: &SimpleMap<Key, Value>): vector<Key> {
        let _t1 = &self.data;
        let _t2 = vector::empty<Key>();
        let _t3 = 0;
        let _t4 = vector::length<Element<Key, Value>>(_t1);
        while (_t3 < _t4) {
            let _t5 = vector::borrow<Element<Key, Value>>(_t1, _t3);
            let _t18 = &mut _t2;
            let _t21 = *&_t5.key;
            vector::push_back<Key>(_t18, _t21);
            _t3 = _t3 + 1;
            continue
        };
        _t2
    }
    public fun values<Key, Value: copy>(self: &SimpleMap<Key, Value>): vector<Value> {
        let _t1 = &self.data;
        let _t2 = vector::empty<Value>();
        let _t3 = 0;
        let _t4 = vector::length<Element<Key, Value>>(_t1);
        while (_t3 < _t4) {
            let _t5 = vector::borrow<Element<Key, Value>>(_t1, _t3);
            let _t18 = &mut _t2;
            let _t21 = *&_t5.value;
            vector::push_back<Value>(_t18, _t21);
            _t3 = _t3 + 1;
            continue
        };
        _t2
    }
    public fun contains_key<Key: store, Value: store>(self: &SimpleMap<Key, Value>, key: &Key): bool {
        option::is_some<u64>(&find<Key,Value>(self, key))
    }
    public fun create<Key: store, Value: store>(): SimpleMap<Key, Value> {
        new<Key,Value>()
    }
    public fun new<Key: store, Value: store>(): SimpleMap<Key, Value> {
        SimpleMap<Key,Value>{data: vector::empty<Element<Key, Value>>()}
    }
    public fun new_from<Key: store, Value: store>(keys: vector<Key>, values: vector<Value>): SimpleMap<Key, Value> {
        let _t2 = new<Key,Value>();
        add_all<Key,Value>(&mut _t2, keys, values);
        _t2
    }
    public fun to_vec_pair<Key: store, Value: store>(self: SimpleMap<Key, Value>): (vector<Key>, vector<Value>) {
        let _t1 = vector::empty<Key>();
        let _t2 = vector::empty<Value>();
        let SimpleMap<Key,Value>{data: _t11} = self;
        let _t3 = _t11;
        vector::reverse<Element<Key, Value>>(&mut _t3);
        let _t4 = _t3;
        let _t5 = vector::length<Element<Key, Value>>(&_t4);
        while (_t5 > 0) {
            let Element<Key,Value>{key: _t21,value: _t22} = vector::pop_back<Element<Key, Value>>(&mut _t4);
            vector::push_back<Key>(&mut _t1, _t21);
            vector::push_back<Value>(&mut _t2, _t22);
            _t5 = _t5 - 1;
            continue
        };
        vector::destroy_empty<Element<Key, Value>>(_t4);
        (_t1, _t2)
    }
    public fun upsert<Key: store, Value: store>(self: &mut SimpleMap<Key, Value>, key: Key, value: Value): (option::Option<Key>, option::Option<Value>) {
        let _t3 = &mut self.data;
        let _t4 = vector::length<Element<Key, Value>>(freeze(_t3));
        let _t5 = 0;
        'l0: loop {
            loop {
                if (!(_t5 < _t4)) break 'l0;
                if (&vector::borrow<Element<Key, Value>>(freeze(_t3), _t5).key == &key) break;
                _t5 = _t5 + 1
            };
            let _t28 = Element<Key,Value>{key: key,value: value};
            vector::push_back<Element<Key, Value>>(_t3, _t28);
            vector::swap<Element<Key, Value>>(_t3, _t5, _t4);
            let Element<Key,Value>{key: _t34,value: _t35} = vector::pop_back<Element<Key, Value>>(_t3);
            let _t36 = option::some<Key>(_t34);
            let _t38 = option::some<Value>(_t35);
            return (_t36, _t38)
        };
        _t3 = &mut self.data;
        let _t7 = Element<Key,Value>{key: key,value: value};
        vector::push_back<Element<Key, Value>>(_t3, _t7);
        let _t50 = option::none<Key>();
        let _t51 = option::none<Value>();
        (_t50, _t51)
    }
}

============ recompilation succeeded ========
