module 0x1::simple_map {
    use 0x1::option;
    use 0x1::error;
    use 0x1::vector;
    struct Element<Key, Value> has copy, drop, store {
        key: Key,
        value: Value,
    }
    struct SimpleMap<Key, Value> has copy, drop, store {
        data: vector<Element<Key, Value>>,
    }
    public fun length<Key: store, Value: store>(self: &SimpleMap<Key, Value>): u64 {
        vector::length<Element<Key, Value>>(&self.data)
    }
    public fun borrow<Key: store, Value: store>(self: &SimpleMap<Key, Value>, key: &Key): &Value {
        let _v0 = find<Key,Value>(self, key);
        if (!option::is_some<u64>(&_v0)) {
            let _v1 = error::invalid_argument(2);
            abort _v1
        };
        let _v2 = option::extract<u64>(&mut _v0);
        &vector::borrow<Element<Key, Value>>(&self.data, _v2).value
    }
    public fun borrow_mut<Key: store, Value: store>(self: &mut SimpleMap<Key, Value>, key: &Key): &mut Value {
        let _v0 = find<Key,Value>(freeze(self), key);
        if (!option::is_some<u64>(&_v0)) {
            let _v1 = error::invalid_argument(2);
            abort _v1
        };
        let _v2 = option::extract<u64>(&mut _v0);
        &mut vector::borrow_mut<Element<Key, Value>>(&mut self.data, _v2).value
    }
    public fun destroy_empty<Key: store, Value: store>(self: SimpleMap<Key, Value>) {
        let SimpleMap<Key,Value>{data: _v0} = self;
        vector::destroy_empty<Element<Key, Value>>(_v0);
    }
    fun find<Key: store, Value: store>(self: &SimpleMap<Key, Value>, key: &Key): option::Option<u64> {
        let _v0 = vector::length<Element<Key, Value>>(&self.data);
        let _v1 = 0;
        'l0: loop {
            loop {
                if (!(_v1 < _v0)) break 'l0;
                if (&vector::borrow<Element<Key, Value>>(&self.data, _v1).key == key) break;
                _v1 = _v1 + 1
            };
            return option::some<u64>(_v1)
        };
        option::none<u64>()
    }
    public fun remove<Key: store, Value: store>(self: &mut SimpleMap<Key, Value>, key: &Key): (Key, Value) {
        let _v0 = find<Key,Value>(freeze(self), key);
        if (!option::is_some<u64>(&_v0)) {
            let _v1 = error::invalid_argument(2);
            abort _v1
        };
        let _v2 = option::extract<u64>(&mut _v0);
        let Element<Key,Value>{key: _v3, value: _v4} = vector::swap_remove<Element<Key, Value>>(&mut self.data, _v2);
        (_v3, _v4)
    }
    public fun add<Key: store, Value: store>(self: &mut SimpleMap<Key, Value>, key: Key, value: Value) {
        let _v0 = freeze(self);
        let _v1 = &key;
        let _v2 = find<Key,Value>(_v0, _v1);
        if (!option::is_none<u64>(&_v2)) {
            let _v3 = error::invalid_argument(1);
            abort _v3
        };
        let _v4 = &mut self.data;
        let _v5 = Element<Key,Value>{key: key, value: value};
        vector::push_back<Element<Key, Value>>(_v4, _v5);
    }
    public fun add_all<Key: store, Value: store>(self: &mut SimpleMap<Key, Value>, keys: vector<Key>, values: vector<Value>) {
        let _v0 = keys;
        let _v1 = values;
        vector::reverse<Key>(&mut _v0);
        vector::reverse<Value>(&mut _v1);
        let _v2 = _v0;
        let _v3 = _v1;
        let _v4 = vector::length<Key>(&_v2);
        let _v5 = vector::length<Value>(&_v3);
        assert!(_v4 == _v5, 131074);
        while (_v4 > 0) {
            let _v6 = vector::pop_back<Key>(&mut _v2);
            let _v7 = vector::pop_back<Value>(&mut _v3);
            add<Key,Value>(self, _v6, _v7);
            _v4 = _v4 - 1;
            continue
        };
        vector::destroy_empty<Key>(_v2);
        vector::destroy_empty<Value>(_v3);
    }
    public fun keys<Key: copy, Value>(self: &SimpleMap<Key, Value>): vector<Key> {
        let _v0 = &self.data;
        let _v1 = vector::empty<Key>();
        let _v2 = 0;
        let _v3 = vector::length<Element<Key, Value>>(_v0);
        while (_v2 < _v3) {
            let _v4 = vector::borrow<Element<Key, Value>>(_v0, _v2);
            let _v5 = &mut _v1;
            let _v6 = *&_v4.key;
            vector::push_back<Key>(_v5, _v6);
            _v2 = _v2 + 1;
            continue
        };
        _v1
    }
    public fun values<Key, Value: copy>(self: &SimpleMap<Key, Value>): vector<Value> {
        let _v0 = &self.data;
        let _v1 = vector::empty<Value>();
        let _v2 = 0;
        let _v3 = vector::length<Element<Key, Value>>(_v0);
        while (_v2 < _v3) {
            let _v4 = vector::borrow<Element<Key, Value>>(_v0, _v2);
            let _v5 = &mut _v1;
            let _v6 = *&_v4.value;
            vector::push_back<Value>(_v5, _v6);
            _v2 = _v2 + 1;
            continue
        };
        _v1
    }
    public fun contains_key<Key: store, Value: store>(self: &SimpleMap<Key, Value>, key: &Key): bool {
        let _v0 = find<Key,Value>(self, key);
        option::is_some<u64>(&_v0)
    }
    public fun create<Key: store, Value: store>(): SimpleMap<Key, Value> {
        new<Key,Value>()
    }
    public fun new<Key: store, Value: store>(): SimpleMap<Key, Value> {
        SimpleMap<Key,Value>{data: vector::empty<Element<Key, Value>>()}
    }
    public fun new_from<Key: store, Value: store>(keys: vector<Key>, values: vector<Value>): SimpleMap<Key, Value> {
        let _v0 = new<Key,Value>();
        add_all<Key,Value>(&mut _v0, keys, values);
        _v0
    }
    public fun to_vec_pair<Key: store, Value: store>(self: SimpleMap<Key, Value>): (vector<Key>, vector<Value>) {
        let _v0 = vector::empty<Key>();
        let _v1 = vector::empty<Value>();
        let SimpleMap<Key,Value>{data: _v2} = self;
        let _v3 = _v2;
        vector::reverse<Element<Key, Value>>(&mut _v3);
        let _v4 = _v3;
        let _v5 = vector::length<Element<Key, Value>>(&_v4);
        while (_v5 > 0) {
            let Element<Key,Value>{key: _v6, value: _v7} = vector::pop_back<Element<Key, Value>>(&mut _v4);
            vector::push_back<Key>(&mut _v0, _v6);
            vector::push_back<Value>(&mut _v1, _v7);
            _v5 = _v5 - 1;
            continue
        };
        vector::destroy_empty<Element<Key, Value>>(_v4);
        (_v0, _v1)
    }
    public fun upsert<Key: store, Value: store>(self: &mut SimpleMap<Key, Value>, key: Key, value: Value): (option::Option<Key>, option::Option<Value>) {
        let _v0 = &mut self.data;
        let _v1 = vector::length<Element<Key, Value>>(freeze(_v0));
        let _v2 = 0;
        'l0: loop {
            loop {
                if (!(_v2 < _v1)) break 'l0;
                let _v3 = &vector::borrow<Element<Key, Value>>(freeze(_v0), _v2).key;
                let _v4 = &key;
                if (_v3 == _v4) break;
                _v2 = _v2 + 1;
                continue
            };
            let _v5 = Element<Key,Value>{key: key, value: value};
            vector::push_back<Element<Key, Value>>(_v0, _v5);
            vector::swap<Element<Key, Value>>(_v0, _v2, _v1);
            let Element<Key,Value>{key: _v6, value: _v7} = vector::pop_back<Element<Key, Value>>(_v0);
            let _v8 = option::some<Key>(_v6);
            let _v9 = option::some<Value>(_v7);
            return (_v8, _v9)
        };
        _v0 = &mut self.data;
        let _v10 = Element<Key,Value>{key: key, value: value};
        vector::push_back<Element<Key, Value>>(_v0, _v10);
        let _v11 = option::none<Key>();
        let _v12 = option::none<Value>();
        (_v11, _v12)
    }
}

============ recompilation succeeded ========
