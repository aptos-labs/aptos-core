//**** Cross-compiled for `move` syntax from `tests/simplifier/conditional_borrow.move`

//# publish
module 0x8675::M {
    struct S has copy, drop {
        f: u64,
    }
    public fun test(): u64 {
        let _t1 = test1(7);
        let _t3 = test1(2);
        _t1 + _t3
    }
    fun test1(p0: u64): u64 {
        let _t1;
        if (p0 < 4) _t1 = p0 else _t1 = 3;
        let _t3 = &mut _t1;
        *_t3 = 10;
        let _t4 = p0;
        _t3 = &mut _t4;
        *_t3 = *_t3 + 1;
        let _t2 = _t4;
        let _t5 = _t2 + 0;
        _t3 = &mut _t5;
        *_t3 = *_t3 + 2;
        let _t6 = _t2;
        _t3 = &mut _t6;
        *_t3 = *_t3 + 4;
        let _t7 = _t2;
        _t3 = &mut _t7;
        *_t3 = *_t3 + 8;
        let _t8 = _t2;
        _t3 = &mut _t8;
        *_t3 = *_t3 + 16;
        _t2
    }
    fun test1b(p0: S): u64 {
        let _t2;
        let _t1 = S{f: 3};
        if (*&(&p0).f < 4) _t2 = p0 else _t2 = _t1;
        let _t3 = &mut _t2;
        let _t4 = *_t3;
        let _t27 = &mut (&mut _t4).f;
        *_t27 = 10;
        let _t5 = p0;
        _t3 = &mut _t5;
        let _t6 = *_t3;
        let _t36 = *&(&_t6).f + 1;
        let _t7 = *_t3;
        let _t40 = &mut (&mut _t7).f;
        *_t40 = _t36;
        let _t8 = _t5;
        let _t9 = &mut (&mut _t8).f;
        *_t9 = *_t9 + 1;
        let _t10 = _t8;
        let _t11 = *&(&_t10).f;
        _t9 = &mut _t11;
        *_t9 = *_t9 + 1;
        let _t12 = *&(&_t10).f;
        _t9 = &mut _t12;
        *_t9 = *_t9 + 8;
        let _t13 = *&(&_t10).f;
        _t9 = &mut _t13;
        *_t9 = *_t9 + 16;
        *&(&_t10).f
    }
    public fun testb(): u64 {
        let _t2 = test1b(S{f: 7});
        let _t5 = test1b(S{f: 2});
        _t2 + _t5
    }
}


//# run 0x8675::M::test

//# run 0x8675::M::testb