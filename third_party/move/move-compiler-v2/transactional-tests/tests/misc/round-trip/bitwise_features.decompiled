//**** Cross-compiled for `move` syntax from `tests/misc/bitwise_features.move`

//# publish
module 0x42::TestFeatures {
    struct Features has key {
        features: vector<u8>,
    }
    fun contains(p0: &vector<u8>, p1: u64): bool {
        let _v0;
        let _v1 = p1 / 8;
        let _v2 = (p1 % 8) as u8;
        let _v3 = 1u8 << _v2;
        let _v4 = 0x1::vector::length<u8>(p0);
        if (_v1 < _v4) _v0 = *0x1::vector::borrow<u8>(p0, _v1) & _v3 != 0u8 else _v0 = false;
        _v0
    }
    public fun enable_feature_flags(p0: vector<u64>)
        acquires Features
    {
        let _v0 = &mut borrow_global_mut<Features>(@0xbeef).features;
        let _v1 = 0;
        let _v2 = 0x1::vector::length<u64>(&p0);
        while (_v1 < _v2) {
            let _v3 = *0x1::vector::borrow<u64>(&p0, _v1);
            set(_v0, _v3, true);
            _v1 = _v1 + 1;
            continue
        };
    }
    fun set(p0: &mut vector<u8>, p1: u64, p2: bool) {
        let _v0 = 0x1::vector::length<u8>(freeze(p0));
        let _v1 = *p0;
        let _v2 = p1 / 8;
        let _v3 = (p1 % 8) as u8;
        let _v4 = 1u8 << _v3;
        while (0x1::vector::length<u8>(freeze(p0)) <= _v2) {
            0x1::vector::push_back<u8>(p0, 0u8);
            _v0 = _v0 + 1
        };
        let _v5 = 0x1::vector::borrow_mut<u8>(p0, _v2);
        if (p2) *_v5 = *_v5 | _v4 else *_v5 = *_v5 & (255u8 ^ _v4);
    }
    public fun test(p0: signer)
        acquires Features
    {
        let _v0 = &p0;
        let _v1 = Features{features: vector[1u8, 2u8, 3u8]};
        move_to<Features>(_v0, _v1);
        enable_feature_flags(vector[2]);
        assert!(contains(&borrow_global<Features>(@0xbeef).features, 2), 0);
        if (contains(&borrow_global<Features>(@0xbeef).features, 1)) abort 1;
        if (contains(&borrow_global<Features>(@0xbeef).features, 3)) abort 2;
    }
}


//# run 0x42::TestFeatures::test --signers 0xbeef