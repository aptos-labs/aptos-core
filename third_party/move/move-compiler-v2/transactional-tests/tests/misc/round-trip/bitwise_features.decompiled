//**** Cross-compiled for `move` syntax from `tests/misc/bitwise_features.move`

//# publish
module 0x42::TestFeatures {
    struct Features has key {
        features: vector<u8>,
    }
    fun contains(p0: &vector<u8>, p1: u64): bool {
        let _t4;
        let _t2 = p1 / 8;
        let _t12 = (p1 % 8) as u8;
        let _t3 = 1u8 << _t12;
        let _t16 = 0x1::vector::length<u8>(p0);
        if (_t2 < _t16) _t4 = *0x1::vector::borrow<u8>(p0, _t2) & _t3 != 0u8 else _t4 = false;
        _t4
    }
    public fun enable_feature_flags(p0: vector<u64>)
        acquires Features
    {
        let _t1 = &mut borrow_global_mut<Features>(@0xbeef).features;
        let _t2 = 0;
        let _t3 = 0x1::vector::length<u64>(&p0);
        while (_t2 < _t3) {
            let _t17 = *0x1::vector::borrow<u64>(&p0, _t2);
            set(_t1, _t17, true);
            _t2 = _t2 + 1;
            continue
        };
    }
    fun set(p0: &mut vector<u8>, p1: u64, p2: bool) {
        let _t3 = 0x1::vector::length<u8>(freeze(p0));
        let _t11 = *p0;
        let _t4 = p1 / 8;
        let _t19 = (p1 % 8) as u8;
        let _t5 = 1u8 << _t19;
        while (0x1::vector::length<u8>(freeze(p0)) <= _t4) {
            0x1::vector::push_back<u8>(p0, 0u8);
            _t3 = _t3 + 1
        };
        let _t6 = 0x1::vector::borrow_mut<u8>(p0, _t4);
        if (p2) *_t6 = *_t6 | _t5 else *_t6 = *_t6 & (255u8 ^ _t5);
    }
    public fun test(p0: signer)
        acquires Features
    {
        let _t1 = &p0;
        let _t3 = Features{features: vector[1u8, 2u8, 3u8]};
        move_to<Features>(_t1, _t3);
        enable_feature_flags(vector[2]);
        if (!contains(&borrow_global<Features>(@0xbeef).features, 2)) abort 0;
        if (contains(&borrow_global<Features>(@0xbeef).features, 1)) abort 1;
        if (contains(&borrow_global<Features>(@0xbeef).features, 3)) abort 2;
    }
}


//# run 0x42::TestFeatures::test --signers 0xbeef