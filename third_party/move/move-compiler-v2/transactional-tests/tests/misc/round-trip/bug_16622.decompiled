//**** Cross-compiled for `move` syntax from `tests/misc/bug_16622.move`

//# publish
module 0xcafe::m0 {
    enum Enum0 has copy, drop {
        Variant0,
        Variant1 {
            field1: bool,
        }
    }
    struct S has copy, drop {
        field2: Enum0,
    }
    public fun f0() {
        let _t4;
        let _t0 = S{field2: Enum0::Variant1{field1: false}};
        let _t2 = *&(&_t0).field2;
        if (&_t2 is Variant0) {
            let Enum0::Variant0{} = _t2;
            let _t3 = true;
            _t4 = &mut _t3
        } else _t4 = &mut (&mut (&mut _t0).field2).field1;
        *_t4 = true;
    }
}


//# run 0xCAFE::m0::f0

//# publish
module 0xcafe::m1 {
    enum Enum0 has copy, drop {
        Variant0,
        Variant1,
    }
    struct S has copy, drop {
        field: Enum0,
    }
    public fun f0() {
        let _t4;
        let _t0 = S{field: Enum0::Variant1{}};
        let _t2 = *&(&_t0).field;
        if (&_t2 is Variant1) {
            let Enum0::Variant1{} = _t2;
            let _t3 = true;
            _t4 = &mut _t3
        } else {
            let _t5 = _t0;
            let _t23 = *&(&_t5).field;
            let _t6 = true;
            _t4 = &mut _t6
        };
        *_t4 = true;
    }
    public fun f1() {
        let _t7;
        let _t0 = S{field: Enum0::Variant1{}};
        let _t2 = *&(&_t0).field;
        let _t3 = *&(&_t0).field;
        let _t18 = &_t2;
        let _t4 = &_t3;
        if ((_t18 is Variant1) && (_t4 is Variant1)) {
            let Enum0::Variant1{} = _t2;
            let Enum0::Variant1{} = _t3;
            let _t8 = true;
            _t7 = &mut _t8
        } else {
            let _t5 = _t0;
            let _t25 = *&(&_t5).field;
            let _t6 = true;
            _t7 = &mut _t6
        };
        *_t7 = true;
    }
}


//# run 0xCAFE::m1::f0

//# run 0xCAFE::m1::f1

//# publish
module 0xcafe::m2 {
    enum Enum0 has copy, drop {
        Variant0,
        Variant1 {
            field1: bool,
        }
    }
    enum Enum1 has copy, drop {
        Variant2 {
            field2: Enum0,
        }
    }
    struct Struct1 has copy, drop {
        _0: bool,
    }
    public fun f0() {
        let _t3;
        let _t0 = Enum1::Variant2{field2: Enum0::Variant1{field1: false}};
        let _t2 = *&(&_t0).field2;
        if (&_t2 is Variant1) {
            let Enum0::Variant1{field1: _t19} = _t2;
            _t3 = Struct1{_0: true}
        } else {
            let _t8 = _t0;
            let _t37 = *&(&_t8).field2;
            _t3 = Struct1{_0: true}
        };
        let _t4 = Struct1{_0: *&(&(&_t0).field2).field1};
        let _t5 = &mut _t4;
        *_t5 = _t3;
        let _t6 = true;
        let _t7 = &mut _t6;
        *_t7 = true;
    }
}


//# run 0xCAFE::m2::f0

//# publish
module 0xcafe::m3 {
    enum Enum0 has copy, drop {
        Variant0,
        Variant1,
    }
    struct S has copy, drop {
        field: Enum0,
    }
    fun f0(p0: S) {
        let _t4;
        let _t2 = *&(&p0).field;
        if (&_t2 is Variant0) {
            let Enum0::Variant0{} = _t2;
            let _t3 = 1u8;
            _t4 = &mut _t3
        } else {
            let _t19 = *&(&p0).field;
            let _t5 = 1u8;
            _t4 = &mut _t5
        };
        *_t4 = 1u8;
    }
    public fun test() {
        f0(S{field: Enum0::Variant1{}});
    }
}


//# run 0xCAFE::m3::test