//**** Cross-compiled for `move` syntax from `tests/misc/freeze_mut_ref.move`

//# publish
module 0x42::freeze_mut_ref {
    struct G has drop {
        f: u64,
    }
    public fun borrow_mut<T0>(p0: &mut vector<T0>): &T0 {
        freeze(0x1::vector::borrow_mut<T0>(p0, 0))
    }
    public fun borrow_mut2<T0>(p0: &mut T0): &T0 {
        freeze(p0)
    }
    fun t1(p0: &mut G): &G {
        freeze(p0)
    }
    fun t2(p0: &mut u64, p1: &mut u64): (&mut u64, &mut u64) {
        (p0, p1)
    }
    public fun t5(p0: &mut G): (u64, u64, u64) {
        let _v0 = 0 + 1 + 1;
        let _v1 = &mut p0.f;
        let _v2 = 2;
        let _v3 = &mut _v2;
        *_v1 = 0;
        let _v4 = freeze(_v3);
        *_v1 = 2;
        let _v5 = *_v4;
        let _v6 = *_v1;
        (_v5, _v6, _v0)
    }
    fun test_1() {
        let _v0 = 0;
        assert!(*freeze(&mut _v0) == 0, 0);
        let _v1 = G{f: 3};
        assert!(*&t1(&mut _v1).f == 3, 1);
    }
    fun test_2() {
        let _v0 = G{f: 50};
        let (_v1,_v2,_v3) = t5(&mut _v0);
        assert!(_v1 == 2, 0);
        assert!(_v2 == 2, 1);
        assert!(_v3 == 2, 2);
    }
    fun test_3() {
        let _v0 = vector[0];
        assert!(*borrow_mut<u64>(&mut _v0) == 0, 0);
    }
    fun test_5() {
        let _v0 = 3;
        assert!(*borrow_mut2<u64>(&mut _v0) == 3, 0);
    }
    fun test_6() {
        let _v0 = G{f: 2};
        let _v1 = G{f: 3};
        assert!(*&(&_v0).f == 2, 0);
    }
    fun test_7() {
        let _v0 = G{f: 2};
        let _v1 = G{f: 3};
        assert!(*&(&_v0).f == 2, 0);
    }
}


//# run 0x42::freeze_mut_ref::test_1

//# run 0x42::freeze_mut_ref::test_2

//# run 0x42::freeze_mut_ref::test_3

//# run 0x42::freeze_mut_ref::test_5

//# run 0x42::freeze_mut_ref::test_6

//# run 0x42::freeze_mut_ref::test_7