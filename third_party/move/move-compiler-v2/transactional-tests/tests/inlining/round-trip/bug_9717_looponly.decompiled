//**** Cross-compiled for `move` syntax from `tests/inlining/bug_9717_looponly.move`

//# publish
module 0xcafe::vectors {
    public entry fun entry_test_guess_flips_abort() {
        guess_flips_abort(vector[0u8, 0u8, 0u8, 0u8]);
    }
    public entry fun guess_flips_abort(p0: vector<u8>) {
        let _t1 = 0;
        let _t2 = &p0;
        'l0: loop {
            loop {
                let _t7 = 0x1::vector::length<u8>(_t2);
                if (!(_t1 < _t7)) break 'l0;
                if (!(*0x1::vector::borrow<u8>(_t2, _t1) == 0u8)) break;
                _t1 = _t1 + 1;
                continue
            };
            abort 3
        };
    }
    public entry fun entry_test_guess_flips_break() {
        guess_flips_break(vector[0u8, 0u8, 0u8, 0u8]);
    }
    public entry fun guess_flips_break(p0: vector<u8>) {
        let _t1 = 0;
        let _t2 = &p0;
        loop {
            let _t7 = 0x1::vector::length<u8>(_t2);
            if (!(_t1 < _t7)) break;
            if (*0x1::vector::borrow<u8>(_t2, _t1) != 0u8) break;
            _t1 = _t1 + 1;
            continue
        };
    }
    public entry fun entry_test_guess_flips_break2() {
        guess_flips_break2(vector[0u8, 0u8, 0u8, 0u8]);
    }
    public entry fun guess_flips_break2(p0: vector<u8>) {
        let _t1 = 0;
        let _t2 = &p0;
        loop {
            let _t7 = 0x1::vector::length<u8>(_t2);
            if (!(_t1 < _t7)) break;
            if (*0x1::vector::borrow<u8>(_t2, _t1) != 0u8) break;
            _t1 = _t1 + 1;
            if (!(*0x1::vector::borrow<u8>(_t2, _t1) == 5u8)) continue;
            break
        };
    }
    public entry fun entry_test_guess_flips_continue() {
        guess_flips_continue(vector[0u8, 0u8, 0u8, 0u8]);
    }
    public entry fun guess_flips_continue(p0: vector<u8>) {
        let _t1 = 0;
        let _t2 = &p0;
        loop {
            let _t7 = 0x1::vector::length<u8>(_t2);
            if (!(_t1 < _t7)) break;
            if (*0x1::vector::borrow<u8>(_t2, _t1) != 0u8) continue;
            _t1 = _t1 + 1;
            continue
        };
    }
    public entry fun entry_test_guess_flips_nocheck() {
        guess_flips_nocheck(vector[0u8, 0u8, 0u8, 0u8]);
    }
    public entry fun guess_flips_nocheck(p0: vector<u8>) {
        let _t1 = 0;
        let _t2 = &p0;
        loop {
            let _t7 = 0x1::vector::length<u8>(_t2);
            if (!(_t1 < _t7)) break;
            _t1 = _t1 + 1;
            continue
        };
    }
    fun test_guess_flips_abort() {
        guess_flips_abort(vector[0u8, 0u8, 0u8, 0u8]);
    }
    fun test_guess_flips_break() {
        guess_flips_break(vector[0u8, 0u8, 0u8, 0u8]);
    }
    fun test_guess_flips_break2() {
        guess_flips_break2(vector[0u8, 0u8, 0u8, 0u8]);
    }
    fun test_guess_flips_continue() {
        guess_flips_continue(vector[0u8, 0u8, 0u8, 0u8]);
    }
    fun test_guess_flips_nocheck() {
        guess_flips_nocheck(vector[0u8, 0u8, 0u8, 0u8]);
    }
}


//# run 0xcafe::vectors::test_guess_flips_break

//# run 0xcafe::vectors::test_guess_flips_abort

//# run 0xcafe::vectors::test_guess_flips_nocheck

//# run 0xcafe::vectors::test_guess_flips_continue