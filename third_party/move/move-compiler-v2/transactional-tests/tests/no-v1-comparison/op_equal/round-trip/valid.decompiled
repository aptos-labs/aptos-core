//**** Cross-compiled for `move` syntax from `tests/no-v1-comparison/op_equal/valid.move`

//# publish
module 0x42::test {
    struct Coin has drop {
        _0: u256,
    }
    struct Wrapper<T0> has drop {
        _0: T0,
    }
    fun add1_new(p0: u256): u256 {
        p0 + 1u256
    }
    fun add1_old(p0: u256): u256 {
        p0 + 1u256
    }
    fun coin_inc_new_1(p0: &mut Coin) {
        let _v0 = &mut p0._0;
        *_v0 = *_v0 + 1u256;
    }
    fun coin_inc_new_2(p0: &mut Coin) {
        let _v0 = &mut p0._0;
        *_v0 = *_v0 + 1u256;
    }
    fun coin_inc_old_1(p0: &mut Coin) {
        let _v0 = *&p0._0 + 1u256;
        let _v1 = &mut p0._0;
        *_v1 = _v0;
    }
    fun coin_inc_old_2(p0: &mut Coin) {
        let _v0 = &mut p0._0;
        *_v0 = *_v0 + 1u256;
    }
    fun inc_new(p0: &mut u256) {
        *p0 = *p0 + 1u256;
    }
    fun inc_old(p0: &mut u256) {
        *p0 = *p0 + 1u256;
    }
    fun inc_vec_coin_new(p0: vector<Coin>, p1: u64): vector<Coin> {
        let _v0 = &mut 0x1::vector::borrow_mut<Coin>(&mut p0, p1)._0;
        *_v0 = *_v0 + 1u256;
        p0
    }
    fun inc_vec_coin_old(p0: vector<Coin>, p1: u64): vector<Coin> {
        let _v0 = *&0x1::vector::borrow<Coin>(&p0, p1)._0 + 1u256;
        let _v1 = &mut 0x1::vector::borrow_mut<Coin>(&mut p0, p1)._0;
        *_v1 = _v0;
        p0
    }
    fun inc_vec_new(p0: &mut vector<u256>, p1: u64) {
        let _v0 = 0x1::vector::borrow_mut<u256>(p0, p1);
        *_v0 = *_v0 + 1u256;
    }
    fun inc_vec_old(p0: &mut vector<u256>, p1: u64) {
        let _v0 = *0x1::vector::borrow<u256>(freeze(p0), p1) + 1u256;
        let _v1 = 0x1::vector::borrow_mut<u256>(p0, p1);
        *_v1 = _v0;
    }
    fun inc_vec_wrapped_coin_new(p0: vector<Wrapper<Coin>>, p1: u64): vector<Wrapper<Coin>> {
        let _v0 = &mut (&mut 0x1::vector::borrow_mut<Wrapper<Coin>>(&mut p0, p1)._0)._0;
        *_v0 = *_v0 + 1u256;
        p0
    }
    fun inc_vec_wrapped_coin_old(p0: vector<Wrapper<Coin>>, p1: u64): vector<Wrapper<Coin>> {
        let _v0 = *&(&0x1::vector::borrow<Wrapper<Coin>>(&p0, p1)._0)._0 + 1u256;
        let _v1 = &mut (&mut 0x1::vector::borrow_mut<Wrapper<Coin>>(&mut p0, p1)._0)._0;
        *_v1 = _v0;
        p0
    }
    fun inc_wrapped_coin_new(p0: &mut Wrapper<Coin>) {
        let _v0 = &mut (&mut p0._0)._0;
        *_v0 = *_v0 + 1u256;
    }
    fun inc_wrapped_coin_old(p0: &mut Wrapper<Coin>) {
        let _v0 = *&(&p0._0)._0 + 1u256;
        let _v1 = &mut (&mut p0._0)._0;
        *_v1 = _v0;
    }
    fun test1() {
        let _v0 = add1_old(42u256);
        let _v1 = add1_new(42u256);
        assert!(_v0 == _v1, 14566554180833181696);
    }
    fun test2() {
        let _v0 = 42u256;
        let _v1 = _v0;
        inc_new(&mut _v0);
        inc_old(&mut _v1);
        assert!(_v0 == _v1, 14566554180833181696);
    }
    fun test3() {
        let _v0 = Coin{_0: 42u256};
        let _v1 = Coin{_0: 42u256};
        let _v2 = Coin{_0: 42u256};
        let _v3 = Coin{_0: 42u256};
        coin_inc_new_1(&mut _v0);
        coin_inc_new_2(&mut _v1);
        coin_inc_old_1(&mut _v2);
        coin_inc_old_2(&mut _v3);
        let _v4 = &_v0;
        let _v5 = &_v1;
        assert!(_v4 == _v5, 14566554180833181696);
        let _v6 = &_v0;
        let _v7 = &_v2;
        assert!(_v6 == _v7, 14566554180833181696);
        let _v8 = &_v0;
        let _v9 = &_v3;
        assert!(_v8 == _v9, 14566554180833181696);
    }
    fun test4() {
        let _v0 = Wrapper<Coin>{_0: Coin{_0: 42u256}};
        let _v1 = Wrapper<Coin>{_0: Coin{_0: 42u256}};
        inc_wrapped_coin_new(&mut _v0);
        inc_wrapped_coin_old(&mut _v1);
        assert!(_v0 == _v1, 14566554180833181696);
    }
    fun test5() {
        let _v0 = vector[42u256];
        let _v1 = vector[42u256];
        inc_vec_new(&mut _v0, 0);
        inc_vec_old(&mut _v1, 0);
        assert!(_v0 == _v1, 14566554180833181696);
    }
    fun test6() {
        let _v0 = Coin{_0: 42u256};
        let _v1 = 0x1::vector::empty<Coin>();
        0x1::vector::push_back<Coin>(&mut _v1, _v0);
        let _v2 = Coin{_0: 42u256};
        let _v3 = 0x1::vector::empty<Coin>();
        0x1::vector::push_back<Coin>(&mut _v3, _v2);
        let _v4 = inc_vec_coin_new(_v1, 0);
        let _v5 = inc_vec_coin_old(_v3, 0);
        assert!(_v4 == _v5, 14566554180833181696);
    }
    fun test7() {
        let _v0 = Wrapper<Coin>{_0: Coin{_0: 42u256}};
        let _v1 = 0x1::vector::empty<Wrapper<Coin>>();
        0x1::vector::push_back<Wrapper<Coin>>(&mut _v1, _v0);
        let _v2 = Wrapper<Coin>{_0: Coin{_0: 42u256}};
        let _v3 = 0x1::vector::empty<Wrapper<Coin>>();
        0x1::vector::push_back<Wrapper<Coin>>(&mut _v3, _v2);
        let _v4 = inc_vec_wrapped_coin_new(_v1, 0);
        let _v5 = inc_vec_wrapped_coin_old(_v3, 0);
        assert!(_v4 == _v5, 14566554180833181696);
    }
    fun test8() {
        let _v0 = 0;
        let _v1 = vector[0u256, 1u256];
        let _v2 = &mut _v1;
        let _v3 = x_plusplus(&mut _v0);
        let _v4 = 0x1::vector::borrow_mut<u256>(_v2, _v3);
        *_v4 = *_v4 + 1u256;
        assert!(_v1 == vector[1u256, 1u256], 14566554180833181696);
    }
    fun x_plusplus(p0: &mut u64): u64 {
        let _v0 = *p0;
        *p0 = *p0 + 1;
        _v0
    }
}


//# run --verbose -- 0x42::test::test1

//# run --verbose -- 0x42::test::test2

//# run --verbose -- 0x42::test::test3

//# run --verbose -- 0x42::test::test4

//# run --verbose -- 0x42::test::test5

//# run --verbose -- 0x42::test::test6

//# run --verbose -- 0x42::test::test7

//# run --verbose -- 0x42::test::test8