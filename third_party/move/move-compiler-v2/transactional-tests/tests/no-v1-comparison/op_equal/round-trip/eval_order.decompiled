//**** Cross-compiled for `move` syntax from `tests/no-v1-comparison/op_equal/eval_order.move`

//# publish
module 0xc0ffee::m {
    fun mod1(p0: &mut u64) {
        *p0 = *p0 + 2;
    }
    fun mod2(p0: &mut u64): u64 {
        let _t1 = p0;
        *_t1 = *_t1 + 2;
        *p0
    }
    public fun test0() {
        let _t0 = 1 + 2;
        _t0 = _t0 + _t0;
        if (!(_t0 + _t0 == 12)) abort 14566554180833181696;
    }
    public fun test1() {
        let _t0 = 1 + 2;
        if (!(_t0 + _t0 == 6)) abort 14566554180833181696;
    }
    public fun test2() {
        let _t0 = 1;
        mod1(&mut _t0);
        if (!(_t0 + _t0 == 6)) abort 14566554180833181696;
    }
    public fun test3() {
        let _t0 = 1;
        let _t1 = mod2(&mut _t0);
        if (!(_t0 + _t1 == 6)) abort 14566554180833181696;
    }
    public fun test4() {
        let _t0 = vector[1, 2, 3];
        let _t1 = &_t0;
        let _t2 = 0 + 1;
        let _t3 = _t2;
        _t3 = *0x1::vector::borrow<u64>(_t1, _t3);
        let _t15 = &mut _t0;
        let _t18 = _t2 + 1;
        let _t4 = 0x1::vector::borrow_mut<u64>(_t15, _t18);
        *_t4 = *_t4 + _t3;
        if (!(_t0 == vector[1, 2, 5])) abort 14566554180833181696;
    }
}


//# run --verbose -- 0xc0ffee::m::test0

//# run --verbose -- 0xc0ffee::m::test1

//# run --verbose -- 0xc0ffee::m::test2

//# run --verbose -- 0xc0ffee::m::test3

//# run --verbose -- 0xc0ffee::m::test4