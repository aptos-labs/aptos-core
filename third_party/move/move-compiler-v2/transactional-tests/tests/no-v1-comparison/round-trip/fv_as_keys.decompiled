//**** Cross-compiled for `move` syntax from `tests/no-v1-comparison/fv_as_keys.move`

//# publish
module 0x99::test_struct {
    use 0x1::signer;
    struct Wrapper<T0> has drop, key {
        fv: |T0|(u64) has copy + drop + store,
    }
    public fun init(p0: &signer) {
        let _v0 = Wrapper<||(u64) has drop + store>{fv: |arg0: ||(u64) has drop + store| test(arg0)};
        move_to<Wrapper<||(u64) has drop + store>>(p0, _v0);
    }
    #[persistent]
    fun test(p0: ||(u64) has drop + store): u64 {
        let _v0;
        if (p0() == 1) _v0 = 1 else _v0 = 2;
        _v0
    }
    #[persistent]
    fun test1(): u64 {
        1
    }
    #[persistent]
    fun test2(): u64 {
        2
    }
    public fun test_bad_borrow_from(p0: &signer)
        acquires Wrapper
    {
        let _v0 = signer::address_of(p0);
        let _v1 = borrow_global<Wrapper<||(u64) has copy + drop + store>>(_v0);
        let _v2: ||u64 has copy + drop = || test1();
        let _v3 = *&_v1.fv;
        assert!(_v3(_v2) == 1, 14566554180833181696);
        let _v4: ||u64 has copy + drop = || test2();
        let _v5 = *&_v1.fv;
        assert!(_v5(_v4) == 2, 14566554180833181696);
    }
    public fun test_bad_move_from(p0: &signer)
        acquires Wrapper
    {
        let _v0 = signer::address_of(p0);
        let _v1 = move_from<Wrapper<||(u64) has copy + drop + store>>(_v0);
    }
    public fun test_borrow_from(p0: &signer)
        acquires Wrapper
    {
        let _v0 = signer::address_of(p0);
        let _v1 = borrow_global<Wrapper<||(u64) has drop + store>>(_v0);
        let _v2: ||u64 has copy + drop = || test1();
        let _v3 = *&_v1.fv;
        assert!(_v3(_v2) == 1, 14566554180833181696);
        let _v4: ||u64 has copy + drop = || test2();
        let _v5 = *&_v1.fv;
        assert!(_v5(_v4) == 2, 14566554180833181696);
    }
    public fun test_exist(p0: &signer) {
        let _v0 = signer::address_of(p0);
        assert!(exists<Wrapper<||(u64) has drop + store>>(_v0), 14566554180833181696);
    }
    public fun test_move_from(p0: &signer)
        acquires Wrapper
    {
        let _v0 = signer::address_of(p0);
        let _v1 = move_from<Wrapper<||(u64) has drop + store>>(_v0);
    }
    public fun test_not_exist_1(p0: &signer) {
        let _v0 = signer::address_of(p0);
        if (exists<Wrapper<u64>>(_v0)) abort 14566554180833181696;
    }
    public fun test_not_exist_2(p0: &signer) {
        let _v0 = signer::address_of(p0);
        if (exists<Wrapper<||(u64) has store>>(_v0)) abort 14566554180833181696;
    }
    public fun test_not_exist_3(p0: &signer) {
        let _v0 = signer::address_of(p0);
        if (exists<Wrapper<||(u64) has copy + drop + store>>(_v0)) abort 14566554180833181696;
    }
}


//# run --verbose --signers 0x1 -- 0x99::test_struct::init

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_exist

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_not_exist_1

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_not_exist_2

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_not_exist_3

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_bad_borrow_from

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_borrow_from

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_bad_move_from

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_move_from

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_borrow_from

//# publish
module 0x99::test_enum {
    use 0x1::signer;
    enum Wrapper<T0> has key {
        V1 {
            fv1: |T0|(u64) has copy + store,
        }
        V2 {
            fv1: |T0|(u64) has copy + drop + store,
        }
    }
    public fun init(p0: &signer) {
        let _v0 = Wrapper::V1<||(u64) has drop + store>{fv1: |arg0: ||(u64) has drop + store| test(arg0)};
        move_to<Wrapper<||(u64) has drop + store>>(p0, _v0);
    }
    #[persistent]
    fun test(p0: ||(u64) has drop + store): u64 {
        let _v0;
        if (p0() == 1) _v0 = 1 else _v0 = 2;
        _v0
    }
    public fun bad_init(p0: &signer) {
        let _v0 = Wrapper::V2<||(u64) has drop + store>{fv1: |arg0: ||(u64) has drop + store| test(arg0)};
        move_to<Wrapper<||(u64) has drop + store>>(p0, _v0);
    }
    #[persistent]
    fun test1(): u64 {
        1
    }
    #[persistent]
    fun test2(): u64 {
        2
    }
    public fun test_bad_borrow_from(p0: &signer)
        acquires Wrapper
    {
        let _v0 = signer::address_of(p0);
        let _v1 = borrow_global<Wrapper<||(u64) has copy + drop + store>>(_v0);
    }
    public fun test_bad_move_from(p0: &signer)
        acquires Wrapper
    {
        let _v0;
        let _v1 = signer::address_of(p0);
        let _v2 = move_from<Wrapper<||(u64) has copy + drop + store>>(_v1);
        let _v3 = &_v2;
        if (_v3 is V1) {
            let Wrapper::V1<||(u64) has copy + drop + store>{fv1: _v4} = _v2;
            let _v5: ||u64 has copy + drop = || test1();
            _v0 = _v4(_v5)
        } else if (_v3 is V2) {
            let Wrapper::V2<||(u64) has copy + drop + store>{fv1: _v6} = _v2;
            let _v7: ||u64 has copy + drop = || test2();
            _v0 = _v6(_v7)
        } else abort 14566554180833181697;
        assert!(_v0 == 1, 0);
    }
    public fun test_borrow_from(p0: &signer)
        acquires Wrapper
    {
        let _v0;
        let _v1 = signer::address_of(p0);
        let _v2 = borrow_global<Wrapper<||(u64) has drop + store>>(_v1);
        if (_v2 is V1) {
            let _v3 = &_v2.fv1;
            let _v4: ||u64 has copy + drop = || test1();
            let _v5 = *_v3;
            _v0 = _v5(_v4)
        } else if (_v2 is V2) {
            let _v6 = &_v2.fv1;
            let _v7: ||u64 has copy + drop = || test2();
            let _v8 = *_v6;
            _v0 = _v8(_v7)
        } else abort 14566554180833181697;
        assert!(_v0 == 1, 0);
    }
    public fun test_exist(p0: &signer) {
        let _v0 = signer::address_of(p0);
        assert!(exists<Wrapper<||(u64) has drop + store>>(_v0), 14566554180833181696);
    }
    public fun test_move_from(p0: &signer)
        acquires Wrapper
    {
        let _v0;
        let _v1 = signer::address_of(p0);
        let _v2 = move_from<Wrapper<||(u64) has drop + store>>(_v1);
        let _v3 = &_v2;
        if (_v3 is V1) {
            let Wrapper::V1<||(u64) has drop + store>{fv1: _v4} = _v2;
            let _v5: ||u64 has copy + drop = || test1();
            _v0 = _v4(_v5)
        } else if (_v3 is V2) {
            let Wrapper::V2<||(u64) has drop + store>{fv1: _v6} = _v2;
            let _v7: ||u64 has copy + drop = || test2();
            _v0 = _v6(_v7)
        } else abort 14566554180833181697;
        assert!(_v0 == 1, 0);
    }
    public fun test_not_exist_1(p0: &signer) {
        let _v0 = signer::address_of(p0);
        if (exists<Wrapper<u64>>(_v0)) abort 14566554180833181696;
    }
    public fun test_not_exist_2(p0: &signer) {
        let _v0 = signer::address_of(p0);
        if (exists<Wrapper<||(u64) has store>>(_v0)) abort 14566554180833181696;
    }
    public fun test_not_exist_3(p0: &signer) {
        let _v0 = signer::address_of(p0);
        if (exists<Wrapper<||(u64) has copy + drop + store>>(_v0)) abort 14566554180833181696;
    }
}


//# run --verbose --signers 0x1 -- 0x99::test_enum::init

//# run --verbose --signers 0x1 -- 0x99::test_enum::bad_init

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_exist

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_not_exist_1

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_not_exist_2

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_not_exist_3

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_bad_borrow_from

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_borrow_from

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_bad_move_from

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_move_from

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_move_from