//**** Cross-compiled for `move` syntax from `tests/no-v1-comparison/fv_as_keys.move`

//# publish
module 0x99::test_struct {
    use 0x1::signer;
    struct Wrapper<T0> has drop, key {
        fv: |T0|(u64) has copy + drop + store,
    }
    public fun init(p0: &signer) {
        let _t5 = Wrapper<||(u64) has drop + store>{fv: |arg0: ||(u64) has drop + store| test(arg0)};
        move_to<Wrapper<||(u64) has drop + store>>(p0, _t5);
    }
    #[persistent]
    fun test(p0: ||(u64) has drop + store): u64 {
        let _t1;
        if (p0() == 1) _t1 = 1 else _t1 = 2;
        _t1
    }
    #[persistent]
    fun test1(): u64 {
        1
    }
    #[persistent]
    fun test2(): u64 {
        2
    }
    public fun test_bad_borrow_from(p0: &signer)
        acquires Wrapper
    {
        let _t3 = signer::address_of(p0);
        let _t1 = borrow_global<Wrapper<||(u64) has copy + drop + store>>(_t3);
        let _t5: ||u64 has copy + drop = || test1();
        let _t8 = *&_t1.fv;
        if (!(_t8(_t5) == 1)) abort 14566554180833181696;
        let _t12: ||u64 has copy + drop = || test2();
        let _t15 = *&_t1.fv;
        if (!(_t15(_t12) == 2)) abort 14566554180833181696;
    }
    public fun test_bad_move_from(p0: &signer)
        acquires Wrapper
    {
        let _t2 = signer::address_of(p0);
        let _t3 = move_from<Wrapper<||(u64) has copy + drop + store>>(_t2);
    }
    public fun test_borrow_from(p0: &signer)
        acquires Wrapper
    {
        let _t3 = signer::address_of(p0);
        let _t1 = borrow_global<Wrapper<||(u64) has drop + store>>(_t3);
        let _t5: ||u64 has copy + drop = || test1();
        let _t8 = *&_t1.fv;
        if (!(_t8(_t5) == 1)) abort 14566554180833181696;
        let _t12: ||u64 has copy + drop = || test2();
        let _t15 = *&_t1.fv;
        if (!(_t15(_t12) == 2)) abort 14566554180833181696;
    }
    public fun test_exist(p0: &signer) {
        let _t2 = signer::address_of(p0);
        if (!exists<Wrapper<||(u64) has drop + store>>(_t2)) abort 14566554180833181696;
    }
    public fun test_move_from(p0: &signer)
        acquires Wrapper
    {
        let _t2 = signer::address_of(p0);
        let _t3 = move_from<Wrapper<||(u64) has drop + store>>(_t2);
    }
    public fun test_not_exist_1(p0: &signer) {
        let _t2 = signer::address_of(p0);
        if (exists<Wrapper<u64>>(_t2)) abort 14566554180833181696;
    }
    public fun test_not_exist_2(p0: &signer) {
        let _t2 = signer::address_of(p0);
        if (exists<Wrapper<||(u64) has store>>(_t2)) abort 14566554180833181696;
    }
    public fun test_not_exist_3(p0: &signer) {
        let _t2 = signer::address_of(p0);
        if (exists<Wrapper<||(u64) has copy + drop + store>>(_t2)) abort 14566554180833181696;
    }
}


//# run --verbose --signers 0x1 -- 0x99::test_struct::init

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_exist

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_not_exist_1

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_not_exist_2

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_not_exist_3

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_bad_borrow_from

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_borrow_from

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_bad_move_from

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_move_from

//# run --verbose --signers 0x1 -- 0x99::test_struct::test_borrow_from

//# publish
module 0x99::test_enum {
    use 0x1::signer;
    enum Wrapper<T0> has key {
        V1 {
            fv1: |T0|(u64) has copy + store,
        }
        V2 {
            fv1: |T0|(u64) has copy + drop + store,
        }
    }
    public fun init(p0: &signer) {
        let _t1 = Wrapper::V1<||(u64) has drop + store>{fv1: |arg0: ||(u64) has drop + store| test(arg0)};
        move_to<Wrapper<||(u64) has drop + store>>(p0, _t1);
    }
    #[persistent]
    fun test(p0: ||(u64) has drop + store): u64 {
        let _t1;
        if (p0() == 1) _t1 = 1 else _t1 = 2;
        _t1
    }
    public fun bad_init(p0: &signer) {
        let _t1 = Wrapper::V2<||(u64) has drop + store>{fv1: |arg0: ||(u64) has drop + store| test(arg0)};
        move_to<Wrapper<||(u64) has drop + store>>(p0, _t1);
    }
    #[persistent]
    fun test1(): u64 {
        1
    }
    #[persistent]
    fun test2(): u64 {
        2
    }
    public fun test_bad_borrow_from(p0: &signer)
        acquires Wrapper
    {
        let _t3 = signer::address_of(p0);
        let _t4 = borrow_global<Wrapper<||(u64) has copy + drop + store>>(_t3);
    }
    public fun test_bad_move_from(p0: &signer)
        acquires Wrapper
    {
        let _t4;
        let _t7 = signer::address_of(p0);
        let _t1 = move_from<Wrapper<||(u64) has copy + drop + store>>(_t7);
        let _t2 = &_t1;
        if (_t2 is V1) {
            let Wrapper::V1<||(u64) has copy + drop + store>{fv1: _t14} = _t1;
            let _t15: ||u64 has copy + drop = || test1();
            _t4 = _t14(_t15)
        } else if (_t2 is V2) {
            let Wrapper::V2<||(u64) has copy + drop + store>{fv1: _t25} = _t1;
            let _t26: ||u64 has copy + drop = || test2();
            _t4 = _t25(_t26)
        } else abort 14566554180833181697;
        if (!(_t4 == 1)) abort 0;
    }
    public fun test_borrow_from(p0: &signer)
        acquires Wrapper
    {
        let _t3;
        let _t6 = signer::address_of(p0);
        let _t1 = borrow_global<Wrapper<||(u64) has drop + store>>(_t6);
        if (_t1 is V1) {
            let _t2 = &_t1.fv1;
            let _t12: ||u64 has copy + drop = || test1();
            let _t14 = *_t2;
            _t3 = _t14(_t12)
        } else if (_t1 is V2) {
            let _t4 = &_t1.fv1;
            let _t24: ||u64 has copy + drop = || test2();
            let _t26 = *_t4;
            _t3 = _t26(_t24)
        } else abort 14566554180833181697;
        if (!(_t3 == 1)) abort 0;
    }
    public fun test_exist(p0: &signer) {
        let _t2 = signer::address_of(p0);
        if (!exists<Wrapper<||(u64) has drop + store>>(_t2)) abort 14566554180833181696;
    }
    public fun test_move_from(p0: &signer)
        acquires Wrapper
    {
        let _t4;
        let _t7 = signer::address_of(p0);
        let _t1 = move_from<Wrapper<||(u64) has drop + store>>(_t7);
        let _t2 = &_t1;
        if (_t2 is V1) {
            let Wrapper::V1<||(u64) has drop + store>{fv1: _t14} = _t1;
            let _t15: ||u64 has copy + drop = || test1();
            _t4 = _t14(_t15)
        } else if (_t2 is V2) {
            let Wrapper::V2<||(u64) has drop + store>{fv1: _t25} = _t1;
            let _t26: ||u64 has copy + drop = || test2();
            _t4 = _t25(_t26)
        } else abort 14566554180833181697;
        if (!(_t4 == 1)) abort 0;
    }
    public fun test_not_exist_1(p0: &signer) {
        let _t2 = signer::address_of(p0);
        if (exists<Wrapper<u64>>(_t2)) abort 14566554180833181696;
    }
    public fun test_not_exist_2(p0: &signer) {
        let _t2 = signer::address_of(p0);
        if (exists<Wrapper<||(u64) has store>>(_t2)) abort 14566554180833181696;
    }
    public fun test_not_exist_3(p0: &signer) {
        let _t2 = signer::address_of(p0);
        if (exists<Wrapper<||(u64) has copy + drop + store>>(_t2)) abort 14566554180833181696;
    }
}


//# run --verbose --signers 0x1 -- 0x99::test_enum::init

//# run --verbose --signers 0x1 -- 0x99::test_enum::bad_init

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_exist

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_not_exist_1

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_not_exist_2

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_not_exist_3

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_bad_borrow_from

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_borrow_from

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_bad_move_from

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_move_from

//# run --verbose --signers 0x1 -- 0x99::test_enum::test_move_from