//**** Cross-compiled for `move` syntax from `tests/no-v1-comparison/bug_14762.move`

//# publish
module 0x42::m {
    use 0x1::option;
    use 0x1::vector;
    struct T has copy, drop, store {
        issuer: vector<u8>,
        version: u64,
    }
    struct J has copy, drop, store {
        variant: u64,
    }
    struct S has copy, drop, store {
        entries: vector<T>,
    }
    fun test(p0: &mut S, p1: vector<u8>): option::Option<T> {
        let _v0;
        let _v1 = &p0.entries;
        let _v2 = false;
        let _v3 = 0;
        let _v4 = 0;
        let _v5 = vector::length<T>(_v1);
        'l0: loop {
            loop {
                if (!(_v4 < _v5)) break 'l0;
                if (*&vector::borrow<T>(_v1, _v4).issuer == p1) break;
                _v4 = _v4 + 1
            };
            _v2 = true;
            _v3 = _v4;
            break
        };
        if (_v2) _v0 = option::some<T>(vector::remove<T>(&mut p0.entries, _v3)) else _v0 = option::none<T>();
        _v0
    }
    fun test1() {
        let _v0 = T{issuer: vector[1u8], version: 1};
        let _v1 = T{issuer: vector[2u8], version: 0};
        let _v2 = vector::empty<T>();
        let _v3 = &mut _v2;
        vector::push_back<T>(_v3, _v0);
        vector::push_back<T>(_v3, _v1);
        let _v4 = S{entries: _v2};
        let _v5 = test(&mut _v4, vector[0u8]);
        assert!(option::is_none<T>(&_v5), 0);
        let _v6 = test(&mut _v4, vector[1u8]);
        assert!(option::is_some<T>(&_v6), 0);
        assert!(*&option::borrow<T>(&_v6).issuer == vector[1u8], 0);
        let _v7 = test(&mut _v4, vector[2u8]);
        assert!(option::is_some<T>(&_v7), 0);
        assert!(*&option::borrow<T>(&_v7).issuer == vector[2u8], 0);
    }
}


//# run 0x42::m::test1