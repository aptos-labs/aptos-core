//**** Cross-compiled for `move` syntax from `tests/no-v1-comparison/enum/match_cover.move`

//# publish
module 0xc0ffee::m {
    enum A has drop {
        V1 {
            a: Q,
            b: R,
        }
    }
    enum Q has drop {
        Q1,
        Q2,
    }
    enum R has drop {
        R1,
        R2,
    }
    public fun test1(p0: A) {
        let _v0 = &p0;
        if (!((_v0 is V1) && (&_v0.a is Q1))) {
            if (!((_v0 is V1) && (&_v0.b is R1))) {
                loop {
                    if (_v0 is V1) {
                        let _v1 = &_v0.a;
                        let _v2 = &_v0.b;
                        if (_v1 is Q2) {
                            if (_v2 is R2) break}
                    };
                    abort 14566554180833181697
                };
                let A::V1{a: _v3, b: _v4} = p0;
                let Q::Q2{} = _v3;
                let R::R2{} = _v4;
                return ()
            };
            let A::V1{a: _v5, b: _v6} = p0;
            let R::R1{} = _v6;
            return ()
        };
        let A::V1{a: _v7, b: _v8} = p0;
        let Q::Q1{} = _v7;
    }
    public fun test2(p0: A) {
        let _v0 = &p0;
        if (!((_v0 is V1) && (&_v0.a is Q1))) {
            if (!((_v0 is V1) && (&_v0.b is R1))) {
                assert!(_v0 is V1, 14566554180833181697);
                let A::V1{a: _v1, b: _v2} = p0;
                return ()
            };
            let A::V1{a: _v3, b: _v4} = p0;
            let R::R1{} = _v4;
            return ()
        };
        let A::V1{a: _v5, b: _v6} = p0;
        let Q::Q1{} = _v5;
    }
    public fun test3(p0: A) {
        let _v0 = &p0;
        if (!((_v0 is V1) && (&_v0.a is Q1))) {
            if (!((_v0 is V1) && (&_v0.b is R1))) return ();
            let A::V1{a: _v1, b: _v2} = p0;
            let R::R1{} = _v2;
            return ()
        };
        let A::V1{a: _v3, b: _v4} = p0;
        let Q::Q1{} = _v3;
    }
    public fun test4(p0: A) {
        let _v0 = &p0;
        if (!((_v0 is V1) && (&_v0.a is Q1))) {
            assert!(_v0 is V1, 14566554180833181697);
            let A::V1{a: _v1, b: _v2} = p0;
            return ()
        };
        let A::V1{a: _v3, b: _v4} = p0;
        let Q::Q1{} = _v3;
    }
    public fun test5(p0: A) {
        let _v0 = &p0;
        if (!((_v0 is V1) && (&_v0.a is Q1))) {
            assert!((_v0 is V1) && (&_v0.a is Q2), 14566554180833181697);
            let A::V1{a: _v1, b: _v2} = p0;
            let Q::Q2{} = _v1;
            return ()
        };
        let A::V1{a: _v3, b: _v4} = p0;
        let Q::Q1{} = _v3;
    }
    public fun test6(p0: A) {
        let _v0 = &p0;
        if (!((_v0 is V1) && (&_v0.a is Q1))) {
            if (!((_v0 is V1) && (&_v0.a is Q2))) return ();
            let A::V1{a: _v1, b: _v2} = p0;
            let Q::Q2{} = _v1;
            return ()
        };
        let A::V1{a: _v3, b: _v4} = p0;
        let Q::Q1{} = _v3;
    }
}


//# publish
module 0xc0ffee::n {
    enum A has drop {
        V1 {
            a: P,
            b: Q,
            c: R,
        }
    }
    enum P has drop {
        P1,
        P2,
    }
    enum Q has drop {
        Q1,
        Q2,
    }
    enum R has drop {
        R1,
        R2,
    }
    public fun test(p0: A) {
        let _v0 = &p0;
        if (!((_v0 is V1) && (&_v0.a is P1))) {
            if (!((_v0 is V1) && (&_v0.b is Q1))) {
                if (!((_v0 is V1) && (&_v0.c is R1))) {
                    loop {
                        if (_v0 is V1) {
                            let _v1 = &_v0.a;
                            let _v2 = &_v0.b;
                            let _v3 = &_v0.c;
                            if (_v1 is P2) {
                                if (_v2 is Q2) {
                                    if (_v3 is R2) break}}
                        };
                        abort 14566554180833181697
                    };
                    let A::V1{a: _v4, b: _v5, c: _v6} = p0;
                    let P::P2{} = _v4;
                    let Q::Q2{} = _v5;
                    let R::R2{} = _v6;
                    return ()
                };
                let A::V1{a: _v7, b: _v8, c: _v9} = p0;
                let R::R1{} = _v9;
                return ()
            };
            let A::V1{a: _v10, b: _v11, c: _v12} = p0;
            let Q::Q1{} = _v11;
            return ()
        };
        let A::V1{a: _v13, b: _v14, c: _v15} = p0;
        let P::P1{} = _v13;
    }
}


//# publish
module 0xc0ffee::o {
    enum E has drop {
        V1 {
            a: F,
            b: G,
        }
        V2 {
            a: F,
            b: G,
            c: H,
        }
    }
    enum F has drop {
        F1,
        F2 {
            a: G,
        }
    }
    enum G has drop {
        G1 {
            a: H,
            b: H,
        }
        G2 {
            a: H,
        }
    }
    enum H has drop {
        H1 {
            a: u64,
        }
        H2 {
            b: u64,
        }
    }
    public fun test1(p0: E) {
        let _v0 = &p0;
        loop {
            if (!(_v0 is V1)) {
                if (_v0 is V2) break;
                abort 14566554180833181697
            };
            let E::V1{a: _v1, b: _v2} = p0;
            return ()
        };
        let E::V2{a: _v3, b: _v4, c: _v5} = p0;
    }
    public fun test2(p0: E) {
        let _v0 = &p0;
        loop {
            let _v1;
            if (_v0 is V1) {
                _v1 = &_v0.b;
                if (_v1 is G1) {
                    if (&_v1.a is H1) break}
            };
            loop {
                if (_v0 is V1) {
                    _v1 = &_v0.b;
                    if (_v1 is G1) {
                        if (&_v1.b is H1) break}
                };
                if (!((_v0 is V1) && (&_v0.a is F1))) {
                    if (!((_v0 is V1) && (&_v0.a is F2))) {
                        assert!(_v0 is V2, 14566554180833181697);
                        let E::V2{a: _v2, b: _v3, c: _v4} = p0;
                        return ()
                    };
                    let E::V1{a: _v5, b: _v6} = p0;
                    let F::F2{a: _v7} = _v5;
                    return ()
                };
                let E::V1{a: _v8, b: _v9} = p0;
                let F::F1{} = _v8;
                return ()
            };
            let E::V1{a: _v10, b: _v11} = p0;
            let G::G1{a: _v12, b: _v13} = _v11;
            let H::H1{a: _v14} = _v13;
            return ()
        };
        let E::V1{a: _v15, b: _v16} = p0;
        let G::G1{a: _v17, b: _v18} = _v16;
        let H::H1{a: _v19} = _v17;
    }
    public fun test3(p0: E) {
        let _v0 = &p0;
        if (!((_v0 is V1) && (&_v0.b is G1))) {
            if (!((_v0 is V1) && (&_v0.a is F2))) {
                loop {
                    if (_v0 is V1) {
                        let _v1 = &_v0.a;
                        let _v2 = &_v0.b;
                        if (_v1 is F1) {
                            if (_v2 is G2) {
                                if (&_v2.a is H2) break}}
                    };
                    if (!((_v0 is V1) && (&_v0.a is F1))) {
                        assert!(_v0 is V2, 14566554180833181697);
                        let E::V2{a: _v3, b: _v4, c: _v5} = p0;
                        return ()
                    };
                    let E::V1{a: _v6, b: _v7} = p0;
                    let F::F1{} = _v6;
                    return ()
                };
                let E::V1{a: _v8, b: _v9} = p0;
                let F::F1{} = _v8;
                let G::G2{a: _v10} = _v9;
                let H::H2{b: _v11} = _v10;
                return ()
            };
            let E::V1{a: _v12, b: _v13} = p0;
            let F::F2{a: _v14} = _v12;
            return ()
        };
        let E::V1{a: _v15, b: _v16} = p0;
        let G::G1{a: _v17, b: _v18} = _v16;
    }
}
