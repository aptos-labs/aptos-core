//**** Cross-compiled for `move` syntax from `tests/no-v1-comparison/enum/enum_matching.move`

//# publish
module 0x42::m {
    enum Option<T0> has drop {
        None,
        Some {
            value: T0,
        }
    }
    struct Box has drop {
        x: u64,
    }
    enum CommonFields {
        Foo {
            x: u64,
            y: u64,
        }
        Bar {
            z: u64,
            x: u64,
        }
    }
    enum Inner has drop {
        Inner1 {
            x: u64,
        }
        Inner2 {
            x: u64,
            y: u64,
        }
    }
    enum Outer has drop {
        None,
        One {
            i: Inner,
        }
        Two {
            i: Inner,
            b: Box,
        }
    }
    public fun is_some<T0>(p0: &Option<T0>): bool {
        loop {
            if (!(p0 is None)) {
                if (p0 is Some) break;
                abort 14566554180833181697
            };
            return false
        };
        true
    }
    public fun inner_value(p0: Inner): u64 {
        let _v0 = &p0;
        loop {
            if (!(_v0 is Inner1)) {
                if (_v0 is Inner2) break;
                abort 14566554180833181697
            };
            let Inner::Inner1{x: _v1} = p0;
            return _v1
        };
        let Inner::Inner2{x: _v2, y: _v3} = p0;
        _v2 + _v3
    }
    public fun is_inner1(p0: &Inner): bool {
        p0 is Inner1
    }
    public fun is_some_dropped<T0: drop>(p0: Option<T0>): bool {
        if (&p0 is None) {
            let Option::None<T0>{} = p0;
            return false
        };
        true
    }
    public fun is_some_specialized(p0: &Option<Option<u64>>): bool {
        'l0: loop {
            loop {
                if (!(p0 is None)) {
                    if (p0 is Some) {
                        if (&p0.value is None) break 'l0};
                    if (p0 is Some) {
                        if (&p0.value is Some) break};
                    abort 14566554180833181697
                };
                return false
            };
            return true
        };
        false
    }
    public fun outer_value(p0: Outer): u64 {
        let _v0 = &p0;
        'l0: loop {
            loop {
                if (!(_v0 is None)) {
                    if (_v0 is One) break;
                    if (_v0 is Two) break 'l0;
                    abort 14566554180833181697
                };
                let Outer::None{} = p0;
                return 0
            };
            let Outer::One{i: _v1} = p0;
            return inner_value(_v1)
        };
        let Outer::Two{i: _v2, b: _v3} = p0;
        let _v4 = _v3;
        let _v5 = inner_value(_v2);
        let _v6 = *&(&_v4).x;
        _v5 + _v6
    }
    public fun outer_value_nested(p0: Outer): u64 {
        let _v0 = &p0;
        'l0: loop {
            'l1: loop {
                loop {
                    if (!(_v0 is None)) {
                        if (_v0 is One) {
                            if (&_v0.i is Inner1) break 'l0};
                        if (_v0 is One) break;
                        if (_v0 is Two) break 'l1;
                        abort 14566554180833181697
                    };
                    let Outer::None{} = p0;
                    return 0
                };
                let Outer::One{i: _v1} = p0;
                return inner_value(_v1)
            };
            let Outer::Two{i: _v2, b: _v3} = p0;
            let _v4 = _v3;
            let _v5 = inner_value(_v2);
            let _v6 = *&(&_v4).x;
            return _v5 + _v6
        };
        let Outer::One{i: _v7} = p0;
        let Inner::Inner1{x: _v8} = _v7;
        _v8
    }
    public fun outer_value_with_cond(p0: Outer): u64 {
        let _v0 = &p0;
        'l0: loop {
            'l1: loop {
                loop {
                    if (!(_v0 is None)) {
                        if (_v0 is One) {
                            if (is_inner1(&_v0.i)) break 'l0};
                        if (_v0 is One) break;
                        if (_v0 is Two) break 'l1;
                        abort 14566554180833181697
                    };
                    let Outer::None{} = p0;
                    return 0
                };
                let Outer::One{i: _v1} = p0;
                return inner_value(_v1)
            };
            let Outer::Two{i: _v2, b: _v3} = p0;
            let _v4 = _v3;
            let _v5 = inner_value(_v2);
            let _v6 = *&(&_v4).x;
            return _v5 + _v6
        };
        let Outer::One{i: _v7} = p0;
        inner_value(_v7) % 2
    }
    public fun outer_value_with_cond_ref(p0: &Outer): bool {
        'l0: loop {
            'l1: loop {
                loop {
                    if (!(p0 is None)) {
                        if (p0 is One) {
                            if (is_inner1(&p0.i)) break 'l0};
                        if (p0 is One) break;
                        if (p0 is Two) break 'l1;
                        abort 14566554180833181697
                    };
                    return false
                };
                return is_inner1(&p0.i)
            };
            return is_inner1(&p0.i)
        };
        true
    }
    fun select_common_fields(p0: CommonFields): u64 {
        let _v0;
        let _v1;
        let _v2 = &p0;
        if (_v2 is Bar) _v1 = &_v2.x else _v1 = &_v2.x;
        let _v3 = *_v1;
        let _v4 = &p0;
        if (_v4 is Foo) {
            let CommonFields::Foo{x: _v5, y: _v6} = p0;
            _v0 = _v6
        } else if (_v4 is Bar) {
            let CommonFields::Bar{z: _v7, x: _v8} = p0;
            _v0 = _v7
        } else abort 14566554180833181697;
        _v3 + _v0
    }
    fun t1_inner_value(): u64 {
        inner_value(Inner::Inner2{x: 2, y: 5})
    }
    fun t1_is_inner1(): bool {
        let _v0 = Inner::Inner1{x: 2};
        is_inner1(&_v0)
    }
    fun t1_is_some(): bool {
        let _v0 = Option::None<u64>{};
        is_some<u64>(&_v0)
    }
    fun t1_is_some_specialized(): bool {
        let _v0 = Option::Some<Option<u64>>{value: Option::None<u64>{}};
        is_some_specialized(&_v0)
    }
    fun t1_outer_value(): u64 {
        outer_value(Outer::None{})
    }
    fun t1_outer_value_nested(): u64 {
        outer_value_nested(Outer::One{i: Inner::Inner1{x: 27}})
    }
    fun t1_outer_value_with_cond(): u64 {
        outer_value_with_cond(Outer::One{i: Inner::Inner1{x: 43}})
    }
    fun t1_outer_value_with_cond_ref(): bool {
        let _v0 = Outer::One{i: Inner::Inner1{x: 43}};
        outer_value_with_cond_ref(&_v0)
    }
    fun t2_is_inner1(): bool {
        let _v0 = Inner::Inner2{x: 2, y: 3};
        is_inner1(&_v0)
    }
    fun t2_is_some(): bool {
        let _v0 = Option::Some<u64>{value: 3};
        is_some<u64>(&_v0)
    }
    fun t2_is_some_specialized(): bool {
        let _v0 = Option::Some<Option<u64>>{value: Option::Some<u64>{value: 1}};
        is_some_specialized(&_v0)
    }
    fun t2_outer_value(): u64 {
        outer_value(Outer::One{i: Inner::Inner2{x: 1, y: 2}})
    }
    fun t2_outer_value_nested(): u64 {
        let _v0 = Inner::Inner1{x: 5};
        let _v1 = Box{x: 7};
        outer_value_nested(Outer::Two{i: _v0, b: _v1})
    }
    fun t3_outer_value(): u64 {
        let _v0 = Inner::Inner1{x: 1};
        let _v1 = Box{x: 7};
        outer_value(Outer::Two{i: _v0, b: _v1})
    }
}


//# run 0x42::m::t1_is_inner1

//# run 0x42::m::t2_is_inner1

//# run 0x42::m::t1_inner_value

//# run 0x42::m::t1_outer_value

//# run 0x42::m::t2_outer_value

//# run 0x42::m::t3_outer_value

//# run 0x42::m::t1_outer_value_nested

//# run 0x42::m::t2_outer_value_nested

//# run 0x42::m::t1_outer_value_with_cond

//# run 0x42::m::t1_outer_value_with_cond_ref

//# run 0x42::m::t1_is_some

//# run 0x42::m::t2_is_some

//# run 0x42::m::t1_is_some_specialized

//# run 0x42::m::t2_is_some_specialized