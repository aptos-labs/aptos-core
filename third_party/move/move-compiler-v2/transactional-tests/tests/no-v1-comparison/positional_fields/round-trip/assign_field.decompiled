//**** Cross-compiled for `move` syntax from `tests/no-v1-comparison/positional_fields/assign_field.move`

//# publish
module 0x42::test {
    enum E has drop {
        V1 {
            _0: u8,
            _1: bool,
        }
        V2 {
            _0: S3,
        }
    }
    struct S3 has drop {
        _0: S2,
        _1: S0,
        _2: S2,
    }
    struct S2 has copy, drop {
        _0: S0,
        _1: u8,
    }
    struct S0 has copy, drop {
        x: u8,
    }
    struct S1 has drop {
        _0: u64,
        _1: bool,
    }
    fun assign0(p0: u64, p1: bool): S1 {
        let _v0 = S1{_0: p0, _1: p1};
        while (*&(&_v0)._1) {
            let _v1 = *&(&_v0)._0 - 1;
            let _v2 = *&(&_v0)._0;
            _v0 = S1{_0: _v1, _1: _v2 >= 2};
            continue
        };
        _v0
    }
    fun assign1(p0: S1): u64 {
        let _v0 = 0;
        loop {
            let _v1;
            if (!*&(&p0)._1) break;
            if (*&(&p0)._0 > 0) _v1 = *&(&p0)._0 - 1 else _v1 = 0;
            p0 = S1{_0: _v1, _1: _v1 >= 1};
            _v0 = _v0 + 1;
            continue
        };
        _v0
    }
    fun assign_chained(p0: S3): S3 {
        let _v0 = *&(&(&(&p0)._0)._0).x;
        let _v1 = *&(&(&p0)._1).x;
        let _v2 = _v0 + _v1;
        let _v3 = *&(&(&(&p0)._2)._0).x;
        let _v4 = _v2 + _v3;
        let _v5 = &mut (&mut (&mut (&mut p0)._0)._0).x;
        *_v5 = 0u8;
        let _v6 = &mut (&mut (&mut p0)._1).x;
        *_v6 = 1u8;
        let _v7 = &mut (&mut (&mut (&mut p0)._2)._0).x;
        *_v7 = 2u8;
        p0
    }
    fun assign_enum(p0: &mut E) {
        if (p0 is V1) {
            let _v0 = &mut p0._0;
            let _v1 = &mut p0._1;
            *_v0 = 42u8;
            *_v1 = true
        } else if (p0 is V2) {
            let _v2 = &mut p0._0;
            let _v3 = &mut (&mut (&mut _v2._0)._0).x;
            *_v3 = 0u8;
            let _v4 = &mut (&mut _v2._1).x;
            *_v4 = 1u8;
            let _v5 = &mut (&mut (&mut _v2._2)._0).x;
            *_v5 = 2u8
        } else abort 14566554180833181697;
    }
    fun simple(p0: S1): S1 {
        let _v0 = &mut (&mut p0)._0;
        *_v0 = 42;
        let _v1 = &mut (&mut p0)._1;
        *_v1 = true;
        p0
    }
    fun simple_ref(p0: &mut S1) {
        let _v0 = &mut p0._0;
        *_v0 = 42;
        let _v1 = &mut p0._1;
        *_v1 = true;
    }
    fun test_assign0(): S1 {
        assign0(4, true)
    }
    fun test_assign1(): u64 {
        assign1(S1{_0: 4, _1: true})
    }
    fun test_assign_chained(): S3 {
        let _v0 = S0{x: 42u8};
        let _v1 = S2{_0: _v0, _1: 42u8};
        assign_chained(S3{_0: _v1, _1: _v0, _2: _v1})
    }
    fun test_assign_enum_1(): bool {
        let _v0 = S0{x: 43u8};
        let _v1 = S2{_0: _v0, _1: 42u8};
        let _v2 = E::V2{_0: S3{_0: _v1, _1: _v0, _2: _v1}};
        assign_enum(&mut _v2);
        let _v3 = S0{x: 0u8};
        let _v4 = S0{x: 1u8};
        let _v5 = S0{x: 2u8};
        let _v6 = S2{_0: _v3, _1: 42u8};
        let _v7 = S2{_0: _v5, _1: 42u8};
        let _v8 = E::V2{_0: S3{_0: _v6, _1: _v4, _2: _v7}};
        _v2 == _v8
    }
    fun test_assign_enum_2(): bool {
        let _v0 = E::V1{_0: 0u8, _1: false};
        assign_enum(&mut _v0);
        let _v1 = E::V1{_0: 42u8, _1: true};
        _v0 == _v1
    }
    fun test_simple(): S1 {
        simple(S1{_0: 0, _1: false})
    }
    fun test_simple_ref(): S1 {
        let _v0 = S1{_0: 0, _1: false};
        simple_ref(&mut _v0);
        _v0
    }
}


//# run --verbose -- 0x42::test::test_simple

//# run --verbose -- 0x42::test::test_simple_ref

//# run --verbose -- 0x42::test::test_assign0

//# run --verbose -- 0x42::test::test_assign1

//# run --verbose -- 0x42::test::test_assign_chained

//# run --verbose -- 0x42::test::test_assign_enum_1

//# run --verbose -- 0x42::test::test_assign_enum_2