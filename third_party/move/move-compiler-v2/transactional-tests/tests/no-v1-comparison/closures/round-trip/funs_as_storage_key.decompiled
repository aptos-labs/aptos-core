//**** Cross-compiled for `move` syntax from `tests/no-v1-comparison/closures/funs_as_storage_key.move`

//# publish
module 0x42::mod2 {
    struct Registry<T0: copy + store> has store, key {
        func: T0,
    }
    public fun get_item<T0: copy + store>(p0: address): T0
        acquires Registry
    {
        *&borrow_global<Registry<T0>>(p0).func
    }
    public fun item_exists<T0: copy + store>(p0: address): bool {
        exists<Registry<T0>>(p0)
    }
    public fun remove_item<T0: copy + store>(p0: address): T0
        acquires Registry
    {
        let Registry<T0>{func: _v0} = move_from<Registry<T0>>(p0);
        _v0
    }
    public fun save_item<T0: copy + store>(p0: &signer, p1: T0) {
        let _v0 = Registry<T0>{func: p1};
        move_to<Registry<T0>>(p0, _v0);
    }
}


//# publish
module 0x42::mod3 {
    use 0x42::mod2;
    use 0x1::signer;
    struct MyStruct1 has copy, store, key {
        x: u64,
    }
    struct MyStruct2 has copy, store, key {
        y: u8,
    }
    public fun test_items(p0: signer, p1: bool): bool {
        let _v0: |address|(bool) has copy + drop + store = |arg0| mod2::item_exists<MyStruct1>(arg0);
        let _v1: |address|(bool) has copy + drop + store = |arg0| mod2::item_exists<MyStruct2>(arg0);
        let _v2 = signer::address_of(&p0);
        if (!exists<MyStruct1>(_v2)) {
            let _v3 = MyStruct1{x: 3};
            mod2::save_item<MyStruct1>(&p0, _v3);
            let _v4 = &p0;
            move_to<MyStruct1>(_v4, _v3)
        };
        if (p1) mod2::save_item<|address|(bool) has copy + drop + store>(&p0, _v0) else mod2::save_item<|address|(bool) has copy + drop + store>(&p0, _v1);
        assert!(mod2::item_exists<|address|(bool) has copy + drop + store>(_v2), 14566554180833181696);
        let _v5 = mod2::get_item<|address|(bool) has copy + drop + store>(_v2);
        let _v6 = _v5(_v2);
        assert!(p1 == _v6, 14566554180833181696);
        let _v7 = mod2::remove_item<|address|(bool) has copy + drop + store>(_v2);
        true
    }
}


//# publish
module 0x42::mod4 {
    struct Wrapper<T0> has key {
        fv: T0,
    }
    fun check_exists(p0: &signer) {
        assert!(exists<Wrapper<|&u64, &mut u8|(&u64) has copy + drop + store>>(@0x42), 404);
    }
    fun initialize(p0: &signer) {
        let _v0 = Wrapper<|&u64, &mut u8|(&u64) has copy + drop + store>{fv: |arg0,arg1| test(arg0, arg1)};
        move_to<Wrapper<|&u64, &mut u8|(&u64) has copy + drop + store>>(p0, _v0);
    }
    #[persistent]
    fun test(p0: &u64, p1: &mut u8): &u64 {
        p0
    }
}


//# publish
module 0x42::mod5 {
    struct VecWrapper<T0> has key {
        fvs: vector<T0>,
    }
    fun check_exists(p0: &signer) {
        assert!(exists<VecWrapper<|&u64, &mut u8|(&u64) has copy + drop + store>>(@0x42), 404);
    }
    fun initialize(p0: &signer) {
        let _v0: |&u64, &mut u8|&u64 has copy + drop = |arg0,arg1| test(arg0, arg1);
        let _v1 = 0x1::vector::empty<|&u64, &mut u8|(&u64) has copy + drop + store>();
        0x1::vector::push_back<|&u64, &mut u8|(&u64) has copy + drop + store>(&mut _v1, _v0);
        let _v2 = VecWrapper<|&u64, &mut u8|(&u64) has copy + drop + store>{fvs: _v1};
        move_to<VecWrapper<|&u64, &mut u8|(&u64) has copy + drop + store>>(p0, _v2);
    }
    #[persistent]
    fun test(p0: &u64, p1: &mut u8): &u64 {
        p0
    }
}


//# publish
module 0x42::mod6 {
    struct VecWrapper<T0> has key {
        fvs: vector<T0>,
    }
    fun compute(p0: &signer): u8
        acquires VecWrapper
    {
        let _v0;
        if (exists<VecWrapper<|&mut u8| has drop + store>>(@0x42)) _v0 = false else _v0 = !exists<VecWrapper<|&mut u8| has store>>(@0x42);
        assert!(_v0, 404);
        let _v1 = &borrow_global<VecWrapper<|&mut u8| has copy + drop + store>>(@0x42).fvs;
        let _v2 = 0u8;
        let _v3 = 0;
        while (_v3 < 3) {
            let _v4 = 0x1::vector::borrow<|&mut u8| has copy + drop + store>(_v1, _v3);
            let _v5 = &mut _v2;
            let _v6 = *_v4;
            _v6(_v5);
            _v3 = _v3 + 1;
            continue
        };
        _v2
    }
    fun initialize(p0: &signer) {
        let _v0: |&mut u8| has copy + drop = |arg0| test1(arg0);
        let _v1: |&mut u8| has copy + drop = |arg0| test2(arg0);
        let _v2: |&mut u8| has copy + drop = |arg0| test3(arg0);
        let _v3 = 0x1::vector::empty<|&mut u8| has copy + drop + store>();
        let _v4 = &mut _v3;
        0x1::vector::push_back<|&mut u8| has copy + drop + store>(_v4, _v0);
        0x1::vector::push_back<|&mut u8| has copy + drop + store>(_v4, _v1);
        0x1::vector::push_back<|&mut u8| has copy + drop + store>(_v4, _v2);
        let _v5 = VecWrapper<|&mut u8| has copy + drop + store>{fvs: _v3};
        move_to<VecWrapper<|&mut u8| has copy + drop + store>>(p0, _v5);
    }
    #[persistent]
    fun test1(p0: &mut u8) {
        *p0 = *p0 + 1u8;
    }
    #[persistent]
    fun test2(p0: &mut u8) {
        *p0 = *p0 + 2u8;
    }
    #[persistent]
    fun test3(p0: &mut u8) {
        *p0 = *p0 + 3u8;
    }
}


//# run 0x42::mod3::test_items --signers 0x42 --args true

//# run 0x42::mod3::test_items --signers 0x42 --args false

//# run 0x42::mod4::initialize --signers 0x42

//# run 0x42::mod4::check_exists --signers 0x42

//# run 0x42::mod5::initialize --signers 0x42

//# run 0x42::mod5::check_exists --signers 0x42

//# run 0x42::mod6::initialize --signers 0x42

//# run 0x42::mod6::compute --signers 0x42