//**** Cross-compiled for `move` syntax from `tests/no-v1-comparison/closures/calculator.move`

//# publish
module 0x66::calculator {
    use 0x1::signer;
    enum Input {
        Number {
            _0: u64,
        }
        Add,
        Sub,
    }
    enum State has copy, drop, key {
        Empty,
        Value {
            _0: u64,
        }
        Continuation {
            _0: |u64|(u64) has copy + drop + store,
        }
    }
    entry fun add(p0: &signer)
        acquires State
    {
        let _t2 = Input::Add{};
        process(p0, _t2);
    }
    fun process(p0: &signer, p1: Input)
        acquires State
    {
        let _t8;
        let _t10 = signer::address_of(p0);
        let _t2 = move_from<State>(_t10);
        let _t3 = &_t2;
        let _t4 = &p1;
        if ((_t3 is Empty) && (_t4 is Number)) {
            let State::Empty{} = _t2;
            let Input::Number{_0: _t79} = p1;
            _t8 = State::Value{_0: _t79};
            move_to<State>(p0, _t8)
        } else if ((_t3 is Value) && (_t4 is Number)) {
            let State::Value{_0: _t67} = _t2;
            let Input::Number{_0: _t69} = p1;
            let _t72 = State::Value{_0: _t69};
            move_to<State>(p0, _t72)
        } else if ((_t3 is Value) && (_t4 is Add)) {
            let State::Value{_0: _t56} = _t2;
            let Input::Add{} = p1;
            let _t61 = State::Continuation{_0: |arg0| storable_add(_t56, arg0)};
            move_to<State>(p0, _t61)
        } else if ((_t3 is Value) && (_t4 is Sub)) {
            let State::Value{_0: _t45} = _t2;
            let Input::Sub{} = p1;
            let _t50 = State::Continuation{_0: |arg0| storable_sub(_t45, arg0)};
            move_to<State>(p0, _t50)
        } else if ((_t3 is Continuation) && (_t4 is Number)) {
            let State::Continuation{_0: _t31} = _t2;
            let Input::Number{_0: _t33} = p1;
            _t8 = State::Value{_0: _t31(_t33)};
            move_to<State>(p0, _t8)
        } else abort 1;
    }
    fun init_module(p0: &signer) {
        let _t2 = State::Empty{};
        move_to<State>(p0, _t2);
    }
    entry fun number(p0: &signer, p1: u64)
        acquires State
    {
        let _t4 = Input::Number{_0: p1};
        process(p0, _t4);
    }
    #[persistent]
    fun storable_sub(p0: u64, p1: u64): u64 {
        p0 - p1
    }
    #[persistent]
    fun storable_add(p0: u64, p1: u64): u64 {
        p0 + p1
    }
    entry fun sub(p0: &signer)
        acquires State
    {
        let _t2 = Input::Sub{};
        process(p0, _t2);
    }
    fun view(p0: &signer): u64
        acquires State
    {
        let _t3 = signer::address_of(p0);
        let _t1 = borrow_global<State>(_t3);
        if (!(_t1 is Value)) abort 1;
        *&_t1._0
    }
}


//# run 0x66::calculator::init_module --signers 0x66

//# run 0x66::calculator::number --signers 0x66 --args 10

//# run 0x66::calculator::add --signers 0x66

//# run 0x66::calculator::number --signers 0x66 --args 20

//# run 0x66::calculator::sub --signers 0x66

//# run 0x66::calculator::number --signers 0x66 --args 5

//# run 0x66::calculator::view --signers 0x66