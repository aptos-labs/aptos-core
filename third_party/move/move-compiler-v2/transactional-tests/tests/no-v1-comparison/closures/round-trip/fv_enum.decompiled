//**** Cross-compiled for `move` syntax from `tests/no-v1-comparison/closures/fv_enum.move`

//# publish
module 0x66::fv_enum_basic {
    use 0x1::signer;
    enum Action has drop {
        Noop,
        Call {
            _0: |u64|(u64) has drop,
        }
    }
    enum FunVec<T0> has key {
        V1 {
            v1: vector<|&mut T0|(T0) has copy + store>,
        }
        V2 {
            v0: u64,
            v1: vector<|&mut T0|(T0) has copy + store>,
        }
    }
    enum Mapper<T0, T1> has key {
        Id {
            _0: |T0|(T1) has copy + store,
        }
        Twice {
            _0: Version<T0, T1>,
        }
    }
    enum Version<T0, T1> has copy, store {
        V1 {
            v1: |T0|(T1) has copy + store,
        }
    }
    #[persistent]
    fun add_k_persistent(p0: u64, p1: u64): u64 {
        p0 + p1
    }
    #[persistent]
    fun add_k_persistent_ref(p0: &mut u64, p1: u64): u64 {
        *p0 = *p0 + 1;
        *p0 + p1
    }
    fun call_square(p0: u64) {
        let _t3;
        let _t1 = Action::Call{_0: |arg0| square(arg0)};
        if (&_t1 is Call) {
            let Action::Call{_0: _t9} = _t1;
            _t3 = _t9(p0)
        } else _t3 = 0;
        if (!(_t3 == 49)) abort 14566554180833181696;
    }
    fun square(p0: u64): u64 {
        p0 * p0
    }
    fun test_enum_in_another_enum(p0: &signer)
        acquires Mapper
    {
        let _t4;
        let _t11 = Mapper::Twice<u64,u64>{_0: Version::V1<u64,u64>{v1: |arg0| add_k_persistent(arg0, 3)}};
        move_to<Mapper<u64, u64>>(p0, _t11);
        let _t13 = signer::address_of(p0);
        let _t2 = borrow_global<Mapper<u64, u64>>(_t13);
        if (_t2 is Twice) {
            let _t3 = &_t2._0;
            let _t22 = *&_t3.v1;
            let _t23 = _t22(10);
            let _t26 = *&_t3.v1;
            _t4 = _t26(_t23)
        } else if (_t2 is Id) {
            let _t38 = *&_t2._0;
            _t4 = _t38(10)
        } else abort 14566554180833181697;
        if (!(_t4 == 16)) abort 99;
    }
    fun test_fun_vec(p0: &signer)
        acquires FunVec
    {
        let _t1: |&mut u64|(u64) has copy + drop + store = |arg0| add_k_persistent_ref(arg0, 3);
        let _t14 = 0x1::vector::empty<|&mut u64|(u64) has copy + store>();
        let _t15 = &mut _t14;
        0x1::vector::push_back<|&mut u64|(u64) has copy + store>(_t15, _t1);
        0x1::vector::push_back<|&mut u64|(u64) has copy + store>(_t15, _t1);
        let _t2 = FunVec::V1<u64>{v1: _t14};
        move_to<FunVec<u64>>(p0, _t2);
        let _t20 = signer::address_of(p0);
        let _t3 = move_from<FunVec<u64>>(_t20);
        let _t4 = &_t3;
        if (_t4 is V1) {
            let FunVec::V1<u64>{v1: _t27} = _t3;
            let _t5 = _t27;
            let _t6 = 0x1::vector::pop_back<|&mut u64|(u64) has copy + store>(&mut _t5);
            let _t7 = 3;
            let _t31 = &mut _t7;
            let _t8 = _t6(_t31);
            if (!(_t7 == 4)) abort 0;
            if (!(_t8 == 7)) abort 1;
            0x1::vector::push_back<|&mut u64|(u64) has copy + store>(&mut _t5, _t6);
            _t2 = FunVec::V2<u64>{v0: 10, v1: _t5};
            move_to<FunVec<u64>>(p0, _t2)
        } else if (_t4 is V2) {
            let FunVec::V2<u64>{v0: _t55, v1: _t56} = _t3;
            0x1::vector::destroy_empty<|&mut u64|(u64) has copy + store>(_t56);
            if (false) () else abort 2
        } else abort 14566554180833181697;
    }
}


//# run 0x66::fv_enum_basic::call_square --args 7

//# run 0x66::fv_enum_basic::test_enum_in_another_enum --signers 0x66

//# run 0x66::fv_enum_basic::test_fun_vec --signers 0x66