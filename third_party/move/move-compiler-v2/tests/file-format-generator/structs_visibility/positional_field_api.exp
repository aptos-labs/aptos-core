
============ disassembled file-format ==================
// Bytecode version v10
module 0x42::m1
struct NestedPair<T0: drop> has drop
  _0: Pair
  _1: Wrapper<T0>

struct Pair has copy + drop
  _0: u64
  _1: bool

struct VecWrap<T0: drop> has drop
  _0: vector<T0>

struct Wrapper<T0: drop> has drop
  _0: T0

// Function definition at index 0
#[pack] public fun pack$NestedPair<T0: drop>(l0: Pair, l1: Wrapper<T0>): NestedPair<T0>
    local l2: Pair
    local l3: Wrapper<T0>
    move_loc l0
    move_loc l1
    pack NestedPair<T0>
    ret

// Function definition at index 1
#[unpack] public fun unpack$NestedPair<T0: drop>(l0: NestedPair<T0>): (Pair, Wrapper<T0>)
    local l1: NestedPair<T0>
    move_loc l0
    unpack NestedPair<T0>
    ret

// Function definition at index 2
#[borrow] public fun borrow$NestedPair$0<T0: drop>(l0: &NestedPair<T0>): &Pair
    local l1: &NestedPair<T0>
    move_loc l0
    borrow_field NestedPair<T0>, _0
    ret

// Function definition at index 3
#[borrow] public fun borrow$NestedPair$1<T0: drop>(l0: &NestedPair<T0>): &Wrapper<T0>
    local l1: &NestedPair<T0>
    move_loc l0
    borrow_field NestedPair<T0>, _1
    ret

// Function definition at index 4
#[borrow_mut] public fun borrow_mut$NestedPair$0<T0: drop>(l0: &mut NestedPair<T0>): &mut Pair
    local l1: &mut NestedPair<T0>
    move_loc l0
    mut_borrow_field NestedPair<T0>, _0
    ret

// Function definition at index 5
#[borrow_mut] public fun borrow_mut$NestedPair$1<T0: drop>(l0: &mut NestedPair<T0>): &mut Wrapper<T0>
    local l1: &mut NestedPair<T0>
    move_loc l0
    mut_borrow_field NestedPair<T0>, _1
    ret

// Function definition at index 6
#[pack] public fun pack$Pair(l0: u64, l1: bool): Pair
    local l2: u64
    local l3: bool
    move_loc l0
    move_loc l1
    pack Pair
    ret

// Function definition at index 7
#[unpack] public fun unpack$Pair(l0: Pair): (u64, bool)
    local l1: Pair
    move_loc l0
    unpack Pair
    ret

// Function definition at index 8
#[borrow] public fun borrow$Pair$0(l0: &Pair): &u64
    local l1: &Pair
    move_loc l0
    borrow_field Pair, _0
    ret

// Function definition at index 9
#[borrow] public fun borrow$Pair$1(l0: &Pair): &bool
    local l1: &Pair
    move_loc l0
    borrow_field Pair, _1
    ret

// Function definition at index 10
#[borrow_mut] public fun borrow_mut$Pair$0(l0: &mut Pair): &mut u64
    local l1: &mut Pair
    move_loc l0
    mut_borrow_field Pair, _0
    ret

// Function definition at index 11
#[borrow_mut] public fun borrow_mut$Pair$1(l0: &mut Pair): &mut bool
    local l1: &mut Pair
    move_loc l0
    mut_borrow_field Pair, _1
    ret

// Function definition at index 12
#[pack] public fun pack$VecWrap<T0: drop>(l0: vector<T0>): VecWrap<T0>
    local l1: vector<T0>
    move_loc l0
    pack VecWrap<T0>
    ret

// Function definition at index 13
#[unpack] public fun unpack$VecWrap<T0: drop>(l0: VecWrap<T0>): vector<T0>
    local l1: VecWrap<T0>
    move_loc l0
    unpack VecWrap<T0>
    ret

// Function definition at index 14
#[borrow] public fun borrow$VecWrap$0<T0: drop>(l0: &VecWrap<T0>): &vector<T0>
    local l1: &VecWrap<T0>
    move_loc l0
    borrow_field VecWrap<T0>, _0
    ret

// Function definition at index 15
#[borrow_mut] public fun borrow_mut$VecWrap$0<T0: drop>(l0: &mut VecWrap<T0>): &mut vector<T0>
    local l1: &mut VecWrap<T0>
    move_loc l0
    mut_borrow_field VecWrap<T0>, _0
    ret

// Function definition at index 16
#[pack] public fun pack$Wrapper<T0: drop>(l0: T0): Wrapper<T0>
    local l1: T0
    move_loc l0
    pack Wrapper<T0>
    ret

// Function definition at index 17
#[unpack] public fun unpack$Wrapper<T0: drop>(l0: Wrapper<T0>): T0
    local l1: Wrapper<T0>
    move_loc l0
    unpack Wrapper<T0>
    ret

// Function definition at index 18
#[borrow] public fun borrow$Wrapper$0<T0: drop>(l0: &Wrapper<T0>): &T0
    local l1: &Wrapper<T0>
    move_loc l0
    borrow_field Wrapper<T0>, _0
    ret

// Function definition at index 19
#[borrow_mut] public fun borrow_mut$Wrapper$0<T0: drop>(l0: &mut Wrapper<T0>): &mut T0
    local l1: &mut Wrapper<T0>
    move_loc l0
    mut_borrow_field Wrapper<T0>, _0
    ret

// Bytecode version v10
module 0x42::m2
use 0x42::m1
// Function definition at index 0
#[persistent] public fun test_borrow_nested_pair_fields()
    local l0: m1::Wrapper<u64>
    local l1: m1::Pair
    local l2: m1::NestedPair<u64>
    local l3: &bool
    local l4: &u64
    ld_u64 1
    ld_false
    call m1::pack$Pair
    ld_u64 99
    call m1::pack$Wrapper<u64>
    // @5
    st_loc l0
    st_loc l1
    move_loc l1
    move_loc l0
    call m1::pack$NestedPair<u64>
    // @10
    st_loc l2
    borrow_loc l2
    call m1::borrow$NestedPair$0<u64>
    call m1::borrow$Pair$0
    borrow_loc l2
    // @15
    call m1::borrow$NestedPair$0<u64>
    call m1::borrow$Pair$1
    st_loc l3
    borrow_loc l2
    call m1::borrow$NestedPair$1<u64>
    // @20
    call m1::borrow$Wrapper$0<u64>
    st_loc l4
    read_ref
    ld_u64 1
    eq
    // @25
    br_false l0
    branch l1
l0: move_loc l3
    pop
    move_loc l4
    // @30
    pop
    ld_u64 3
    abort
l1: move_loc l3
    read_ref
    // @35
    not
    br_false l2
    branch l3
l2: move_loc l4
    pop
    // @40
    ld_u64 4
    abort
l3: move_loc l4
    read_ref
    ld_u64 99
    // @45
    eq
    br_false l4
    branch l5
l4: ld_u64 5
    abort
    // @50
l5: ret

// Function definition at index 1
#[persistent] public fun test_borrow_pair_fields()
    local l0: m1::Pair
    local l1: &bool
    ld_u64 42
    ld_true
    call m1::pack$Pair
    st_loc l0
    borrow_loc l0
    // @5
    call m1::borrow$Pair$0
    borrow_loc l0
    call m1::borrow$Pair$1
    st_loc l1
    read_ref
    // @10
    ld_u64 42
    eq
    br_false l0
    branch l1
l0: move_loc l1
    // @15
    pop
    ld_u64 0
    abort
l1: move_loc l1
    read_ref
    // @20
    br_false l2
    branch l3
l2: ld_u64 1
    abort
l3: ret

// Function definition at index 2
#[persistent] public fun test_borrow_vecwrap_element()
    local l0: m1::VecWrap<u64>
    local l1: &u64
    ld_const<vector<u64>> [10, 20, 30]
    call m1::pack$VecWrap<u64>
    st_loc l0
    borrow_loc l0
    call m1::borrow$VecWrap$0<u64>
    // @5
    ld_u64 0
    vec_borrow <u64>
    borrow_loc l0
    call m1::borrow$VecWrap$0<u64>
    ld_u64 1
    // @10
    vec_borrow <u64>
    st_loc l1
    read_ref
    ld_u64 10
    eq
    // @15
    br_false l0
    branch l1
l0: move_loc l1
    pop
    ld_u64 6
    // @20
    abort
l1: move_loc l1
    read_ref
    ld_u64 20
    eq
    // @25
    br_false l2
    branch l3
l2: ld_u64 7
    abort
l3: ret

// Function definition at index 3
#[persistent] public fun test_borrow_wrapper_field()
    local l0: m1::Wrapper<u64>
    ld_u64 100
    call m1::pack$Wrapper<u64>
    st_loc l0
    borrow_loc l0
    call m1::borrow$Wrapper$0<u64>
    // @5
    read_ref
    ld_u64 100
    eq
    br_false l0
    branch l1
    // @10
l0: ld_u64 2
    abort
l1: ret

// Function definition at index 4
#[persistent] public fun test_mut_borrow_nestedpair()
    local l0: m1::Wrapper<u64>
    local l1: m1::Pair
    local l2: m1::NestedPair<u64>
    local l3: &mut m1::NestedPair<u64>
    local l4: u64
    local l5: &mut u64
    local l6: u64
    local l7: &mut u64
    ld_u64 0
    ld_true
    call m1::pack$Pair
    ld_u64 77
    call m1::pack$Wrapper<u64>
    // @5
    st_loc l0
    st_loc l1
    move_loc l1
    move_loc l0
    call m1::pack$NestedPair<u64>
    // @10
    st_loc l2
    mut_borrow_loc l2
    st_loc l3
    copy_loc l3
    call m1::borrow_mut$NestedPair$0<u64>
    // @15
    call m1::borrow_mut$Pair$0
    ld_u64 123
    st_loc l4
    st_loc l5
    move_loc l4
    // @20
    move_loc l5
    write_ref
    move_loc l3
    call m1::borrow_mut$NestedPair$1<u64>
    call m1::borrow_mut$Wrapper$0<u64>
    // @25
    ld_u64 456
    st_loc l6
    st_loc l7
    move_loc l6
    move_loc l7
    // @30
    write_ref
    borrow_loc l2
    call m1::borrow$NestedPair$0<u64>
    call m1::borrow$Pair$0
    read_ref
    // @35
    ld_u64 123
    eq
    br_false l0
    branch l1
l0: ld_u64 10
    // @40
    abort
l1: borrow_loc l2
    call m1::borrow$NestedPair$1<u64>
    call m1::borrow$Wrapper$0<u64>
    read_ref
    // @45
    ld_u64 456
    eq
    br_false l2
    branch l3
l2: ld_u64 11
    // @50
    abort
l3: ret

// Function definition at index 5
#[persistent] public fun test_mut_borrow_pair()
    local l0: m1::Pair
    local l1: u64
    local l2: &mut u64
    ld_u64 7
    ld_false
    call m1::pack$Pair
    st_loc l0
    mut_borrow_loc l0
    // @5
    call m1::borrow_mut$Pair$0
    ld_u64 8
    st_loc l1
    st_loc l2
    move_loc l1
    // @10
    move_loc l2
    write_ref
    borrow_loc l0
    call m1::borrow$Pair$0
    read_ref
    // @15
    ld_u64 8
    eq
    br_false l0
    branch l1
l0: ld_u64 8
    // @20
    abort
l1: ret

// Function definition at index 6
#[persistent] public fun test_mut_borrow_vecwrap_element()
    local l0: m1::VecWrap<u64>
    local l1: u64
    local l2: &mut u64
    ld_const<vector<u64>> [1, 2, 3]
    call m1::pack$VecWrap<u64>
    st_loc l0
    mut_borrow_loc l0
    call m1::borrow_mut$VecWrap$0<u64>
    // @5
    ld_u64 1
    vec_mut_borrow <u64>
    ld_u64 10
    st_loc l1
    st_loc l2
    // @10
    move_loc l1
    move_loc l2
    write_ref
    borrow_loc l0
    call m1::borrow$VecWrap$0<u64>
    // @15
    ld_u64 1
    vec_borrow <u64>
    read_ref
    ld_u64 10
    eq
    // @20
    br_false l0
    branch l1
l0: ld_u64 9
    abort
l1: ret


============ bytecode verification succeeded ========
