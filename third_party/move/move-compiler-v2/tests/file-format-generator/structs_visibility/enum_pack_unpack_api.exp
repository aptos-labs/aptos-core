
============ disassembled file-format ==================
// Bytecode version v10
module 0x42::m1
enum E has drop
  A
    x: u64
  B
    x: u64

enum Inner
  Inner1
    x: u64
  Inner2
    x: u64
    y: u64

enum Result<T0: copy + drop, T1: copy + drop> has copy + drop
  Ok
    _0: T0
  Err
    _0: T1

// Function definition at index 0
#[test_variant=0] public fun test_variant$E$A(l0: &E): bool
    local l1: &E
    move_loc l0
    test_variant E, A
    ret

// Function definition at index 1
#[test_variant=1] public fun test_variant$E$B(l0: &E): bool
    local l1: &E
    move_loc l0
    test_variant E, B
    ret

// Function definition at index 2
#[pack_variant=0] public fun pack$E$A(l0: u64): E
    local l1: u64
    move_loc l0
    pack_variant E, A
    ret

// Function definition at index 3
#[pack_variant=1] public fun pack$E$B(l0: u64): E
    local l1: u64
    move_loc l0
    pack_variant E, B
    ret

// Function definition at index 4
#[unpack_variant=0] public fun unpack$E$A(l0: E): u64
    local l1: E
    move_loc l0
    unpack_variant E, A
    ret

// Function definition at index 5
#[unpack_variant=1] public fun unpack$E$B(l0: E): u64
    local l1: E
    move_loc l0
    unpack_variant E, B
    ret

// Function definition at index 6
#[borrow=0] public fun borrow$E$0$0(l0: &E): &u64
    local l1: &E
    move_loc l0
    borrow_variant_field E, A::x, B::x
    ret

// Function definition at index 7
#[borrow_mut=0] public fun borrow_mut$E$0$0(l0: &mut E): &mut u64
    local l1: &mut E
    move_loc l0
    mut_borrow_variant_field E, A::x, B::x
    ret

// Function definition at index 8
#[test_variant=0] public fun test_variant$Inner$Inner1(l0: &Inner): bool
    local l1: &Inner
    move_loc l0
    test_variant Inner, Inner1
    ret

// Function definition at index 9
#[test_variant=1] public fun test_variant$Inner$Inner2(l0: &Inner): bool
    local l1: &Inner
    move_loc l0
    test_variant Inner, Inner2
    ret

// Function definition at index 10
#[pack_variant=0] public fun pack$Inner$Inner1(l0: u64): Inner
    local l1: u64
    move_loc l0
    pack_variant Inner, Inner1
    ret

// Function definition at index 11
#[pack_variant=1] public fun pack$Inner$Inner2(l0: u64, l1: u64): Inner
    local l2: u64
    local l3: u64
    move_loc l0
    move_loc l1
    pack_variant Inner, Inner2
    ret

// Function definition at index 12
#[unpack_variant=0] public fun unpack$Inner$Inner1(l0: Inner): u64
    local l1: Inner
    move_loc l0
    unpack_variant Inner, Inner1
    ret

// Function definition at index 13
#[unpack_variant=1] public fun unpack$Inner$Inner2(l0: Inner): (u64, u64)
    local l1: Inner
    move_loc l0
    unpack_variant Inner, Inner2
    ret

// Function definition at index 14
#[borrow=0] public fun borrow$Inner$0$0(l0: &Inner): &u64
    local l1: &Inner
    move_loc l0
    borrow_variant_field Inner, Inner1::x, Inner2::x
    ret

// Function definition at index 15
#[borrow=1] public fun borrow$Inner$1$1(l0: &Inner): &u64
    local l1: &Inner
    move_loc l0
    borrow_variant_field Inner, Inner2::y
    ret

// Function definition at index 16
#[borrow_mut=0] public fun borrow_mut$Inner$0$0(l0: &mut Inner): &mut u64
    local l1: &mut Inner
    move_loc l0
    mut_borrow_variant_field Inner, Inner1::x, Inner2::x
    ret

// Function definition at index 17
#[borrow_mut=1] public fun borrow_mut$Inner$1$1(l0: &mut Inner): &mut u64
    local l1: &mut Inner
    move_loc l0
    mut_borrow_variant_field Inner, Inner2::y
    ret

// Function definition at index 18
#[test_variant=0] public fun test_variant$Result$Ok<T0: copy + drop, T1: copy + drop>(l0: &Result<T0, T1>): bool
    local l1: &Result<T0, T1>
    move_loc l0
    test_variant Result<T0, T1>, Ok
    ret

// Function definition at index 19
#[test_variant=1] public fun test_variant$Result$Err<T0: copy + drop, T1: copy + drop>(l0: &Result<T0, T1>): bool
    local l1: &Result<T0, T1>
    move_loc l0
    test_variant Result<T0, T1>, Err
    ret

// Function definition at index 20
#[pack_variant=0] public fun pack$Result$Ok<T0: copy + drop, T1: copy + drop>(l0: T0): Result<T0, T1>
    local l1: T0
    move_loc l0
    pack_variant Result<T0, T1>, Ok
    ret

// Function definition at index 21
#[pack_variant=1] public fun pack$Result$Err<T0: copy + drop, T1: copy + drop>(l0: T1): Result<T0, T1>
    local l1: T1
    move_loc l0
    pack_variant Result<T0, T1>, Err
    ret

// Function definition at index 22
#[unpack_variant=0] public fun unpack$Result$Ok<T0: copy + drop, T1: copy + drop>(l0: Result<T0, T1>): T0
    local l1: Result<T0, T1>
    move_loc l0
    unpack_variant Result<T0, T1>, Ok
    ret

// Function definition at index 23
#[unpack_variant=1] public fun unpack$Result$Err<T0: copy + drop, T1: copy + drop>(l0: Result<T0, T1>): T1
    local l1: Result<T0, T1>
    move_loc l0
    unpack_variant Result<T0, T1>, Err
    ret

// Function definition at index 24
#[borrow=0] public fun borrow$Result$0$0<T0: copy + drop, T1: copy + drop>(l0: &Result<T0, T1>): &T0
    local l1: &Result<T0, T1>
    move_loc l0
    borrow_variant_field Result<T0, T1>, Ok::_0
    ret

// Function definition at index 25
#[borrow=0] public fun borrow$Result$0$1<T0: copy + drop, T1: copy + drop>(l0: &Result<T0, T1>): &T1
    local l1: &Result<T0, T1>
    move_loc l0
    borrow_variant_field Result<T0, T1>, Err::_0
    ret

// Function definition at index 26
#[borrow_mut=0] public fun borrow_mut$Result$0$0<T0: copy + drop, T1: copy + drop>(l0: &mut Result<T0, T1>): &mut T0
    local l1: &mut Result<T0, T1>
    move_loc l0
    mut_borrow_variant_field Result<T0, T1>, Ok::_0
    ret

// Function definition at index 27
#[borrow_mut=0] public fun borrow_mut$Result$0$1<T0: copy + drop, T1: copy + drop>(l0: &mut Result<T0, T1>): &mut T1
    local l1: &mut Result<T0, T1>
    move_loc l0
    mut_borrow_variant_field Result<T0, T1>, Err::_0
    ret

// Bytecode version v10
module 0x42::m2
use 0x42::m1
// Function definition at index 0
#[persistent] public fun test_pack_unpack_result_err()
    ld_u8 7
    call m1::pack$Result$Err<u64, u8>
    call m1::unpack$Result$Err<u64, u8>
    ld_u8 7
    eq
    // @5
    br_false l0
    branch l1
l0: ld_u64 3
    abort
l1: ret

// Function definition at index 1
#[persistent] public fun test_pack_unpack_result_ok()
    local l0: m1::Result<u64, u64>
    ld_u64 42
    call m1::pack$Result$Ok<u64, u64>
    st_loc l0
    copy_loc l0
    ld_u64 42
    // @5
    call m1::pack$Result$Ok<u64, u64>
    eq
    br_false l0
    branch l1
l0: ld_u64 1
    // @10
    abort
l1: move_loc l0
    call m1::unpack$Result$Ok<u64, u64>
    ld_u64 42
    eq
    // @15
    br_false l2
    branch l3
l2: ld_u64 2
    abort
l3: ret

// Function definition at index 2
#[persistent] public fun test_unpack_enum_e()
    local l0: m1::E
    local l1: m1::E
    ld_u64 100
    call m1::pack$E$A
    ld_u64 200
    call m1::pack$E$B
    st_loc l0
    // @5
    st_loc l1
    move_loc l1
    call m1::unpack$E$A
    ld_u64 100
    eq
    // @10
    br_false l0
    branch l1
l0: ld_u64 4
    abort
l1: move_loc l0
    // @15
    call m1::unpack$E$B
    ld_u64 200
    eq
    br_false l2
    branch l3
    // @20
l2: ld_u64 5
    abort
l3: ret

// Function definition at index 3
#[persistent] public fun test_unpack_inner()
    local l0: m1::Inner
    local l1: m1::Inner
    local l2: &m1::Inner
    local l3: u64
    local l4: u64
    local l5: u64
    local l6: &m1::Inner
    local l7: u64
    local l8: u64
    local l9: u64
    ld_u64 10
    call m1::pack$Inner$Inner1
    st_loc l0
    ld_u64 20
    ld_u64 30
    // @5
    call m1::pack$Inner$Inner2
    st_loc l1
    borrow_loc l0
    st_loc l2
    copy_loc l2
    // @10
    call m1::test_variant$Inner$Inner1
    br_false l0
    move_loc l2
    pop
    move_loc l0
    // @15
    call m1::unpack$Inner$Inner1
    st_loc l3
    branch l1
l0: move_loc l2
    call m1::test_variant$Inner$Inner2
    // @20
    br_false l2
    move_loc l0
    call m1::unpack$Inner$Inner2
    st_loc l4
    st_loc l5
    // @25
    move_loc l5
    move_loc l4
    add
    st_loc l3
    branch l1
    // @30
l2: ld_u64 14566554180833181697
    abort
l1: borrow_loc l1
    st_loc l6
    copy_loc l6
    // @35
    call m1::test_variant$Inner$Inner1
    br_false l3
    move_loc l6
    pop
    move_loc l1
    // @40
    call m1::unpack$Inner$Inner1
    st_loc l7
    branch l4
l3: move_loc l6
    call m1::test_variant$Inner$Inner2
    // @45
    br_false l5
    move_loc l1
    call m1::unpack$Inner$Inner2
    st_loc l8
    st_loc l9
    // @50
    move_loc l9
    move_loc l8
    add
    st_loc l7
    branch l4
    // @55
l5: ld_u64 14566554180833181697
    abort
l4: move_loc l3
    ld_u64 10
    eq
    // @60
    br_false l6
    branch l7
l6: ld_u64 6
    abort
l7: move_loc l7
    // @65
    ld_u64 50
    eq
    br_false l8
    branch l9
l8: ld_u64 7
    // @70
    abort
l9: ret


============ bytecode verification succeeded ========
