
============ disassembled file-format ==================
// Bytecode version v10
module 0x66::fv_enum_basic
enum Action has drop
  Noop
  Call
    _0: |u64|u64 has drop

enum FunVec<T0> has drop
  V1
    v1: vector<|&mut T0|T0 has copy + drop + store>
  V2
    v0: u64
    v1: vector<|&mut T0|T0 has copy + drop + store>

enum Mapper<T0, T1> has drop
  Id
    _0: |T0|T1 has copy + drop + store
  Twice
    _0: Version<T0, T1>

enum Version<T0, T1> has copy + drop + store
  V1
    v1: |T0|T1 has copy + drop + store

// Function definition at index 0
#[test_variant] public fun test_variant$Action$Noop(l0: &Action): bool
    local l1: &Action
    move_loc l0
    test_variant Action, Noop
    ret

// Function definition at index 1
#[test_variant] public fun test_variant$Action$Call(l0: &Action): bool
    local l1: &Action
    move_loc l0
    test_variant Action, Call
    ret

// Function definition at index 2
#[pack_variant] public fun pack$Action$Noop(): Action
    pack_variant Action, Noop
    ret

// Function definition at index 3
#[pack_variant] public fun pack$Action$Call(l0: |u64|u64 has drop): Action
    local l1: |u64|u64 has drop
    move_loc l0
    pack_variant Action, Call
    ret

// Function definition at index 4
#[unpack_variant] public fun unpack$Action$Noop(l0: Action)
    local l1: Action
    move_loc l0
    unpack_variant Action, Noop
    ret

// Function definition at index 5
#[unpack_variant] public fun unpack$Action$Call(l0: Action): |u64|u64 has drop
    local l1: Action
    move_loc l0
    unpack_variant Action, Call
    ret

// Function definition at index 6
#[borrow] public fun borrow$Action$0$0(l0: &Action): &|u64|u64 has drop
    local l1: &Action
    move_loc l0
    borrow_variant_field Action, Call::_0
    ret

// Function definition at index 7
#[borrow_mut] public fun borrow_mut$Action$0$0(l0: &mut Action): &mut |u64|u64 has drop
    local l1: &mut Action
    move_loc l0
    mut_borrow_variant_field Action, Call::_0
    ret

// Function definition at index 8
#[test_variant] public fun test_variant$FunVec$V1<T0>(l0: &FunVec<T0>): bool
    local l1: &FunVec<T0>
    move_loc l0
    test_variant FunVec<T0>, V1
    ret

// Function definition at index 9
#[test_variant] public fun test_variant$FunVec$V2<T0>(l0: &FunVec<T0>): bool
    local l1: &FunVec<T0>
    move_loc l0
    test_variant FunVec<T0>, V2
    ret

// Function definition at index 10
#[pack_variant] public fun pack$FunVec$V1<T0>(l0: vector<|&mut T0|T0 has copy + drop + store>): FunVec<T0>
    local l1: vector<|&mut T0|T0 has copy + drop + store>
    move_loc l0
    pack_variant FunVec<T0>, V1
    ret

// Function definition at index 11
#[pack_variant] public fun pack$FunVec$V2<T0>(l0: u64, l1: vector<|&mut T0|T0 has copy + drop + store>): FunVec<T0>
    local l2: u64
    local l3: vector<|&mut T0|T0 has copy + drop + store>
    move_loc l0
    move_loc l1
    pack_variant FunVec<T0>, V2
    ret

// Function definition at index 12
#[unpack_variant] public fun unpack$FunVec$V1<T0>(l0: FunVec<T0>): vector<|&mut T0|T0 has copy + drop + store>
    local l1: FunVec<T0>
    move_loc l0
    unpack_variant FunVec<T0>, V1
    ret

// Function definition at index 13
#[unpack_variant] public fun unpack$FunVec$V2<T0>(l0: FunVec<T0>): (u64, vector<|&mut T0|T0 has copy + drop + store>)
    local l1: FunVec<T0>
    move_loc l0
    unpack_variant FunVec<T0>, V2
    ret

// Function definition at index 14
#[borrow] public fun borrow$FunVec$0$1<T0>(l0: &FunVec<T0>): &u64
    local l1: &FunVec<T0>
    move_loc l0
    borrow_variant_field FunVec<T0>, V2::v0
    ret

// Function definition at index 15
#[borrow] public fun borrow$FunVec$0$0<T0>(l0: &FunVec<T0>): &vector<|&mut T0|T0 has copy + drop + store>
    local l1: &FunVec<T0>
    move_loc l0
    borrow_variant_field FunVec<T0>, V1::v1
    ret

// Function definition at index 16
#[borrow] public fun borrow$FunVec$1$2<T0>(l0: &FunVec<T0>): &vector<|&mut T0|T0 has copy + drop + store>
    local l1: &FunVec<T0>
    move_loc l0
    borrow_variant_field FunVec<T0>, V2::v1
    ret

// Function definition at index 17
#[borrow_mut] public fun borrow_mut$FunVec$0$1<T0>(l0: &mut FunVec<T0>): &mut u64
    local l1: &mut FunVec<T0>
    move_loc l0
    mut_borrow_variant_field FunVec<T0>, V2::v0
    ret

// Function definition at index 18
#[borrow_mut] public fun borrow_mut$FunVec$0$0<T0>(l0: &mut FunVec<T0>): &mut vector<|&mut T0|T0 has copy + drop + store>
    local l1: &mut FunVec<T0>
    move_loc l0
    mut_borrow_variant_field FunVec<T0>, V1::v1
    ret

// Function definition at index 19
#[borrow_mut] public fun borrow_mut$FunVec$1$2<T0>(l0: &mut FunVec<T0>): &mut vector<|&mut T0|T0 has copy + drop + store>
    local l1: &mut FunVec<T0>
    move_loc l0
    mut_borrow_variant_field FunVec<T0>, V2::v1
    ret

// Function definition at index 20
#[test_variant] public fun test_variant$Mapper$Id<T0, T1>(l0: &Mapper<T0, T1>): bool
    local l1: &Mapper<T0, T1>
    move_loc l0
    test_variant Mapper<T0, T1>, Id
    ret

// Function definition at index 21
#[test_variant] public fun test_variant$Mapper$Twice<T0, T1>(l0: &Mapper<T0, T1>): bool
    local l1: &Mapper<T0, T1>
    move_loc l0
    test_variant Mapper<T0, T1>, Twice
    ret

// Function definition at index 22
#[pack_variant] public fun pack$Mapper$Id<T0, T1>(l0: |T0|T1 has copy + drop + store): Mapper<T0, T1>
    local l1: |T0|T1 has copy + drop + store
    move_loc l0
    pack_variant Mapper<T0, T1>, Id
    ret

// Function definition at index 23
#[pack_variant] public fun pack$Mapper$Twice<T0, T1>(l0: Version<T0, T1>): Mapper<T0, T1>
    local l1: Version<T0, T1>
    move_loc l0
    pack_variant Mapper<T0, T1>, Twice
    ret

// Function definition at index 24
#[unpack_variant] public fun unpack$Mapper$Id<T0, T1>(l0: Mapper<T0, T1>): |T0|T1 has copy + drop + store
    local l1: Mapper<T0, T1>
    move_loc l0
    unpack_variant Mapper<T0, T1>, Id
    ret

// Function definition at index 25
#[unpack_variant] public fun unpack$Mapper$Twice<T0, T1>(l0: Mapper<T0, T1>): Version<T0, T1>
    local l1: Mapper<T0, T1>
    move_loc l0
    unpack_variant Mapper<T0, T1>, Twice
    ret

// Function definition at index 26
#[borrow] public fun borrow$Mapper$0$1<T0, T1>(l0: &Mapper<T0, T1>): &Version<T0, T1>
    local l1: &Mapper<T0, T1>
    move_loc l0
    borrow_variant_field Mapper<T0, T1>, Twice::_0
    ret

// Function definition at index 27
#[borrow] public fun borrow$Mapper$0$0<T0, T1>(l0: &Mapper<T0, T1>): &|T0|T1 has copy + drop + store
    local l1: &Mapper<T0, T1>
    move_loc l0
    borrow_variant_field Mapper<T0, T1>, Id::_0
    ret

// Function definition at index 28
#[borrow_mut] public fun borrow_mut$Mapper$0$1<T0, T1>(l0: &mut Mapper<T0, T1>): &mut Version<T0, T1>
    local l1: &mut Mapper<T0, T1>
    move_loc l0
    mut_borrow_variant_field Mapper<T0, T1>, Twice::_0
    ret

// Function definition at index 29
#[borrow_mut] public fun borrow_mut$Mapper$0$0<T0, T1>(l0: &mut Mapper<T0, T1>): &mut |T0|T1 has copy + drop + store
    local l1: &mut Mapper<T0, T1>
    move_loc l0
    mut_borrow_variant_field Mapper<T0, T1>, Id::_0
    ret

// Function definition at index 30
#[test_variant] public fun test_variant$Version$V1<T0, T1>(l0: &Version<T0, T1>): bool
    local l1: &Version<T0, T1>
    move_loc l0
    test_variant Version<T0, T1>, V1
    ret

// Function definition at index 31
#[pack_variant] public fun pack$Version$V1<T0, T1>(l0: |T0|T1 has copy + drop + store): Version<T0, T1>
    local l1: |T0|T1 has copy + drop + store
    move_loc l0
    pack_variant Version<T0, T1>, V1
    ret

// Function definition at index 32
#[unpack_variant] public fun unpack$Version$V1<T0, T1>(l0: Version<T0, T1>): |T0|T1 has copy + drop + store
    local l1: Version<T0, T1>
    move_loc l0
    unpack_variant Version<T0, T1>, V1
    ret

// Function definition at index 33
#[borrow] public fun borrow$Version$0$0<T0, T1>(l0: &Version<T0, T1>): &|T0|T1 has copy + drop + store
    local l1: &Version<T0, T1>
    move_loc l0
    borrow_variant_field Version<T0, T1>, V1::v1
    ret

// Function definition at index 34
#[borrow_mut] public fun borrow_mut$Version$0$0<T0, T1>(l0: &mut Version<T0, T1>): &mut |T0|T1 has copy + drop + store
    local l1: &mut Version<T0, T1>
    move_loc l0
    mut_borrow_variant_field Version<T0, T1>, V1::v1
    ret

// Bytecode version v10
module 0x66::fv_enum_basic_public
use 0x66::fv_enum_basic
// Function definition at index 0
#[persistent] fun add_k_persistent(l0: u64, l1: u64): u64
    move_loc l0
    move_loc l1
    add
    ret

// Function definition at index 1
#[persistent] fun add_k_persistent_ref(l0: &mut u64, l1: u64): u64
    copy_loc l0
    read_ref
    ld_u64 1
    add
    copy_loc l0
    // @5
    write_ref
    move_loc l0
    read_ref
    move_loc l1
    add
    // @10
    ret

// Function definition at index 2
fun call_square(l0: u64)
    local l1: fv_enum_basic::Action
    local l2: |u64|u64 has drop
    local l3: u64
    pack_closure square, 0
    call fv_enum_basic::pack$Action$Call
    st_loc l1
    borrow_loc l1
    call fv_enum_basic::test_variant$Action$Call
    // @5
    br_false l0
    move_loc l1
    call fv_enum_basic::unpack$Action$Call
    st_loc l2
    move_loc l0
    // @10
    move_loc l2
    call_closure <|u64|u64 has drop>
    st_loc l3
l2: move_loc l3
    ld_u64 49
    // @15
    eq
    br_false l1
    ret
l1: ld_u64 14566554180833181696
    abort
    // @20
l0: ld_u64 0
    st_loc l3
    branch l2

// Function definition at index 3
fun square(l0: u64): u64
    copy_loc l0
    move_loc l0
    mul
    ret

// Function definition at index 4
fun test_enum_in_another_enum()
    local l0: fv_enum_basic::Mapper<u64, u64>
    local l1: &mut fv_enum_basic::Mapper<u64, u64>
    local l2: &mut fv_enum_basic::Version<u64, u64>
    local l3: u64
    local l4: &mut |u64|u64 has copy + drop + store
    ld_u64 3
    pack_closure add_k_persistent, 10
    call fv_enum_basic::pack$Version$V1<u64, u64>
    call fv_enum_basic::pack$Mapper$Twice<u64, u64>
    st_loc l0
    // @5
    mut_borrow_loc l0
    st_loc l1
    copy_loc l1
    freeze_ref
    call fv_enum_basic::test_variant$Mapper$Twice<u64, u64>
    // @10
    br_false l0
    move_loc l1
    call fv_enum_basic::borrow_mut$Mapper$0$1<u64, u64>
    st_loc l2
    ld_u64 10
    // @15
    copy_loc l2
    freeze_ref
    call fv_enum_basic::borrow$Version$0$0<u64, u64>
    read_ref
    call_closure <|u64|u64 has copy + drop + store>
    // @20
    move_loc l2
    freeze_ref
    call fv_enum_basic::borrow$Version$0$0<u64, u64>
    read_ref
    call_closure <|u64|u64 has copy + drop + store>
    // @25
    st_loc l3
l3: move_loc l3
    ld_u64 16
    eq
    br_false l1
    // @30
    ret
l1: ld_u64 99
    abort
l0: copy_loc l1
    freeze_ref
    // @35
    call fv_enum_basic::test_variant$Mapper$Id<u64, u64>
    br_false l2
    move_loc l1
    call fv_enum_basic::borrow_mut$Mapper$0$0<u64, u64>
    st_loc l4
    // @40
    ld_u64 10
    move_loc l4
    read_ref
    call_closure <|u64|u64 has copy + drop + store>
    st_loc l3
    // @45
    branch l3
l2: move_loc l1
    pop
    ld_u64 14566554180833181697
    abort

// Function definition at index 5
fun test_fun_vec()
    local l0: |&mut u64|u64 has copy + drop + store
    local l1: fv_enum_basic::FunVec<u64>
    local l2: &fv_enum_basic::FunVec<u64>
    local l3: vector<|&mut u64|u64 has copy + drop + store>
    local l4: u64
    local l5: u64
    local l6: bool
    ld_u64 3
    pack_closure add_k_persistent_ref, 10
    st_loc l0
    copy_loc l0
    move_loc l0
    // @5
    vec_pack <|&mut u64|u64 has copy + drop + store>, 2
    call fv_enum_basic::pack$FunVec$V1<u64>
    st_loc l1
    borrow_loc l1
    st_loc l2
    // @10
    copy_loc l2
    call fv_enum_basic::test_variant$FunVec$V1<u64>
    br_false l0
    move_loc l2
    pop
    // @15
    move_loc l1
    call fv_enum_basic::unpack$FunVec$V1<u64>
    st_loc l3
    mut_borrow_loc l3
    vec_pop_back <|&mut u64|u64 has copy + drop + store>
    // @20
    st_loc l0
    ld_u64 3
    st_loc l4
    mut_borrow_loc l4
    copy_loc l0
    // @25
    call_closure <|&mut u64|u64 has copy + drop + store>
    st_loc l5
    move_loc l4
    ld_u64 4
    eq
    // @30
    br_false l1
    move_loc l5
    ld_u64 7
    eq
    br_false l2
    // @35
    mut_borrow_loc l3
    move_loc l0
    vec_push_back <|&mut u64|u64 has copy + drop + store>
    ld_u64 10
    move_loc l3
    // @40
    call fv_enum_basic::pack$FunVec$V2<u64>
    pop
    ret
l2: ld_u64 1
    abort
    // @45
l1: ld_u64 0
    abort
l0: move_loc l2
    call fv_enum_basic::test_variant$FunVec$V2<u64>
    br_false l3
    // @50
    move_loc l1
    call fv_enum_basic::unpack$FunVec$V2<u64>
    vec_unpack <|&mut u64|u64 has copy + drop + store>, 0
    pop
    ld_false
    // @55
    br_false l4
    ret
l4: ld_u64 2
    abort
l3: ld_u64 14566554180833181697
    // @60
    abort


============ bytecode verification succeeded ========
