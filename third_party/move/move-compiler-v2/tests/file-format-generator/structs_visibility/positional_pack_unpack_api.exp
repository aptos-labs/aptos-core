
============ disassembled file-format ==================
// Bytecode version v10
module 0x42::m1
struct NestedPair<T0: drop> has drop
  _0: Pair
  _1: Wrapper<T0>

struct Pair has copy + drop
  _0: u64
  _1: bool

struct VecWrap<T0: drop> has drop
  _0: vector<T0>

struct Wrapper<T0: drop> has drop
  _0: T0

// Function definition at index 0
#[pack] public fun pack$NestedPair<T0: drop>(l0: Pair, l1: Wrapper<T0>): NestedPair<T0>
    local l2: Pair
    local l3: Wrapper<T0>
    move_loc l0
    move_loc l1
    pack NestedPair<T0>
    ret

// Function definition at index 1
#[unpack] public fun unpack$NestedPair<T0: drop>(l0: NestedPair<T0>): (Pair, Wrapper<T0>)
    local l1: NestedPair<T0>
    move_loc l0
    unpack NestedPair<T0>
    ret

// Function definition at index 2
#[borrow=0] public fun borrow$NestedPair$0<T0: drop>(l0: &NestedPair<T0>): &Pair
    local l1: &NestedPair<T0>
    move_loc l0
    borrow_field NestedPair<T0>, _0
    ret

// Function definition at index 3
#[borrow=1] public fun borrow$NestedPair$1<T0: drop>(l0: &NestedPair<T0>): &Wrapper<T0>
    local l1: &NestedPair<T0>
    move_loc l0
    borrow_field NestedPair<T0>, _1
    ret

// Function definition at index 4
#[borrow_mut=0] public fun borrow_mut$NestedPair$0<T0: drop>(l0: &mut NestedPair<T0>): &mut Pair
    local l1: &mut NestedPair<T0>
    move_loc l0
    mut_borrow_field NestedPair<T0>, _0
    ret

// Function definition at index 5
#[borrow_mut=1] public fun borrow_mut$NestedPair$1<T0: drop>(l0: &mut NestedPair<T0>): &mut Wrapper<T0>
    local l1: &mut NestedPair<T0>
    move_loc l0
    mut_borrow_field NestedPair<T0>, _1
    ret

// Function definition at index 6
#[pack] public fun pack$Pair(l0: u64, l1: bool): Pair
    local l2: u64
    local l3: bool
    move_loc l0
    move_loc l1
    pack Pair
    ret

// Function definition at index 7
#[unpack] public fun unpack$Pair(l0: Pair): (u64, bool)
    local l1: Pair
    move_loc l0
    unpack Pair
    ret

// Function definition at index 8
#[borrow=0] public fun borrow$Pair$0(l0: &Pair): &u64
    local l1: &Pair
    move_loc l0
    borrow_field Pair, _0
    ret

// Function definition at index 9
#[borrow=1] public fun borrow$Pair$1(l0: &Pair): &bool
    local l1: &Pair
    move_loc l0
    borrow_field Pair, _1
    ret

// Function definition at index 10
#[borrow_mut=0] public fun borrow_mut$Pair$0(l0: &mut Pair): &mut u64
    local l1: &mut Pair
    move_loc l0
    mut_borrow_field Pair, _0
    ret

// Function definition at index 11
#[borrow_mut=1] public fun borrow_mut$Pair$1(l0: &mut Pair): &mut bool
    local l1: &mut Pair
    move_loc l0
    mut_borrow_field Pair, _1
    ret

// Function definition at index 12
#[pack] public fun pack$VecWrap<T0: drop>(l0: vector<T0>): VecWrap<T0>
    local l1: vector<T0>
    move_loc l0
    pack VecWrap<T0>
    ret

// Function definition at index 13
#[unpack] public fun unpack$VecWrap<T0: drop>(l0: VecWrap<T0>): vector<T0>
    local l1: VecWrap<T0>
    move_loc l0
    unpack VecWrap<T0>
    ret

// Function definition at index 14
#[borrow=0] public fun borrow$VecWrap$0<T0: drop>(l0: &VecWrap<T0>): &vector<T0>
    local l1: &VecWrap<T0>
    move_loc l0
    borrow_field VecWrap<T0>, _0
    ret

// Function definition at index 15
#[borrow_mut=0] public fun borrow_mut$VecWrap$0<T0: drop>(l0: &mut VecWrap<T0>): &mut vector<T0>
    local l1: &mut VecWrap<T0>
    move_loc l0
    mut_borrow_field VecWrap<T0>, _0
    ret

// Function definition at index 16
#[pack] public fun pack$Wrapper<T0: drop>(l0: T0): Wrapper<T0>
    local l1: T0
    move_loc l0
    pack Wrapper<T0>
    ret

// Function definition at index 17
#[unpack] public fun unpack$Wrapper<T0: drop>(l0: Wrapper<T0>): T0
    local l1: Wrapper<T0>
    move_loc l0
    unpack Wrapper<T0>
    ret

// Function definition at index 18
#[borrow=0] public fun borrow$Wrapper$0<T0: drop>(l0: &Wrapper<T0>): &T0
    local l1: &Wrapper<T0>
    move_loc l0
    borrow_field Wrapper<T0>, _0
    ret

// Function definition at index 19
#[borrow_mut=0] public fun borrow_mut$Wrapper$0<T0: drop>(l0: &mut Wrapper<T0>): &mut T0
    local l1: &mut Wrapper<T0>
    move_loc l0
    mut_borrow_field Wrapper<T0>, _0
    ret

// Bytecode version v10
module 0x42::m2
use 0x42::m1
// Function definition at index 0
#[persistent] public fun try_nested_pair_unpack()
    local l0: m1::Wrapper<vector<u64>>
    local l1: m1::Pair
    local l2: m1::Wrapper<vector<u64>>
    local l3: m1::Pair
    local l4: vector<u64>
    local l5: bool
    local l6: u64
    ld_u64 5
    ld_false
    call m1::pack$Pair
    ld_const<vector<u64>> [42, 43]
    call m1::pack$Wrapper<vector<u64>>
    // @5
    st_loc l0
    st_loc l1
    move_loc l1
    move_loc l0
    call m1::pack$NestedPair<vector<u64>>
    // @10
    call m1::unpack$NestedPair<vector<u64>>
    st_loc l2
    st_loc l3
    move_loc l3
    call m1::unpack$Pair
    // @15
    move_loc l2
    call m1::unpack$Wrapper<vector<u64>>
    st_loc l4
    st_loc l5
    st_loc l6
    // @20
    move_loc l6
    ld_u64 5
    eq
    br_false l0
    branch l1
    // @25
l0: ld_u64 4
    abort
l1: move_loc l5
    ld_false
    eq
    // @30
    br_false l2
    branch l3
l2: ld_u64 5
    abort
l3: borrow_loc l4
    // @35
    ld_u64 1
    vec_borrow <u64>
    read_ref
    ld_u64 43
    eq
    // @40
    br_false l4
    branch l5
l4: ld_u64 6
    abort
l5: ret

// Function definition at index 1
#[persistent] public fun try_pack_unpack_pair()
    local l0: bool
    local l1: u64
    ld_u64 1
    ld_true
    call m1::pack$Pair
    call m1::unpack$Pair
    st_loc l0
    // @5
    st_loc l1
    move_loc l1
    ld_u64 1
    eq
    br_false l0
    // @10
    branch l1
l0: ld_u64 1
    abort
l1: move_loc l0
    ld_true
    // @15
    eq
    br_false l2
    branch l3
l2: ld_u64 2
    abort
    // @20
l3: ret

// Function definition at index 2
#[persistent] public fun try_pack_unpack_wrapper()
    ld_u64 100
    call m1::pack$Wrapper<u64>
    call m1::unpack$Wrapper<u64>
    ld_u64 100
    eq
    // @5
    br_false l0
    branch l1
l0: ld_u64 3
    abort
l1: ret

// Function definition at index 3
#[persistent] public fun try_pass_as_arg()
    ld_u64 88
    ld_true
    call m1::pack$Pair
    call use_as_param
    ret

// Function definition at index 4
#[persistent] public fun try_return_positional(): m1::Pair
    ld_u64 77
    ld_false
    call m1::pack$Pair
    ret

// Function definition at index 5
#[persistent] public fun try_unpack_from_return()
    local l0: bool
    local l1: u64
    call try_return_positional
    call m1::unpack$Pair
    st_loc l0
    st_loc l1
    move_loc l1
    // @5
    ld_u64 77
    eq
    br_false l0
    branch l1
l0: ld_u64 9
    // @10
    abort
l1: move_loc l0
    ld_false
    eq
    br_false l2
    // @15
    branch l3
l2: ld_u64 10
    abort
l3: ret

// Function definition at index 6
#[persistent] public fun try_vecwrap_unpack()
    local l0: vector<u64>
    ld_const<vector<u64>> [10, 20, 30]
    call m1::pack$VecWrap<u64>
    call m1::unpack$VecWrap<u64>
    st_loc l0
    borrow_loc l0
    // @5
    ld_u64 0
    vec_borrow <u64>
    read_ref
    ld_u64 10
    eq
    // @10
    br_false l0
    branch l1
l0: ld_u64 7
    abort
l1: borrow_loc l0
    // @15
    ld_u64 2
    vec_borrow <u64>
    read_ref
    ld_u64 30
    eq
    // @20
    br_false l2
    branch l3
l2: ld_u64 8
    abort
l3: ret

// Function definition at index 7
#[persistent] public fun use_as_param(l0: m1::Pair)
    local l1: bool
    local l2: u64
    move_loc l0
    call m1::unpack$Pair
    st_loc l1
    st_loc l2
    move_loc l2
    // @5
    ld_u64 88
    eq
    br_false l0
    branch l1
l0: ld_u64 11
    // @10
    abort
l1: move_loc l1
    ld_true
    eq
    br_false l2
    // @15
    branch l3
l2: ld_u64 12
    abort
l3: ret


============ bytecode verification succeeded ========
