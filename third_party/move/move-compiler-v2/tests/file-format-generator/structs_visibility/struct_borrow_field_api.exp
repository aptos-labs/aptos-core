
============ disassembled file-format ==================
// Bytecode version v10
module 0x42::m1
struct T<T0: drop + store> has copy + drop + store
  h: T0

struct S<T0: drop + store> has drop
  f: u64
  g: T<T0>

// Function definition at index 0
#[pack] public fun pack$T<T0: drop + store>(l0: T0): T<T0>
    local l1: T0
    move_loc l0
    pack T<T0>
    ret

// Function definition at index 1
#[unpack] public fun unpack$T<T0: drop + store>(l0: T<T0>): T0
    local l1: T<T0>
    move_loc l0
    unpack T<T0>
    ret

// Function definition at index 2
#[borrow] public fun borrow$T$0<T0: drop + store>(l0: &T<T0>): &T0
    local l1: &T<T0>
    move_loc l0
    borrow_field T<T0>, h
    ret

// Function definition at index 3
#[borrow_mut] public fun borrow_mut$T$0<T0: drop + store>(l0: &mut T<T0>): &mut T0
    local l1: &mut T<T0>
    move_loc l0
    mut_borrow_field T<T0>, h
    ret

// Function definition at index 4
#[pack] public fun pack$S<T0: drop + store>(l0: u64, l1: T<T0>): S<T0>
    local l2: u64
    local l3: T<T0>
    move_loc l0
    move_loc l1
    pack S<T0>
    ret

// Function definition at index 5
#[unpack] public fun unpack$S<T0: drop + store>(l0: S<T0>): (u64, T<T0>)
    local l1: S<T0>
    move_loc l0
    unpack S<T0>
    ret

// Function definition at index 6
#[borrow] public fun borrow$S$0<T0: drop + store>(l0: &S<T0>): &u64
    local l1: &S<T0>
    move_loc l0
    borrow_field S<T0>, f
    ret

// Function definition at index 7
#[borrow] public fun borrow$S$1<T0: drop + store>(l0: &S<T0>): &T<T0>
    local l1: &S<T0>
    move_loc l0
    borrow_field S<T0>, g
    ret

// Function definition at index 8
#[borrow_mut] public fun borrow_mut$S$0<T0: drop + store>(l0: &mut S<T0>): &mut u64
    local l1: &mut S<T0>
    move_loc l0
    mut_borrow_field S<T0>, f
    ret

// Function definition at index 9
#[borrow_mut] public fun borrow_mut$S$1<T0: drop + store>(l0: &mut S<T0>): &mut T<T0>
    local l1: &mut S<T0>
    move_loc l0
    mut_borrow_field S<T0>, g
    ret

// Bytecode version v10
module 0x42::m2
use 0x42::m1
// Function definition at index 0
#[persistent] public fun try_immut_and_mut_diff_fields()
    local l0: u64
    local l1: m1::T<u64>
    local l2: m1::S<u64>
    local l3: &mut u64
    ld_u64 30
    call m1::pack$T<u64>
    ld_u64 40
    st_loc l0
    st_loc l1
    // @5
    move_loc l0
    move_loc l1
    call m1::pack$S<u64>
    st_loc l2
    borrow_loc l2
    // @10
    call m1::borrow$S$0<u64>
    read_ref
    ld_u64 40
    eq
    br_false l0
    // @15
    branch l1
l0: ld_u64 9
    abort
l1: mut_borrow_loc l2
    call m1::borrow_mut$S$1<u64>
    // @20
    call m1::borrow_mut$T$0<u64>
    st_loc l3
    copy_loc l3
    read_ref
    ld_u64 1
    // @25
    add
    copy_loc l3
    write_ref
    move_loc l3
    read_ref
    // @30
    ld_u64 31
    eq
    br_false l2
    branch l3
l2: ld_u64 10
    // @35
    abort
l3: ret

// Function definition at index 1
#[persistent] public fun try_immut_borrow_fields()
    local l0: u64
    local l1: m1::T<u64>
    local l2: m1::S<u64>
    local l3: &u64
    ld_u64 100
    call m1::pack$T<u64>
    ld_u64 200
    st_loc l0
    st_loc l1
    // @5
    move_loc l0
    move_loc l1
    call m1::pack$S<u64>
    st_loc l2
    borrow_loc l2
    // @10
    call m1::borrow$S$0<u64>
    borrow_loc l2
    call m1::borrow$S$1<u64>
    call m1::borrow$T$0<u64>
    st_loc l3
    // @15
    read_ref
    ld_u64 200
    eq
    br_false l0
    branch l1
    // @20
l0: move_loc l3
    pop
    ld_u64 3
    abort
l1: move_loc l3
    // @25
    read_ref
    ld_u64 100
    eq
    br_false l2
    branch l3
    // @30
l2: ld_u64 4
    abort
l3: ret

// Function definition at index 2
#[persistent] public fun try_immut_from_mut()
    local l0: u64
    local l1: m1::T<u64>
    local l2: m1::S<u64>
    ld_u64 5
    call m1::pack$T<u64>
    ld_u64 6
    st_loc l0
    st_loc l1
    // @5
    move_loc l0
    move_loc l1
    call m1::pack$S<u64>
    st_loc l2
    mut_borrow_loc l2
    // @10
    freeze_ref
    call m1::borrow$S$0<u64>
    read_ref
    ld_u64 6
    eq
    // @15
    br_false l0
    branch l1
l0: ld_u64 5
    abort
l1: ret

// Function definition at index 3
#[persistent] public fun try_mut_borrow_seq()
    local l0: u64
    local l1: m1::T<u64>
    local l2: m1::S<u64>
    local l3: &mut u64
    local l4: &mut u64
    ld_u64 1
    call m1::pack$T<u64>
    ld_u64 2
    st_loc l0
    st_loc l1
    // @5
    move_loc l0
    move_loc l1
    call m1::pack$S<u64>
    st_loc l2
    mut_borrow_loc l2
    // @10
    call m1::borrow_mut$S$0<u64>
    st_loc l3
    copy_loc l3
    read_ref
    ld_u64 10
    // @15
    add
    move_loc l3
    write_ref
    mut_borrow_loc l2
    call m1::borrow_mut$S$1<u64>
    // @20
    call m1::borrow_mut$T$0<u64>
    st_loc l4
    copy_loc l4
    read_ref
    ld_u64 20
    // @25
    add
    move_loc l4
    write_ref
    borrow_loc l2
    call m1::borrow$S$0<u64>
    // @30
    read_ref
    ld_u64 12
    eq
    br_false l0
    branch l1
    // @35
l0: ld_u64 7
    abort
l1: borrow_loc l2
    call m1::borrow$S$1<u64>
    call m1::borrow$T$0<u64>
    // @40
    read_ref
    ld_u64 21
    eq
    br_false l2
    branch l3
    // @45
l2: ld_u64 8
    abort
l3: ret

// Function definition at index 4
#[persistent] public fun try_reborrow_same_field_seq()
    local l0: u64
    local l1: m1::T<u64>
    local l2: m1::S<u64>
    local l3: u64
    local l4: &mut u64
    local l5: &mut u64
    ld_u64 9
    call m1::pack$T<u64>
    ld_u64 8
    st_loc l0
    st_loc l1
    // @5
    move_loc l0
    move_loc l1
    call m1::pack$S<u64>
    st_loc l2
    mut_borrow_loc l2
    // @10
    call m1::borrow_mut$S$0<u64>
    ld_u64 88
    st_loc l3
    st_loc l4
    move_loc l3
    // @15
    move_loc l4
    write_ref
    mut_borrow_loc l2
    call m1::borrow_mut$S$0<u64>
    st_loc l5
    // @20
    copy_loc l5
    read_ref
    ld_u64 1
    add
    move_loc l5
    // @25
    write_ref
    borrow_loc l2
    call m1::borrow$S$0<u64>
    read_ref
    ld_u64 89
    // @30
    eq
    br_false l0
    branch l1
l0: ld_u64 11
    abort
    // @35
l1: ret

// Function definition at index 5
#[persistent] public fun try_unpack_ref()
    local l0: u64
    local l1: m1::T<u64>
    local l2: m1::S<u64>
    local l3: &m1::S<u64>
    local l4: &m1::T<u64>
    local l5: &m1::S<u64>
    local l6: &m1::T<u64>
    ld_u64 9
    call m1::pack$T<u64>
    ld_u64 8
    st_loc l0
    st_loc l1
    // @5
    move_loc l0
    move_loc l1
    call m1::pack$S<u64>
    st_loc l2
    borrow_loc l2
    // @10
    st_loc l3
    copy_loc l3
    call m1::borrow$S$0<u64>
    move_loc l3
    call m1::borrow$S$1<u64>
    // @15
    st_loc l4
    read_ref
    ld_u64 8
    eq
    br_false l0
    // @20
    branch l1
l0: move_loc l4
    pop
    ld_u64 11
    abort
    // @25
l1: move_loc l4
    call m1::borrow$T$0<u64>
    read_ref
    ld_u64 9
    eq
    // @30
    br_false l2
    branch l3
l2: ld_u64 12
    abort
l3: borrow_loc l2
    // @35
    call m1::borrow$S$1<u64>
    call m1::borrow$T$0<u64>
    read_ref
    ld_u64 9
    eq
    // @40
    br_false l4
    branch l5
l4: ld_u64 14
    abort
l5: borrow_loc l2
    // @45
    call m1::borrow$S$1<u64>
    call m1::borrow$T$0<u64>
    read_ref
    ld_u64 9
    eq
    // @50
    br_false l6
    branch l7
l6: ld_u64 15
    abort
l7: borrow_loc l2
    // @55
    st_loc l5
    copy_loc l5
    call m1::borrow$S$0<u64>
    move_loc l5
    call m1::borrow$S$1<u64>
    // @60
    st_loc l6
    move_loc l6
    pop
    read_ref
    ld_u64 8
    // @65
    eq
    br_false l8
    branch l9
l8: ld_u64 15
    abort
    // @70
l9: ret


============ bytecode verification succeeded ========
