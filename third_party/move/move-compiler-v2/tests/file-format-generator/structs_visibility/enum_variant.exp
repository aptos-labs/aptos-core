
============ disassembled file-format ==================
// Bytecode version v10
module 0x42::m
friend 0x42::m2
enum Data has drop
  V1
    x: u64
  V2
    x: u64
    y: bool
  V3

enum Data2 has drop
  V1
    x: u64
  V2
    y: u64
    x: u64
  V3

enum Data3 has drop
  V1
    d1: Data
  V2
    d1: Data
    d2: Data2
  V3
    d1: Data
    d2: Data2
    d3: V<u64>
  V4
    d1: Data
    d2: Data2
    d3: V<u64>
    d4: vector<u64>

struct V<T0> has drop
  x: vector<T0>

// Function definition at index 0
#[test_variant=0] friend fun test_variant$Data$V1(l0: &Data): bool
    local l1: &Data
    move_loc l0
    test_variant Data, V1
    ret

// Function definition at index 1
#[test_variant=1] friend fun test_variant$Data$V2(l0: &Data): bool
    local l1: &Data
    move_loc l0
    test_variant Data, V2
    ret

// Function definition at index 2
#[test_variant=2] friend fun test_variant$Data$V3(l0: &Data): bool
    local l1: &Data
    move_loc l0
    test_variant Data, V3
    ret

// Function definition at index 3
#[pack_variant=0] friend fun pack$Data$V1(l0: u64): Data
    local l1: u64
    move_loc l0
    pack_variant Data, V1
    ret

// Function definition at index 4
#[pack_variant=1] friend fun pack$Data$V2(l0: u64, l1: bool): Data
    local l2: u64
    local l3: bool
    move_loc l0
    move_loc l1
    pack_variant Data, V2
    ret

// Function definition at index 5
#[pack_variant=2] friend fun pack$Data$V3(): Data
    pack_variant Data, V3
    ret

// Function definition at index 6
#[unpack_variant=0] friend fun unpack$Data$V1(l0: Data): u64
    local l1: Data
    move_loc l0
    unpack_variant Data, V1
    ret

// Function definition at index 7
#[unpack_variant=1] friend fun unpack$Data$V2(l0: Data): (u64, bool)
    local l1: Data
    move_loc l0
    unpack_variant Data, V2
    ret

// Function definition at index 8
#[unpack_variant=2] friend fun unpack$Data$V3(l0: Data)
    local l1: Data
    move_loc l0
    unpack_variant Data, V3
    ret

// Function definition at index 9
#[borrow=0] friend fun borrow$Data$0$0(l0: &Data): &u64
    local l1: &Data
    move_loc l0
    borrow_variant_field Data, V1::x, V2::x
    ret

// Function definition at index 10
#[borrow=1] friend fun borrow$Data$1$1(l0: &Data): &bool
    local l1: &Data
    move_loc l0
    borrow_variant_field Data, V2::y
    ret

// Function definition at index 11
#[borrow_mut=0] friend fun borrow_mut$Data$0$0(l0: &mut Data): &mut u64
    local l1: &mut Data
    move_loc l0
    mut_borrow_variant_field Data, V1::x, V2::x
    ret

// Function definition at index 12
#[borrow_mut=1] friend fun borrow_mut$Data$1$1(l0: &mut Data): &mut bool
    local l1: &mut Data
    move_loc l0
    mut_borrow_variant_field Data, V2::y
    ret

// Function definition at index 13
#[test_variant=0] friend fun test_variant$Data2$V1(l0: &Data2): bool
    local l1: &Data2
    move_loc l0
    test_variant Data2, V1
    ret

// Function definition at index 14
#[test_variant=1] friend fun test_variant$Data2$V2(l0: &Data2): bool
    local l1: &Data2
    move_loc l0
    test_variant Data2, V2
    ret

// Function definition at index 15
#[test_variant=2] friend fun test_variant$Data2$V3(l0: &Data2): bool
    local l1: &Data2
    move_loc l0
    test_variant Data2, V3
    ret

// Function definition at index 16
#[pack_variant=0] friend fun pack$Data2$V1(l0: u64): Data2
    local l1: u64
    move_loc l0
    pack_variant Data2, V1
    ret

// Function definition at index 17
#[pack_variant=1] friend fun pack$Data2$V2(l0: u64, l1: u64): Data2
    local l2: u64
    local l3: u64
    move_loc l0
    move_loc l1
    pack_variant Data2, V2
    ret

// Function definition at index 18
#[pack_variant=2] friend fun pack$Data2$V3(): Data2
    pack_variant Data2, V3
    ret

// Function definition at index 19
#[unpack_variant=0] friend fun unpack$Data2$V1(l0: Data2): u64
    local l1: Data2
    move_loc l0
    unpack_variant Data2, V1
    ret

// Function definition at index 20
#[unpack_variant=1] friend fun unpack$Data2$V2(l0: Data2): (u64, u64)
    local l1: Data2
    move_loc l0
    unpack_variant Data2, V2
    ret

// Function definition at index 21
#[unpack_variant=2] friend fun unpack$Data2$V3(l0: Data2)
    local l1: Data2
    move_loc l0
    unpack_variant Data2, V3
    ret

// Function definition at index 22
#[borrow=0] friend fun borrow$Data2$0$0(l0: &Data2): &u64
    local l1: &Data2
    move_loc l0
    borrow_variant_field Data2, V1::x, V2::y
    ret

// Function definition at index 23
#[borrow=1] friend fun borrow$Data2$1$1(l0: &Data2): &u64
    local l1: &Data2
    move_loc l0
    borrow_variant_field Data2, V2::x
    ret

// Function definition at index 24
#[borrow_mut=0] friend fun borrow_mut$Data2$0$0(l0: &mut Data2): &mut u64
    local l1: &mut Data2
    move_loc l0
    mut_borrow_variant_field Data2, V1::x, V2::y
    ret

// Function definition at index 25
#[borrow_mut=1] friend fun borrow_mut$Data2$1$1(l0: &mut Data2): &mut u64
    local l1: &mut Data2
    move_loc l0
    mut_borrow_variant_field Data2, V2::x
    ret

// Function definition at index 26
#[test_variant=0] friend fun test_variant$Data3$V1(l0: &Data3): bool
    local l1: &Data3
    move_loc l0
    test_variant Data3, V1
    ret

// Function definition at index 27
#[test_variant=1] friend fun test_variant$Data3$V2(l0: &Data3): bool
    local l1: &Data3
    move_loc l0
    test_variant Data3, V2
    ret

// Function definition at index 28
#[test_variant=2] friend fun test_variant$Data3$V3(l0: &Data3): bool
    local l1: &Data3
    move_loc l0
    test_variant Data3, V3
    ret

// Function definition at index 29
#[test_variant=3] friend fun test_variant$Data3$V4(l0: &Data3): bool
    local l1: &Data3
    move_loc l0
    test_variant Data3, V4
    ret

// Function definition at index 30
#[pack_variant=0] friend fun pack$Data3$V1(l0: Data): Data3
    local l1: Data
    move_loc l0
    pack_variant Data3, V1
    ret

// Function definition at index 31
#[pack_variant=1] friend fun pack$Data3$V2(l0: Data, l1: Data2): Data3
    local l2: Data
    local l3: Data2
    move_loc l0
    move_loc l1
    pack_variant Data3, V2
    ret

// Function definition at index 32
#[pack_variant=2] friend fun pack$Data3$V3(l0: Data, l1: Data2, l2: V<u64>): Data3
    local l3: Data
    local l4: Data2
    local l5: V<u64>
    move_loc l0
    move_loc l1
    move_loc l2
    pack_variant Data3, V3
    ret

// Function definition at index 33
#[pack_variant=3] friend fun pack$Data3$V4(l0: Data, l1: Data2, l2: V<u64>, l3: vector<u64>): Data3
    local l4: Data
    local l5: Data2
    local l6: V<u64>
    local l7: vector<u64>
    move_loc l0
    move_loc l1
    move_loc l2
    move_loc l3
    pack_variant Data3, V4
    // @5
    ret

// Function definition at index 34
#[unpack_variant=0] friend fun unpack$Data3$V1(l0: Data3): Data
    local l1: Data3
    move_loc l0
    unpack_variant Data3, V1
    ret

// Function definition at index 35
#[unpack_variant=1] friend fun unpack$Data3$V2(l0: Data3): (Data, Data2)
    local l1: Data3
    move_loc l0
    unpack_variant Data3, V2
    ret

// Function definition at index 36
#[unpack_variant=2] friend fun unpack$Data3$V3(l0: Data3): (Data, Data2, V<u64>)
    local l1: Data3
    move_loc l0
    unpack_variant Data3, V3
    ret

// Function definition at index 37
#[unpack_variant=3] friend fun unpack$Data3$V4(l0: Data3): (Data, Data2, V<u64>, vector<u64>)
    local l1: Data3
    move_loc l0
    unpack_variant Data3, V4
    ret

// Function definition at index 38
#[borrow=0] friend fun borrow$Data3$0$0(l0: &Data3): &Data
    local l1: &Data3
    move_loc l0
    borrow_variant_field Data3, V1::d1, V2::d1, V3::d1, V4::d1
    ret

// Function definition at index 39
#[borrow=1] friend fun borrow$Data3$1$1(l0: &Data3): &Data2
    local l1: &Data3
    move_loc l0
    borrow_variant_field Data3, V2::d2, V3::d2, V4::d2
    ret

// Function definition at index 40
#[borrow=2] friend fun borrow$Data3$2$2(l0: &Data3): &V<u64>
    local l1: &Data3
    move_loc l0
    borrow_variant_field Data3, V3::d3, V4::d3
    ret

// Function definition at index 41
#[borrow=3] friend fun borrow$Data3$3$3(l0: &Data3): &vector<u64>
    local l1: &Data3
    move_loc l0
    borrow_variant_field Data3, V4::d4
    ret

// Function definition at index 42
#[borrow_mut=0] friend fun borrow_mut$Data3$0$0(l0: &mut Data3): &mut Data
    local l1: &mut Data3
    move_loc l0
    mut_borrow_variant_field Data3, V1::d1, V2::d1, V3::d1, V4::d1
    ret

// Function definition at index 43
#[borrow_mut=1] friend fun borrow_mut$Data3$1$1(l0: &mut Data3): &mut Data2
    local l1: &mut Data3
    move_loc l0
    mut_borrow_variant_field Data3, V2::d2, V3::d2, V4::d2
    ret

// Function definition at index 44
#[borrow_mut=2] friend fun borrow_mut$Data3$2$2(l0: &mut Data3): &mut V<u64>
    local l1: &mut Data3
    move_loc l0
    mut_borrow_variant_field Data3, V3::d3, V4::d3
    ret

// Function definition at index 45
#[borrow_mut=3] friend fun borrow_mut$Data3$3$3(l0: &mut Data3): &mut vector<u64>
    local l1: &mut Data3
    move_loc l0
    mut_borrow_variant_field Data3, V4::d4
    ret

// Function definition at index 46
#[pack] friend fun pack$V<T0>(l0: vector<T0>): V<T0>
    local l1: vector<T0>
    move_loc l0
    pack V<T0>
    ret

// Function definition at index 47
#[unpack] friend fun unpack$V<T0>(l0: V<T0>): vector<T0>
    local l1: V<T0>
    move_loc l0
    unpack V<T0>
    ret

// Function definition at index 48
#[borrow=0] friend fun borrow$V$0<T0>(l0: &V<T0>): &vector<T0>
    local l1: &V<T0>
    move_loc l0
    borrow_field V<T0>, x
    ret

// Function definition at index 49
#[borrow_mut=0] friend fun borrow_mut$V$0<T0>(l0: &mut V<T0>): &mut vector<T0>
    local l1: &mut V<T0>
    move_loc l0
    mut_borrow_field V<T0>, x
    ret

// Bytecode version v10
module 0x42::m2
use 0x42::m
// Function definition at index 0
fun test_v1(): bool
    local l0: m::Data
    local l1: &m::Data
    local l2: bool
    ld_u64 43
    call m::pack$Data$V1
    st_loc l0
    borrow_loc l0
    call m::test_variant$Data$V1
    // @5
    br_false l0
    borrow_loc l0
    st_loc l1
    copy_loc l1
    call m::test_variant$Data$V1
    // @10
    st_loc l2
    copy_loc l2
    br_false l1
    move_loc l1
    pop
    // @15
    branch l2
l1: move_loc l1
    call m::test_variant$Data$V3
    st_loc l2
    copy_loc l2
    // @20
    br_false l2
    branch l2
l2: branch l3
l0: ld_false
    st_loc l2
    // @25
l3: move_loc l2
    ret

// Function definition at index 1
#[persistent] public fun test_v1_mut_borrow()
    local l0: m::Data
    local l1: u64
    local l2: &mut u64
    ld_u64 43
    call m::pack$Data$V1
    st_loc l0
    mut_borrow_loc l0
    call m::borrow_mut$Data$0$0
    // @5
    ld_u64 44
    st_loc l1
    st_loc l2
    move_loc l1
    move_loc l2
    // @10
    write_ref
    borrow_loc l0
    call m::borrow$Data$0$0
    read_ref
    ld_u64 44
    // @15
    eq
    br_false l0
    branch l1
l0: ld_u64 1
    abort
    // @20
l1: ret

// Function definition at index 2
fun test_v1v3(): bool
    local l0: m::Data
    local l1: &m::Data
    local l2: bool
    local l3: m::Data
    local l4: &m::Data
    local l5: bool
    ld_u64 43
    call m::pack$Data$V1
    st_loc l0
    borrow_loc l0
    st_loc l1
    // @5
    copy_loc l1
    call m::test_variant$Data$V1
    st_loc l2
    copy_loc l2
    br_false l0
    // @10
    move_loc l1
    pop
    branch l1
l0: move_loc l1
    call m::test_variant$Data$V3
    // @15
    st_loc l2
    copy_loc l2
    br_false l1
    branch l1
l1: call m::pack$Data$V3
    // @20
    st_loc l3
    move_loc l2
    br_false l2
    borrow_loc l3
    st_loc l4
    // @25
    copy_loc l4
    call m::test_variant$Data$V1
    st_loc l5
    copy_loc l5
    br_false l3
    // @30
    move_loc l4
    pop
    branch l4
l3: move_loc l4
    call m::test_variant$Data$V3
    // @35
    st_loc l5
    copy_loc l5
    br_false l4
    branch l4
l4: branch l5
    // @40
l2: ld_false
    st_loc l5
l5: move_loc l5
    ret

// Function definition at index 3
fun test_v1v3_ref(): bool
    local l0: m::Data
    local l1: &m::Data
    local l2: bool
    local l3: m::Data
    local l4: &mut m::Data
    local l5: bool
    ld_u64 43
    call m::pack$Data$V1
    st_loc l0
    borrow_loc l0
    st_loc l1
    // @5
    copy_loc l1
    call m::test_variant$Data$V1
    st_loc l2
    copy_loc l2
    br_false l0
    // @10
    move_loc l1
    pop
    branch l1
l0: move_loc l1
    call m::test_variant$Data$V3
    // @15
    st_loc l2
    copy_loc l2
    br_false l1
    branch l1
l1: call m::pack$Data$V3
    // @20
    st_loc l3
    move_loc l2
    br_false l2
    mut_borrow_loc l3
    st_loc l4
    // @25
    copy_loc l4
    freeze_ref
    call m::test_variant$Data$V1
    st_loc l5
    copy_loc l5
    // @30
    br_false l3
    move_loc l4
    pop
    branch l4
l3: move_loc l4
    // @35
    freeze_ref
    call m::test_variant$Data$V3
    st_loc l5
    copy_loc l5
    br_false l4
    // @40
    branch l4
l4: branch l5
l2: ld_false
    st_loc l5
l5: move_loc l5
    // @45
    ret

// Function definition at index 4
#[persistent] public fun test_v2_mut_borrow_2()
    local l0: m::Data2
    local l1: &mut m::Data2
    local l2: &mut u64
    local l3: &m::Data2
    local l4: &m::Data2
    local l5: &u64
    ld_u64 43
    ld_u64 44
    call m::pack$Data2$V2
    st_loc l0
    mut_borrow_loc l0
    // @5
    st_loc l1
    copy_loc l1
    freeze_ref
    call m::test_variant$Data2$V2
    br_true l0
    // @10
    branch l1
l0: move_loc l1
    call m::borrow_mut$Data2$1$1
    st_loc l2
    branch l2
    // @15
l1: copy_loc l1
    freeze_ref
    st_loc l3
    copy_loc l3
    call m::test_variant$Data2$V1
    // @20
    br_true l3
    move_loc l3
    pop
    move_loc l1
    pop
    // @25
    ld_u64 14566554180833181697
    abort
l3: move_loc l3
    pop
    move_loc l1
    // @30
    call m::borrow_mut$Data2$0$0
    st_loc l2
l2: ld_u64 45
    move_loc l2
    write_ref
    // @35
    borrow_loc l0
    st_loc l4
    copy_loc l4
    call m::test_variant$Data2$V2
    br_true l4
    // @40
    branch l5
l4: move_loc l4
    call m::borrow$Data2$1$1
    st_loc l5
    branch l6
    // @45
l5: copy_loc l4
    call m::test_variant$Data2$V1
    br_true l7
    move_loc l4
    pop
    // @50
    ld_u64 14566554180833181697
    abort
l7: move_loc l4
    call m::borrow$Data2$0$0
    st_loc l5
    // @55
l6: move_loc l5
    read_ref
    ld_u64 45
    eq
    br_false l8
    // @60
    branch l9
l8: ld_u64 1
    abort
l9: ret


============ bytecode verification succeeded ========
