
============ disassembled file-format ==================
// Bytecode version v10
module 0x42::m1
struct T<T0: drop + store> has copy + drop + store
  h: T0

struct S<T0: drop + store> has drop
  f: u64
  g: T<T0>

// Function definition at index 0
#[pack] public fun pack$T<T0: drop + store>(l0: T0): T<T0>
    local l1: T0
    move_loc l0
    pack T<T0>
    ret

// Function definition at index 1
#[unpack] public fun unpack$T<T0: drop + store>(l0: T<T0>): T0
    local l1: T<T0>
    move_loc l0
    unpack T<T0>
    ret

// Function definition at index 2
#[borrow=0] public fun borrow$T$0<T0: drop + store>(l0: &T<T0>): &T0
    local l1: &T<T0>
    move_loc l0
    borrow_field T<T0>, h
    ret

// Function definition at index 3
#[borrow_mut=0] public fun borrow_mut$T$0<T0: drop + store>(l0: &mut T<T0>): &mut T0
    local l1: &mut T<T0>
    move_loc l0
    mut_borrow_field T<T0>, h
    ret

// Function definition at index 4
#[pack] public fun pack$S<T0: drop + store>(l0: u64, l1: T<T0>): S<T0>
    local l2: u64
    local l3: T<T0>
    move_loc l0
    move_loc l1
    pack S<T0>
    ret

// Function definition at index 5
#[unpack] public fun unpack$S<T0: drop + store>(l0: S<T0>): (u64, T<T0>)
    local l1: S<T0>
    move_loc l0
    unpack S<T0>
    ret

// Function definition at index 6
#[borrow=0] public fun borrow$S$0<T0: drop + store>(l0: &S<T0>): &u64
    local l1: &S<T0>
    move_loc l0
    borrow_field S<T0>, f
    ret

// Function definition at index 7
#[borrow=1] public fun borrow$S$1<T0: drop + store>(l0: &S<T0>): &T<T0>
    local l1: &S<T0>
    move_loc l0
    borrow_field S<T0>, g
    ret

// Function definition at index 8
#[borrow_mut=0] public fun borrow_mut$S$0<T0: drop + store>(l0: &mut S<T0>): &mut u64
    local l1: &mut S<T0>
    move_loc l0
    mut_borrow_field S<T0>, f
    ret

// Function definition at index 9
#[borrow_mut=1] public fun borrow_mut$S$1<T0: drop + store>(l0: &mut S<T0>): &mut T<T0>
    local l1: &mut S<T0>
    move_loc l0
    mut_borrow_field S<T0>, g
    ret

// Bytecode version v10
module 0x42::m2
use 0x42::m1
// Function definition at index 0
#[persistent] public fun try_immut_and_mut_diff_fields()
    local l0: m1::T<u64>
    local l1: m1::S<u64>
    local l2: &mut u64
    ld_u64 30
    call m1::pack$T<u64>
    st_loc l0
    ld_u64 40
    move_loc l0
    // @5
    call m1::pack$S<u64>
    st_loc l1
    borrow_loc l1
    call m1::borrow$S$0<u64>
    read_ref
    // @10
    ld_u64 40
    eq
    br_false l0
    mut_borrow_loc l1
    call m1::borrow_mut$S$1<u64>
    // @15
    call m1::borrow_mut$T$0<u64>
    st_loc l2
    copy_loc l2
    read_ref
    ld_u64 1
    // @20
    add
    copy_loc l2
    write_ref
    move_loc l2
    read_ref
    // @25
    ld_u64 31
    eq
    br_false l1
    ret
l1: ld_u64 10
    // @30
    abort
l0: ld_u64 9
    abort

// Function definition at index 1
#[persistent] public fun try_immut_borrow_fields()
    local l0: m1::T<u64>
    local l1: m1::S<u64>
    local l2: &u64
    ld_u64 100
    call m1::pack$T<u64>
    st_loc l0
    ld_u64 200
    move_loc l0
    // @5
    call m1::pack$S<u64>
    st_loc l1
    borrow_loc l1
    call m1::borrow$S$0<u64>
    borrow_loc l1
    // @10
    call m1::borrow$S$1<u64>
    call m1::borrow$T$0<u64>
    st_loc l2
    read_ref
    ld_u64 200
    // @15
    eq
    br_false l0
    move_loc l2
    read_ref
    ld_u64 100
    // @20
    eq
    br_false l1
    ret
l1: ld_u64 4
    abort
    // @25
l0: move_loc l2
    pop
    ld_u64 3
    abort

// Function definition at index 2
#[persistent] public fun try_immut_from_mut()
    local l0: m1::T<u64>
    local l1: m1::S<u64>
    ld_u64 5
    call m1::pack$T<u64>
    st_loc l0
    ld_u64 6
    move_loc l0
    // @5
    call m1::pack$S<u64>
    st_loc l1
    mut_borrow_loc l1
    freeze_ref
    call m1::borrow$S$0<u64>
    // @10
    read_ref
    ld_u64 6
    eq
    br_false l0
    ret
    // @15
l0: ld_u64 5
    abort

// Function definition at index 3
#[persistent] public fun try_mut_borrow_seq()
    local l0: m1::T<u64>
    local l1: m1::S<u64>
    local l2: &mut u64
    ld_u64 1
    call m1::pack$T<u64>
    st_loc l0
    ld_u64 2
    move_loc l0
    // @5
    call m1::pack$S<u64>
    st_loc l1
    mut_borrow_loc l1
    call m1::borrow_mut$S$0<u64>
    st_loc l2
    // @10
    copy_loc l2
    read_ref
    ld_u64 10
    add
    move_loc l2
    // @15
    write_ref
    mut_borrow_loc l1
    call m1::borrow_mut$S$1<u64>
    call m1::borrow_mut$T$0<u64>
    st_loc l2
    // @20
    copy_loc l2
    read_ref
    ld_u64 20
    add
    move_loc l2
    // @25
    write_ref
    borrow_loc l1
    call m1::borrow$S$0<u64>
    read_ref
    ld_u64 12
    // @30
    eq
    br_false l0
    borrow_loc l1
    call m1::borrow$S$1<u64>
    call m1::borrow$T$0<u64>
    // @35
    read_ref
    ld_u64 21
    eq
    br_false l1
    ret
    // @40
l1: ld_u64 8
    abort
l0: ld_u64 7
    abort

// Function definition at index 4
#[persistent] public fun try_reborrow_same_field_seq()
    local l0: m1::T<u64>
    local l1: m1::S<u64>
    local l2: u64
    local l3: &mut u64
    ld_u64 9
    call m1::pack$T<u64>
    st_loc l0
    ld_u64 8
    move_loc l0
    // @5
    call m1::pack$S<u64>
    st_loc l1
    mut_borrow_loc l1
    call m1::borrow_mut$S$0<u64>
    st_loc l3
    // @10
    ld_u64 88
    move_loc l3
    write_ref
    mut_borrow_loc l1
    call m1::borrow_mut$S$0<u64>
    // @15
    st_loc l3
    copy_loc l3
    read_ref
    ld_u64 1
    add
    // @20
    move_loc l3
    write_ref
    borrow_loc l1
    call m1::borrow$S$0<u64>
    read_ref
    // @25
    ld_u64 89
    eq
    br_false l0
    ret
l0: ld_u64 11
    // @30
    abort

// Function definition at index 5
#[persistent] public fun try_unpack_ref()
    local l0: m1::T<u64>
    local l1: m1::S<u64>
    local l2: &m1::S<u64>
    local l3: &m1::T<u64>
    local l4: &m1::T<u64>
    ld_u64 9
    call m1::pack$T<u64>
    st_loc l0
    ld_u64 8
    move_loc l0
    // @5
    call m1::pack$S<u64>
    st_loc l1
    borrow_loc l1
    st_loc l2
    copy_loc l2
    // @10
    call m1::borrow$S$0<u64>
    move_loc l2
    call m1::borrow$S$1<u64>
    st_loc l3
    read_ref
    // @15
    ld_u64 8
    eq
    br_false l0
    move_loc l3
    call m1::borrow$T$0<u64>
    // @20
    read_ref
    ld_u64 9
    eq
    br_false l1
    borrow_loc l1
    // @25
    call m1::borrow$S$1<u64>
    call m1::borrow$T$0<u64>
    read_ref
    ld_u64 9
    eq
    // @30
    br_false l2
    borrow_loc l1
    call m1::borrow$S$1<u64>
    call m1::borrow$T$0<u64>
    read_ref
    // @35
    ld_u64 9
    eq
    br_false l3
    borrow_loc l1
    st_loc l2
    // @40
    copy_loc l2
    call m1::borrow$S$0<u64>
    move_loc l2
    call m1::borrow$S$1<u64>
    pop
    // @45
    read_ref
    ld_u64 8
    eq
    br_false l4
    ret
    // @50
l4: ld_u64 15
    abort
l3: ld_u64 15
    abort
l2: ld_u64 14
    // @55
    abort
l1: ld_u64 12
    abort
l0: move_loc l3
    pop
    // @60
    ld_u64 11
    abort


============ bytecode verification succeeded ========
