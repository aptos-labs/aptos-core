
============ disassembled file-format ==================
// Bytecode version v10
module 0xc0ffee::m
friend 0xc0ffee::n
friend 0xc0ffee::n2
friend 0xc0ffee::n3
friend 0xc0ffee::n4
friend 0xc0ffee::n5
friend 0xc0ffee::n6
friend 0xc0ffee::n7
enum Wrapper has drop
  V1
    _0: u64
  V2
    _0: u64

// Function definition at index 0
#[test_variant] friend fun test_variant$Wrapper$V1(l0: &Wrapper): bool
    local l1: &Wrapper
    move_loc l0
    test_variant Wrapper, V1
    ret

// Function definition at index 1
#[test_variant] friend fun test_variant$Wrapper$V2(l0: &Wrapper): bool
    local l1: &Wrapper
    move_loc l0
    test_variant Wrapper, V2
    ret

// Function definition at index 2
#[pack_variant] friend fun pack$Wrapper$V1(l0: u64): Wrapper
    local l1: u64
    move_loc l0
    pack_variant Wrapper, V1
    ret

// Function definition at index 3
#[pack_variant] friend fun pack$Wrapper$V2(l0: u64): Wrapper
    local l1: u64
    move_loc l0
    pack_variant Wrapper, V2
    ret

// Function definition at index 4
#[unpack_variant] friend fun unpack$Wrapper$V1(l0: Wrapper): u64
    local l1: Wrapper
    move_loc l0
    unpack_variant Wrapper, V1
    ret

// Function definition at index 5
#[unpack_variant] friend fun unpack$Wrapper$V2(l0: Wrapper): u64
    local l1: Wrapper
    move_loc l0
    unpack_variant Wrapper, V2
    ret

// Function definition at index 6
#[borrow] friend fun borrow$Wrapper$0$0(l0: &Wrapper): &u64
    local l1: &Wrapper
    move_loc l0
    borrow_variant_field Wrapper, V1::_0, V2::_0
    ret

// Function definition at index 7
#[borrow_mut] friend fun borrow_mut$Wrapper$0$0(l0: &mut Wrapper): &mut u64
    local l1: &mut Wrapper
    move_loc l0
    mut_borrow_variant_field Wrapper, V1::_0, V2::_0
    ret

// Function definition at index 8
#[persistent] public fun make(l0: u64): Wrapper
    move_loc l0
    pack_variant Wrapper, V1
    ret

// Bytecode version v10
module 0xc0ffee::n
use 0xc0ffee::m
// Function definition at index 0
fun test()
    local l0: m::Wrapper
    ld_u64 22
    call m::make
    st_loc l0
    borrow_loc l0
    call m::borrow$Wrapper$0$0
    // @5
    read_ref
    ld_u64 22
    eq
    br_false l0
    branch l1
    // @10
l0: ld_u64 1
    abort
l1: ret

// Bytecode version v10
module 0xc0ffee::n2
use 0xc0ffee::m
// Function definition at index 0
fun test_pack()
    ld_u64 22
    call m::pack$Wrapper$V1
    pop
    ret

// Bytecode version v10
module 0xc0ffee::n3
use 0xc0ffee::m
// Function definition at index 0
fun test_unpack(l0: m::Wrapper)
    move_loc l0
    call m::unpack$Wrapper$V1
    pop
    ret

// Bytecode version v10
module 0xc0ffee::n4
use 0xc0ffee::m
// Function definition at index 0
fun test_select_variant(l0: m::Wrapper): u64
    borrow_loc l0
    call m::borrow$Wrapper$0$0
    read_ref
    ret

// Bytecode version v10
module 0xc0ffee::n5
use 0xc0ffee::m
// Function definition at index 0
fun test_test_variant(l0: m::Wrapper): bool
    borrow_loc l0
    call m::test_variant$Wrapper$V1
    ret

// Bytecode version v10
module 0xc0ffee::n6
use 0xc0ffee::m
// Function definition at index 0
fun test_test_variant_immutable_borrow(l0: &m::Wrapper): bool
    move_loc l0
    call m::test_variant$Wrapper$V1
    ret

// Function definition at index 1
fun test_test_variant_mut_borrow(l0: &mut m::Wrapper): bool
    move_loc l0
    freeze_ref
    call m::test_variant$Wrapper$V1
    ret

// Bytecode version v10
module 0xc0ffee::n7
use 0xc0ffee::m
// Function definition at index 0
fun test_match(l0: m::Wrapper): bool
    local l1: &m::Wrapper
    local l2: bool
    borrow_loc l0
    st_loc l1
    copy_loc l1
    call m::test_variant$Wrapper$V1
    br_false l0
    // @5
    move_loc l1
    pop
    move_loc l0
    call m::unpack$Wrapper$V1
    ld_true
    // @10
    st_loc l2
    pop
    branch l1
l0: move_loc l1
    call m::test_variant$Wrapper$V2
    // @15
    br_false l2
    move_loc l0
    call m::unpack$Wrapper$V2
    ld_false
    st_loc l2
    // @20
    pop
    branch l1
l2: ld_u64 14566554180833181697
    abort
l1: move_loc l2
    // @25
    ret

// Function definition at index 1
fun test_match_mut_borrow(l0: &mut m::Wrapper): bool
    local l1: bool
    copy_loc l0
    freeze_ref
    call m::test_variant$Wrapper$V1
    br_false l0
    move_loc l0
    // @5
    pop
    ld_true
    st_loc l1
    branch l1
l0: move_loc l0
    // @10
    freeze_ref
    call m::test_variant$Wrapper$V2
    br_false l2
    ld_false
    st_loc l1
    // @15
    branch l1
l2: ld_u64 14566554180833181697
    abort
l1: move_loc l1
    ret


============ bytecode verification succeeded ========
