
============ disassembled file-format ==================
// Bytecode version v10
module 0x42::m
friend 0x42::m2
enum Data has drop
  V1
    x: u64
  V2
    x: u64
    y: bool
  V3

enum Data2<T0, T1> has drop
  V1
    x: T0
  V2
    y: u64
    x: T1
  V3

// Function definition at index 0
#[test_variant] friend fun test_variant$Data$V1(l0: &Data): bool
    local l1: &Data
    move_loc l0
    test_variant Data, V1
    ret

// Function definition at index 1
#[test_variant] friend fun test_variant$Data$V2(l0: &Data): bool
    local l1: &Data
    move_loc l0
    test_variant Data, V2
    ret

// Function definition at index 2
#[test_variant] friend fun test_variant$Data$V3(l0: &Data): bool
    local l1: &Data
    move_loc l0
    test_variant Data, V3
    ret

// Function definition at index 3
#[pack_variant] friend fun pack$Data$V1(l0: u64): Data
    local l1: u64
    move_loc l0
    pack_variant Data, V1
    ret

// Function definition at index 4
#[pack_variant] friend fun pack$Data$V2(l0: u64, l1: bool): Data
    local l2: u64
    local l3: bool
    move_loc l0
    move_loc l1
    pack_variant Data, V2
    ret

// Function definition at index 5
#[pack_variant] friend fun pack$Data$V3(): Data
    pack_variant Data, V3
    ret

// Function definition at index 6
#[unpack_variant] friend fun unpack$Data$V1(l0: Data): u64
    local l1: Data
    move_loc l0
    unpack_variant Data, V1
    ret

// Function definition at index 7
#[unpack_variant] friend fun unpack$Data$V2(l0: Data): (u64, bool)
    local l1: Data
    move_loc l0
    unpack_variant Data, V2
    ret

// Function definition at index 8
#[unpack_variant] friend fun unpack$Data$V3(l0: Data)
    local l1: Data
    move_loc l0
    unpack_variant Data, V3
    ret

// Function definition at index 9
#[borrow] friend fun borrow$Data$0$0(l0: &Data): &u64
    local l1: &Data
    move_loc l0
    borrow_variant_field Data, V1::x, V2::x
    ret

// Function definition at index 10
#[borrow] friend fun borrow$Data$1$1(l0: &Data): &bool
    local l1: &Data
    move_loc l0
    borrow_variant_field Data, V2::y
    ret

// Function definition at index 11
#[borrow_mut] friend fun borrow_mut$Data$0$0(l0: &mut Data): &mut u64
    local l1: &mut Data
    move_loc l0
    mut_borrow_variant_field Data, V1::x, V2::x
    ret

// Function definition at index 12
#[borrow_mut] friend fun borrow_mut$Data$1$1(l0: &mut Data): &mut bool
    local l1: &mut Data
    move_loc l0
    mut_borrow_variant_field Data, V2::y
    ret

// Function definition at index 13
#[test_variant] friend fun test_variant$Data2$V1<T0, T1>(l0: &Data2<T0, T1>): bool
    local l1: &Data2<T0, T1>
    move_loc l0
    test_variant Data2<T0, T1>, V1
    ret

// Function definition at index 14
#[test_variant] friend fun test_variant$Data2$V2<T0, T1>(l0: &Data2<T0, T1>): bool
    local l1: &Data2<T0, T1>
    move_loc l0
    test_variant Data2<T0, T1>, V2
    ret

// Function definition at index 15
#[test_variant] friend fun test_variant$Data2$V3<T0, T1>(l0: &Data2<T0, T1>): bool
    local l1: &Data2<T0, T1>
    move_loc l0
    test_variant Data2<T0, T1>, V3
    ret

// Function definition at index 16
#[pack_variant] friend fun pack$Data2$V1<T0, T1>(l0: T0): Data2<T0, T1>
    local l1: T0
    move_loc l0
    pack_variant Data2<T0, T1>, V1
    ret

// Function definition at index 17
#[pack_variant] friend fun pack$Data2$V2<T0, T1>(l0: u64, l1: T1): Data2<T0, T1>
    local l2: u64
    local l3: T1
    move_loc l0
    move_loc l1
    pack_variant Data2<T0, T1>, V2
    ret

// Function definition at index 18
#[pack_variant] friend fun pack$Data2$V3<T0, T1>(): Data2<T0, T1>
    pack_variant Data2<T0, T1>, V3
    ret

// Function definition at index 19
#[unpack_variant] friend fun unpack$Data2$V1<T0, T1>(l0: Data2<T0, T1>): T0
    local l1: Data2<T0, T1>
    move_loc l0
    unpack_variant Data2<T0, T1>, V1
    ret

// Function definition at index 20
#[unpack_variant] friend fun unpack$Data2$V2<T0, T1>(l0: Data2<T0, T1>): (u64, T1)
    local l1: Data2<T0, T1>
    move_loc l0
    unpack_variant Data2<T0, T1>, V2
    ret

// Function definition at index 21
#[unpack_variant] friend fun unpack$Data2$V3<T0, T1>(l0: Data2<T0, T1>)
    local l1: Data2<T0, T1>
    move_loc l0
    unpack_variant Data2<T0, T1>, V3
    ret

// Function definition at index 22
#[borrow] friend fun borrow$Data2$0$1<T0, T1>(l0: &Data2<T0, T1>): &u64
    local l1: &Data2<T0, T1>
    move_loc l0
    borrow_variant_field Data2<T0, T1>, V2::y
    ret

// Function definition at index 23
#[borrow] friend fun borrow$Data2$0$0<T0, T1>(l0: &Data2<T0, T1>): &T0
    local l1: &Data2<T0, T1>
    move_loc l0
    borrow_variant_field Data2<T0, T1>, V1::x
    ret

// Function definition at index 24
#[borrow] friend fun borrow$Data2$1$2<T0, T1>(l0: &Data2<T0, T1>): &T1
    local l1: &Data2<T0, T1>
    move_loc l0
    borrow_variant_field Data2<T0, T1>, V2::x
    ret

// Function definition at index 25
#[borrow_mut] friend fun borrow_mut$Data2$0$1<T0, T1>(l0: &mut Data2<T0, T1>): &mut u64
    local l1: &mut Data2<T0, T1>
    move_loc l0
    mut_borrow_variant_field Data2<T0, T1>, V2::y
    ret

// Function definition at index 26
#[borrow_mut] friend fun borrow_mut$Data2$0$0<T0, T1>(l0: &mut Data2<T0, T1>): &mut T0
    local l1: &mut Data2<T0, T1>
    move_loc l0
    mut_borrow_variant_field Data2<T0, T1>, V1::x
    ret

// Function definition at index 27
#[borrow_mut] friend fun borrow_mut$Data2$1$2<T0, T1>(l0: &mut Data2<T0, T1>): &mut T1
    local l1: &mut Data2<T0, T1>
    move_loc l0
    mut_borrow_variant_field Data2<T0, T1>, V2::x
    ret

// Bytecode version v10
module 0x42::m2
use 0x42::m
// Function definition at index 0
fun test_data2_mut_borrow()
    local l0: m::Data2<u64, u64>
    local l1: u64
    local l2: &mut m::Data2<u64, u64>
    local l3: &mut u64
    ld_u64 43
    ld_u64 44
    call m::pack$Data2$V2<u64, u64>
    st_loc l0
    ld_u64 45
    // @5
    st_loc l1
    mut_borrow_loc l0
    st_loc l2
    copy_loc l2
    freeze_ref
    // @10
    call m::test_variant$Data2$V2<u64, u64>
    br_true l0
    move_loc l2
    call m::borrow_mut$Data2$0$0<u64, u64>
    st_loc l3
    // @15
l1: move_loc l1
    move_loc l3
    write_ref
    ret
l0: move_loc l2
    // @20
    call m::borrow_mut$Data2$1$2<u64, u64>
    st_loc l3
    branch l1

// Function definition at index 1
fun test_v1()
    local l0: m::Data
    local l1: &m::Data
    ld_u64 43
    call m::pack$Data$V1
    st_loc l0
    borrow_loc l0
    call m::borrow$Data$0$0
    // @5
    read_ref
    ld_u64 43
    eq
    br_false l0
    borrow_loc l0
    // @10
    st_loc l1
    copy_loc l1
    call m::test_variant$Data$V1
    br_true l1
    move_loc l1
    // @15
    pop
    ld_u64 14566554180833181697
    abort
l1: move_loc l1
    call m::borrow$Data$0$0
    // @20
    read_ref
    ld_u64 43
    eq
    br_false l2
    mut_borrow_loc l0
    // @25
    freeze_ref
    call m::borrow$Data$0$0
    read_ref
    ld_u64 43
    eq
    // @30
    br_false l3
    ret
l3: ld_u64 3
    abort
l2: ld_u64 2
    // @35
    abort
l0: ld_u64 1
    abort

// Function definition at index 2
fun test_v1_mut_borrow()
    local l0: m::Data
    local l1: u64
    local l2: &mut u64
    local l3: &mut m::Data
    ld_u64 43
    call m::pack$Data$V1
    st_loc l0
    mut_borrow_loc l0
    call m::borrow_mut$Data$0$0
    // @5
    st_loc l2
    ld_u64 44
    move_loc l2
    write_ref
    borrow_loc l0
    // @10
    call m::borrow$Data$0$0
    read_ref
    ld_u64 44
    eq
    br_false l0
    // @15
    mut_borrow_loc l0
    st_loc l3
    ld_u64 45
    move_loc l3
    call m::borrow_mut$Data$0$0
    // @20
    write_ref
    borrow_loc l0
    call m::borrow$Data$0$0
    read_ref
    ld_u64 45
    // @25
    eq
    br_false l1
    ret
l1: ld_u64 3
    abort
    // @30
l0: ld_u64 1
    abort

// Function definition at index 3
fun test_v2_mut_borrow()
    local l0: m::Data
    local l1: &mut m::Data
    ld_u64 43
    ld_true
    call m::pack$Data$V2
    st_loc l0
    mut_borrow_loc l0
    // @5
    st_loc l1
    copy_loc l1
    freeze_ref
    call m::borrow$Data$0$0
    read_ref
    // @10
    ld_u64 43
    eq
    br_false l0
    move_loc l1
    freeze_ref
    // @15
    call m::borrow$Data$1$1
    read_ref
    ld_true
    eq
    br_false l1
    // @20
    ret
l1: ld_u64 2
    abort
l0: move_loc l1
    pop
    // @25
    ld_u64 1
    abort


============ bytecode verification succeeded ========
