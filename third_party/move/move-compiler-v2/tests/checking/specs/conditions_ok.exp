// -- Model dump before first bytecode pipeline
module 0x42::M {
    struct Ghost$some_global {
        v: u64,
    }
    private fun add_some(x: &mut u64): u64 {
        x = Add<u64>(Deref(x), 1);
        Deref(x)
    }
    spec {
      aborts_if Or(Eq<u64>(Freeze(false)($t0), 0), Eq<u64>(select M::Ghost$some_global.v(global<0x42::M::Ghost$some_global>(0x0)), 0));
      ensures Gt(Old<u64>($t0), $t0);
      ensures Eq<u64>(result0(), Freeze(false)($t0));
    }

    private fun multiple_results(x: u64): (u64, bool) {
        Tuple(x, true)
    }
    spec {
      ensures And(Eq<u64>($t0, result0()), Eq<bool>(result1(), true));
    }

    private fun with_emits<T>(_guid: vector<u8>,_msg: T,x: u64): u64 {
        x
    }
    spec {
      emit $t1 to $t0;
      emit $t1 to $t0 if true;
      emit $t1 to $t0 if Gt($t2, 7);
    }

} // end 0x42::M

// -- Sourcified model before first bytecode pipeline
module 0x42::M {
    fun add_some(x: &mut u64): u64 {
        *x = *x + 1;
        *x
    }

    spec add_some(x: &mut u64): u64 {
        global some_global: u64;
        aborts_if x == 0 || some_global == 0;
        ensures old(x) > x;
        ensures result == x;
    }

    fun multiple_results(x: u64): (u64, bool) {
        (x, true)
    }

    spec multiple_results(x: u64): (u64, bool) {
        ensures x == result_1 && result_2 == true;
    }

    fun with_emits<T: drop>(_guid: vector<u8>, _msg: T, x: u64): u64 {
        x
    }

    spec with_emits<T: drop>(_guid: vector<u8>, _msg: T, x: u64): u64 {
        emits _msg to _guid;
        emits _msg to _guid if true;
        emits _msg to _guid if x > 7;
    }

}
