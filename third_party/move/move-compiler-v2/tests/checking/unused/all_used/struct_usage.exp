// -- Model dump before first bytecode pipeline
module 0x42::m {
    struct FunArg {
        val: u64,
    }
    struct FunResult {
        res: u64,
    }
    struct Inner {
        value: u64,
    }
    struct Input {
        x: u64,
    }
    struct Outer {
        inner: Inner,
    }
    struct Resource {
        data: u64,
    }
    struct Result {
        value: u64,
    }
    private fun apply_fun(f: |FunArg|FunResult,arg: FunArg): FunResult {
        (f)(arg)
    }
    private fun make_outer(): Outer {
        pack m::Outer(pack m::Inner(1))
    }
    private fun make_result(): Result {
        pack m::Result(42)
    }
    private fun process_input(input: Input): u64 {
        select m::Input.x<Input>(input)
    }
    public fun test(account: &signer): u64 {
        {
          let r: Result = m::make_result();
          {
            let i: Input = pack m::Input(10);
            {
              let o: Outer = m::make_outer();
              MoveTo<Resource>(account, pack m::Resource(select m::Result.value<Result>(r)));
              {
                let res: FunResult = m::apply_fun(closure#0m::__lambda__1__test(), pack m::FunArg(5));
                Add<u64>(Add<u64>(m::process_input(i), select m::Inner.value<Inner>(select m::Outer.inner<Outer>(o))), select m::FunResult.res<FunResult>(res))
              }
            }
          }
        }
    }
    private fun __lambda__1__test(a: FunArg): FunResult {
        pack m::FunResult(select m::FunArg.val<FunArg>(a))
    }
} // end 0x42::m

// -- Sourcified model before first bytecode pipeline
module 0x42::m {
    struct FunArg has copy, drop {
        val: u64,
    }
    struct FunResult has drop {
        res: u64,
    }
    struct Inner has drop {
        value: u64,
    }
    struct Input has drop {
        x: u64,
    }
    struct Outer has drop {
        inner: Inner,
    }
    struct Resource has key {
        data: u64,
    }
    struct Result has drop {
        value: u64,
    }
    fun apply_fun(f: |FunArg|FunResult, arg: FunArg): FunResult {
        f(arg)
    }
    fun make_outer(): Outer {
        Outer{inner: Inner{value: 1}}
    }
    fun make_result(): Result {
        Result{value: 42}
    }
    fun process_input(input: Input): u64 {
        input.x
    }
    public fun test(account: &signer): u64 {
        let r = make_result();
        let i = Input{x: 10};
        let o = make_outer();
        move_to<Resource>(account, Resource{data: r.value});
        let res = apply_fun(|arg0| lambda__1__test(arg0), FunArg{val: 5});
        process_input(i) + o.inner.value + res.res
    }
    fun lambda__1__test(a: FunArg): FunResult {
        FunResult{res: a.val}
    }
}
