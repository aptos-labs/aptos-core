// -- Model dump before first bytecode pipeline
module 0x8675309::M {
    enum X {
        A,
        B,
    }
    private fun bar(x: X): u64 {
        match (Tuple(x, x)) {
          (M::X::A, M::X::A): (X, X) => {
            1
          }
          _: (X, X) => {
            2
          }
        }

    }
    private fun foo(x: X): u64 {
        match (Tuple(x, x)) {
          (M::X::A, M::X::A): (X, X) => {
            1
          }
          (_: X, _: X): (X, X) => {
            2
          }
        }

    }
    private fun test_exhaustive_then_wildcard(x: X): u64 {
        match (Tuple(x, x)) {
          (M::X::A, M::X::A): (X, X) => {
            1
          }
          (M::X::A, M::X::B): (X, X) => {
            2
          }
          (M::X::B, M::X::A): (X, X) => {
            3
          }
          (M::X::B, M::X::B): (X, X) => {
            4
          }
          _: (X, X) => {
            5
          }
        }

    }
    private fun test_wildcard_first(x: X): u64 {
        match (Tuple(x, x)) {
          _: (X, X) => {
            1
          }
          (M::X::A, M::X::A): (X, X) => {
            2
          }
        }

    }
    private fun test_wildcard_positions(x: X,y: X): u64 {
        match (Tuple(x, y)) {
          (M::X::A, _: X): (X, X) => {
            1
          }
          (_: X, M::X::A): (X, X) => {
            2
          }
          _: (X, X) => {
            3
          }
        }

    }
    private fun test_wildcard_with_guard(x: X,cond: bool): u64 {
        match (Tuple(x, x)) {
          (M::X::A, M::X::A): (X, X) => {
            1
          }
          _: (X, X) if cond => {
            2
          }
          _: (X, X) => {
            3
          }
        }

    }
} // end 0x8675309::M

// -- Sourcified model before first bytecode pipeline
module 0x8675309::M {
    enum X has copy, drop {
        A,
        B,
    }
    fun bar(x: X): u64 {
        match ((x, x)) {
            (X::A{},X::A{}) => 1,
            _ => 2,
        }
    }
    fun foo(x: X): u64 {
        match ((x, x)) {
            (X::A{},X::A{}) => 1,
            (_,_) => 2,
        }
    }
    fun test_exhaustive_then_wildcard(x: X): u64 {
        match ((x, x)) {
            (X::A{},X::A{}) => 1,
            (X::A{},X::B{}) => 2,
            (X::B{},X::A{}) => 3,
            (X::B{},X::B{}) => 4,
            _ => 5,
        }
    }
    fun test_wildcard_first(x: X): u64 {
        match ((x, x)) {
            _ => 1,
            (X::A{},X::A{}) => 2,
        }
    }
    fun test_wildcard_positions(x: X, y: X): u64 {
        match ((x, y)) {
            (X::A{},_) => 1,
            (_,X::A{}) => 2,
            _ => 3,
        }
    }
    fun test_wildcard_with_guard(x: X, cond: bool): u64 {
        match ((x, x)) {
            (X::A{},X::A{}) => 1,
            _ if cond => 2,
            _ => 3,
        }
    }
}


Diagnostics:
error: unreachable pattern
   ┌─ tests/checking/typing/wildcard_match_tuple.move:37:13
   │
37 │             _ => 5,
   │             ^

error: unreachable pattern
   ┌─ tests/checking/typing/wildcard_match_tuple.move:45:13
   │
45 │             (X::A, X::A) => 2,
   │             ^^^^^^^^^^^^
