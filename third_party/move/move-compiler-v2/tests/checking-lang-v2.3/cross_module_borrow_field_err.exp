// -- Model dump before first bytecode pipeline
module 0xc0ffee::m {
    enum Wrapper {
        V1 {
            0: u64,
            1: u64,
        }
        V2 {
            0: u64,
        }
    }
    public fun make(x: u64): Wrapper {
        pack m::Wrapper::V1(x, Add<u64>(x, 1))
    }
    public fun pack$0xc0ffee$m$Wrapper$V1(_0: u64,_1: u64): Wrapper {
        pack m::Wrapper::V1(_0, _1)
    }
    public fun pack$0xc0ffee$m$Wrapper$V2(_0: u64): Wrapper {
        pack m::Wrapper::V2(_0)
    }
    public fun unpack$0xc0ffee$m$Wrapper$V1(_s: Wrapper): (u64, u64) {
        {
          let m::Wrapper::V1{ 0, 1 } = _s;
          Tuple(0, 1)
        }
    }
    public fun unpack$0xc0ffee$m$Wrapper$V2(_s: Wrapper): (u64) {
        {
          let m::Wrapper::V2{ 0 } = _s;
          Tuple(0)
        }
    }
    public fun unpack_mut_ref$0xc0ffee$m$Wrapper$V1(_s: &mut Wrapper): (&mut u64, &mut u64) {
        Tuple(Borrow(Mutable)(select_variants m::Wrapper.V1.0(_s)), Borrow(Mutable)(select_variants m::Wrapper.V1.1(_s)))
    }
    public fun unpack_mut_ref$0xc0ffee$m$Wrapper$V2(_s: &mut Wrapper): (&mut u64) {
        Tuple(Borrow(Mutable)(select_variants m::Wrapper.V2.0(_s)))
    }
    public fun borrow$0xc0ffee$m$Wrapper$0(_s: &Wrapper): &u64 {
        Borrow(Immutable)(select_variants m::Wrapper.V1.0|m::Wrapper.V2.0(_s))
    }
    public fun borrow$0xc0ffee$m$Wrapper$1(_s: &Wrapper): &u64 {
        Borrow(Immutable)(select_variants m::Wrapper.V1.1(_s))
    }
    public fun borrow_mut$0xc0ffee$m$Wrapper$0(_s: &mut Wrapper): &mut u64 {
        Borrow(Mutable)(select_variants m::Wrapper.V1.0|m::Wrapper.V2.0(_s))
    }
    public fun borrow_mut$0xc0ffee$m$Wrapper$1(_s: &mut Wrapper): &mut u64 {
        Borrow(Mutable)(select_variants m::Wrapper.V1.1(_s))
    }
    public fun test_variant$0xc0ffee$m$Wrapper$V1(_s: &Wrapper): bool {
        test_variants m::Wrapper::V1(_s)
    }
    public fun test_variant$0xc0ffee$m$Wrapper$V2(_s: &Wrapper): bool {
        test_variants m::Wrapper::V2(_s)
    }
} // end 0xc0ffee::m
module 0xc0ffee::n {
    use 0xc0ffee::m; // resolved as: 0xc0ffee::m
    use 0xc0ffee::m::{Wrapper}; // resolved as: 0xc0ffee::m
    private fun foo(_x: &mut u64,_y: &mut u64) {
        Tuple()
    }
    private fun test_1() {
        {
          let x: m::Wrapper = m::make(22);
          {
            let x_0: &mut u64 = Borrow(Mutable)(select_variants m::Wrapper.V1.0|m::Wrapper.V2.0<m::Wrapper>(x));
            {
              let x_1: &mut u64 = Borrow(Mutable)(select_variants m::Wrapper.V1.1<m::Wrapper>(x));
              n::foo(x_0, x_1);
              Tuple()
            }
          }
        }
    }
    private fun test_2() {
        {
          let x: m::Wrapper = m::make(22);
          {
            let x_0: &mut u64 = Borrow(Mutable)(select_variants m::Wrapper.V1.0|m::Wrapper.V2.0<m::Wrapper>(x));
            {
              let x_1: &mut u64 = Borrow(Mutable)(select_variants m::Wrapper.V1.1<m::Wrapper>(x));
              x_0 = 23;
              x_1 = 24;
              Tuple()
            }
          }
        }
    }
    private fun test_match() {
        {
          let x: m::Wrapper = m::make(22);
          match (Borrow(Mutable)(x)) {
            m::Wrapper::V2{ 0: _ } => {
              Tuple()
            }
            m::Wrapper::V1{ 0: x_0, 1: x_1 } => {
              n::foo(x_0, x_1);
              Tuple()
            }
          }

        }
    }
    private fun test_no_err() {
        {
          let x: m::Wrapper = m::make(22);
          select_variants m::Wrapper.V1.0|m::Wrapper.V2.0<m::Wrapper>(x) = 23;
          select_variants m::Wrapper.V1.1<m::Wrapper>(x) = 24;
          Tuple()
        }
    }
} // end 0xc0ffee::n

// -- Sourcified model before first bytecode pipeline
module 0xc0ffee::m {
    enum Wrapper has drop {
        V1 {
            0: u64,
            1: u64,
        }
        V2 {
            0: u64,
        }
    }
    public fun make(x: u64): Wrapper {
        Wrapper::V1(x, x + 1)
    }
    public fun pack_0xc0ffee_m_Wrapper_V1(_0: u64, _1: u64): Wrapper {
        Wrapper::V1(_0, _1)
    }
    public fun pack_0xc0ffee_m_Wrapper_V2(_0: u64): Wrapper {
        Wrapper::V2(_0)
    }
    public fun unpack_0xc0ffee_m_Wrapper_V1(_s: Wrapper): (u64, u64) {
        let Wrapper::V1(0, 1) = _s;
        (0, 1)
    }
    public fun unpack_0xc0ffee_m_Wrapper_V2(_s: Wrapper): (u64) {
        let Wrapper::V2(0) = _s;
        (0)
    }
    public fun unpack_mut_ref_0xc0ffee_m_Wrapper_V1(_s: &mut Wrapper): (&mut u64, &mut u64) {
        (&mut _s.0, &mut _s.1)
    }
    public fun unpack_mut_ref_0xc0ffee_m_Wrapper_V2(_s: &mut Wrapper): (&mut u64) {
        (&mut _s.0)
    }
    public fun borrow_0xc0ffee_m_Wrapper_0(_s: &Wrapper): &u64 {
        &_s.0
    }
    public fun borrow_0xc0ffee_m_Wrapper_1(_s: &Wrapper): &u64 {
        &_s.1
    }
    public fun borrow_mut_0xc0ffee_m_Wrapper_0(_s: &mut Wrapper): &mut u64 {
        &mut _s.0
    }
    public fun borrow_mut_0xc0ffee_m_Wrapper_1(_s: &mut Wrapper): &mut u64 {
        &mut _s.1
    }
    public fun test_variant_0xc0ffee_m_Wrapper_V1(_s: &Wrapper): bool {
        _s is V1
    }
    public fun test_variant_0xc0ffee_m_Wrapper_V2(_s: &Wrapper): bool {
        _s is V2
    }
}
module 0xc0ffee::n {
    use 0xc0ffee::m;
    use 0xc0ffee::m;
    fun foo(_x: &mut u64, _y: &mut u64) {
    }
    fun test_1() {
        let x = m::make(22);
        let x_0 = &mut x.0;
        let x_1 = &mut x.1;
        foo(x_0, x_1);
    }
    fun test_2() {
        let x = m::make(22);
        let x_0 = &mut x.0;
        let x_1 = &mut x.1;
        *x_0 = 23;
        *x_1 = 24;
    }
    fun test_match() {
        let x = m::make(22);
        match (&mut x) {
            m::Wrapper::V2(_) => (),
            m::Wrapper::V1(x_0, x_1) => {
                foo(x_0, x_1);
            },
        }
    }
    fun test_no_err() {
        let x = m::make(22);
        x.0 = 23;
        x.1 = 24;
    }
}

============ bytecode before first stackless bytecode pipeline ================

[variant baseline]
public fun m::make($t0: u64): 0xc0ffee::m::Wrapper {
     var $t1: 0xc0ffee::m::Wrapper
     var $t2: u64
     var $t3: u64
     var $t4: u64
     var $t5: u64
  0: $t2 := infer($t0)
  1: $t4 := infer($t0)
  2: $t5 := 1
  3: $t3 := +($t4, $t5)
  4: $t1 := pack_variant 0xc0ffee::m::Wrapper::V1($t2, $t3)
  5: return $t1
}


[variant baseline]
public fun m::pack$0xc0ffee$m$Wrapper$V1($t0: u64, $t1: u64): 0xc0ffee::m::Wrapper {
     var $t2: 0xc0ffee::m::Wrapper
     var $t3: u64
  0: $t3 := infer($t0)
  1: $t2 := pack_variant 0xc0ffee::m::Wrapper::V1($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::pack$0xc0ffee$m$Wrapper$V2($t0: u64): 0xc0ffee::m::Wrapper {
     var $t1: 0xc0ffee::m::Wrapper
  0: $t1 := pack_variant 0xc0ffee::m::Wrapper::V2($t0)
  1: return $t1
}


[variant baseline]
public fun m::unpack$0xc0ffee$m$Wrapper$V1($t0: 0xc0ffee::m::Wrapper): (u64, u64) {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     var $t4: u64
  0: ($t3, $t4) := unpack_variant 0xc0ffee::m::Wrapper::V1($t0)
  1: $t1 := infer($t3)
  2: $t2 := infer($t4)
  3: return ($t1, $t2)
}


[variant baseline]
public fun m::unpack$0xc0ffee$m$Wrapper$V2($t0: 0xc0ffee::m::Wrapper): u64 {
     var $t1: u64
     var $t2: u64
  0: $t2 := unpack_variant 0xc0ffee::m::Wrapper::V2($t0)
  1: $t1 := infer($t2)
  2: return $t1
}


[variant baseline]
public fun m::unpack_mut_ref$0xc0ffee$m$Wrapper$V1($t0: &mut 0xc0ffee::m::Wrapper): (&mut u64, &mut u64) {
     var $t1: &mut u64
     var $t2: &mut u64
  0: $t1 := borrow_variant_field<0xc0ffee::m::Wrapper::V1>.0($t0)
  1: $t2 := borrow_variant_field<0xc0ffee::m::Wrapper::V1>.1($t0)
  2: return ($t1, $t2)
}


[variant baseline]
public fun m::unpack_mut_ref$0xc0ffee$m$Wrapper$V2($t0: &mut 0xc0ffee::m::Wrapper): &mut u64 {
     var $t1: &mut u64
  0: $t1 := borrow_variant_field<0xc0ffee::m::Wrapper::V2>.0($t0)
  1: return $t1
}


[variant baseline]
public fun m::borrow$0xc0ffee$m$Wrapper$0($t0: &0xc0ffee::m::Wrapper): &u64 {
     var $t1: &u64
  0: $t1 := borrow_variant_field<0xc0ffee::m::Wrapper::V1|V2>.0($t0)
  1: return $t1
}


[variant baseline]
public fun m::borrow$0xc0ffee$m$Wrapper$1($t0: &0xc0ffee::m::Wrapper): &u64 {
     var $t1: &u64
  0: $t1 := borrow_variant_field<0xc0ffee::m::Wrapper::V1>.1($t0)
  1: return $t1
}


[variant baseline]
public fun m::borrow_mut$0xc0ffee$m$Wrapper$0($t0: &mut 0xc0ffee::m::Wrapper): &mut u64 {
     var $t1: &mut u64
  0: $t1 := borrow_variant_field<0xc0ffee::m::Wrapper::V1|V2>.0($t0)
  1: return $t1
}


[variant baseline]
public fun m::borrow_mut$0xc0ffee$m$Wrapper$1($t0: &mut 0xc0ffee::m::Wrapper): &mut u64 {
     var $t1: &mut u64
  0: $t1 := borrow_variant_field<0xc0ffee::m::Wrapper::V1>.1($t0)
  1: return $t1
}


[variant baseline]
public fun m::test_variant$0xc0ffee$m$Wrapper$V1($t0: &0xc0ffee::m::Wrapper): bool {
     var $t1: bool
  0: $t1 := test_variant 0xc0ffee::m::Wrapper::V1($t0)
  1: if ($t1) goto 3 else goto 2
  2: label L1
  3: label L0
  4: return $t1
}


[variant baseline]
public fun m::test_variant$0xc0ffee$m$Wrapper$V2($t0: &0xc0ffee::m::Wrapper): bool {
     var $t1: bool
  0: $t1 := test_variant 0xc0ffee::m::Wrapper::V2($t0)
  1: if ($t1) goto 3 else goto 2
  2: label L1
  3: label L0
  4: return $t1
}


[variant baseline]
fun n::foo($t0: &mut u64, $t1: &mut u64) {
  0: return ()
}


[variant baseline]
fun n::test_1() {
     var $t0: 0xc0ffee::m::Wrapper
     var $t1: u64
     var $t2: &mut u64
     var $t3: &mut 0xc0ffee::m::Wrapper
     var $t4: &mut u64
     var $t5: &mut 0xc0ffee::m::Wrapper
     var $t6: &mut u64
  0: $t1 := 22
  1: $t0 := m::make($t1)
  2: $t3 := borrow_local($t0)
  3: $t2 := m::borrow_mut$0xc0ffee$m$Wrapper$0($t3)
  4: $t5 := borrow_local($t0)
  5: $t4 := m::borrow_mut$0xc0ffee$m$Wrapper$1($t5)
  6: $t6 := infer($t2)
  7: n::foo($t6, $t4)
  8: return ()
}


[variant baseline]
fun n::test_2() {
     var $t0: 0xc0ffee::m::Wrapper
     var $t1: u64
     var $t2: &mut u64
     var $t3: &mut 0xc0ffee::m::Wrapper
     var $t4: &mut u64
     var $t5: &mut 0xc0ffee::m::Wrapper
     var $t6: u64
     var $t7: u64
  0: $t1 := 22
  1: $t0 := m::make($t1)
  2: $t3 := borrow_local($t0)
  3: $t2 := m::borrow_mut$0xc0ffee$m$Wrapper$0($t3)
  4: $t5 := borrow_local($t0)
  5: $t4 := m::borrow_mut$0xc0ffee$m$Wrapper$1($t5)
  6: $t6 := 23
  7: write_ref($t2, $t6)
  8: $t7 := 24
  9: write_ref($t4, $t7)
 10: return ()
}


[variant baseline]
fun n::test_match() {
     var $t0: 0xc0ffee::m::Wrapper
     var $t1: u64
     var $t2: &mut 0xc0ffee::m::Wrapper
     var $t3: bool
     var $t4: &0xc0ffee::m::Wrapper
     var $t5: &mut u64
     var $t6: &mut u64
     var $t7: &mut u64
     var $t8: &0xc0ffee::m::Wrapper
     var $t9: &mut u64
     var $t10: u64
  0: $t1 := 22
  1: $t0 := m::make($t1)
  2: $t2 := borrow_local($t0)
  3: $t4 := freeze_ref(implicit)($t2)
  4: $t3 := m::test_variant$0xc0ffee$m$Wrapper$V2($t4)
  5: if ($t3) goto 6 else goto 9
  6: label L2
  7: $t5 := m::unpack_mut_ref$0xc0ffee$m$Wrapper$V2($t2)
  8: goto 21
  9: label L1
 10: $t8 := freeze_ref(implicit)($t2)
 11: $t3 := m::test_variant$0xc0ffee$m$Wrapper$V1($t8)
 12: if ($t3) goto 13 else goto 18
 13: label L4
 14: ($t6, $t7) := m::unpack_mut_ref$0xc0ffee$m$Wrapper$V1($t2)
 15: $t9 := infer($t6)
 16: n::foo($t9, $t7)
 17: goto 21
 18: label L3
 19: $t10 := 14566554180833181697
 20: abort($t10)
 21: label L0
 22: return ()
}


[variant baseline]
fun n::test_no_err() {
     var $t0: 0xc0ffee::m::Wrapper
     var $t1: u64
     var $t2: u64
     var $t3: &mut u64
     var $t4: &mut 0xc0ffee::m::Wrapper
     var $t5: u64
     var $t6: &mut u64
     var $t7: &mut 0xc0ffee::m::Wrapper
  0: $t1 := 22
  1: $t0 := m::make($t1)
  2: $t2 := 23
  3: $t4 := borrow_local($t0)
  4: $t3 := m::borrow_mut$0xc0ffee$m$Wrapper$0($t4)
  5: write_ref($t3, $t2)
  6: $t5 := 24
  7: $t7 := borrow_local($t0)
  8: $t6 := m::borrow_mut$0xc0ffee$m$Wrapper$1($t7)
  9: write_ref($t6, $t5)
 10: return ()
}


Diagnostics:
error: cannot transfer mutable value since it is borrowed
   ┌─ tests/checking-lang-v2.3/cross_module_borrow_field_err.move:19:19
   │
18 │         let x_0 = &mut x.0;
   │                   -------- previously mutably borrowed here: field borrow for non-private struct/enum `0xc0ffee::m::Wrapper` is converted into a function call
19 │         let x_1 = &mut x.1;
   │                   ^^^^^^^^ transfer attempted here
20 │         foo(x_0, x_1);
   │             --- conflicting reference `x_0` used here

error: cannot transfer mutable value since it is borrowed
   ┌─ tests/checking-lang-v2.3/cross_module_borrow_field_err.move:30:19
   │
29 │         let x_0 = &mut x.0;
   │                   -------- previously mutably borrowed here: field borrow for non-private struct/enum `0xc0ffee::m::Wrapper` is converted into a function call
30 │         let x_1 = &mut x.1;
   │                   ^^^^^^^^ transfer attempted here
31 │         *x_0 = 23;
   │         --------- conflicting reference `x_0` used here
