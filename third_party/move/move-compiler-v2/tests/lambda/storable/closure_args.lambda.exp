// -- Model dump before env processor pipeline:
module 0x42::mod1 {
    struct S {
        x: u64,
    }
    struct Sboth {
        x: u64,
    }
    struct Scopy {
        x: u64,
    }
    struct Sstore {
        x: u64,
    }
    public fun base_fun(a: S,b: u64): u64 {
        Mul<u64>(select mod1::S.x<S>(a), b)
    }
    public fun base_fun2(a: u64,b: S): u64 {
        Mul<u64>(a, select mod1::S.x<S>(b))
    }
    public fun both_fun(a: Sboth,b: u64): u64 {
        Mul<u64>(select mod1::Sboth.x<Sboth>(a), b)
    }
    public fun both_fun2(a: u64,b: Sboth): u64 {
        Mul<u64>(a, select mod1::Sboth.x<Sboth>(b))
    }
    public fun copy_fun(a: Scopy,b: u64): u64 {
        Mul<u64>(select mod1::Scopy.x<Scopy>(a), b)
    }
    public fun copy_fun2(a: u64,b: Scopy): u64 {
        Mul<u64>(a, select mod1::Scopy.x<Scopy>(b))
    }
    public fun return_function_base(key: u64,x: u64): |u64|u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_both(key: u64,x: u64): |u64|u64 with copy+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_copy(key: u64,x: u64): |u64|u64 with copy {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_store(key: u64,x: u64): |u64|u64 with store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun store_fun(a: Sstore,b: u64): u64 {
        Mul<u64>(select mod1::Sstore.x<Sstore>(a), b)
    }
    public fun store_fun2(a: u64,b: Sstore): u64 {
        Mul<u64>(a, select mod1::Sstore.x<Sstore>(b))
    }
    public fun use_function_base(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_both(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_copy(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_store(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
} // end 0x42::mod1


// -- Model dump after env processor unused checks:
module 0x42::mod1 {
    struct S {
        x: u64,
    }
    struct Sboth {
        x: u64,
    }
    struct Scopy {
        x: u64,
    }
    struct Sstore {
        x: u64,
    }
    public fun base_fun(a: S,b: u64): u64 {
        Mul<u64>(select mod1::S.x<S>(a), b)
    }
    public fun base_fun2(a: u64,b: S): u64 {
        Mul<u64>(a, select mod1::S.x<S>(b))
    }
    public fun both_fun(a: Sboth,b: u64): u64 {
        Mul<u64>(select mod1::Sboth.x<Sboth>(a), b)
    }
    public fun both_fun2(a: u64,b: Sboth): u64 {
        Mul<u64>(a, select mod1::Sboth.x<Sboth>(b))
    }
    public fun copy_fun(a: Scopy,b: u64): u64 {
        Mul<u64>(select mod1::Scopy.x<Scopy>(a), b)
    }
    public fun copy_fun2(a: u64,b: Scopy): u64 {
        Mul<u64>(a, select mod1::Scopy.x<Scopy>(b))
    }
    public fun return_function_base(key: u64,x: u64): |u64|u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_both(key: u64,x: u64): |u64|u64 with copy+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_copy(key: u64,x: u64): |u64|u64 with copy {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_store(key: u64,x: u64): |u64|u64 with store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun store_fun(a: Sstore,b: u64): u64 {
        Mul<u64>(select mod1::Sstore.x<Sstore>(a), b)
    }
    public fun store_fun2(a: u64,b: Sstore): u64 {
        Mul<u64>(a, select mod1::Sstore.x<Sstore>(b))
    }
    public fun use_function_base(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_both(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_copy(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_store(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
} // end 0x42::mod1


// -- Model dump after env processor type parameter check:
module 0x42::mod1 {
    struct S {
        x: u64,
    }
    struct Sboth {
        x: u64,
    }
    struct Scopy {
        x: u64,
    }
    struct Sstore {
        x: u64,
    }
    public fun base_fun(a: S,b: u64): u64 {
        Mul<u64>(select mod1::S.x<S>(a), b)
    }
    public fun base_fun2(a: u64,b: S): u64 {
        Mul<u64>(a, select mod1::S.x<S>(b))
    }
    public fun both_fun(a: Sboth,b: u64): u64 {
        Mul<u64>(select mod1::Sboth.x<Sboth>(a), b)
    }
    public fun both_fun2(a: u64,b: Sboth): u64 {
        Mul<u64>(a, select mod1::Sboth.x<Sboth>(b))
    }
    public fun copy_fun(a: Scopy,b: u64): u64 {
        Mul<u64>(select mod1::Scopy.x<Scopy>(a), b)
    }
    public fun copy_fun2(a: u64,b: Scopy): u64 {
        Mul<u64>(a, select mod1::Scopy.x<Scopy>(b))
    }
    public fun return_function_base(key: u64,x: u64): |u64|u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_both(key: u64,x: u64): |u64|u64 with copy+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_copy(key: u64,x: u64): |u64|u64 with copy {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_store(key: u64,x: u64): |u64|u64 with store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun store_fun(a: Sstore,b: u64): u64 {
        Mul<u64>(select mod1::Sstore.x<Sstore>(a), b)
    }
    public fun store_fun2(a: u64,b: Sstore): u64 {
        Mul<u64>(a, select mod1::Sstore.x<Sstore>(b))
    }
    public fun use_function_base(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_both(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_copy(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_store(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
} // end 0x42::mod1


// -- Model dump after env processor check recursive struct definition:
module 0x42::mod1 {
    struct S {
        x: u64,
    }
    struct Sboth {
        x: u64,
    }
    struct Scopy {
        x: u64,
    }
    struct Sstore {
        x: u64,
    }
    public fun base_fun(a: S,b: u64): u64 {
        Mul<u64>(select mod1::S.x<S>(a), b)
    }
    public fun base_fun2(a: u64,b: S): u64 {
        Mul<u64>(a, select mod1::S.x<S>(b))
    }
    public fun both_fun(a: Sboth,b: u64): u64 {
        Mul<u64>(select mod1::Sboth.x<Sboth>(a), b)
    }
    public fun both_fun2(a: u64,b: Sboth): u64 {
        Mul<u64>(a, select mod1::Sboth.x<Sboth>(b))
    }
    public fun copy_fun(a: Scopy,b: u64): u64 {
        Mul<u64>(select mod1::Scopy.x<Scopy>(a), b)
    }
    public fun copy_fun2(a: u64,b: Scopy): u64 {
        Mul<u64>(a, select mod1::Scopy.x<Scopy>(b))
    }
    public fun return_function_base(key: u64,x: u64): |u64|u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_both(key: u64,x: u64): |u64|u64 with copy+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_copy(key: u64,x: u64): |u64|u64 with copy {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_store(key: u64,x: u64): |u64|u64 with store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun store_fun(a: Sstore,b: u64): u64 {
        Mul<u64>(select mod1::Sstore.x<Sstore>(a), b)
    }
    public fun store_fun2(a: u64,b: Sstore): u64 {
        Mul<u64>(a, select mod1::Sstore.x<Sstore>(b))
    }
    public fun use_function_base(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_both(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_copy(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_store(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
} // end 0x42::mod1


// -- Model dump after env processor check cyclic type instantiation:
module 0x42::mod1 {
    struct S {
        x: u64,
    }
    struct Sboth {
        x: u64,
    }
    struct Scopy {
        x: u64,
    }
    struct Sstore {
        x: u64,
    }
    public fun base_fun(a: S,b: u64): u64 {
        Mul<u64>(select mod1::S.x<S>(a), b)
    }
    public fun base_fun2(a: u64,b: S): u64 {
        Mul<u64>(a, select mod1::S.x<S>(b))
    }
    public fun both_fun(a: Sboth,b: u64): u64 {
        Mul<u64>(select mod1::Sboth.x<Sboth>(a), b)
    }
    public fun both_fun2(a: u64,b: Sboth): u64 {
        Mul<u64>(a, select mod1::Sboth.x<Sboth>(b))
    }
    public fun copy_fun(a: Scopy,b: u64): u64 {
        Mul<u64>(select mod1::Scopy.x<Scopy>(a), b)
    }
    public fun copy_fun2(a: u64,b: Scopy): u64 {
        Mul<u64>(a, select mod1::Scopy.x<Scopy>(b))
    }
    public fun return_function_base(key: u64,x: u64): |u64|u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_both(key: u64,x: u64): |u64|u64 with copy+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_copy(key: u64,x: u64): |u64|u64 with copy {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_store(key: u64,x: u64): |u64|u64 with store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun store_fun(a: Sstore,b: u64): u64 {
        Mul<u64>(select mod1::Sstore.x<Sstore>(a), b)
    }
    public fun store_fun2(a: u64,b: Sstore): u64 {
        Mul<u64>(a, select mod1::Sstore.x<Sstore>(b))
    }
    public fun use_function_base(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_both(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_copy(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_store(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
} // end 0x42::mod1


// -- Model dump after env processor unused struct params check:
module 0x42::mod1 {
    struct S {
        x: u64,
    }
    struct Sboth {
        x: u64,
    }
    struct Scopy {
        x: u64,
    }
    struct Sstore {
        x: u64,
    }
    public fun base_fun(a: S,b: u64): u64 {
        Mul<u64>(select mod1::S.x<S>(a), b)
    }
    public fun base_fun2(a: u64,b: S): u64 {
        Mul<u64>(a, select mod1::S.x<S>(b))
    }
    public fun both_fun(a: Sboth,b: u64): u64 {
        Mul<u64>(select mod1::Sboth.x<Sboth>(a), b)
    }
    public fun both_fun2(a: u64,b: Sboth): u64 {
        Mul<u64>(a, select mod1::Sboth.x<Sboth>(b))
    }
    public fun copy_fun(a: Scopy,b: u64): u64 {
        Mul<u64>(select mod1::Scopy.x<Scopy>(a), b)
    }
    public fun copy_fun2(a: u64,b: Scopy): u64 {
        Mul<u64>(a, select mod1::Scopy.x<Scopy>(b))
    }
    public fun return_function_base(key: u64,x: u64): |u64|u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_both(key: u64,x: u64): |u64|u64 with copy+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_copy(key: u64,x: u64): |u64|u64 with copy {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_store(key: u64,x: u64): |u64|u64 with store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun store_fun(a: Sstore,b: u64): u64 {
        Mul<u64>(select mod1::Sstore.x<Sstore>(a), b)
    }
    public fun store_fun2(a: u64,b: Sstore): u64 {
        Mul<u64>(a, select mod1::Sstore.x<Sstore>(b))
    }
    public fun use_function_base(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_both(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_copy(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_store(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
} // end 0x42::mod1


// -- Model dump after env processor access and use check before inlining:
module 0x42::mod1 {
    struct S {
        x: u64,
    }
    struct Sboth {
        x: u64,
    }
    struct Scopy {
        x: u64,
    }
    struct Sstore {
        x: u64,
    }
    public fun base_fun(a: S,b: u64): u64 {
        Mul<u64>(select mod1::S.x<S>(a), b)
    }
    public fun base_fun2(a: u64,b: S): u64 {
        Mul<u64>(a, select mod1::S.x<S>(b))
    }
    public fun both_fun(a: Sboth,b: u64): u64 {
        Mul<u64>(select mod1::Sboth.x<Sboth>(a), b)
    }
    public fun both_fun2(a: u64,b: Sboth): u64 {
        Mul<u64>(a, select mod1::Sboth.x<Sboth>(b))
    }
    public fun copy_fun(a: Scopy,b: u64): u64 {
        Mul<u64>(select mod1::Scopy.x<Scopy>(a), b)
    }
    public fun copy_fun2(a: u64,b: Scopy): u64 {
        Mul<u64>(a, select mod1::Scopy.x<Scopy>(b))
    }
    public fun return_function_base(key: u64,x: u64): |u64|u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_both(key: u64,x: u64): |u64|u64 with copy+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_copy(key: u64,x: u64): |u64|u64 with copy {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_store(key: u64,x: u64): |u64|u64 with store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun store_fun(a: Sstore,b: u64): u64 {
        Mul<u64>(select mod1::Sstore.x<Sstore>(a), b)
    }
    public fun store_fun2(a: u64,b: Sstore): u64 {
        Mul<u64>(a, select mod1::Sstore.x<Sstore>(b))
    }
    public fun use_function_base(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_both(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_copy(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_store(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
} // end 0x42::mod1


// -- Model dump after env processor inlining:
module 0x42::mod1 {
    struct S {
        x: u64,
    }
    struct Sboth {
        x: u64,
    }
    struct Scopy {
        x: u64,
    }
    struct Sstore {
        x: u64,
    }
    public fun base_fun(a: S,b: u64): u64 {
        Mul<u64>(select mod1::S.x<S>(a), b)
    }
    public fun base_fun2(a: u64,b: S): u64 {
        Mul<u64>(a, select mod1::S.x<S>(b))
    }
    public fun both_fun(a: Sboth,b: u64): u64 {
        Mul<u64>(select mod1::Sboth.x<Sboth>(a), b)
    }
    public fun both_fun2(a: u64,b: Sboth): u64 {
        Mul<u64>(a, select mod1::Sboth.x<Sboth>(b))
    }
    public fun copy_fun(a: Scopy,b: u64): u64 {
        Mul<u64>(select mod1::Scopy.x<Scopy>(a), b)
    }
    public fun copy_fun2(a: u64,b: Scopy): u64 {
        Mul<u64>(a, select mod1::Scopy.x<Scopy>(b))
    }
    public fun return_function_base(key: u64,x: u64): |u64|u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_both(key: u64,x: u64): |u64|u64 with copy+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_copy(key: u64,x: u64): |u64|u64 with copy {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_store(key: u64,x: u64): |u64|u64 with store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun store_fun(a: Sstore,b: u64): u64 {
        Mul<u64>(select mod1::Sstore.x<Sstore>(a), b)
    }
    public fun store_fun2(a: u64,b: Sstore): u64 {
        Mul<u64>(a, select mod1::Sstore.x<Sstore>(b))
    }
    public fun use_function_base(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_both(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_copy(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_store(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
} // end 0x42::mod1


// -- Model dump after env processor access and use check after inlining:
module 0x42::mod1 {
    struct S {
        x: u64,
    }
    struct Sboth {
        x: u64,
    }
    struct Scopy {
        x: u64,
    }
    struct Sstore {
        x: u64,
    }
    public fun base_fun(a: S,b: u64): u64 {
        Mul<u64>(select mod1::S.x<S>(a), b)
    }
    public fun base_fun2(a: u64,b: S): u64 {
        Mul<u64>(a, select mod1::S.x<S>(b))
    }
    public fun both_fun(a: Sboth,b: u64): u64 {
        Mul<u64>(select mod1::Sboth.x<Sboth>(a), b)
    }
    public fun both_fun2(a: u64,b: Sboth): u64 {
        Mul<u64>(a, select mod1::Sboth.x<Sboth>(b))
    }
    public fun copy_fun(a: Scopy,b: u64): u64 {
        Mul<u64>(select mod1::Scopy.x<Scopy>(a), b)
    }
    public fun copy_fun2(a: u64,b: Scopy): u64 {
        Mul<u64>(a, select mod1::Scopy.x<Scopy>(b))
    }
    public fun return_function_base(key: u64,x: u64): |u64|u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_both(key: u64,x: u64): |u64|u64 with copy+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_copy(key: u64,x: u64): |u64|u64 with copy {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_store(key: u64,x: u64): |u64|u64 with store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun store_fun(a: Sstore,b: u64): u64 {
        Mul<u64>(select mod1::Sstore.x<Sstore>(a), b)
    }
    public fun store_fun2(a: u64,b: Sstore): u64 {
        Mul<u64>(a, select mod1::Sstore.x<Sstore>(b))
    }
    public fun use_function_base(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_both(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_copy(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_store(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
} // end 0x42::mod1


// -- Model dump after env processor acquires check:
module 0x42::mod1 {
    struct S {
        x: u64,
    }
    struct Sboth {
        x: u64,
    }
    struct Scopy {
        x: u64,
    }
    struct Sstore {
        x: u64,
    }
    public fun base_fun(a: S,b: u64): u64 {
        Mul<u64>(select mod1::S.x<S>(a), b)
    }
    public fun base_fun2(a: u64,b: S): u64 {
        Mul<u64>(a, select mod1::S.x<S>(b))
    }
    public fun both_fun(a: Sboth,b: u64): u64 {
        Mul<u64>(select mod1::Sboth.x<Sboth>(a), b)
    }
    public fun both_fun2(a: u64,b: Sboth): u64 {
        Mul<u64>(a, select mod1::Sboth.x<Sboth>(b))
    }
    public fun copy_fun(a: Scopy,b: u64): u64 {
        Mul<u64>(select mod1::Scopy.x<Scopy>(a), b)
    }
    public fun copy_fun2(a: u64,b: Scopy): u64 {
        Mul<u64>(a, select mod1::Scopy.x<Scopy>(b))
    }
    public fun return_function_base(key: u64,x: u64): |u64|u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_both(key: u64,x: u64): |u64|u64 with copy+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_copy(key: u64,x: u64): |u64|u64 with copy {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_store(key: u64,x: u64): |u64|u64 with store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun store_fun(a: Sstore,b: u64): u64 {
        Mul<u64>(select mod1::Sstore.x<Sstore>(a), b)
    }
    public fun store_fun2(a: u64,b: Sstore): u64 {
        Mul<u64>(a, select mod1::Sstore.x<Sstore>(b))
    }
    public fun use_function_base(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_both(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_copy(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_store(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
} // end 0x42::mod1


// -- Model dump after env processor simplifier:
module 0x42::mod1 {
    struct S {
        x: u64,
    }
    struct Sboth {
        x: u64,
    }
    struct Scopy {
        x: u64,
    }
    struct Sstore {
        x: u64,
    }
    public fun base_fun(a: S,b: u64): u64 {
        Mul<u64>(select mod1::S.x<S>(a), b)
    }
    public fun base_fun2(a: u64,b: S): u64 {
        Mul<u64>(a, select mod1::S.x<S>(b))
    }
    public fun both_fun(a: Sboth,b: u64): u64 {
        Mul<u64>(select mod1::Sboth.x<Sboth>(a), b)
    }
    public fun both_fun2(a: u64,b: Sboth): u64 {
        Mul<u64>(a, select mod1::Sboth.x<Sboth>(b))
    }
    public fun copy_fun(a: Scopy,b: u64): u64 {
        Mul<u64>(select mod1::Scopy.x<Scopy>(a), b)
    }
    public fun copy_fun2(a: u64,b: Scopy): u64 {
        Mul<u64>(a, select mod1::Scopy.x<Scopy>(b))
    }
    public fun return_function_base(key: u64,x: u64): |u64|u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                     move|x: u64| mod1::base_fun(a, x)
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_both(key: u64,x: u64): |u64|u64 with copy+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                     move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_copy(key: u64,x: u64): |u64|u64 with copy {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                     move|x: u64| mod1::base_fun(a, x) with copy, drop
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_store(key: u64,x: u64): |u64|u64 with store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                     move|x: u64| mod1::base_fun(a, x) with drop, store
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun store_fun(a: Sstore,b: u64): u64 {
        Mul<u64>(select mod1::Sstore.x<Sstore>(a), b)
    }
    public fun store_fun2(a: u64,b: Sstore): u64 {
        Mul<u64>(a, select mod1::Sstore.x<Sstore>(b))
    }
    public fun use_function_base(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                     move|x: u64| mod1::base_fun(a, x)
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_both(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                     move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_copy(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                     move|x: u64| mod1::base_fun(a, x) with copy, drop
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_store(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+store = if Eq<u64>(key, 0) {
                     move|x: u64| mod1::base_fun(a, x) with drop, store
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
} // end 0x42::mod1



Diagnostics:
warning: Unused local variable `x`. Consider removing or prefixing with an underscore: `_x`
   ┌─ tests/lambda/storable/closure_args.move:58:21
   │
58 │                 let x = 3;
   │                     ^

warning: Unused parameter `x`. Consider removing or prefixing with an underscore: `_x`
   ┌─ tests/lambda/storable/closure_args.move:80:47
   │
80 │     public fun return_function_base(key: u64, x: u64): |u64|u64 {
   │                                               ^

warning: Unused local variable `x`. Consider removing or prefixing with an underscore: `_x`
   ┌─ tests/lambda/storable/closure_args.move:87:21
   │
87 │                 let x = 3;
   │                     ^

warning: Unused local variable `x`. Consider removing or prefixing with an underscore: `_x`
    ┌─ tests/lambda/storable/closure_args.move:118:21
    │
118 │                 let x = 3;
    │                     ^

error: Lambda captures free variables with types that do not have some declared abilities: copy
    ┌─ tests/lambda/storable/closure_args.move:119:17
    │
119 │                 move |x| base_fun(a, x) with copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    │                                   │
    │                                   Captured free value is missing abilities: copy

error: Lambda captures free variables with types that do not have some declared abilities: copy
    ┌─ tests/lambda/storable/closure_args.move:127:17
    │
127 │                 move |x| store_fun(a_store, x) with copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    │                                    │
    │                                    Captured free value is missing abilities: copy

warning: Unused parameter `x`. Consider removing or prefixing with an underscore: `_x`
    ┌─ tests/lambda/storable/closure_args.move:140:47
    │
140 │     public fun return_function_copy(key: u64, x: u64): |u64|u64 with copy {
    │                                               ^

warning: Unused local variable `x`. Consider removing or prefixing with an underscore: `_x`
    ┌─ tests/lambda/storable/closure_args.move:147:21
    │
147 │                 let x = 3;
    │                     ^

error: Lambda captures free variables with types that do not have some declared abilities: copy
    ┌─ tests/lambda/storable/closure_args.move:148:17
    │
148 │                 move |x| base_fun(a, x) with copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    │                                   │
    │                                   Captured free value is missing abilities: copy

error: Lambda captures free variables with types that do not have some declared abilities: copy
    ┌─ tests/lambda/storable/closure_args.move:156:17
    │
156 │                 move |x| store_fun(a_store, x) with copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    │                                    │
    │                                    Captured free value is missing abilities: copy

warning: Unused local variable `x`. Consider removing or prefixing with an underscore: `_x`
    ┌─ tests/lambda/storable/closure_args.move:177:21
    │
177 │                 let x = 3;
    │                     ^

error: Lambda captures free variables with types that do not have some declared abilities: store
    ┌─ tests/lambda/storable/closure_args.move:178:17
    │
178 │                 move |x| base_fun(a, x) with store
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    │                                   │
    │                                   Captured free value is missing abilities: store

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:178:17
    │
178 │                 move |x| base_fun(a, x) with store
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:180:17
    │
180 │                 move |x| base_fun2(x, a) with store
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Lambda captures free variables with types that do not have some declared abilities: store
    ┌─ tests/lambda/storable/closure_args.move:182:17
    │
182 │                 move |x| copy_fun(a_copy, x) with store
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    │                                   │
    │                                   Captured free value is missing abilities: store

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:182:17
    │
182 │                 move |x| copy_fun(a_copy, x) with store
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:184:17
    │
184 │                 move |x| copy_fun2(x, a_copy) with store
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:188:17
    │
188 │                 move |x| store_fun2(x, a_store) with store
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:192:17
    │
192 │                 move |x| both_fun2(x, a_both) with store
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:194:17
    │
194 │                 move |x| x * 2 with store
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: Unused parameter `x`. Consider removing or prefixing with an underscore: `_x`
    ┌─ tests/lambda/storable/closure_args.move:199:48
    │
199 │     public fun return_function_store(key: u64, x: u64): |u64|u64 with store {
    │                                                ^

warning: Unused local variable `x`. Consider removing or prefixing with an underscore: `_x`
    ┌─ tests/lambda/storable/closure_args.move:206:21
    │
206 │                 let x = 3;
    │                     ^

error: Lambda captures free variables with types that do not have some declared abilities: store
    ┌─ tests/lambda/storable/closure_args.move:207:17
    │
207 │                 move |x| base_fun(a, x) with store
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    │                                   │
    │                                   Captured free value is missing abilities: store

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:207:17
    │
207 │                 move |x| base_fun(a, x) with store
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:209:17
    │
209 │                 move |x| base_fun2(x, a) with store
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Lambda captures free variables with types that do not have some declared abilities: store
    ┌─ tests/lambda/storable/closure_args.move:211:17
    │
211 │                 move |x| copy_fun(a_copy, x) with store
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    │                                   │
    │                                   Captured free value is missing abilities: store

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:211:17
    │
211 │                 move |x| copy_fun(a_copy, x) with store
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:213:17
    │
213 │                 move |x| copy_fun2(x, a_copy) with store
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:217:17
    │
217 │                 move |x| store_fun2(x, a_store) with store
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:221:17
    │
221 │                 move |x| both_fun2(x, a_both) with store
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:223:17
    │
223 │                 move |x| x * 2 with store
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: Unused local variable `x`. Consider removing or prefixing with an underscore: `_x`
    ┌─ tests/lambda/storable/closure_args.move:237:21
    │
237 │                 let x = 3;
    │                     ^

error: Lambda captures free variables with types that do not have some declared abilities: copy + store
    ┌─ tests/lambda/storable/closure_args.move:238:17
    │
238 │                 move |x| base_fun(a, x) with store+copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    │                                   │
    │                                   Captured free value is missing abilities: copy + store

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:238:17
    │
238 │                 move |x| base_fun(a, x) with store+copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:240:17
    │
240 │                 move |x| base_fun2(x, a) with store+copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Lambda captures free variables with types that do not have some declared abilities: store
    ┌─ tests/lambda/storable/closure_args.move:242:17
    │
242 │                 move |x| copy_fun(a_copy, x) with store+copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    │                                   │
    │                                   Captured free value is missing abilities: store

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:242:17
    │
242 │                 move |x| copy_fun(a_copy, x) with store+copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:244:17
    │
244 │                 move |x| copy_fun2(x, a_copy) with store+copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Lambda captures free variables with types that do not have some declared abilities: copy
    ┌─ tests/lambda/storable/closure_args.move:246:17
    │
246 │                 move |x| store_fun(a_store, x) with store+copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    │                                    │
    │                                    Captured free value is missing abilities: copy

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:246:17
    │
246 │                 move |x| store_fun(a_store, x) with store+copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:248:17
    │
248 │                 move |x| store_fun2(x, a_store) with store+copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:252:17
    │
252 │                 move |x| both_fun2(x, a_both) with store+copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:254:17
    │
254 │                 move |x| x * 2 with store+copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: Unused parameter `x`. Consider removing or prefixing with an underscore: `_x`
    ┌─ tests/lambda/storable/closure_args.move:259:47
    │
259 │     public fun return_function_both(key: u64, x: u64): |u64|u64 with store+copy {
    │                                               ^

warning: Unused local variable `x`. Consider removing or prefixing with an underscore: `_x`
    ┌─ tests/lambda/storable/closure_args.move:266:21
    │
266 │                 let x = 3;
    │                     ^

error: Lambda captures free variables with types that do not have some declared abilities: copy + store
    ┌─ tests/lambda/storable/closure_args.move:267:17
    │
267 │                 move |x| base_fun(a, x) with store+copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    │                                   │
    │                                   Captured free value is missing abilities: copy + store

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:267:17
    │
267 │                 move |x| base_fun(a, x) with store+copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:269:17
    │
269 │                 move |x| base_fun2(x, a) with store+copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Lambda captures free variables with types that do not have some declared abilities: store
    ┌─ tests/lambda/storable/closure_args.move:271:17
    │
271 │                 move |x| copy_fun(a_copy, x) with store+copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    │                                   │
    │                                   Captured free value is missing abilities: store

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:271:17
    │
271 │                 move |x| copy_fun(a_copy, x) with store+copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:273:17
    │
273 │                 move |x| copy_fun2(x, a_copy) with store+copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Lambda captures free variables with types that do not have some declared abilities: copy
    ┌─ tests/lambda/storable/closure_args.move:275:17
    │
275 │                 move |x| store_fun(a_store, x) with store+copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    │                                    │
    │                                    Captured free value is missing abilities: copy

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:275:17
    │
275 │                 move |x| store_fun(a_store, x) with store+copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:277:17
    │
277 │                 move |x| store_fun2(x, a_store) with store+copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:281:17
    │
281 │                 move |x| both_fun2(x, a_both) with store+copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
    ┌─ tests/lambda/storable/closure_args.move:283:17
    │
283 │                 move |x| x * 2 with store+copy
    │                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
