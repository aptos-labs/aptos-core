// -- Model dump before env processor pipeline:
module 0x42::mod1 {
    struct S {
        x: u64,
    }
    struct Sboth {
        x: u64,
    }
    struct Scopy {
        x: u64,
    }
    struct Sstore {
        x: u64,
    }
    public fun base_fun(a: S,b: u64): u64 {
        Mul<u64>(select mod1::S.x<S>(a), b)
    }
    public fun base_fun2(a: u64,b: S): u64 {
        Mul<u64>(a, select mod1::S.x<S>(b))
    }
    public fun both_fun(a: Sboth,b: u64): u64 {
        Mul<u64>(select mod1::Sboth.x<Sboth>(a), b)
    }
    public fun both_fun2(a: u64,b: Sboth): u64 {
        Mul<u64>(a, select mod1::Sboth.x<Sboth>(b))
    }
    public fun copy_fun(a: Scopy,b: u64): u64 {
        Mul<u64>(select mod1::Scopy.x<Scopy>(a), b)
    }
    public fun copy_fun2(a: u64,b: Scopy): u64 {
        Mul<u64>(a, select mod1::Scopy.x<Scopy>(b))
    }
    public fun return_function_base(key: u64,x: u64): |u64|u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_both(key: u64,x: u64): |u64|u64 with copy+drop+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_copy(key: u64,x: u64): |u64|u64 with copy+drop {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_store(key: u64,x: u64): |u64|u64 with drop+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun store_fun(a: Sstore,b: u64): u64 {
        Mul<u64>(select mod1::Sstore.x<Sstore>(a), b)
    }
    public fun store_fun2(a: u64,b: Sstore): u64 {
        Mul<u64>(a, select mod1::Sstore.x<Sstore>(b))
    }
    public fun use_function_base(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_both(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_copy(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_store(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
} // end 0x42::mod1


// -- Model dump after env processor unused checks:
module 0x42::mod1 {
    struct S {
        x: u64,
    }
    struct Sboth {
        x: u64,
    }
    struct Scopy {
        x: u64,
    }
    struct Sstore {
        x: u64,
    }
    public fun base_fun(a: S,b: u64): u64 {
        Mul<u64>(select mod1::S.x<S>(a), b)
    }
    public fun base_fun2(a: u64,b: S): u64 {
        Mul<u64>(a, select mod1::S.x<S>(b))
    }
    public fun both_fun(a: Sboth,b: u64): u64 {
        Mul<u64>(select mod1::Sboth.x<Sboth>(a), b)
    }
    public fun both_fun2(a: u64,b: Sboth): u64 {
        Mul<u64>(a, select mod1::Sboth.x<Sboth>(b))
    }
    public fun copy_fun(a: Scopy,b: u64): u64 {
        Mul<u64>(select mod1::Scopy.x<Scopy>(a), b)
    }
    public fun copy_fun2(a: u64,b: Scopy): u64 {
        Mul<u64>(a, select mod1::Scopy.x<Scopy>(b))
    }
    public fun return_function_base(key: u64,x: u64): |u64|u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_both(key: u64,x: u64): |u64|u64 with copy+drop+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_copy(key: u64,x: u64): |u64|u64 with copy+drop {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_store(key: u64,x: u64): |u64|u64 with drop+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun store_fun(a: Sstore,b: u64): u64 {
        Mul<u64>(select mod1::Sstore.x<Sstore>(a), b)
    }
    public fun store_fun2(a: u64,b: Sstore): u64 {
        Mul<u64>(a, select mod1::Sstore.x<Sstore>(b))
    }
    public fun use_function_base(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_both(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_copy(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_store(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
} // end 0x42::mod1


// -- Model dump after env processor type parameter check:
module 0x42::mod1 {
    struct S {
        x: u64,
    }
    struct Sboth {
        x: u64,
    }
    struct Scopy {
        x: u64,
    }
    struct Sstore {
        x: u64,
    }
    public fun base_fun(a: S,b: u64): u64 {
        Mul<u64>(select mod1::S.x<S>(a), b)
    }
    public fun base_fun2(a: u64,b: S): u64 {
        Mul<u64>(a, select mod1::S.x<S>(b))
    }
    public fun both_fun(a: Sboth,b: u64): u64 {
        Mul<u64>(select mod1::Sboth.x<Sboth>(a), b)
    }
    public fun both_fun2(a: u64,b: Sboth): u64 {
        Mul<u64>(a, select mod1::Sboth.x<Sboth>(b))
    }
    public fun copy_fun(a: Scopy,b: u64): u64 {
        Mul<u64>(select mod1::Scopy.x<Scopy>(a), b)
    }
    public fun copy_fun2(a: u64,b: Scopy): u64 {
        Mul<u64>(a, select mod1::Scopy.x<Scopy>(b))
    }
    public fun return_function_base(key: u64,x: u64): |u64|u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_both(key: u64,x: u64): |u64|u64 with copy+drop+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_copy(key: u64,x: u64): |u64|u64 with copy+drop {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_store(key: u64,x: u64): |u64|u64 with drop+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun store_fun(a: Sstore,b: u64): u64 {
        Mul<u64>(select mod1::Sstore.x<Sstore>(a), b)
    }
    public fun store_fun2(a: u64,b: Sstore): u64 {
        Mul<u64>(a, select mod1::Sstore.x<Sstore>(b))
    }
    public fun use_function_base(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_both(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_copy(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_store(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
} // end 0x42::mod1


// -- Model dump after env processor check recursive struct definition:
module 0x42::mod1 {
    struct S {
        x: u64,
    }
    struct Sboth {
        x: u64,
    }
    struct Scopy {
        x: u64,
    }
    struct Sstore {
        x: u64,
    }
    public fun base_fun(a: S,b: u64): u64 {
        Mul<u64>(select mod1::S.x<S>(a), b)
    }
    public fun base_fun2(a: u64,b: S): u64 {
        Mul<u64>(a, select mod1::S.x<S>(b))
    }
    public fun both_fun(a: Sboth,b: u64): u64 {
        Mul<u64>(select mod1::Sboth.x<Sboth>(a), b)
    }
    public fun both_fun2(a: u64,b: Sboth): u64 {
        Mul<u64>(a, select mod1::Sboth.x<Sboth>(b))
    }
    public fun copy_fun(a: Scopy,b: u64): u64 {
        Mul<u64>(select mod1::Scopy.x<Scopy>(a), b)
    }
    public fun copy_fun2(a: u64,b: Scopy): u64 {
        Mul<u64>(a, select mod1::Scopy.x<Scopy>(b))
    }
    public fun return_function_base(key: u64,x: u64): |u64|u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_both(key: u64,x: u64): |u64|u64 with copy+drop+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_copy(key: u64,x: u64): |u64|u64 with copy+drop {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_store(key: u64,x: u64): |u64|u64 with drop+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun store_fun(a: Sstore,b: u64): u64 {
        Mul<u64>(select mod1::Sstore.x<Sstore>(a), b)
    }
    public fun store_fun2(a: u64,b: Sstore): u64 {
        Mul<u64>(a, select mod1::Sstore.x<Sstore>(b))
    }
    public fun use_function_base(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_both(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_copy(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_store(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
} // end 0x42::mod1


// -- Model dump after env processor check cyclic type instantiation:
module 0x42::mod1 {
    struct S {
        x: u64,
    }
    struct Sboth {
        x: u64,
    }
    struct Scopy {
        x: u64,
    }
    struct Sstore {
        x: u64,
    }
    public fun base_fun(a: S,b: u64): u64 {
        Mul<u64>(select mod1::S.x<S>(a), b)
    }
    public fun base_fun2(a: u64,b: S): u64 {
        Mul<u64>(a, select mod1::S.x<S>(b))
    }
    public fun both_fun(a: Sboth,b: u64): u64 {
        Mul<u64>(select mod1::Sboth.x<Sboth>(a), b)
    }
    public fun both_fun2(a: u64,b: Sboth): u64 {
        Mul<u64>(a, select mod1::Sboth.x<Sboth>(b))
    }
    public fun copy_fun(a: Scopy,b: u64): u64 {
        Mul<u64>(select mod1::Scopy.x<Scopy>(a), b)
    }
    public fun copy_fun2(a: u64,b: Scopy): u64 {
        Mul<u64>(a, select mod1::Scopy.x<Scopy>(b))
    }
    public fun return_function_base(key: u64,x: u64): |u64|u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_both(key: u64,x: u64): |u64|u64 with copy+drop+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_copy(key: u64,x: u64): |u64|u64 with copy+drop {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_store(key: u64,x: u64): |u64|u64 with drop+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun store_fun(a: Sstore,b: u64): u64 {
        Mul<u64>(select mod1::Sstore.x<Sstore>(a), b)
    }
    public fun store_fun2(a: u64,b: Sstore): u64 {
        Mul<u64>(a, select mod1::Sstore.x<Sstore>(b))
    }
    public fun use_function_base(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_both(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_copy(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_store(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
} // end 0x42::mod1


// -- Model dump after env processor unused struct params check:
module 0x42::mod1 {
    struct S {
        x: u64,
    }
    struct Sboth {
        x: u64,
    }
    struct Scopy {
        x: u64,
    }
    struct Sstore {
        x: u64,
    }
    public fun base_fun(a: S,b: u64): u64 {
        Mul<u64>(select mod1::S.x<S>(a), b)
    }
    public fun base_fun2(a: u64,b: S): u64 {
        Mul<u64>(a, select mod1::S.x<S>(b))
    }
    public fun both_fun(a: Sboth,b: u64): u64 {
        Mul<u64>(select mod1::Sboth.x<Sboth>(a), b)
    }
    public fun both_fun2(a: u64,b: Sboth): u64 {
        Mul<u64>(a, select mod1::Sboth.x<Sboth>(b))
    }
    public fun copy_fun(a: Scopy,b: u64): u64 {
        Mul<u64>(select mod1::Scopy.x<Scopy>(a), b)
    }
    public fun copy_fun2(a: u64,b: Scopy): u64 {
        Mul<u64>(a, select mod1::Scopy.x<Scopy>(b))
    }
    public fun return_function_base(key: u64,x: u64): |u64|u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_both(key: u64,x: u64): |u64|u64 with copy+drop+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_copy(key: u64,x: u64): |u64|u64 with copy+drop {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_store(key: u64,x: u64): |u64|u64 with drop+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun store_fun(a: Sstore,b: u64): u64 {
        Mul<u64>(select mod1::Sstore.x<Sstore>(a), b)
    }
    public fun store_fun2(a: u64,b: Sstore): u64 {
        Mul<u64>(a, select mod1::Sstore.x<Sstore>(b))
    }
    public fun use_function_base(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_both(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_copy(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_store(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
} // end 0x42::mod1


// -- Model dump after env processor access and use check before inlining:
module 0x42::mod1 {
    struct S {
        x: u64,
    }
    struct Sboth {
        x: u64,
    }
    struct Scopy {
        x: u64,
    }
    struct Sstore {
        x: u64,
    }
    public fun base_fun(a: S,b: u64): u64 {
        Mul<u64>(select mod1::S.x<S>(a), b)
    }
    public fun base_fun2(a: u64,b: S): u64 {
        Mul<u64>(a, select mod1::S.x<S>(b))
    }
    public fun both_fun(a: Sboth,b: u64): u64 {
        Mul<u64>(select mod1::Sboth.x<Sboth>(a), b)
    }
    public fun both_fun2(a: u64,b: Sboth): u64 {
        Mul<u64>(a, select mod1::Sboth.x<Sboth>(b))
    }
    public fun copy_fun(a: Scopy,b: u64): u64 {
        Mul<u64>(select mod1::Scopy.x<Scopy>(a), b)
    }
    public fun copy_fun2(a: u64,b: Scopy): u64 {
        Mul<u64>(a, select mod1::Scopy.x<Scopy>(b))
    }
    public fun return_function_base(key: u64,x: u64): |u64|u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_both(key: u64,x: u64): |u64|u64 with copy+drop+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_copy(key: u64,x: u64): |u64|u64 with copy+drop {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_store(key: u64,x: u64): |u64|u64 with drop+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun store_fun(a: Sstore,b: u64): u64 {
        Mul<u64>(select mod1::Sstore.x<Sstore>(a), b)
    }
    public fun store_fun2(a: u64,b: Sstore): u64 {
        Mul<u64>(a, select mod1::Sstore.x<Sstore>(b))
    }
    public fun use_function_base(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_both(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_copy(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_store(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
} // end 0x42::mod1


// -- Model dump after env processor inlining:
module 0x42::mod1 {
    struct S {
        x: u64,
    }
    struct Sboth {
        x: u64,
    }
    struct Scopy {
        x: u64,
    }
    struct Sstore {
        x: u64,
    }
    public fun base_fun(a: S,b: u64): u64 {
        Mul<u64>(select mod1::S.x<S>(a), b)
    }
    public fun base_fun2(a: u64,b: S): u64 {
        Mul<u64>(a, select mod1::S.x<S>(b))
    }
    public fun both_fun(a: Sboth,b: u64): u64 {
        Mul<u64>(select mod1::Sboth.x<Sboth>(a), b)
    }
    public fun both_fun2(a: u64,b: Sboth): u64 {
        Mul<u64>(a, select mod1::Sboth.x<Sboth>(b))
    }
    public fun copy_fun(a: Scopy,b: u64): u64 {
        Mul<u64>(select mod1::Scopy.x<Scopy>(a), b)
    }
    public fun copy_fun2(a: u64,b: Scopy): u64 {
        Mul<u64>(a, select mod1::Scopy.x<Scopy>(b))
    }
    public fun return_function_base(key: u64,x: u64): |u64|u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_both(key: u64,x: u64): |u64|u64 with copy+drop+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_copy(key: u64,x: u64): |u64|u64 with copy+drop {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_store(key: u64,x: u64): |u64|u64 with drop+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun store_fun(a: Sstore,b: u64): u64 {
        Mul<u64>(select mod1::Sstore.x<Sstore>(a), b)
    }
    public fun store_fun2(a: u64,b: Sstore): u64 {
        Mul<u64>(a, select mod1::Sstore.x<Sstore>(b))
    }
    public fun use_function_base(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_both(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_copy(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_store(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
} // end 0x42::mod1


// -- Model dump after env processor access and use check after inlining:
module 0x42::mod1 {
    struct S {
        x: u64,
    }
    struct Sboth {
        x: u64,
    }
    struct Scopy {
        x: u64,
    }
    struct Sstore {
        x: u64,
    }
    public fun base_fun(a: S,b: u64): u64 {
        Mul<u64>(select mod1::S.x<S>(a), b)
    }
    public fun base_fun2(a: u64,b: S): u64 {
        Mul<u64>(a, select mod1::S.x<S>(b))
    }
    public fun both_fun(a: Sboth,b: u64): u64 {
        Mul<u64>(select mod1::Sboth.x<Sboth>(a), b)
    }
    public fun both_fun2(a: u64,b: Sboth): u64 {
        Mul<u64>(a, select mod1::Sboth.x<Sboth>(b))
    }
    public fun copy_fun(a: Scopy,b: u64): u64 {
        Mul<u64>(select mod1::Scopy.x<Scopy>(a), b)
    }
    public fun copy_fun2(a: u64,b: Scopy): u64 {
        Mul<u64>(a, select mod1::Scopy.x<Scopy>(b))
    }
    public fun return_function_base(key: u64,x: u64): |u64|u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_both(key: u64,x: u64): |u64|u64 with copy+drop+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_copy(key: u64,x: u64): |u64|u64 with copy+drop {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_store(key: u64,x: u64): |u64|u64 with drop+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun store_fun(a: Sstore,b: u64): u64 {
        Mul<u64>(select mod1::Sstore.x<Sstore>(a), b)
    }
    public fun store_fun2(a: u64,b: Sstore): u64 {
        Mul<u64>(a, select mod1::Sstore.x<Sstore>(b))
    }
    public fun use_function_base(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_both(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_copy(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_store(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
} // end 0x42::mod1


// -- Model dump after env processor acquires check:
module 0x42::mod1 {
    struct S {
        x: u64,
    }
    struct Sboth {
        x: u64,
    }
    struct Scopy {
        x: u64,
    }
    struct Sstore {
        x: u64,
    }
    public fun base_fun(a: S,b: u64): u64 {
        Mul<u64>(select mod1::S.x<S>(a), b)
    }
    public fun base_fun2(a: u64,b: S): u64 {
        Mul<u64>(a, select mod1::S.x<S>(b))
    }
    public fun both_fun(a: Sboth,b: u64): u64 {
        Mul<u64>(select mod1::Sboth.x<Sboth>(a), b)
    }
    public fun both_fun2(a: u64,b: Sboth): u64 {
        Mul<u64>(a, select mod1::Sboth.x<Sboth>(b))
    }
    public fun copy_fun(a: Scopy,b: u64): u64 {
        Mul<u64>(select mod1::Scopy.x<Scopy>(a), b)
    }
    public fun copy_fun2(a: u64,b: Scopy): u64 {
        Mul<u64>(a, select mod1::Scopy.x<Scopy>(b))
    }
    public fun return_function_base(key: u64,x: u64): |u64|u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_both(key: u64,x: u64): |u64|u64 with copy+drop+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_copy(key: u64,x: u64): |u64|u64 with copy+drop {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_store(key: u64,x: u64): |u64|u64 with drop+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun store_fun(a: Sstore,b: u64): u64 {
        Mul<u64>(select mod1::Sstore.x<Sstore>(a), b)
    }
    public fun store_fun2(a: u64,b: Sstore): u64 {
        Mul<u64>(a, select mod1::Sstore.x<Sstore>(b))
    }
    public fun use_function_base(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x)
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_both(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_copy(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with copy, drop
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_store(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                    {
                      let x: u64 = 3;
                       move|x: u64| mod1::base_fun(a, x) with drop, store
                    }
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
} // end 0x42::mod1


// -- Model dump after env processor simplifier:
module 0x42::mod1 {
    struct S {
        x: u64,
    }
    struct Sboth {
        x: u64,
    }
    struct Scopy {
        x: u64,
    }
    struct Sstore {
        x: u64,
    }
    public fun base_fun(a: S,b: u64): u64 {
        Mul<u64>(select mod1::S.x<S>(a), b)
    }
    public fun base_fun2(a: u64,b: S): u64 {
        Mul<u64>(a, select mod1::S.x<S>(b))
    }
    public fun both_fun(a: Sboth,b: u64): u64 {
        Mul<u64>(select mod1::Sboth.x<Sboth>(a), b)
    }
    public fun both_fun2(a: u64,b: Sboth): u64 {
        Mul<u64>(a, select mod1::Sboth.x<Sboth>(b))
    }
    public fun copy_fun(a: Scopy,b: u64): u64 {
        Mul<u64>(select mod1::Scopy.x<Scopy>(a), b)
    }
    public fun copy_fun2(a: u64,b: Scopy): u64 {
        Mul<u64>(a, select mod1::Scopy.x<Scopy>(b))
    }
    public fun return_function_base(key: u64,x: u64): |u64|u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                     move|x: u64| mod1::base_fun(a, x)
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_both(key: u64,x: u64): |u64|u64 with copy+drop+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                     move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_copy(key: u64,x: u64): |u64|u64 with copy+drop {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                     move|x: u64| mod1::base_fun(a, x) with copy, drop
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun return_function_store(key: u64,x: u64): |u64|u64 with drop+store {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                     move|x: u64| mod1::base_fun(a, x) with drop, store
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  f
                }
              }
            }
          }
        }
    }
    public fun store_fun(a: Sstore,b: u64): u64 {
        Mul<u64>(select mod1::Sstore.x<Sstore>(a), b)
    }
    public fun store_fun2(a: u64,b: Sstore): u64 {
        Mul<u64>(a, select mod1::Sstore.x<Sstore>(b))
    }
    public fun use_function_base(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                     move|x: u64| mod1::base_fun(a, x)
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a)
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x)
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy)
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x)
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store)
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x)
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both)
                                } else {
                                   move|x: u64| Mul<u64>(x, 2)
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_both(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                     move|x: u64| mod1::base_fun(a, x) with copy, drop, store
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_copy(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                     move|x: u64| mod1::base_fun(a, x) with copy, drop
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with copy, drop
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with copy, drop
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with copy, drop
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with copy, drop
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with copy, drop
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with copy, drop
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with copy, drop
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with copy, drop
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
    public fun use_function_store(key: u64,x: u64): u64 {
        {
          let a: S = pack mod1::S(2);
          {
            let a_copy: Scopy = pack mod1::Scopy(2);
            {
              let a_store: Sstore = pack mod1::Sstore(2);
              {
                let a_both: Sboth = pack mod1::Sboth(2);
                {
                  let f: |u64|u64 with copy+drop+store = if Eq<u64>(key, 0) {
                     move|x: u64| mod1::base_fun(a, x) with drop, store
                  } else {
                    if Eq<u64>(key, 1) {
                       move|x: u64| mod1::base_fun2(x, a) with drop, store
                    } else {
                      if Eq<u64>(key, 2) {
                         move|x: u64| mod1::copy_fun(a_copy, x) with drop, store
                      } else {
                        if Eq<u64>(key, 3) {
                           move|x: u64| mod1::copy_fun2(x, a_copy) with drop, store
                        } else {
                          if Eq<u64>(key, 4) {
                             move|x: u64| mod1::store_fun(a_store, x) with drop, store
                          } else {
                            if Eq<u64>(key, 5) {
                               move|x: u64| mod1::store_fun2(x, a_store) with drop, store
                            } else {
                              if Eq<u64>(key, 6) {
                                 move|x: u64| mod1::both_fun(a_both, x) with drop, store
                              } else {
                                if Eq<u64>(key, 7) {
                                   move|x: u64| mod1::both_fun2(x, a_both) with drop, store
                                } else {
                                   move|x: u64| Mul<u64>(x, 2) with drop, store
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  };
                  (f)(x)
                }
              }
            }
          }
        }
    }
} // end 0x42::mod1



Diagnostics:
warning: Unused local variable `x`. Consider removing or prefixing with an underscore: `_x`
    tests/lambda/storable/closure_args.move:58:21
   
58                  let x = 3;
                        ^

warning: Unused parameter `x`. Consider removing or prefixing with an underscore: `_x`
    tests/lambda/storable/closure_args.move:80:47
   
80      public fun return_function_base(key: u64, x: u64): |u64|u64 {
                                                  ^

warning: Unused local variable `x`. Consider removing or prefixing with an underscore: `_x`
    tests/lambda/storable/closure_args.move:87:21
   
87                  let x = 3;
                        ^

warning: Unused local variable `x`. Consider removing or prefixing with an underscore: `_x`
     tests/lambda/storable/closure_args.move:118:21
    
118                  let x = 3;
                         ^

error: Lambda captures free variables with types that do not have some declared abilities: copy
     tests/lambda/storable/closure_args.move:119:17
    
119                  move |x| base_fun(a, x) with copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                                       
                                       Captured free value is missing abilities: copy

error: Lambda captures free variables with types that do not have some declared abilities: copy
     tests/lambda/storable/closure_args.move:127:17
    
127                  move |x| store_fun(a_store, x) with copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                                        
                                        Captured free value is missing abilities: copy

warning: Unused parameter `x`. Consider removing or prefixing with an underscore: `_x`
     tests/lambda/storable/closure_args.move:140:47
    
140      public fun return_function_copy(key: u64, x: u64): |u64|u64 with copy {
                                                   ^

warning: Unused local variable `x`. Consider removing or prefixing with an underscore: `_x`
     tests/lambda/storable/closure_args.move:147:21
    
147                  let x = 3;
                         ^

error: Lambda captures free variables with types that do not have some declared abilities: copy
     tests/lambda/storable/closure_args.move:148:17
    
148                  move |x| base_fun(a, x) with copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                                       
                                       Captured free value is missing abilities: copy

error: Lambda captures free variables with types that do not have some declared abilities: copy
     tests/lambda/storable/closure_args.move:156:17
    
156                  move |x| store_fun(a_store, x) with copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                                        
                                        Captured free value is missing abilities: copy

warning: Unused local variable `x`. Consider removing or prefixing with an underscore: `_x`
     tests/lambda/storable/closure_args.move:177:21
    
177                  let x = 3;
                         ^

error: Lambda captures free variables with types that do not have some declared abilities: store
     tests/lambda/storable/closure_args.move:178:17
    
178                  move |x| base_fun(a, x) with store
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                                       
                                       Captured free value is missing abilities: store

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:178:17
    
178                  move |x| base_fun(a, x) with store
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:180:17
    
180                  move |x| base_fun2(x, a) with store
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Lambda captures free variables with types that do not have some declared abilities: store
     tests/lambda/storable/closure_args.move:182:17
    
182                  move |x| copy_fun(a_copy, x) with store
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                                       
                                       Captured free value is missing abilities: store

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:182:17
    
182                  move |x| copy_fun(a_copy, x) with store
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:184:17
    
184                  move |x| copy_fun2(x, a_copy) with store
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:188:17
    
188                  move |x| store_fun2(x, a_store) with store
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:192:17
    
192                  move |x| both_fun2(x, a_both) with store
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:194:17
    
194                  move |x| x * 2 with store
                     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: Unused parameter `x`. Consider removing or prefixing with an underscore: `_x`
     tests/lambda/storable/closure_args.move:199:48
    
199      public fun return_function_store(key: u64, x: u64): |u64|u64 with store {
                                                    ^

warning: Unused local variable `x`. Consider removing or prefixing with an underscore: `_x`
     tests/lambda/storable/closure_args.move:206:21
    
206                  let x = 3;
                         ^

error: Lambda captures free variables with types that do not have some declared abilities: store
     tests/lambda/storable/closure_args.move:207:17
    
207                  move |x| base_fun(a, x) with store
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                                       
                                       Captured free value is missing abilities: store

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:207:17
    
207                  move |x| base_fun(a, x) with store
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:209:17
    
209                  move |x| base_fun2(x, a) with store
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Lambda captures free variables with types that do not have some declared abilities: store
     tests/lambda/storable/closure_args.move:211:17
    
211                  move |x| copy_fun(a_copy, x) with store
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                                       
                                       Captured free value is missing abilities: store

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:211:17
    
211                  move |x| copy_fun(a_copy, x) with store
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:213:17
    
213                  move |x| copy_fun2(x, a_copy) with store
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:217:17
    
217                  move |x| store_fun2(x, a_store) with store
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:221:17
    
221                  move |x| both_fun2(x, a_both) with store
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:223:17
    
223                  move |x| x * 2 with store
                     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: Unused local variable `x`. Consider removing or prefixing with an underscore: `_x`
     tests/lambda/storable/closure_args.move:237:21
    
237                  let x = 3;
                         ^

error: Lambda captures free variables with types that do not have some declared abilities: copy + store
     tests/lambda/storable/closure_args.move:238:17
    
238                  move |x| base_fun(a, x) with store+copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                                       
                                       Captured free value is missing abilities: copy + store

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:238:17
    
238                  move |x| base_fun(a, x) with store+copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:240:17
    
240                  move |x| base_fun2(x, a) with store+copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Lambda captures free variables with types that do not have some declared abilities: store
     tests/lambda/storable/closure_args.move:242:17
    
242                  move |x| copy_fun(a_copy, x) with store+copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                                       
                                       Captured free value is missing abilities: store

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:242:17
    
242                  move |x| copy_fun(a_copy, x) with store+copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:244:17
    
244                  move |x| copy_fun2(x, a_copy) with store+copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Lambda captures free variables with types that do not have some declared abilities: copy
     tests/lambda/storable/closure_args.move:246:17
    
246                  move |x| store_fun(a_store, x) with store+copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                                        
                                        Captured free value is missing abilities: copy

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:246:17
    
246                  move |x| store_fun(a_store, x) with store+copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:248:17
    
248                  move |x| store_fun2(x, a_store) with store+copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:252:17
    
252                  move |x| both_fun2(x, a_both) with store+copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:254:17
    
254                  move |x| x * 2 with store+copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: Unused parameter `x`. Consider removing or prefixing with an underscore: `_x`
     tests/lambda/storable/closure_args.move:259:47
    
259      public fun return_function_both(key: u64, x: u64): |u64|u64 with store+copy {
                                                   ^

warning: Unused local variable `x`. Consider removing or prefixing with an underscore: `_x`
     tests/lambda/storable/closure_args.move:266:21
    
266                  let x = 3;
                         ^

error: Lambda captures free variables with types that do not have some declared abilities: copy + store
     tests/lambda/storable/closure_args.move:267:17
    
267                  move |x| base_fun(a, x) with store+copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                                       
                                       Captured free value is missing abilities: copy + store

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:267:17
    
267                  move |x| base_fun(a, x) with store+copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:269:17
    
269                  move |x| base_fun2(x, a) with store+copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Lambda captures free variables with types that do not have some declared abilities: store
     tests/lambda/storable/closure_args.move:271:17
    
271                  move |x| copy_fun(a_copy, x) with store+copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                                       
                                       Captured free value is missing abilities: store

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:271:17
    
271                  move |x| copy_fun(a_copy, x) with store+copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:273:17
    
273                  move |x| copy_fun2(x, a_copy) with store+copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Lambda captures free variables with types that do not have some declared abilities: copy
     tests/lambda/storable/closure_args.move:275:17
    
275                  move |x| store_fun(a_store, x) with store+copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                                        
                                        Captured free value is missing abilities: copy

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:275:17
    
275                  move |x| store_fun(a_store, x) with store+copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:277:17
    
277                  move |x| store_fun2(x, a_store) with store+copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:281:17
    
281                  move |x| both_fun2(x, a_both) with store+copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
     tests/lambda/storable/closure_args.move:283:17
    
283                  move |x| x * 2 with store+copy
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
