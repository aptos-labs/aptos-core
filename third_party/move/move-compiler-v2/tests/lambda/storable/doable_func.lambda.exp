// -- Model dump before env processor pipeline:
module 0x42::mod4 {
    public fun alt_multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod4
module 0x42::mod3 {
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod3
module 0x42::mod2 {
    friend fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
} // end 0x42::mod2
module 0x42::mod1 {
    friend fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::mod1
module 0x42::test {
    use 0x42::mod1; // resolved as: 0x42::mod1
    use 0x42::mod2; // resolved as: 0x42::mod2
    use 0x42::mod3; // resolved as: 0x42::mod3
    use 0x42::mod4::{alt_multiply}; // resolved as: 0x42::mod4
    private fun add_mul(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(z, Add<u64>(x, y))
    }
    private fun choose_function1(key: u64,x: u64): u64 {
        {
          let f: |u64|u64 with copy+drop = if Eq<u64>(key, 0) {
            mod2::double
          } else {
            if Eq<u64>(key, 1) {
              mod1::triple
            } else {
              if Eq<u64>(key, 2) {
                 move|x: u64| mod3::multiply(4, x)
              } else {
                if Eq<u64>(key, 3) {
                  {
                    let x: u64 = 5;
                     move|y: u64| mod4::alt_multiply(x, y)
                  }
                } else {
                  if Eq<u64>(key, 4) {
                    {
                      let x: u64 = 6;
                       move|y: u64| mod3::multiply(y, x)
                    }
                  } else {
                    if Eq<u64>(key, 5) {
                       move|x: u64| test::multiply3(x, 3, 2)
                    } else {
                      if Eq<u64>(key, 6) {
                         move|x: u64| mod3::multiply(x, 7)
                      } else {
                        if Eq<u64>(key, 7) {
                           move|x: u64| test::multiply3(4, x, 2)
                        } else {
                          if Eq<u64>(key, 8) {
                             move|x: u64| test::multiply3(3, 3, x)
                          } else {
                            if Eq<u64>(key, 9) {
                              {
                                let x: u64 = 2;
                                {
                                  let y: u64 = 5;
                                   move|z: u64| test::multiply3(x, y, z)
                                }
                              }
                            } else {
                              if Eq<u64>(key, 10) {
                                {
                                  let z: u64 = 11;
                                   move|x: u64| mod4::alt_multiply(x, z) with copy, drop
                                }
                              } else {
                                if Eq<u64>(key, 11) {
                                  {
                                    let g: |(u64, u64)|u64 with copy+drop+store =  move|(x: u64, y: u64): (u64, u64)| mod3::multiply(x, y) with copy, drop;
                                     move|x: u64| (g)(x, 11)
                                  }
                                } else {
                                  if Eq<u64>(key, 12) {
                                    {
                                      let h: |u64|u64 with copy+drop+store =  move|x: u64| mod3::multiply(x, 12) with copy, drop;
                                       move|x: u64| (h)(x) with copy, drop
                                    }
                                  } else {
                                    if Eq<u64>(key, 14) {
                                      {
                                        let i: |u64|u64 with copy+drop+store =  move|x: u64| test::multiply3(2, x, 2);
                                         move|z: u64| (i)(z)
                                      }
                                    } else {
                                      {
                                        let i: |(u64, u64)|u64 with copy+drop+store =  move|(x: u64, y: u64): (u64, u64)| {
                                          let q: u64 = Sub<u64>(y, 1);
                                          mod3::multiply(x, Add<u64>(q, 1))
                                        };
                                         move|x: u64| (i)(x, 15)
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          };
          (f)(x)
        }
    }
    private fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    public fun test_functions() {
        {
          let x: u64 = 3;
          {
            let i: u64 = 0;
            {
              let __update_iter_flag: bool = false;
              {
                let __upper_bound_value: u64 = 15;
                loop {
                  if true {
                    if __update_iter_flag {
                      i: u64 = Add<u64>(i, 1)
                    } else {
                      __update_iter_flag: bool = true
                    };
                    if Lt<u64>(i, __upper_bound_value) {
                      {
                        let y: u64 = test::choose_function1(i, 3);
                        if Eq<u64>(y, Mul<u64>(Add<u64>(i, 2), x)) {
                          Tuple()
                        } else {
                          Abort(i)
                        };
                        Tuple()
                      }
                    } else {
                      break
                    };
                    Tuple()
                  } else {
                    break
                  }
                };
                Tuple()
              }
            }
          }
        }
    }
} // end 0x42::test


// -- Model dump after env processor unused checks:
module 0x42::mod4 {
    public fun alt_multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod4
module 0x42::mod3 {
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod3
module 0x42::mod2 {
    friend fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
} // end 0x42::mod2
module 0x42::mod1 {
    friend fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::mod1
module 0x42::test {
    use 0x42::mod1; // resolved as: 0x42::mod1
    use 0x42::mod2; // resolved as: 0x42::mod2
    use 0x42::mod3; // resolved as: 0x42::mod3
    use 0x42::mod4::{alt_multiply}; // resolved as: 0x42::mod4
    private fun add_mul(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(z, Add<u64>(x, y))
    }
    private fun choose_function1(key: u64,x: u64): u64 {
        {
          let f: |u64|u64 with copy+drop = if Eq<u64>(key, 0) {
            mod2::double
          } else {
            if Eq<u64>(key, 1) {
              mod1::triple
            } else {
              if Eq<u64>(key, 2) {
                 move|x: u64| mod3::multiply(4, x)
              } else {
                if Eq<u64>(key, 3) {
                  {
                    let x: u64 = 5;
                     move|y: u64| mod4::alt_multiply(x, y)
                  }
                } else {
                  if Eq<u64>(key, 4) {
                    {
                      let x: u64 = 6;
                       move|y: u64| mod3::multiply(y, x)
                    }
                  } else {
                    if Eq<u64>(key, 5) {
                       move|x: u64| test::multiply3(x, 3, 2)
                    } else {
                      if Eq<u64>(key, 6) {
                         move|x: u64| mod3::multiply(x, 7)
                      } else {
                        if Eq<u64>(key, 7) {
                           move|x: u64| test::multiply3(4, x, 2)
                        } else {
                          if Eq<u64>(key, 8) {
                             move|x: u64| test::multiply3(3, 3, x)
                          } else {
                            if Eq<u64>(key, 9) {
                              {
                                let x: u64 = 2;
                                {
                                  let y: u64 = 5;
                                   move|z: u64| test::multiply3(x, y, z)
                                }
                              }
                            } else {
                              if Eq<u64>(key, 10) {
                                {
                                  let z: u64 = 11;
                                   move|x: u64| mod4::alt_multiply(x, z) with copy, drop
                                }
                              } else {
                                if Eq<u64>(key, 11) {
                                  {
                                    let g: |(u64, u64)|u64 with copy+drop+store =  move|(x: u64, y: u64): (u64, u64)| mod3::multiply(x, y) with copy, drop;
                                     move|x: u64| (g)(x, 11)
                                  }
                                } else {
                                  if Eq<u64>(key, 12) {
                                    {
                                      let h: |u64|u64 with copy+drop+store =  move|x: u64| mod3::multiply(x, 12) with copy, drop;
                                       move|x: u64| (h)(x) with copy, drop
                                    }
                                  } else {
                                    if Eq<u64>(key, 14) {
                                      {
                                        let i: |u64|u64 with copy+drop+store =  move|x: u64| test::multiply3(2, x, 2);
                                         move|z: u64| (i)(z)
                                      }
                                    } else {
                                      {
                                        let i: |(u64, u64)|u64 with copy+drop+store =  move|(x: u64, y: u64): (u64, u64)| {
                                          let q: u64 = Sub<u64>(y, 1);
                                          mod3::multiply(x, Add<u64>(q, 1))
                                        };
                                         move|x: u64| (i)(x, 15)
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          };
          (f)(x)
        }
    }
    private fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    public fun test_functions() {
        {
          let x: u64 = 3;
          {
            let i: u64 = 0;
            {
              let __update_iter_flag: bool = false;
              {
                let __upper_bound_value: u64 = 15;
                loop {
                  if true {
                    if __update_iter_flag {
                      i: u64 = Add<u64>(i, 1)
                    } else {
                      __update_iter_flag: bool = true
                    };
                    if Lt<u64>(i, __upper_bound_value) {
                      {
                        let y: u64 = test::choose_function1(i, 3);
                        if Eq<u64>(y, Mul<u64>(Add<u64>(i, 2), x)) {
                          Tuple()
                        } else {
                          Abort(i)
                        };
                        Tuple()
                      }
                    } else {
                      break
                    };
                    Tuple()
                  } else {
                    break
                  }
                };
                Tuple()
              }
            }
          }
        }
    }
} // end 0x42::test


// -- Model dump after env processor type parameter check:
module 0x42::mod4 {
    public fun alt_multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod4
module 0x42::mod3 {
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod3
module 0x42::mod2 {
    friend fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
} // end 0x42::mod2
module 0x42::mod1 {
    friend fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::mod1
module 0x42::test {
    use 0x42::mod1; // resolved as: 0x42::mod1
    use 0x42::mod2; // resolved as: 0x42::mod2
    use 0x42::mod3; // resolved as: 0x42::mod3
    use 0x42::mod4::{alt_multiply}; // resolved as: 0x42::mod4
    private fun add_mul(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(z, Add<u64>(x, y))
    }
    private fun choose_function1(key: u64,x: u64): u64 {
        {
          let f: |u64|u64 with copy+drop = if Eq<u64>(key, 0) {
            mod2::double
          } else {
            if Eq<u64>(key, 1) {
              mod1::triple
            } else {
              if Eq<u64>(key, 2) {
                 move|x: u64| mod3::multiply(4, x)
              } else {
                if Eq<u64>(key, 3) {
                  {
                    let x: u64 = 5;
                     move|y: u64| mod4::alt_multiply(x, y)
                  }
                } else {
                  if Eq<u64>(key, 4) {
                    {
                      let x: u64 = 6;
                       move|y: u64| mod3::multiply(y, x)
                    }
                  } else {
                    if Eq<u64>(key, 5) {
                       move|x: u64| test::multiply3(x, 3, 2)
                    } else {
                      if Eq<u64>(key, 6) {
                         move|x: u64| mod3::multiply(x, 7)
                      } else {
                        if Eq<u64>(key, 7) {
                           move|x: u64| test::multiply3(4, x, 2)
                        } else {
                          if Eq<u64>(key, 8) {
                             move|x: u64| test::multiply3(3, 3, x)
                          } else {
                            if Eq<u64>(key, 9) {
                              {
                                let x: u64 = 2;
                                {
                                  let y: u64 = 5;
                                   move|z: u64| test::multiply3(x, y, z)
                                }
                              }
                            } else {
                              if Eq<u64>(key, 10) {
                                {
                                  let z: u64 = 11;
                                   move|x: u64| mod4::alt_multiply(x, z) with copy, drop
                                }
                              } else {
                                if Eq<u64>(key, 11) {
                                  {
                                    let g: |(u64, u64)|u64 with copy+drop+store =  move|(x: u64, y: u64): (u64, u64)| mod3::multiply(x, y) with copy, drop;
                                     move|x: u64| (g)(x, 11)
                                  }
                                } else {
                                  if Eq<u64>(key, 12) {
                                    {
                                      let h: |u64|u64 with copy+drop+store =  move|x: u64| mod3::multiply(x, 12) with copy, drop;
                                       move|x: u64| (h)(x) with copy, drop
                                    }
                                  } else {
                                    if Eq<u64>(key, 14) {
                                      {
                                        let i: |u64|u64 with copy+drop+store =  move|x: u64| test::multiply3(2, x, 2);
                                         move|z: u64| (i)(z)
                                      }
                                    } else {
                                      {
                                        let i: |(u64, u64)|u64 with copy+drop+store =  move|(x: u64, y: u64): (u64, u64)| {
                                          let q: u64 = Sub<u64>(y, 1);
                                          mod3::multiply(x, Add<u64>(q, 1))
                                        };
                                         move|x: u64| (i)(x, 15)
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          };
          (f)(x)
        }
    }
    private fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    public fun test_functions() {
        {
          let x: u64 = 3;
          {
            let i: u64 = 0;
            {
              let __update_iter_flag: bool = false;
              {
                let __upper_bound_value: u64 = 15;
                loop {
                  if true {
                    if __update_iter_flag {
                      i: u64 = Add<u64>(i, 1)
                    } else {
                      __update_iter_flag: bool = true
                    };
                    if Lt<u64>(i, __upper_bound_value) {
                      {
                        let y: u64 = test::choose_function1(i, 3);
                        if Eq<u64>(y, Mul<u64>(Add<u64>(i, 2), x)) {
                          Tuple()
                        } else {
                          Abort(i)
                        };
                        Tuple()
                      }
                    } else {
                      break
                    };
                    Tuple()
                  } else {
                    break
                  }
                };
                Tuple()
              }
            }
          }
        }
    }
} // end 0x42::test


// -- Model dump after env processor check recursive struct definition:
module 0x42::mod4 {
    public fun alt_multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod4
module 0x42::mod3 {
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod3
module 0x42::mod2 {
    friend fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
} // end 0x42::mod2
module 0x42::mod1 {
    friend fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::mod1
module 0x42::test {
    use 0x42::mod1; // resolved as: 0x42::mod1
    use 0x42::mod2; // resolved as: 0x42::mod2
    use 0x42::mod3; // resolved as: 0x42::mod3
    use 0x42::mod4::{alt_multiply}; // resolved as: 0x42::mod4
    private fun add_mul(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(z, Add<u64>(x, y))
    }
    private fun choose_function1(key: u64,x: u64): u64 {
        {
          let f: |u64|u64 with copy+drop = if Eq<u64>(key, 0) {
            mod2::double
          } else {
            if Eq<u64>(key, 1) {
              mod1::triple
            } else {
              if Eq<u64>(key, 2) {
                 move|x: u64| mod3::multiply(4, x)
              } else {
                if Eq<u64>(key, 3) {
                  {
                    let x: u64 = 5;
                     move|y: u64| mod4::alt_multiply(x, y)
                  }
                } else {
                  if Eq<u64>(key, 4) {
                    {
                      let x: u64 = 6;
                       move|y: u64| mod3::multiply(y, x)
                    }
                  } else {
                    if Eq<u64>(key, 5) {
                       move|x: u64| test::multiply3(x, 3, 2)
                    } else {
                      if Eq<u64>(key, 6) {
                         move|x: u64| mod3::multiply(x, 7)
                      } else {
                        if Eq<u64>(key, 7) {
                           move|x: u64| test::multiply3(4, x, 2)
                        } else {
                          if Eq<u64>(key, 8) {
                             move|x: u64| test::multiply3(3, 3, x)
                          } else {
                            if Eq<u64>(key, 9) {
                              {
                                let x: u64 = 2;
                                {
                                  let y: u64 = 5;
                                   move|z: u64| test::multiply3(x, y, z)
                                }
                              }
                            } else {
                              if Eq<u64>(key, 10) {
                                {
                                  let z: u64 = 11;
                                   move|x: u64| mod4::alt_multiply(x, z) with copy, drop
                                }
                              } else {
                                if Eq<u64>(key, 11) {
                                  {
                                    let g: |(u64, u64)|u64 with copy+drop+store =  move|(x: u64, y: u64): (u64, u64)| mod3::multiply(x, y) with copy, drop;
                                     move|x: u64| (g)(x, 11)
                                  }
                                } else {
                                  if Eq<u64>(key, 12) {
                                    {
                                      let h: |u64|u64 with copy+drop+store =  move|x: u64| mod3::multiply(x, 12) with copy, drop;
                                       move|x: u64| (h)(x) with copy, drop
                                    }
                                  } else {
                                    if Eq<u64>(key, 14) {
                                      {
                                        let i: |u64|u64 with copy+drop+store =  move|x: u64| test::multiply3(2, x, 2);
                                         move|z: u64| (i)(z)
                                      }
                                    } else {
                                      {
                                        let i: |(u64, u64)|u64 with copy+drop+store =  move|(x: u64, y: u64): (u64, u64)| {
                                          let q: u64 = Sub<u64>(y, 1);
                                          mod3::multiply(x, Add<u64>(q, 1))
                                        };
                                         move|x: u64| (i)(x, 15)
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          };
          (f)(x)
        }
    }
    private fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    public fun test_functions() {
        {
          let x: u64 = 3;
          {
            let i: u64 = 0;
            {
              let __update_iter_flag: bool = false;
              {
                let __upper_bound_value: u64 = 15;
                loop {
                  if true {
                    if __update_iter_flag {
                      i: u64 = Add<u64>(i, 1)
                    } else {
                      __update_iter_flag: bool = true
                    };
                    if Lt<u64>(i, __upper_bound_value) {
                      {
                        let y: u64 = test::choose_function1(i, 3);
                        if Eq<u64>(y, Mul<u64>(Add<u64>(i, 2), x)) {
                          Tuple()
                        } else {
                          Abort(i)
                        };
                        Tuple()
                      }
                    } else {
                      break
                    };
                    Tuple()
                  } else {
                    break
                  }
                };
                Tuple()
              }
            }
          }
        }
    }
} // end 0x42::test


// -- Model dump after env processor check cyclic type instantiation:
module 0x42::mod4 {
    public fun alt_multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod4
module 0x42::mod3 {
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod3
module 0x42::mod2 {
    friend fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
} // end 0x42::mod2
module 0x42::mod1 {
    friend fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::mod1
module 0x42::test {
    use 0x42::mod1; // resolved as: 0x42::mod1
    use 0x42::mod2; // resolved as: 0x42::mod2
    use 0x42::mod3; // resolved as: 0x42::mod3
    use 0x42::mod4::{alt_multiply}; // resolved as: 0x42::mod4
    private fun add_mul(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(z, Add<u64>(x, y))
    }
    private fun choose_function1(key: u64,x: u64): u64 {
        {
          let f: |u64|u64 with copy+drop = if Eq<u64>(key, 0) {
            mod2::double
          } else {
            if Eq<u64>(key, 1) {
              mod1::triple
            } else {
              if Eq<u64>(key, 2) {
                 move|x: u64| mod3::multiply(4, x)
              } else {
                if Eq<u64>(key, 3) {
                  {
                    let x: u64 = 5;
                     move|y: u64| mod4::alt_multiply(x, y)
                  }
                } else {
                  if Eq<u64>(key, 4) {
                    {
                      let x: u64 = 6;
                       move|y: u64| mod3::multiply(y, x)
                    }
                  } else {
                    if Eq<u64>(key, 5) {
                       move|x: u64| test::multiply3(x, 3, 2)
                    } else {
                      if Eq<u64>(key, 6) {
                         move|x: u64| mod3::multiply(x, 7)
                      } else {
                        if Eq<u64>(key, 7) {
                           move|x: u64| test::multiply3(4, x, 2)
                        } else {
                          if Eq<u64>(key, 8) {
                             move|x: u64| test::multiply3(3, 3, x)
                          } else {
                            if Eq<u64>(key, 9) {
                              {
                                let x: u64 = 2;
                                {
                                  let y: u64 = 5;
                                   move|z: u64| test::multiply3(x, y, z)
                                }
                              }
                            } else {
                              if Eq<u64>(key, 10) {
                                {
                                  let z: u64 = 11;
                                   move|x: u64| mod4::alt_multiply(x, z) with copy, drop
                                }
                              } else {
                                if Eq<u64>(key, 11) {
                                  {
                                    let g: |(u64, u64)|u64 with copy+drop+store =  move|(x: u64, y: u64): (u64, u64)| mod3::multiply(x, y) with copy, drop;
                                     move|x: u64| (g)(x, 11)
                                  }
                                } else {
                                  if Eq<u64>(key, 12) {
                                    {
                                      let h: |u64|u64 with copy+drop+store =  move|x: u64| mod3::multiply(x, 12) with copy, drop;
                                       move|x: u64| (h)(x) with copy, drop
                                    }
                                  } else {
                                    if Eq<u64>(key, 14) {
                                      {
                                        let i: |u64|u64 with copy+drop+store =  move|x: u64| test::multiply3(2, x, 2);
                                         move|z: u64| (i)(z)
                                      }
                                    } else {
                                      {
                                        let i: |(u64, u64)|u64 with copy+drop+store =  move|(x: u64, y: u64): (u64, u64)| {
                                          let q: u64 = Sub<u64>(y, 1);
                                          mod3::multiply(x, Add<u64>(q, 1))
                                        };
                                         move|x: u64| (i)(x, 15)
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          };
          (f)(x)
        }
    }
    private fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    public fun test_functions() {
        {
          let x: u64 = 3;
          {
            let i: u64 = 0;
            {
              let __update_iter_flag: bool = false;
              {
                let __upper_bound_value: u64 = 15;
                loop {
                  if true {
                    if __update_iter_flag {
                      i: u64 = Add<u64>(i, 1)
                    } else {
                      __update_iter_flag: bool = true
                    };
                    if Lt<u64>(i, __upper_bound_value) {
                      {
                        let y: u64 = test::choose_function1(i, 3);
                        if Eq<u64>(y, Mul<u64>(Add<u64>(i, 2), x)) {
                          Tuple()
                        } else {
                          Abort(i)
                        };
                        Tuple()
                      }
                    } else {
                      break
                    };
                    Tuple()
                  } else {
                    break
                  }
                };
                Tuple()
              }
            }
          }
        }
    }
} // end 0x42::test


// -- Model dump after env processor unused struct params check:
module 0x42::mod4 {
    public fun alt_multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod4
module 0x42::mod3 {
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod3
module 0x42::mod2 {
    friend fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
} // end 0x42::mod2
module 0x42::mod1 {
    friend fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::mod1
module 0x42::test {
    use 0x42::mod1; // resolved as: 0x42::mod1
    use 0x42::mod2; // resolved as: 0x42::mod2
    use 0x42::mod3; // resolved as: 0x42::mod3
    use 0x42::mod4::{alt_multiply}; // resolved as: 0x42::mod4
    private fun add_mul(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(z, Add<u64>(x, y))
    }
    private fun choose_function1(key: u64,x: u64): u64 {
        {
          let f: |u64|u64 with copy+drop = if Eq<u64>(key, 0) {
            mod2::double
          } else {
            if Eq<u64>(key, 1) {
              mod1::triple
            } else {
              if Eq<u64>(key, 2) {
                 move|x: u64| mod3::multiply(4, x)
              } else {
                if Eq<u64>(key, 3) {
                  {
                    let x: u64 = 5;
                     move|y: u64| mod4::alt_multiply(x, y)
                  }
                } else {
                  if Eq<u64>(key, 4) {
                    {
                      let x: u64 = 6;
                       move|y: u64| mod3::multiply(y, x)
                    }
                  } else {
                    if Eq<u64>(key, 5) {
                       move|x: u64| test::multiply3(x, 3, 2)
                    } else {
                      if Eq<u64>(key, 6) {
                         move|x: u64| mod3::multiply(x, 7)
                      } else {
                        if Eq<u64>(key, 7) {
                           move|x: u64| test::multiply3(4, x, 2)
                        } else {
                          if Eq<u64>(key, 8) {
                             move|x: u64| test::multiply3(3, 3, x)
                          } else {
                            if Eq<u64>(key, 9) {
                              {
                                let x: u64 = 2;
                                {
                                  let y: u64 = 5;
                                   move|z: u64| test::multiply3(x, y, z)
                                }
                              }
                            } else {
                              if Eq<u64>(key, 10) {
                                {
                                  let z: u64 = 11;
                                   move|x: u64| mod4::alt_multiply(x, z) with copy, drop
                                }
                              } else {
                                if Eq<u64>(key, 11) {
                                  {
                                    let g: |(u64, u64)|u64 with copy+drop+store =  move|(x: u64, y: u64): (u64, u64)| mod3::multiply(x, y) with copy, drop;
                                     move|x: u64| (g)(x, 11)
                                  }
                                } else {
                                  if Eq<u64>(key, 12) {
                                    {
                                      let h: |u64|u64 with copy+drop+store =  move|x: u64| mod3::multiply(x, 12) with copy, drop;
                                       move|x: u64| (h)(x) with copy, drop
                                    }
                                  } else {
                                    if Eq<u64>(key, 14) {
                                      {
                                        let i: |u64|u64 with copy+drop+store =  move|x: u64| test::multiply3(2, x, 2);
                                         move|z: u64| (i)(z)
                                      }
                                    } else {
                                      {
                                        let i: |(u64, u64)|u64 with copy+drop+store =  move|(x: u64, y: u64): (u64, u64)| {
                                          let q: u64 = Sub<u64>(y, 1);
                                          mod3::multiply(x, Add<u64>(q, 1))
                                        };
                                         move|x: u64| (i)(x, 15)
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          };
          (f)(x)
        }
    }
    private fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    public fun test_functions() {
        {
          let x: u64 = 3;
          {
            let i: u64 = 0;
            {
              let __update_iter_flag: bool = false;
              {
                let __upper_bound_value: u64 = 15;
                loop {
                  if true {
                    if __update_iter_flag {
                      i: u64 = Add<u64>(i, 1)
                    } else {
                      __update_iter_flag: bool = true
                    };
                    if Lt<u64>(i, __upper_bound_value) {
                      {
                        let y: u64 = test::choose_function1(i, 3);
                        if Eq<u64>(y, Mul<u64>(Add<u64>(i, 2), x)) {
                          Tuple()
                        } else {
                          Abort(i)
                        };
                        Tuple()
                      }
                    } else {
                      break
                    };
                    Tuple()
                  } else {
                    break
                  }
                };
                Tuple()
              }
            }
          }
        }
    }
} // end 0x42::test


// -- Model dump after env processor access and use check before inlining:
module 0x42::mod4 {
    public fun alt_multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod4
module 0x42::mod3 {
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod3
module 0x42::mod2 {
    friend fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
} // end 0x42::mod2
module 0x42::mod1 {
    friend fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::mod1
module 0x42::test {
    use 0x42::mod1; // resolved as: 0x42::mod1
    use 0x42::mod2; // resolved as: 0x42::mod2
    use 0x42::mod3; // resolved as: 0x42::mod3
    use 0x42::mod4::{alt_multiply}; // resolved as: 0x42::mod4
    private fun add_mul(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(z, Add<u64>(x, y))
    }
    private fun choose_function1(key: u64,x: u64): u64 {
        {
          let f: |u64|u64 with copy+drop = if Eq<u64>(key, 0) {
            mod2::double
          } else {
            if Eq<u64>(key, 1) {
              mod1::triple
            } else {
              if Eq<u64>(key, 2) {
                 move|x: u64| mod3::multiply(4, x)
              } else {
                if Eq<u64>(key, 3) {
                  {
                    let x: u64 = 5;
                     move|y: u64| mod4::alt_multiply(x, y)
                  }
                } else {
                  if Eq<u64>(key, 4) {
                    {
                      let x: u64 = 6;
                       move|y: u64| mod3::multiply(y, x)
                    }
                  } else {
                    if Eq<u64>(key, 5) {
                       move|x: u64| test::multiply3(x, 3, 2)
                    } else {
                      if Eq<u64>(key, 6) {
                         move|x: u64| mod3::multiply(x, 7)
                      } else {
                        if Eq<u64>(key, 7) {
                           move|x: u64| test::multiply3(4, x, 2)
                        } else {
                          if Eq<u64>(key, 8) {
                             move|x: u64| test::multiply3(3, 3, x)
                          } else {
                            if Eq<u64>(key, 9) {
                              {
                                let x: u64 = 2;
                                {
                                  let y: u64 = 5;
                                   move|z: u64| test::multiply3(x, y, z)
                                }
                              }
                            } else {
                              if Eq<u64>(key, 10) {
                                {
                                  let z: u64 = 11;
                                   move|x: u64| mod4::alt_multiply(x, z) with copy, drop
                                }
                              } else {
                                if Eq<u64>(key, 11) {
                                  {
                                    let g: |(u64, u64)|u64 with copy+drop+store =  move|(x: u64, y: u64): (u64, u64)| mod3::multiply(x, y) with copy, drop;
                                     move|x: u64| (g)(x, 11)
                                  }
                                } else {
                                  if Eq<u64>(key, 12) {
                                    {
                                      let h: |u64|u64 with copy+drop+store =  move|x: u64| mod3::multiply(x, 12) with copy, drop;
                                       move|x: u64| (h)(x) with copy, drop
                                    }
                                  } else {
                                    if Eq<u64>(key, 14) {
                                      {
                                        let i: |u64|u64 with copy+drop+store =  move|x: u64| test::multiply3(2, x, 2);
                                         move|z: u64| (i)(z)
                                      }
                                    } else {
                                      {
                                        let i: |(u64, u64)|u64 with copy+drop+store =  move|(x: u64, y: u64): (u64, u64)| {
                                          let q: u64 = Sub<u64>(y, 1);
                                          mod3::multiply(x, Add<u64>(q, 1))
                                        };
                                         move|x: u64| (i)(x, 15)
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          };
          (f)(x)
        }
    }
    private fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    public fun test_functions() {
        {
          let x: u64 = 3;
          {
            let i: u64 = 0;
            {
              let __update_iter_flag: bool = false;
              {
                let __upper_bound_value: u64 = 15;
                loop {
                  if true {
                    if __update_iter_flag {
                      i: u64 = Add<u64>(i, 1)
                    } else {
                      __update_iter_flag: bool = true
                    };
                    if Lt<u64>(i, __upper_bound_value) {
                      {
                        let y: u64 = test::choose_function1(i, 3);
                        if Eq<u64>(y, Mul<u64>(Add<u64>(i, 2), x)) {
                          Tuple()
                        } else {
                          Abort(i)
                        };
                        Tuple()
                      }
                    } else {
                      break
                    };
                    Tuple()
                  } else {
                    break
                  }
                };
                Tuple()
              }
            }
          }
        }
    }
} // end 0x42::test


// -- Model dump after env processor inlining:
module 0x42::mod4 {
    public fun alt_multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod4
module 0x42::mod3 {
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod3
module 0x42::mod2 {
    friend fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
} // end 0x42::mod2
module 0x42::mod1 {
    friend fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::mod1
module 0x42::test {
    use 0x42::mod1; // resolved as: 0x42::mod1
    use 0x42::mod2; // resolved as: 0x42::mod2
    use 0x42::mod3; // resolved as: 0x42::mod3
    use 0x42::mod4::{alt_multiply}; // resolved as: 0x42::mod4
    private fun add_mul(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(z, Add<u64>(x, y))
    }
    private fun choose_function1(key: u64,x: u64): u64 {
        {
          let f: |u64|u64 with copy+drop = if Eq<u64>(key, 0) {
            mod2::double
          } else {
            if Eq<u64>(key, 1) {
              mod1::triple
            } else {
              if Eq<u64>(key, 2) {
                 move|x: u64| mod3::multiply(4, x)
              } else {
                if Eq<u64>(key, 3) {
                  {
                    let x: u64 = 5;
                     move|y: u64| mod4::alt_multiply(x, y)
                  }
                } else {
                  if Eq<u64>(key, 4) {
                    {
                      let x: u64 = 6;
                       move|y: u64| mod3::multiply(y, x)
                    }
                  } else {
                    if Eq<u64>(key, 5) {
                       move|x: u64| test::multiply3(x, 3, 2)
                    } else {
                      if Eq<u64>(key, 6) {
                         move|x: u64| mod3::multiply(x, 7)
                      } else {
                        if Eq<u64>(key, 7) {
                           move|x: u64| test::multiply3(4, x, 2)
                        } else {
                          if Eq<u64>(key, 8) {
                             move|x: u64| test::multiply3(3, 3, x)
                          } else {
                            if Eq<u64>(key, 9) {
                              {
                                let x: u64 = 2;
                                {
                                  let y: u64 = 5;
                                   move|z: u64| test::multiply3(x, y, z)
                                }
                              }
                            } else {
                              if Eq<u64>(key, 10) {
                                {
                                  let z: u64 = 11;
                                   move|x: u64| mod4::alt_multiply(x, z) with copy, drop
                                }
                              } else {
                                if Eq<u64>(key, 11) {
                                  {
                                    let g: |(u64, u64)|u64 with copy+drop+store =  move|(x: u64, y: u64): (u64, u64)| mod3::multiply(x, y) with copy, drop;
                                     move|x: u64| (g)(x, 11)
                                  }
                                } else {
                                  if Eq<u64>(key, 12) {
                                    {
                                      let h: |u64|u64 with copy+drop+store =  move|x: u64| mod3::multiply(x, 12) with copy, drop;
                                       move|x: u64| (h)(x) with copy, drop
                                    }
                                  } else {
                                    if Eq<u64>(key, 14) {
                                      {
                                        let i: |u64|u64 with copy+drop+store =  move|x: u64| test::multiply3(2, x, 2);
                                         move|z: u64| (i)(z)
                                      }
                                    } else {
                                      {
                                        let i: |(u64, u64)|u64 with copy+drop+store =  move|(x: u64, y: u64): (u64, u64)| {
                                          let q: u64 = Sub<u64>(y, 1);
                                          mod3::multiply(x, Add<u64>(q, 1))
                                        };
                                         move|x: u64| (i)(x, 15)
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          };
          (f)(x)
        }
    }
    private fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    public fun test_functions() {
        {
          let x: u64 = 3;
          {
            let i: u64 = 0;
            {
              let __update_iter_flag: bool = false;
              {
                let __upper_bound_value: u64 = 15;
                loop {
                  if true {
                    if __update_iter_flag {
                      i: u64 = Add<u64>(i, 1)
                    } else {
                      __update_iter_flag: bool = true
                    };
                    if Lt<u64>(i, __upper_bound_value) {
                      {
                        let y: u64 = test::choose_function1(i, 3);
                        if Eq<u64>(y, Mul<u64>(Add<u64>(i, 2), x)) {
                          Tuple()
                        } else {
                          Abort(i)
                        };
                        Tuple()
                      }
                    } else {
                      break
                    };
                    Tuple()
                  } else {
                    break
                  }
                };
                Tuple()
              }
            }
          }
        }
    }
} // end 0x42::test


// -- Model dump after env processor access and use check after inlining:
module 0x42::mod4 {
    public fun alt_multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod4
module 0x42::mod3 {
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod3
module 0x42::mod2 {
    friend fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
} // end 0x42::mod2
module 0x42::mod1 {
    friend fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::mod1
module 0x42::test {
    use 0x42::mod1; // resolved as: 0x42::mod1
    use 0x42::mod2; // resolved as: 0x42::mod2
    use 0x42::mod3; // resolved as: 0x42::mod3
    use 0x42::mod4::{alt_multiply}; // resolved as: 0x42::mod4
    private fun add_mul(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(z, Add<u64>(x, y))
    }
    private fun choose_function1(key: u64,x: u64): u64 {
        {
          let f: |u64|u64 with copy+drop = if Eq<u64>(key, 0) {
            mod2::double
          } else {
            if Eq<u64>(key, 1) {
              mod1::triple
            } else {
              if Eq<u64>(key, 2) {
                 move|x: u64| mod3::multiply(4, x)
              } else {
                if Eq<u64>(key, 3) {
                  {
                    let x: u64 = 5;
                     move|y: u64| mod4::alt_multiply(x, y)
                  }
                } else {
                  if Eq<u64>(key, 4) {
                    {
                      let x: u64 = 6;
                       move|y: u64| mod3::multiply(y, x)
                    }
                  } else {
                    if Eq<u64>(key, 5) {
                       move|x: u64| test::multiply3(x, 3, 2)
                    } else {
                      if Eq<u64>(key, 6) {
                         move|x: u64| mod3::multiply(x, 7)
                      } else {
                        if Eq<u64>(key, 7) {
                           move|x: u64| test::multiply3(4, x, 2)
                        } else {
                          if Eq<u64>(key, 8) {
                             move|x: u64| test::multiply3(3, 3, x)
                          } else {
                            if Eq<u64>(key, 9) {
                              {
                                let x: u64 = 2;
                                {
                                  let y: u64 = 5;
                                   move|z: u64| test::multiply3(x, y, z)
                                }
                              }
                            } else {
                              if Eq<u64>(key, 10) {
                                {
                                  let z: u64 = 11;
                                   move|x: u64| mod4::alt_multiply(x, z) with copy, drop
                                }
                              } else {
                                if Eq<u64>(key, 11) {
                                  {
                                    let g: |(u64, u64)|u64 with copy+drop+store =  move|(x: u64, y: u64): (u64, u64)| mod3::multiply(x, y) with copy, drop;
                                     move|x: u64| (g)(x, 11)
                                  }
                                } else {
                                  if Eq<u64>(key, 12) {
                                    {
                                      let h: |u64|u64 with copy+drop+store =  move|x: u64| mod3::multiply(x, 12) with copy, drop;
                                       move|x: u64| (h)(x) with copy, drop
                                    }
                                  } else {
                                    if Eq<u64>(key, 14) {
                                      {
                                        let i: |u64|u64 with copy+drop+store =  move|x: u64| test::multiply3(2, x, 2);
                                         move|z: u64| (i)(z)
                                      }
                                    } else {
                                      {
                                        let i: |(u64, u64)|u64 with copy+drop+store =  move|(x: u64, y: u64): (u64, u64)| {
                                          let q: u64 = Sub<u64>(y, 1);
                                          mod3::multiply(x, Add<u64>(q, 1))
                                        };
                                         move|x: u64| (i)(x, 15)
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          };
          (f)(x)
        }
    }
    private fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    public fun test_functions() {
        {
          let x: u64 = 3;
          {
            let i: u64 = 0;
            {
              let __update_iter_flag: bool = false;
              {
                let __upper_bound_value: u64 = 15;
                loop {
                  if true {
                    if __update_iter_flag {
                      i: u64 = Add<u64>(i, 1)
                    } else {
                      __update_iter_flag: bool = true
                    };
                    if Lt<u64>(i, __upper_bound_value) {
                      {
                        let y: u64 = test::choose_function1(i, 3);
                        if Eq<u64>(y, Mul<u64>(Add<u64>(i, 2), x)) {
                          Tuple()
                        } else {
                          Abort(i)
                        };
                        Tuple()
                      }
                    } else {
                      break
                    };
                    Tuple()
                  } else {
                    break
                  }
                };
                Tuple()
              }
            }
          }
        }
    }
} // end 0x42::test


// -- Model dump after env processor acquires check:
module 0x42::mod4 {
    public fun alt_multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod4
module 0x42::mod3 {
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod3
module 0x42::mod2 {
    friend fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
} // end 0x42::mod2
module 0x42::mod1 {
    friend fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::mod1
module 0x42::test {
    use 0x42::mod1; // resolved as: 0x42::mod1
    use 0x42::mod2; // resolved as: 0x42::mod2
    use 0x42::mod3; // resolved as: 0x42::mod3
    use 0x42::mod4::{alt_multiply}; // resolved as: 0x42::mod4
    private fun add_mul(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(z, Add<u64>(x, y))
    }
    private fun choose_function1(key: u64,x: u64): u64 {
        {
          let f: |u64|u64 with copy+drop = if Eq<u64>(key, 0) {
            mod2::double
          } else {
            if Eq<u64>(key, 1) {
              mod1::triple
            } else {
              if Eq<u64>(key, 2) {
                 move|x: u64| mod3::multiply(4, x)
              } else {
                if Eq<u64>(key, 3) {
                  {
                    let x: u64 = 5;
                     move|y: u64| mod4::alt_multiply(x, y)
                  }
                } else {
                  if Eq<u64>(key, 4) {
                    {
                      let x: u64 = 6;
                       move|y: u64| mod3::multiply(y, x)
                    }
                  } else {
                    if Eq<u64>(key, 5) {
                       move|x: u64| test::multiply3(x, 3, 2)
                    } else {
                      if Eq<u64>(key, 6) {
                         move|x: u64| mod3::multiply(x, 7)
                      } else {
                        if Eq<u64>(key, 7) {
                           move|x: u64| test::multiply3(4, x, 2)
                        } else {
                          if Eq<u64>(key, 8) {
                             move|x: u64| test::multiply3(3, 3, x)
                          } else {
                            if Eq<u64>(key, 9) {
                              {
                                let x: u64 = 2;
                                {
                                  let y: u64 = 5;
                                   move|z: u64| test::multiply3(x, y, z)
                                }
                              }
                            } else {
                              if Eq<u64>(key, 10) {
                                {
                                  let z: u64 = 11;
                                   move|x: u64| mod4::alt_multiply(x, z) with copy, drop
                                }
                              } else {
                                if Eq<u64>(key, 11) {
                                  {
                                    let g: |(u64, u64)|u64 with copy+drop+store =  move|(x: u64, y: u64): (u64, u64)| mod3::multiply(x, y) with copy, drop;
                                     move|x: u64| (g)(x, 11)
                                  }
                                } else {
                                  if Eq<u64>(key, 12) {
                                    {
                                      let h: |u64|u64 with copy+drop+store =  move|x: u64| mod3::multiply(x, 12) with copy, drop;
                                       move|x: u64| (h)(x) with copy, drop
                                    }
                                  } else {
                                    if Eq<u64>(key, 14) {
                                      {
                                        let i: |u64|u64 with copy+drop+store =  move|x: u64| test::multiply3(2, x, 2);
                                         move|z: u64| (i)(z)
                                      }
                                    } else {
                                      {
                                        let i: |(u64, u64)|u64 with copy+drop+store =  move|(x: u64, y: u64): (u64, u64)| {
                                          let q: u64 = Sub<u64>(y, 1);
                                          mod3::multiply(x, Add<u64>(q, 1))
                                        };
                                         move|x: u64| (i)(x, 15)
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          };
          (f)(x)
        }
    }
    private fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    public fun test_functions() {
        {
          let x: u64 = 3;
          {
            let i: u64 = 0;
            {
              let __update_iter_flag: bool = false;
              {
                let __upper_bound_value: u64 = 15;
                loop {
                  if true {
                    if __update_iter_flag {
                      i: u64 = Add<u64>(i, 1)
                    } else {
                      __update_iter_flag: bool = true
                    };
                    if Lt<u64>(i, __upper_bound_value) {
                      {
                        let y: u64 = test::choose_function1(i, 3);
                        if Eq<u64>(y, Mul<u64>(Add<u64>(i, 2), x)) {
                          Tuple()
                        } else {
                          Abort(i)
                        };
                        Tuple()
                      }
                    } else {
                      break
                    };
                    Tuple()
                  } else {
                    break
                  }
                };
                Tuple()
              }
            }
          }
        }
    }
} // end 0x42::test


// -- Model dump after env processor simplifier:
module 0x42::mod4 {
    public fun alt_multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod4
module 0x42::mod3 {
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod3
module 0x42::mod2 {
    friend fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
} // end 0x42::mod2
module 0x42::mod1 {
    friend fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::mod1
module 0x42::test {
    use 0x42::mod1; // resolved as: 0x42::mod1
    use 0x42::mod2; // resolved as: 0x42::mod2
    use 0x42::mod3; // resolved as: 0x42::mod3
    use 0x42::mod4::{alt_multiply}; // resolved as: 0x42::mod4
    private fun add_mul(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(z, Add<u64>(x, y))
    }
    private fun choose_function1(key: u64,x: u64): u64 {
        {
          let f: |u64|u64 with copy+drop = if Eq<u64>(key, 0) {
            mod2::double
          } else {
            if Eq<u64>(key, 1) {
              mod1::triple
            } else {
              if Eq<u64>(key, 2) {
                 move|x: u64| mod3::multiply(4, x)
              } else {
                if Eq<u64>(key, 3) {
                   move|y: u64| mod4::alt_multiply(5, y)
                } else {
                  if Eq<u64>(key, 4) {
                     move|y: u64| mod3::multiply(y, 6)
                  } else {
                    if Eq<u64>(key, 5) {
                       move|x: u64| test::multiply3(x, 3, 2)
                    } else {
                      if Eq<u64>(key, 6) {
                         move|x: u64| mod3::multiply(x, 7)
                      } else {
                        if Eq<u64>(key, 7) {
                           move|x: u64| test::multiply3(4, x, 2)
                        } else {
                          if Eq<u64>(key, 8) {
                             move|x: u64| test::multiply3(3, 3, x)
                          } else {
                            if Eq<u64>(key, 9) {
                               move|z: u64| test::multiply3(2, 5, z)
                            } else {
                              if Eq<u64>(key, 10) {
                                 move|x: u64| mod4::alt_multiply(x, 11) with copy, drop
                              } else {
                                if Eq<u64>(key, 11) {
                                  {
                                    let g: |(u64, u64)|u64 with copy+drop+store =  move|(x: u64, y: u64): (u64, u64)| mod3::multiply(x, y) with copy, drop;
                                     move|x: u64| (g)(x, 11)
                                  }
                                } else {
                                  if Eq<u64>(key, 12) {
                                    {
                                      let h: |u64|u64 with copy+drop+store =  move|x: u64| mod3::multiply(x, 12) with copy, drop;
                                       move|x: u64| (h)(x) with copy, drop
                                    }
                                  } else {
                                    if Eq<u64>(key, 14) {
                                      {
                                        let i: |u64|u64 with copy+drop+store =  move|x: u64| test::multiply3(2, x, 2);
                                         move|z: u64| (i)(z)
                                      }
                                    } else {
                                      {
                                        let i: |(u64, u64)|u64 with copy+drop+store =  move|(x: u64, y: u64): (u64, u64)| {
                                          let q: u64 = Sub<u64>(y, 1);
                                          mod3::multiply(x, Add<u64>(q, 1))
                                        };
                                         move|x: u64| (i)(x, 15)
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          };
          (f)(x)
        }
    }
    private fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    public fun test_functions() {
        {
          let i: u64 = 0;
          {
            let __update_iter_flag: bool = false;
            loop {
              if true {
                if __update_iter_flag {
                  i: u64 = Add<u64>(i, 1)
                } else {
                  __update_iter_flag: bool = true
                };
                if Lt<u64>(i, 15) {
                  {
                    let y: u64 = test::choose_function1(i, 3);
                    if Eq<u64>(y, Mul<u64>(Add<u64>(i, 2), 3)) {
                      Tuple()
                    } else {
                      Abort(i)
                    };
                    Tuple()
                  }
                } else {
                  break
                };
                Tuple()
              } else {
                break
              }
            };
            Tuple()
          }
        }
    }
} // end 0x42::test


// -- Model dump after env processor lambda-lifting:
module 0x42::mod4 {
    public fun alt_multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod4
module 0x42::mod3 {
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod3
module 0x42::mod2 {
    friend fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
} // end 0x42::mod2
module 0x42::mod1 {
    friend fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::mod1
module 0x42::test {
    use 0x42::mod1; // resolved as: 0x42::mod1
    use 0x42::mod2; // resolved as: 0x42::mod2
    use 0x42::mod3; // resolved as: 0x42::mod3
    use 0x42::mod4::{alt_multiply}; // resolved as: 0x42::mod4
    private fun add_mul(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(z, Add<u64>(x, y))
    }
    private fun choose_function1(key: u64,x: u64): u64 {
        {
          let f: |u64|u64 with copy+drop = if Eq<u64>(key, 0) {
            mod2::double
          } else {
            if Eq<u64>(key, 1) {
              mod1::triple
            } else {
              if Eq<u64>(key, 2) {
                earlybind(mod3::multiply, 4)
              } else {
                if Eq<u64>(key, 3) {
                  earlybind(mod4::alt_multiply, 5)
                } else {
                  if Eq<u64>(key, 4) {
                    test::choose_function1$lambda$1
                  } else {
                    if Eq<u64>(key, 5) {
                      test::choose_function1$lambda$2
                    } else {
                      if Eq<u64>(key, 6) {
                        test::choose_function1$lambda$3
                      } else {
                        if Eq<u64>(key, 7) {
                          test::choose_function1$lambda$4
                        } else {
                          if Eq<u64>(key, 8) {
                            earlybind(test::multiply3, 3, 3)
                          } else {
                            if Eq<u64>(key, 9) {
                              earlybind(test::multiply3, 2, 5)
                            } else {
                              if Eq<u64>(key, 10) {
                                test::choose_function1$lambda$5
                              } else {
                                if Eq<u64>(key, 11) {
                                  {
                                    let g: |(u64, u64)|u64 with copy+drop+store = mod3::multiply;
                                    earlybind(test::choose_function1$lambda$6, g)
                                  }
                                } else {
                                  if Eq<u64>(key, 12) {
                                    {
                                      let h: |u64|u64 with copy+drop+store = test::choose_function1$lambda$7;
                                      h
                                    }
                                  } else {
                                    if Eq<u64>(key, 14) {
                                      {
                                        let i: |u64|u64 with copy+drop+store = test::choose_function1$lambda$8;
                                        i
                                      }
                                    } else {
                                      {
                                        let i: |(u64, u64)|u64 with copy+drop+store = test::choose_function1$lambda$9;
                                        earlybind(test::choose_function1$lambda$10, i)
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          };
          (f)(x)
        }
    }
    private fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    public fun test_functions() {
        {
          let i: u64 = 0;
          {
            let __update_iter_flag: bool = false;
            loop {
              if true {
                if __update_iter_flag {
                  i: u64 = Add<u64>(i, 1)
                } else {
                  __update_iter_flag: bool = true
                };
                if Lt<u64>(i, 15) {
                  {
                    let y: u64 = test::choose_function1(i, 3);
                    if Eq<u64>(y, Mul<u64>(Add<u64>(i, 2), 3)) {
                      Tuple()
                    } else {
                      Abort(i)
                    };
                    Tuple()
                  }
                } else {
                  break
                };
                Tuple()
              } else {
                break
              }
            };
            Tuple()
          }
        }
    }
    private fun choose_function1$lambda$1(y: u64): u64 {
        mod3::multiply(y, 6)
    }
    private fun choose_function1$lambda$2(x: u64): u64 {
        test::multiply3(x, 3, 2)
    }
    private fun choose_function1$lambda$3(x: u64): u64 {
        mod3::multiply(x, 7)
    }
    private fun choose_function1$lambda$4(x: u64): u64 {
        test::multiply3(4, x, 2)
    }
    private fun choose_function1$lambda$5(x: u64): u64 {
        mod4::alt_multiply(x, 11)
    }
    private fun choose_function1$lambda$6(g: |(u64, u64)|u64 with copy+drop+store,x: u64): u64 {
        (g)(x, 11)
    }
    private fun choose_function1$lambda$7(x: u64): u64 {
        mod3::multiply(x, 12)
    }
    private fun choose_function1$lambda$8(x: u64): u64 {
        test::multiply3(2, x, 2)
    }
    private fun choose_function1$lambda$9(x: u64,y: u64): u64 {
        {
          let q: u64 = Sub<u64>(y, 1);
          mod3::multiply(x, Add<u64>(q, 1))
        }
    }
    private fun choose_function1$lambda$10(i: |(u64, u64)|u64 with copy+drop+store,x: u64): u64 {
        (i)(x, 15)
    }
} // end 0x42::test


// -- Model dump after env processor specification checker:
module 0x42::mod4 {
    public fun alt_multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod4
module 0x42::mod3 {
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod3
module 0x42::mod2 {
    friend fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
} // end 0x42::mod2
module 0x42::mod1 {
    friend fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::mod1
module 0x42::test {
    use 0x42::mod1; // resolved as: 0x42::mod1
    use 0x42::mod2; // resolved as: 0x42::mod2
    use 0x42::mod3; // resolved as: 0x42::mod3
    use 0x42::mod4::{alt_multiply}; // resolved as: 0x42::mod4
    private fun add_mul(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(z, Add<u64>(x, y))
    }
    private fun choose_function1(key: u64,x: u64): u64 {
        {
          let f: |u64|u64 with copy+drop = if Eq<u64>(key, 0) {
            mod2::double
          } else {
            if Eq<u64>(key, 1) {
              mod1::triple
            } else {
              if Eq<u64>(key, 2) {
                earlybind(mod3::multiply, 4)
              } else {
                if Eq<u64>(key, 3) {
                  earlybind(mod4::alt_multiply, 5)
                } else {
                  if Eq<u64>(key, 4) {
                    test::choose_function1$lambda$1
                  } else {
                    if Eq<u64>(key, 5) {
                      test::choose_function1$lambda$2
                    } else {
                      if Eq<u64>(key, 6) {
                        test::choose_function1$lambda$3
                      } else {
                        if Eq<u64>(key, 7) {
                          test::choose_function1$lambda$4
                        } else {
                          if Eq<u64>(key, 8) {
                            earlybind(test::multiply3, 3, 3)
                          } else {
                            if Eq<u64>(key, 9) {
                              earlybind(test::multiply3, 2, 5)
                            } else {
                              if Eq<u64>(key, 10) {
                                test::choose_function1$lambda$5
                              } else {
                                if Eq<u64>(key, 11) {
                                  {
                                    let g: |(u64, u64)|u64 with copy+drop+store = mod3::multiply;
                                    earlybind(test::choose_function1$lambda$6, g)
                                  }
                                } else {
                                  if Eq<u64>(key, 12) {
                                    {
                                      let h: |u64|u64 with copy+drop+store = test::choose_function1$lambda$7;
                                      h
                                    }
                                  } else {
                                    if Eq<u64>(key, 14) {
                                      {
                                        let i: |u64|u64 with copy+drop+store = test::choose_function1$lambda$8;
                                        i
                                      }
                                    } else {
                                      {
                                        let i: |(u64, u64)|u64 with copy+drop+store = test::choose_function1$lambda$9;
                                        earlybind(test::choose_function1$lambda$10, i)
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          };
          (f)(x)
        }
    }
    private fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    public fun test_functions() {
        {
          let i: u64 = 0;
          {
            let __update_iter_flag: bool = false;
            loop {
              if true {
                if __update_iter_flag {
                  i: u64 = Add<u64>(i, 1)
                } else {
                  __update_iter_flag: bool = true
                };
                if Lt<u64>(i, 15) {
                  {
                    let y: u64 = test::choose_function1(i, 3);
                    if Eq<u64>(y, Mul<u64>(Add<u64>(i, 2), 3)) {
                      Tuple()
                    } else {
                      Abort(i)
                    };
                    Tuple()
                  }
                } else {
                  break
                };
                Tuple()
              } else {
                break
              }
            };
            Tuple()
          }
        }
    }
    private fun choose_function1$lambda$1(y: u64): u64 {
        mod3::multiply(y, 6)
    }
    private fun choose_function1$lambda$2(x: u64): u64 {
        test::multiply3(x, 3, 2)
    }
    private fun choose_function1$lambda$3(x: u64): u64 {
        mod3::multiply(x, 7)
    }
    private fun choose_function1$lambda$4(x: u64): u64 {
        test::multiply3(4, x, 2)
    }
    private fun choose_function1$lambda$5(x: u64): u64 {
        mod4::alt_multiply(x, 11)
    }
    private fun choose_function1$lambda$6(g: |(u64, u64)|u64 with copy+drop+store,x: u64): u64 {
        (g)(x, 11)
    }
    private fun choose_function1$lambda$7(x: u64): u64 {
        mod3::multiply(x, 12)
    }
    private fun choose_function1$lambda$8(x: u64): u64 {
        test::multiply3(2, x, 2)
    }
    private fun choose_function1$lambda$9(x: u64,y: u64): u64 {
        {
          let q: u64 = Sub<u64>(y, 1);
          mod3::multiply(x, Add<u64>(q, 1))
        }
    }
    private fun choose_function1$lambda$10(i: |(u64, u64)|u64 with copy+drop+store,x: u64): u64 {
        (i)(x, 15)
    }
} // end 0x42::test


// -- Model dump after env processor specification rewriter:
module 0x42::mod4 {
    public fun alt_multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod4
module 0x42::mod3 {
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
} // end 0x42::mod3
module 0x42::mod2 {
    friend fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
} // end 0x42::mod2
module 0x42::mod1 {
    friend fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::mod1
module 0x42::test {
    use 0x42::mod1; // resolved as: 0x42::mod1
    use 0x42::mod2; // resolved as: 0x42::mod2
    use 0x42::mod3; // resolved as: 0x42::mod3
    use 0x42::mod4::{alt_multiply}; // resolved as: 0x42::mod4
    private fun add_mul(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(z, Add<u64>(x, y))
    }
    private fun choose_function1(key: u64,x: u64): u64 {
        {
          let f: |u64|u64 with copy+drop = if Eq<u64>(key, 0) {
            mod2::double
          } else {
            if Eq<u64>(key, 1) {
              mod1::triple
            } else {
              if Eq<u64>(key, 2) {
                earlybind(mod3::multiply, 4)
              } else {
                if Eq<u64>(key, 3) {
                  earlybind(mod4::alt_multiply, 5)
                } else {
                  if Eq<u64>(key, 4) {
                    test::choose_function1$lambda$1
                  } else {
                    if Eq<u64>(key, 5) {
                      test::choose_function1$lambda$2
                    } else {
                      if Eq<u64>(key, 6) {
                        test::choose_function1$lambda$3
                      } else {
                        if Eq<u64>(key, 7) {
                          test::choose_function1$lambda$4
                        } else {
                          if Eq<u64>(key, 8) {
                            earlybind(test::multiply3, 3, 3)
                          } else {
                            if Eq<u64>(key, 9) {
                              earlybind(test::multiply3, 2, 5)
                            } else {
                              if Eq<u64>(key, 10) {
                                test::choose_function1$lambda$5
                              } else {
                                if Eq<u64>(key, 11) {
                                  {
                                    let g: |(u64, u64)|u64 with copy+drop+store = mod3::multiply;
                                    earlybind(test::choose_function1$lambda$6, g)
                                  }
                                } else {
                                  if Eq<u64>(key, 12) {
                                    {
                                      let h: |u64|u64 with copy+drop+store = test::choose_function1$lambda$7;
                                      h
                                    }
                                  } else {
                                    if Eq<u64>(key, 14) {
                                      {
                                        let i: |u64|u64 with copy+drop+store = test::choose_function1$lambda$8;
                                        i
                                      }
                                    } else {
                                      {
                                        let i: |(u64, u64)|u64 with copy+drop+store = test::choose_function1$lambda$9;
                                        earlybind(test::choose_function1$lambda$10, i)
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          };
          (f)(x)
        }
    }
    private fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    public fun test_functions() {
        {
          let i: u64 = 0;
          {
            let __update_iter_flag: bool = false;
            loop {
              if true {
                if __update_iter_flag {
                  i: u64 = Add<u64>(i, 1)
                } else {
                  __update_iter_flag: bool = true
                };
                if Lt<u64>(i, 15) {
                  {
                    let y: u64 = test::choose_function1(i, 3);
                    if Eq<u64>(y, Mul<u64>(Add<u64>(i, 2), 3)) {
                      Tuple()
                    } else {
                      Abort(i)
                    };
                    Tuple()
                  }
                } else {
                  break
                };
                Tuple()
              } else {
                break
              }
            };
            Tuple()
          }
        }
    }
    private fun choose_function1$lambda$1(y: u64): u64 {
        mod3::multiply(y, 6)
    }
    private fun choose_function1$lambda$2(x: u64): u64 {
        test::multiply3(x, 3, 2)
    }
    private fun choose_function1$lambda$3(x: u64): u64 {
        mod3::multiply(x, 7)
    }
    private fun choose_function1$lambda$4(x: u64): u64 {
        test::multiply3(4, x, 2)
    }
    private fun choose_function1$lambda$5(x: u64): u64 {
        mod4::alt_multiply(x, 11)
    }
    private fun choose_function1$lambda$6(g: |(u64, u64)|u64 with copy+drop+store,x: u64): u64 {
        (g)(x, 11)
    }
    private fun choose_function1$lambda$7(x: u64): u64 {
        mod3::multiply(x, 12)
    }
    private fun choose_function1$lambda$8(x: u64): u64 {
        test::multiply3(2, x, 2)
    }
    private fun choose_function1$lambda$9(x: u64,y: u64): u64 {
        {
          let q: u64 = Sub<u64>(y, 1);
          mod3::multiply(x, Add<u64>(q, 1))
        }
    }
    private fun choose_function1$lambda$10(i: |(u64, u64)|u64 with copy+drop+store,x: u64): u64 {
        (i)(x, 15)
    }
} // end 0x42::test



Diagnostics:
error: Function-typed values not yet supported except as parameters to calls to inline functions
    tests/lambda/storable/doable_func.move:39:17
   
39                  mod2::double
                    ^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
    tests/lambda/storable/doable_func.move:41:17
   
41                  mod1::triple
                    ^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
    tests/lambda/storable/doable_func.move:43:17
   
43                  move |x| mod3::multiply(4, x)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
    tests/lambda/storable/doable_func.move:46:17
   
46                  move |y| alt_multiply(x, y)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
    tests/lambda/storable/doable_func.move:49:17
   
49                  move |y| mod3::multiply(y, x)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
    tests/lambda/storable/doable_func.move:51:17
   
51                  move |x| multiply3(x, 3, 2)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
    tests/lambda/storable/doable_func.move:53:17
   
53                  move |x| mod3::multiply(x, 7)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
    tests/lambda/storable/doable_func.move:55:17
   
55                  move |x| multiply3(4, x, 2)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
    tests/lambda/storable/doable_func.move:57:17
   
57                  move |x| multiply3(3, 3, x)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
    tests/lambda/storable/doable_func.move:61:17
   
61                  move |z| multiply3(x, y, z)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
    tests/lambda/storable/doable_func.move:64:17
   
64                  move |x| alt_multiply(x, z) with copy
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
    tests/lambda/storable/doable_func.move:66:37
   
66                  let g = move |x, y| mod3::multiply(x, y) with copy+drop;
                                        ^^^^^^^^^^^^^^^^^^^^

error: Calls to function values other than inline function parameters not yet supported
    tests/lambda/storable/doable_func.move:67:26
   
67                  move |x| g(x, 11)
                             ^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
    tests/lambda/storable/doable_func.move:67:17
   
67                  move |x| g(x, 11)
                    ^^^^^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
    tests/lambda/storable/doable_func.move:69:25
   
69                  let h = move |x| mod3::multiply(x, 12) with copy;
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
    tests/lambda/storable/doable_func.move:72:25
   
72                  let i = move |x| multiply3(2, x, 2);
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
    tests/lambda/storable/doable_func.move:75:25
   
75                  let i = move |x, y| { let q = y - 1; 0x42::mod3::multiply(x, q + 1)  };
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Calls to function values other than inline function parameters not yet supported
    tests/lambda/storable/doable_func.move:76:26
   
76                  move |x| i(x, 15)
                             ^^^^^^^^

error: Function-typed values not yet supported except as parameters to calls to inline functions
    tests/lambda/storable/doable_func.move:76:17
   
76                  move |x| i(x, 15)
                    ^^^^^^^^^^^^^^^^^

error: Calls to function values other than inline function parameters not yet supported
    tests/lambda/storable/doable_func.move:78:9
   
78          f(x)
            ^^^^
