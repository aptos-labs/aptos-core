// -- Model dump before env processor pipeline:
module 0x42::test {
    use std::vector;
    private fun choose_function(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
          test::double
        } else {
          if Eq<u64>(key, 1) {
            test::triple
          } else {
            test::multiply_by_x(4)
          }
        }
    }
    private fun choose_function2(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
           move|x: u64| test::double(x) with drop, store
        } else {
          if Eq<u64>(key, 1) {
             move|x: u64| test::triple(x) with drop, store
          } else {
            if Eq<u64>(key, 2) {
              {
                let f: |u64|u64 with store = test::multiply_by_x(4);
                 move|x: u64| (f)(x) with drop, store
              }
            } else {
              if Eq<u64>(key, 3) {
                {
                  let f: |u64|u64 with store = test::multiply_by_x(5);
                   move|x: u64| (f)(x) with drop, store
                }
              } else {
                if Eq<u64>(key, 4) {
                  {
                    let f: |u64|u64 with copy+store =  move|y: u64| test::multiply(6, y) with drop, store;
                    f
                  }
                } else {
                  if Eq<u64>(key, 5) {
                     move|y: u64| test::multiply(y, 7) with drop, store
                  } else {
                    if Eq<u64>(key, 6) {
                      {
                        let f: |u64|u64 with copy+store =  move|y: u64| test::multiply(6, y) with drop, store;
                         move|x: u64| (f)(x) with drop, store
                      }
                    } else {
                      if Eq<u64>(key, 7) {
                        {
                          let f: |u64|u64 with store = test::multiply_by_x(5);
                           move|x: u64| (f)(x) with drop, store
                        }
                      } else {
                         move|y: u64| test::multiply3(y, 3, 4) with drop, store
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun choose_function3(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
          {
            let f: |u64|u64 with copy+store =  move|x: u64| test::double(x) with drop, store;
            f
          }
        } else {
          if Eq<u64>(key, 1) {
            {
              let g: |u64|u64 with copy+store =  move|x: u64| test::triple(x) with drop, store;
              g
            }
          } else {
            {
              let h: |u64|u64 with store = test::multiply_by_x(4);
              h
            }
          }
        }
    }
    public fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
    public fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    private fun multiply_by_x(x: u64): |u64|u64 with store {
         move|y: u64| test::multiply(x, y) with drop, store
    }
    public fun test_function_choosers() {
        test::test_functions(test::choose_function);
        test::test_functions(test::choose_function2);
        test::test_functions(test::choose_function3);
        Tuple()
    }
    public fun test_functions(choose_function_arg: |u64||u64|u64 with store) {
        {
          let sum: vector<u64> = Vector<u64>();
          {
            let x: u64 = 3;
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(0))(x));
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(1))(x));
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(2))(x));
            {
              let g: |u64|u64 with store = test::choose_function(1);
              {
                let h: |u64|u64 with store = test::choose_function(2);
                {
                  let f: |u64|u64 with store = test::choose_function(0);
                  vector::push_back<u64>(Borrow(Mutable)(sum), (f)(5));
                  vector::push_back<u64>(Borrow(Mutable)(sum), (g)(7));
                  vector::push_back<u64>(Borrow(Mutable)(sum), (h)(6));
                  {
                    let funcs: vector<|u64|u64 with store> = Vector<|u64|u64 with store>(test::choose_function(0), test::choose_function(1), test::choose_function(2));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 0)))(9));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 1)))(11));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 2)))(13));
                    if Eq<vector<u64>>(sum, Vector<u64>(6, 9, 12, 10, 21, 24, 18, 33, 52)) {
                      Tuple()
                    } else {
                      Abort(14566554180833181696)
                    }
                  }
                }
              }
            }
          }
        }
    }
    public fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::test


// -- Model dump after env processor unused checks:
module 0x42::test {
    use std::vector;
    private fun choose_function(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
          test::double
        } else {
          if Eq<u64>(key, 1) {
            test::triple
          } else {
            test::multiply_by_x(4)
          }
        }
    }
    private fun choose_function2(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
           move|x: u64| test::double(x) with drop, store
        } else {
          if Eq<u64>(key, 1) {
             move|x: u64| test::triple(x) with drop, store
          } else {
            if Eq<u64>(key, 2) {
              {
                let f: |u64|u64 with store = test::multiply_by_x(4);
                 move|x: u64| (f)(x) with drop, store
              }
            } else {
              if Eq<u64>(key, 3) {
                {
                  let f: |u64|u64 with store = test::multiply_by_x(5);
                   move|x: u64| (f)(x) with drop, store
                }
              } else {
                if Eq<u64>(key, 4) {
                  {
                    let f: |u64|u64 with copy+store =  move|y: u64| test::multiply(6, y) with drop, store;
                    f
                  }
                } else {
                  if Eq<u64>(key, 5) {
                     move|y: u64| test::multiply(y, 7) with drop, store
                  } else {
                    if Eq<u64>(key, 6) {
                      {
                        let f: |u64|u64 with copy+store =  move|y: u64| test::multiply(6, y) with drop, store;
                         move|x: u64| (f)(x) with drop, store
                      }
                    } else {
                      if Eq<u64>(key, 7) {
                        {
                          let f: |u64|u64 with store = test::multiply_by_x(5);
                           move|x: u64| (f)(x) with drop, store
                        }
                      } else {
                         move|y: u64| test::multiply3(y, 3, 4) with drop, store
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun choose_function3(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
          {
            let f: |u64|u64 with copy+store =  move|x: u64| test::double(x) with drop, store;
            f
          }
        } else {
          if Eq<u64>(key, 1) {
            {
              let g: |u64|u64 with copy+store =  move|x: u64| test::triple(x) with drop, store;
              g
            }
          } else {
            {
              let h: |u64|u64 with store = test::multiply_by_x(4);
              h
            }
          }
        }
    }
    public fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
    public fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    private fun multiply_by_x(x: u64): |u64|u64 with store {
         move|y: u64| test::multiply(x, y) with drop, store
    }
    public fun test_function_choosers() {
        test::test_functions(test::choose_function);
        test::test_functions(test::choose_function2);
        test::test_functions(test::choose_function3);
        Tuple()
    }
    public fun test_functions(choose_function_arg: |u64||u64|u64 with store) {
        {
          let sum: vector<u64> = Vector<u64>();
          {
            let x: u64 = 3;
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(0))(x));
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(1))(x));
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(2))(x));
            {
              let g: |u64|u64 with store = test::choose_function(1);
              {
                let h: |u64|u64 with store = test::choose_function(2);
                {
                  let f: |u64|u64 with store = test::choose_function(0);
                  vector::push_back<u64>(Borrow(Mutable)(sum), (f)(5));
                  vector::push_back<u64>(Borrow(Mutable)(sum), (g)(7));
                  vector::push_back<u64>(Borrow(Mutable)(sum), (h)(6));
                  {
                    let funcs: vector<|u64|u64 with store> = Vector<|u64|u64 with store>(test::choose_function(0), test::choose_function(1), test::choose_function(2));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 0)))(9));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 1)))(11));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 2)))(13));
                    if Eq<vector<u64>>(sum, Vector<u64>(6, 9, 12, 10, 21, 24, 18, 33, 52)) {
                      Tuple()
                    } else {
                      Abort(14566554180833181696)
                    }
                  }
                }
              }
            }
          }
        }
    }
    public fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::test


// -- Model dump after env processor type parameter check:
module 0x42::test {
    use std::vector;
    private fun choose_function(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
          test::double
        } else {
          if Eq<u64>(key, 1) {
            test::triple
          } else {
            test::multiply_by_x(4)
          }
        }
    }
    private fun choose_function2(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
           move|x: u64| test::double(x) with drop, store
        } else {
          if Eq<u64>(key, 1) {
             move|x: u64| test::triple(x) with drop, store
          } else {
            if Eq<u64>(key, 2) {
              {
                let f: |u64|u64 with store = test::multiply_by_x(4);
                 move|x: u64| (f)(x) with drop, store
              }
            } else {
              if Eq<u64>(key, 3) {
                {
                  let f: |u64|u64 with store = test::multiply_by_x(5);
                   move|x: u64| (f)(x) with drop, store
                }
              } else {
                if Eq<u64>(key, 4) {
                  {
                    let f: |u64|u64 with copy+store =  move|y: u64| test::multiply(6, y) with drop, store;
                    f
                  }
                } else {
                  if Eq<u64>(key, 5) {
                     move|y: u64| test::multiply(y, 7) with drop, store
                  } else {
                    if Eq<u64>(key, 6) {
                      {
                        let f: |u64|u64 with copy+store =  move|y: u64| test::multiply(6, y) with drop, store;
                         move|x: u64| (f)(x) with drop, store
                      }
                    } else {
                      if Eq<u64>(key, 7) {
                        {
                          let f: |u64|u64 with store = test::multiply_by_x(5);
                           move|x: u64| (f)(x) with drop, store
                        }
                      } else {
                         move|y: u64| test::multiply3(y, 3, 4) with drop, store
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun choose_function3(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
          {
            let f: |u64|u64 with copy+store =  move|x: u64| test::double(x) with drop, store;
            f
          }
        } else {
          if Eq<u64>(key, 1) {
            {
              let g: |u64|u64 with copy+store =  move|x: u64| test::triple(x) with drop, store;
              g
            }
          } else {
            {
              let h: |u64|u64 with store = test::multiply_by_x(4);
              h
            }
          }
        }
    }
    public fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
    public fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    private fun multiply_by_x(x: u64): |u64|u64 with store {
         move|y: u64| test::multiply(x, y) with drop, store
    }
    public fun test_function_choosers() {
        test::test_functions(test::choose_function);
        test::test_functions(test::choose_function2);
        test::test_functions(test::choose_function3);
        Tuple()
    }
    public fun test_functions(choose_function_arg: |u64||u64|u64 with store) {
        {
          let sum: vector<u64> = Vector<u64>();
          {
            let x: u64 = 3;
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(0))(x));
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(1))(x));
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(2))(x));
            {
              let g: |u64|u64 with store = test::choose_function(1);
              {
                let h: |u64|u64 with store = test::choose_function(2);
                {
                  let f: |u64|u64 with store = test::choose_function(0);
                  vector::push_back<u64>(Borrow(Mutable)(sum), (f)(5));
                  vector::push_back<u64>(Borrow(Mutable)(sum), (g)(7));
                  vector::push_back<u64>(Borrow(Mutable)(sum), (h)(6));
                  {
                    let funcs: vector<|u64|u64 with store> = Vector<|u64|u64 with store>(test::choose_function(0), test::choose_function(1), test::choose_function(2));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 0)))(9));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 1)))(11));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 2)))(13));
                    if Eq<vector<u64>>(sum, Vector<u64>(6, 9, 12, 10, 21, 24, 18, 33, 52)) {
                      Tuple()
                    } else {
                      Abort(14566554180833181696)
                    }
                  }
                }
              }
            }
          }
        }
    }
    public fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::test


// -- Model dump after env processor check recursive struct definition:
module 0x42::test {
    use std::vector;
    private fun choose_function(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
          test::double
        } else {
          if Eq<u64>(key, 1) {
            test::triple
          } else {
            test::multiply_by_x(4)
          }
        }
    }
    private fun choose_function2(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
           move|x: u64| test::double(x) with drop, store
        } else {
          if Eq<u64>(key, 1) {
             move|x: u64| test::triple(x) with drop, store
          } else {
            if Eq<u64>(key, 2) {
              {
                let f: |u64|u64 with store = test::multiply_by_x(4);
                 move|x: u64| (f)(x) with drop, store
              }
            } else {
              if Eq<u64>(key, 3) {
                {
                  let f: |u64|u64 with store = test::multiply_by_x(5);
                   move|x: u64| (f)(x) with drop, store
                }
              } else {
                if Eq<u64>(key, 4) {
                  {
                    let f: |u64|u64 with copy+store =  move|y: u64| test::multiply(6, y) with drop, store;
                    f
                  }
                } else {
                  if Eq<u64>(key, 5) {
                     move|y: u64| test::multiply(y, 7) with drop, store
                  } else {
                    if Eq<u64>(key, 6) {
                      {
                        let f: |u64|u64 with copy+store =  move|y: u64| test::multiply(6, y) with drop, store;
                         move|x: u64| (f)(x) with drop, store
                      }
                    } else {
                      if Eq<u64>(key, 7) {
                        {
                          let f: |u64|u64 with store = test::multiply_by_x(5);
                           move|x: u64| (f)(x) with drop, store
                        }
                      } else {
                         move|y: u64| test::multiply3(y, 3, 4) with drop, store
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun choose_function3(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
          {
            let f: |u64|u64 with copy+store =  move|x: u64| test::double(x) with drop, store;
            f
          }
        } else {
          if Eq<u64>(key, 1) {
            {
              let g: |u64|u64 with copy+store =  move|x: u64| test::triple(x) with drop, store;
              g
            }
          } else {
            {
              let h: |u64|u64 with store = test::multiply_by_x(4);
              h
            }
          }
        }
    }
    public fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
    public fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    private fun multiply_by_x(x: u64): |u64|u64 with store {
         move|y: u64| test::multiply(x, y) with drop, store
    }
    public fun test_function_choosers() {
        test::test_functions(test::choose_function);
        test::test_functions(test::choose_function2);
        test::test_functions(test::choose_function3);
        Tuple()
    }
    public fun test_functions(choose_function_arg: |u64||u64|u64 with store) {
        {
          let sum: vector<u64> = Vector<u64>();
          {
            let x: u64 = 3;
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(0))(x));
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(1))(x));
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(2))(x));
            {
              let g: |u64|u64 with store = test::choose_function(1);
              {
                let h: |u64|u64 with store = test::choose_function(2);
                {
                  let f: |u64|u64 with store = test::choose_function(0);
                  vector::push_back<u64>(Borrow(Mutable)(sum), (f)(5));
                  vector::push_back<u64>(Borrow(Mutable)(sum), (g)(7));
                  vector::push_back<u64>(Borrow(Mutable)(sum), (h)(6));
                  {
                    let funcs: vector<|u64|u64 with store> = Vector<|u64|u64 with store>(test::choose_function(0), test::choose_function(1), test::choose_function(2));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 0)))(9));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 1)))(11));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 2)))(13));
                    if Eq<vector<u64>>(sum, Vector<u64>(6, 9, 12, 10, 21, 24, 18, 33, 52)) {
                      Tuple()
                    } else {
                      Abort(14566554180833181696)
                    }
                  }
                }
              }
            }
          }
        }
    }
    public fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::test


// -- Model dump after env processor check cyclic type instantiation:
module 0x42::test {
    use std::vector;
    private fun choose_function(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
          test::double
        } else {
          if Eq<u64>(key, 1) {
            test::triple
          } else {
            test::multiply_by_x(4)
          }
        }
    }
    private fun choose_function2(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
           move|x: u64| test::double(x) with drop, store
        } else {
          if Eq<u64>(key, 1) {
             move|x: u64| test::triple(x) with drop, store
          } else {
            if Eq<u64>(key, 2) {
              {
                let f: |u64|u64 with store = test::multiply_by_x(4);
                 move|x: u64| (f)(x) with drop, store
              }
            } else {
              if Eq<u64>(key, 3) {
                {
                  let f: |u64|u64 with store = test::multiply_by_x(5);
                   move|x: u64| (f)(x) with drop, store
                }
              } else {
                if Eq<u64>(key, 4) {
                  {
                    let f: |u64|u64 with copy+store =  move|y: u64| test::multiply(6, y) with drop, store;
                    f
                  }
                } else {
                  if Eq<u64>(key, 5) {
                     move|y: u64| test::multiply(y, 7) with drop, store
                  } else {
                    if Eq<u64>(key, 6) {
                      {
                        let f: |u64|u64 with copy+store =  move|y: u64| test::multiply(6, y) with drop, store;
                         move|x: u64| (f)(x) with drop, store
                      }
                    } else {
                      if Eq<u64>(key, 7) {
                        {
                          let f: |u64|u64 with store = test::multiply_by_x(5);
                           move|x: u64| (f)(x) with drop, store
                        }
                      } else {
                         move|y: u64| test::multiply3(y, 3, 4) with drop, store
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun choose_function3(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
          {
            let f: |u64|u64 with copy+store =  move|x: u64| test::double(x) with drop, store;
            f
          }
        } else {
          if Eq<u64>(key, 1) {
            {
              let g: |u64|u64 with copy+store =  move|x: u64| test::triple(x) with drop, store;
              g
            }
          } else {
            {
              let h: |u64|u64 with store = test::multiply_by_x(4);
              h
            }
          }
        }
    }
    public fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
    public fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    private fun multiply_by_x(x: u64): |u64|u64 with store {
         move|y: u64| test::multiply(x, y) with drop, store
    }
    public fun test_function_choosers() {
        test::test_functions(test::choose_function);
        test::test_functions(test::choose_function2);
        test::test_functions(test::choose_function3);
        Tuple()
    }
    public fun test_functions(choose_function_arg: |u64||u64|u64 with store) {
        {
          let sum: vector<u64> = Vector<u64>();
          {
            let x: u64 = 3;
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(0))(x));
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(1))(x));
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(2))(x));
            {
              let g: |u64|u64 with store = test::choose_function(1);
              {
                let h: |u64|u64 with store = test::choose_function(2);
                {
                  let f: |u64|u64 with store = test::choose_function(0);
                  vector::push_back<u64>(Borrow(Mutable)(sum), (f)(5));
                  vector::push_back<u64>(Borrow(Mutable)(sum), (g)(7));
                  vector::push_back<u64>(Borrow(Mutable)(sum), (h)(6));
                  {
                    let funcs: vector<|u64|u64 with store> = Vector<|u64|u64 with store>(test::choose_function(0), test::choose_function(1), test::choose_function(2));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 0)))(9));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 1)))(11));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 2)))(13));
                    if Eq<vector<u64>>(sum, Vector<u64>(6, 9, 12, 10, 21, 24, 18, 33, 52)) {
                      Tuple()
                    } else {
                      Abort(14566554180833181696)
                    }
                  }
                }
              }
            }
          }
        }
    }
    public fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::test


// -- Model dump after env processor unused struct params check:
module 0x42::test {
    use std::vector;
    private fun choose_function(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
          test::double
        } else {
          if Eq<u64>(key, 1) {
            test::triple
          } else {
            test::multiply_by_x(4)
          }
        }
    }
    private fun choose_function2(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
           move|x: u64| test::double(x) with drop, store
        } else {
          if Eq<u64>(key, 1) {
             move|x: u64| test::triple(x) with drop, store
          } else {
            if Eq<u64>(key, 2) {
              {
                let f: |u64|u64 with store = test::multiply_by_x(4);
                 move|x: u64| (f)(x) with drop, store
              }
            } else {
              if Eq<u64>(key, 3) {
                {
                  let f: |u64|u64 with store = test::multiply_by_x(5);
                   move|x: u64| (f)(x) with drop, store
                }
              } else {
                if Eq<u64>(key, 4) {
                  {
                    let f: |u64|u64 with copy+store =  move|y: u64| test::multiply(6, y) with drop, store;
                    f
                  }
                } else {
                  if Eq<u64>(key, 5) {
                     move|y: u64| test::multiply(y, 7) with drop, store
                  } else {
                    if Eq<u64>(key, 6) {
                      {
                        let f: |u64|u64 with copy+store =  move|y: u64| test::multiply(6, y) with drop, store;
                         move|x: u64| (f)(x) with drop, store
                      }
                    } else {
                      if Eq<u64>(key, 7) {
                        {
                          let f: |u64|u64 with store = test::multiply_by_x(5);
                           move|x: u64| (f)(x) with drop, store
                        }
                      } else {
                         move|y: u64| test::multiply3(y, 3, 4) with drop, store
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun choose_function3(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
          {
            let f: |u64|u64 with copy+store =  move|x: u64| test::double(x) with drop, store;
            f
          }
        } else {
          if Eq<u64>(key, 1) {
            {
              let g: |u64|u64 with copy+store =  move|x: u64| test::triple(x) with drop, store;
              g
            }
          } else {
            {
              let h: |u64|u64 with store = test::multiply_by_x(4);
              h
            }
          }
        }
    }
    public fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
    public fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    private fun multiply_by_x(x: u64): |u64|u64 with store {
         move|y: u64| test::multiply(x, y) with drop, store
    }
    public fun test_function_choosers() {
        test::test_functions(test::choose_function);
        test::test_functions(test::choose_function2);
        test::test_functions(test::choose_function3);
        Tuple()
    }
    public fun test_functions(choose_function_arg: |u64||u64|u64 with store) {
        {
          let sum: vector<u64> = Vector<u64>();
          {
            let x: u64 = 3;
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(0))(x));
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(1))(x));
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(2))(x));
            {
              let g: |u64|u64 with store = test::choose_function(1);
              {
                let h: |u64|u64 with store = test::choose_function(2);
                {
                  let f: |u64|u64 with store = test::choose_function(0);
                  vector::push_back<u64>(Borrow(Mutable)(sum), (f)(5));
                  vector::push_back<u64>(Borrow(Mutable)(sum), (g)(7));
                  vector::push_back<u64>(Borrow(Mutable)(sum), (h)(6));
                  {
                    let funcs: vector<|u64|u64 with store> = Vector<|u64|u64 with store>(test::choose_function(0), test::choose_function(1), test::choose_function(2));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 0)))(9));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 1)))(11));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 2)))(13));
                    if Eq<vector<u64>>(sum, Vector<u64>(6, 9, 12, 10, 21, 24, 18, 33, 52)) {
                      Tuple()
                    } else {
                      Abort(14566554180833181696)
                    }
                  }
                }
              }
            }
          }
        }
    }
    public fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::test


// -- Model dump after env processor access and use check before inlining:
module 0x42::test {
    use std::vector;
    private fun choose_function(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
          test::double
        } else {
          if Eq<u64>(key, 1) {
            test::triple
          } else {
            test::multiply_by_x(4)
          }
        }
    }
    private fun choose_function2(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
           move|x: u64| test::double(x) with drop, store
        } else {
          if Eq<u64>(key, 1) {
             move|x: u64| test::triple(x) with drop, store
          } else {
            if Eq<u64>(key, 2) {
              {
                let f: |u64|u64 with store = test::multiply_by_x(4);
                 move|x: u64| (f)(x) with drop, store
              }
            } else {
              if Eq<u64>(key, 3) {
                {
                  let f: |u64|u64 with store = test::multiply_by_x(5);
                   move|x: u64| (f)(x) with drop, store
                }
              } else {
                if Eq<u64>(key, 4) {
                  {
                    let f: |u64|u64 with copy+store =  move|y: u64| test::multiply(6, y) with drop, store;
                    f
                  }
                } else {
                  if Eq<u64>(key, 5) {
                     move|y: u64| test::multiply(y, 7) with drop, store
                  } else {
                    if Eq<u64>(key, 6) {
                      {
                        let f: |u64|u64 with copy+store =  move|y: u64| test::multiply(6, y) with drop, store;
                         move|x: u64| (f)(x) with drop, store
                      }
                    } else {
                      if Eq<u64>(key, 7) {
                        {
                          let f: |u64|u64 with store = test::multiply_by_x(5);
                           move|x: u64| (f)(x) with drop, store
                        }
                      } else {
                         move|y: u64| test::multiply3(y, 3, 4) with drop, store
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun choose_function3(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
          {
            let f: |u64|u64 with copy+store =  move|x: u64| test::double(x) with drop, store;
            f
          }
        } else {
          if Eq<u64>(key, 1) {
            {
              let g: |u64|u64 with copy+store =  move|x: u64| test::triple(x) with drop, store;
              g
            }
          } else {
            {
              let h: |u64|u64 with store = test::multiply_by_x(4);
              h
            }
          }
        }
    }
    public fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
    public fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    private fun multiply_by_x(x: u64): |u64|u64 with store {
         move|y: u64| test::multiply(x, y) with drop, store
    }
    public fun test_function_choosers() {
        test::test_functions(test::choose_function);
        test::test_functions(test::choose_function2);
        test::test_functions(test::choose_function3);
        Tuple()
    }
    public fun test_functions(choose_function_arg: |u64||u64|u64 with store) {
        {
          let sum: vector<u64> = Vector<u64>();
          {
            let x: u64 = 3;
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(0))(x));
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(1))(x));
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(2))(x));
            {
              let g: |u64|u64 with store = test::choose_function(1);
              {
                let h: |u64|u64 with store = test::choose_function(2);
                {
                  let f: |u64|u64 with store = test::choose_function(0);
                  vector::push_back<u64>(Borrow(Mutable)(sum), (f)(5));
                  vector::push_back<u64>(Borrow(Mutable)(sum), (g)(7));
                  vector::push_back<u64>(Borrow(Mutable)(sum), (h)(6));
                  {
                    let funcs: vector<|u64|u64 with store> = Vector<|u64|u64 with store>(test::choose_function(0), test::choose_function(1), test::choose_function(2));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 0)))(9));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 1)))(11));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 2)))(13));
                    if Eq<vector<u64>>(sum, Vector<u64>(6, 9, 12, 10, 21, 24, 18, 33, 52)) {
                      Tuple()
                    } else {
                      Abort(14566554180833181696)
                    }
                  }
                }
              }
            }
          }
        }
    }
    public fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::test


// -- Model dump after env processor inlining:
module 0x42::test {
    use std::vector;
    private fun choose_function(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
          test::double
        } else {
          if Eq<u64>(key, 1) {
            test::triple
          } else {
            test::multiply_by_x(4)
          }
        }
    }
    private fun choose_function2(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
           move|x: u64| test::double(x) with drop, store
        } else {
          if Eq<u64>(key, 1) {
             move|x: u64| test::triple(x) with drop, store
          } else {
            if Eq<u64>(key, 2) {
              {
                let f: |u64|u64 with store = test::multiply_by_x(4);
                 move|x: u64| (f)(x) with drop, store
              }
            } else {
              if Eq<u64>(key, 3) {
                {
                  let f: |u64|u64 with store = test::multiply_by_x(5);
                   move|x: u64| (f)(x) with drop, store
                }
              } else {
                if Eq<u64>(key, 4) {
                  {
                    let f: |u64|u64 with copy+store =  move|y: u64| test::multiply(6, y) with drop, store;
                    f
                  }
                } else {
                  if Eq<u64>(key, 5) {
                     move|y: u64| test::multiply(y, 7) with drop, store
                  } else {
                    if Eq<u64>(key, 6) {
                      {
                        let f: |u64|u64 with copy+store =  move|y: u64| test::multiply(6, y) with drop, store;
                         move|x: u64| (f)(x) with drop, store
                      }
                    } else {
                      if Eq<u64>(key, 7) {
                        {
                          let f: |u64|u64 with store = test::multiply_by_x(5);
                           move|x: u64| (f)(x) with drop, store
                        }
                      } else {
                         move|y: u64| test::multiply3(y, 3, 4) with drop, store
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun choose_function3(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
          {
            let f: |u64|u64 with copy+store =  move|x: u64| test::double(x) with drop, store;
            f
          }
        } else {
          if Eq<u64>(key, 1) {
            {
              let g: |u64|u64 with copy+store =  move|x: u64| test::triple(x) with drop, store;
              g
            }
          } else {
            {
              let h: |u64|u64 with store = test::multiply_by_x(4);
              h
            }
          }
        }
    }
    public fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
    public fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    private fun multiply_by_x(x: u64): |u64|u64 with store {
         move|y: u64| test::multiply(x, y) with drop, store
    }
    public fun test_function_choosers() {
        test::test_functions(test::choose_function);
        test::test_functions(test::choose_function2);
        test::test_functions(test::choose_function3);
        Tuple()
    }
    public fun test_functions(choose_function_arg: |u64||u64|u64 with store) {
        {
          let sum: vector<u64> = Vector<u64>();
          {
            let x: u64 = 3;
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(0))(x));
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(1))(x));
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(2))(x));
            {
              let g: |u64|u64 with store = test::choose_function(1);
              {
                let h: |u64|u64 with store = test::choose_function(2);
                {
                  let f: |u64|u64 with store = test::choose_function(0);
                  vector::push_back<u64>(Borrow(Mutable)(sum), (f)(5));
                  vector::push_back<u64>(Borrow(Mutable)(sum), (g)(7));
                  vector::push_back<u64>(Borrow(Mutable)(sum), (h)(6));
                  {
                    let funcs: vector<|u64|u64 with store> = Vector<|u64|u64 with store>(test::choose_function(0), test::choose_function(1), test::choose_function(2));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 0)))(9));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 1)))(11));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 2)))(13));
                    if Eq<vector<u64>>(sum, Vector<u64>(6, 9, 12, 10, 21, 24, 18, 33, 52)) {
                      Tuple()
                    } else {
                      Abort(14566554180833181696)
                    }
                  }
                }
              }
            }
          }
        }
    }
    public fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::test


// -- Model dump after env processor access and use check after inlining:
module 0x42::test {
    use std::vector;
    private fun choose_function(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
          test::double
        } else {
          if Eq<u64>(key, 1) {
            test::triple
          } else {
            test::multiply_by_x(4)
          }
        }
    }
    private fun choose_function2(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
           move|x: u64| test::double(x) with drop, store
        } else {
          if Eq<u64>(key, 1) {
             move|x: u64| test::triple(x) with drop, store
          } else {
            if Eq<u64>(key, 2) {
              {
                let f: |u64|u64 with store = test::multiply_by_x(4);
                 move|x: u64| (f)(x) with drop, store
              }
            } else {
              if Eq<u64>(key, 3) {
                {
                  let f: |u64|u64 with store = test::multiply_by_x(5);
                   move|x: u64| (f)(x) with drop, store
                }
              } else {
                if Eq<u64>(key, 4) {
                  {
                    let f: |u64|u64 with copy+store =  move|y: u64| test::multiply(6, y) with drop, store;
                    f
                  }
                } else {
                  if Eq<u64>(key, 5) {
                     move|y: u64| test::multiply(y, 7) with drop, store
                  } else {
                    if Eq<u64>(key, 6) {
                      {
                        let f: |u64|u64 with copy+store =  move|y: u64| test::multiply(6, y) with drop, store;
                         move|x: u64| (f)(x) with drop, store
                      }
                    } else {
                      if Eq<u64>(key, 7) {
                        {
                          let f: |u64|u64 with store = test::multiply_by_x(5);
                           move|x: u64| (f)(x) with drop, store
                        }
                      } else {
                         move|y: u64| test::multiply3(y, 3, 4) with drop, store
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun choose_function3(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
          {
            let f: |u64|u64 with copy+store =  move|x: u64| test::double(x) with drop, store;
            f
          }
        } else {
          if Eq<u64>(key, 1) {
            {
              let g: |u64|u64 with copy+store =  move|x: u64| test::triple(x) with drop, store;
              g
            }
          } else {
            {
              let h: |u64|u64 with store = test::multiply_by_x(4);
              h
            }
          }
        }
    }
    public fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
    public fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    private fun multiply_by_x(x: u64): |u64|u64 with store {
         move|y: u64| test::multiply(x, y) with drop, store
    }
    public fun test_function_choosers() {
        test::test_functions(test::choose_function);
        test::test_functions(test::choose_function2);
        test::test_functions(test::choose_function3);
        Tuple()
    }
    public fun test_functions(choose_function_arg: |u64||u64|u64 with store) {
        {
          let sum: vector<u64> = Vector<u64>();
          {
            let x: u64 = 3;
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(0))(x));
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(1))(x));
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(2))(x));
            {
              let g: |u64|u64 with store = test::choose_function(1);
              {
                let h: |u64|u64 with store = test::choose_function(2);
                {
                  let f: |u64|u64 with store = test::choose_function(0);
                  vector::push_back<u64>(Borrow(Mutable)(sum), (f)(5));
                  vector::push_back<u64>(Borrow(Mutable)(sum), (g)(7));
                  vector::push_back<u64>(Borrow(Mutable)(sum), (h)(6));
                  {
                    let funcs: vector<|u64|u64 with store> = Vector<|u64|u64 with store>(test::choose_function(0), test::choose_function(1), test::choose_function(2));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 0)))(9));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 1)))(11));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 2)))(13));
                    if Eq<vector<u64>>(sum, Vector<u64>(6, 9, 12, 10, 21, 24, 18, 33, 52)) {
                      Tuple()
                    } else {
                      Abort(14566554180833181696)
                    }
                  }
                }
              }
            }
          }
        }
    }
    public fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::test


// -- Model dump after env processor acquires check:
module 0x42::test {
    use std::vector;
    private fun choose_function(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
          test::double
        } else {
          if Eq<u64>(key, 1) {
            test::triple
          } else {
            test::multiply_by_x(4)
          }
        }
    }
    private fun choose_function2(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
           move|x: u64| test::double(x) with drop, store
        } else {
          if Eq<u64>(key, 1) {
             move|x: u64| test::triple(x) with drop, store
          } else {
            if Eq<u64>(key, 2) {
              {
                let f: |u64|u64 with store = test::multiply_by_x(4);
                 move|x: u64| (f)(x) with drop, store
              }
            } else {
              if Eq<u64>(key, 3) {
                {
                  let f: |u64|u64 with store = test::multiply_by_x(5);
                   move|x: u64| (f)(x) with drop, store
                }
              } else {
                if Eq<u64>(key, 4) {
                  {
                    let f: |u64|u64 with copy+store =  move|y: u64| test::multiply(6, y) with drop, store;
                    f
                  }
                } else {
                  if Eq<u64>(key, 5) {
                     move|y: u64| test::multiply(y, 7) with drop, store
                  } else {
                    if Eq<u64>(key, 6) {
                      {
                        let f: |u64|u64 with copy+store =  move|y: u64| test::multiply(6, y) with drop, store;
                         move|x: u64| (f)(x) with drop, store
                      }
                    } else {
                      if Eq<u64>(key, 7) {
                        {
                          let f: |u64|u64 with store = test::multiply_by_x(5);
                           move|x: u64| (f)(x) with drop, store
                        }
                      } else {
                         move|y: u64| test::multiply3(y, 3, 4) with drop, store
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun choose_function3(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
          {
            let f: |u64|u64 with copy+store =  move|x: u64| test::double(x) with drop, store;
            f
          }
        } else {
          if Eq<u64>(key, 1) {
            {
              let g: |u64|u64 with copy+store =  move|x: u64| test::triple(x) with drop, store;
              g
            }
          } else {
            {
              let h: |u64|u64 with store = test::multiply_by_x(4);
              h
            }
          }
        }
    }
    public fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
    public fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    private fun multiply_by_x(x: u64): |u64|u64 with store {
         move|y: u64| test::multiply(x, y) with drop, store
    }
    public fun test_function_choosers() {
        test::test_functions(test::choose_function);
        test::test_functions(test::choose_function2);
        test::test_functions(test::choose_function3);
        Tuple()
    }
    public fun test_functions(choose_function_arg: |u64||u64|u64 with store) {
        {
          let sum: vector<u64> = Vector<u64>();
          {
            let x: u64 = 3;
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(0))(x));
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(1))(x));
            vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(2))(x));
            {
              let g: |u64|u64 with store = test::choose_function(1);
              {
                let h: |u64|u64 with store = test::choose_function(2);
                {
                  let f: |u64|u64 with store = test::choose_function(0);
                  vector::push_back<u64>(Borrow(Mutable)(sum), (f)(5));
                  vector::push_back<u64>(Borrow(Mutable)(sum), (g)(7));
                  vector::push_back<u64>(Borrow(Mutable)(sum), (h)(6));
                  {
                    let funcs: vector<|u64|u64 with store> = Vector<|u64|u64 with store>(test::choose_function(0), test::choose_function(1), test::choose_function(2));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 0)))(9));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 1)))(11));
                    vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 2)))(13));
                    if Eq<vector<u64>>(sum, Vector<u64>(6, 9, 12, 10, 21, 24, 18, 33, 52)) {
                      Tuple()
                    } else {
                      Abort(14566554180833181696)
                    }
                  }
                }
              }
            }
          }
        }
    }
    public fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::test


// -- Model dump after env processor simplifier:
module 0x42::test {
    use std::vector;
    private fun choose_function(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
          test::double
        } else {
          if Eq<u64>(key, 1) {
            test::triple
          } else {
            test::multiply_by_x(4)
          }
        }
    }
    private fun choose_function2(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
           move|x: u64| test::double(x) with drop, store
        } else {
          if Eq<u64>(key, 1) {
             move|x: u64| test::triple(x) with drop, store
          } else {
            if Eq<u64>(key, 2) {
              {
                let f: |u64|u64 with store = test::multiply_by_x(4);
                 move|x: u64| (f)(x) with drop, store
              }
            } else {
              if Eq<u64>(key, 3) {
                {
                  let f: |u64|u64 with store = test::multiply_by_x(5);
                   move|x: u64| (f)(x) with drop, store
                }
              } else {
                if Eq<u64>(key, 4) {
                  {
                    let f: |u64|u64 with copy+store =  move|y: u64| test::multiply(6, y) with drop, store;
                    f
                  }
                } else {
                  if Eq<u64>(key, 5) {
                     move|y: u64| test::multiply(y, 7) with drop, store
                  } else {
                    if Eq<u64>(key, 6) {
                      {
                        let f: |u64|u64 with copy+store =  move|y: u64| test::multiply(6, y) with drop, store;
                         move|x: u64| (f)(x) with drop, store
                      }
                    } else {
                      if Eq<u64>(key, 7) {
                        {
                          let f: |u64|u64 with store = test::multiply_by_x(5);
                           move|x: u64| (f)(x) with drop, store
                        }
                      } else {
                         move|y: u64| test::multiply3(y, 3, 4) with drop, store
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun choose_function3(key: u64): |u64|u64 with store {
        if Eq<u64>(key, 0) {
          {
            let f: |u64|u64 with copy+store =  move|x: u64| test::double(x) with drop, store;
            f
          }
        } else {
          if Eq<u64>(key, 1) {
            {
              let g: |u64|u64 with copy+store =  move|x: u64| test::triple(x) with drop, store;
              g
            }
          } else {
            {
              let h: |u64|u64 with store = test::multiply_by_x(4);
              h
            }
          }
        }
    }
    public fun double(x: u64): u64 {
        Mul<u64>(x, 2)
    }
    public fun multiply(x: u64,y: u64): u64 {
        Mul<u64>(x, y)
    }
    public fun multiply3(x: u64,y: u64,z: u64): u64 {
        Mul<u64>(Mul<u64>(x, y), z)
    }
    private fun multiply_by_x(x: u64): |u64|u64 with store {
         move|y: u64| test::multiply(x, y) with drop, store
    }
    public fun test_function_choosers() {
        test::test_functions(test::choose_function);
        test::test_functions(test::choose_function2);
        test::test_functions(test::choose_function3);
        Tuple()
    }
    public fun test_functions(choose_function_arg: |u64||u64|u64 with store) {
        {
          let sum: vector<u64> = Vector<u64>();
          vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(0))(3));
          vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(1))(3));
          vector::push_back<u64>(Borrow(Mutable)(sum), ((choose_function_arg)(2))(3));
          {
            let g: |u64|u64 with store = test::choose_function(1);
            {
              let h: |u64|u64 with store = test::choose_function(2);
              {
                let f: |u64|u64 with store = test::choose_function(0);
                vector::push_back<u64>(Borrow(Mutable)(sum), (f)(5));
                vector::push_back<u64>(Borrow(Mutable)(sum), (g)(7));
                vector::push_back<u64>(Borrow(Mutable)(sum), (h)(6));
                {
                  let funcs: vector<|u64|u64 with store> = Vector<|u64|u64 with store>(test::choose_function(0), test::choose_function(1), test::choose_function(2));
                  vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 0)))(9));
                  vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 1)))(11));
                  vector::push_back<u64>(Borrow(Mutable)(sum), (Deref(vector::borrow<|u64|u64>(Borrow(Immutable)(funcs), 2)))(13));
                  if Eq<vector<u64>>(sum, [Number(6), Number(9), Number(12), Number(10), Number(21), Number(24), Number(18), Number(33), Number(52)]) {
                    Tuple()
                  } else {
                    Abort(14566554180833181696)
                  }
                }
              }
            }
          }
        }
    }
    public fun triple(x: u64): u64 {
        Mul<u64>(x, 3)
    }
} // end 0x42::test



Diagnostics:
error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
   ┌─ tests/lambda/storable/return_func_ok.move:49:13
   │
49 │             move |y| multiply(y, 7) with store
   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: The body of a lambdas expression with `store` ability currently must be a simple call to an existing `public` function, with lambda params the same as the *final* arguments to the function call.
   ┌─ tests/lambda/storable/return_func_ok.move:57:13
   │
57 │             move |y| multiply3(y, 3, 4) with store
   │             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
