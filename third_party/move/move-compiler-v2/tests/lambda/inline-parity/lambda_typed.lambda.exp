// -- Model dump before env processor pipeline:
module 0x42::LambdaTest1 {
    public inline fun inline_apply(f: |u64|u64,b: u64): u64 {
        (f)(b)
    }
    public inline fun inline_apply1(f: |u64|u64,b: u64): u64 {
        LambdaTest1::inline_mul(Add<u64>((f)(b), 1), LambdaTest1::inline_mul(3, 4))
    }
    public inline fun inline_mul(a: u64,b: u64): u64 {
        Mul<u64>(a, b)
    }
} // end 0x42::LambdaTest1
module 0x42::LambdaTest2 {
    use 0x42::LambdaTest1; // resolved as: 0x42::LambdaTest1
    use std::vector;
    public inline fun foreach<T>(v: &vector<T>,action: |&T|) {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, vector::length<T>(v)) {
              (action)(vector::borrow<T>(v, i));
              i: u64 = Add<u64>(i, 1);
              Tuple()
            } else {
              break
            }
          }
        }
    }
    public inline fun inline_apply2(g: |u64|u64,c: u64): u64 {
        Add<u64>(LambdaTest1::inline_apply1(|z: u64| z, (g)(LambdaTest1::inline_mul(c, LambdaTest1::inline_apply(|x: u64| x, 3)))), 2)
    }
    public inline fun inline_apply3(g: |u64|u64,c: u64): u64 {
        Add<u64>(LambdaTest1::inline_apply1(g, LambdaTest1::inline_mul(c, LambdaTest1::inline_apply(|x: u64| LambdaTest1::inline_apply(|y: u64| y, x), 3))), 4)
    }
    public fun test_inline_lambda() {
        {
          let v: vector<u64> = Vector<u64>(1, 2, 3);
          {
            let product: u64 = 1;
            LambdaTest2::foreach<u64>(Borrow(Immutable)(v), |e: &u64| product: u64 = LambdaTest1::inline_mul(product, Deref(e)));
            Tuple()
          }
        }
    }
} // end 0x42::LambdaTest2
module 0x42::LambdaTest {
    use 0x42::LambdaTest2; // resolved as: 0x42::LambdaTest2
    public inline fun inline_apply(f: |u64|u64,b: u64): u64 {
        (f)(b)
    }
    public inline fun inline_apply_test(): u64 {
        Add<u64>(LambdaTest2::inline_apply2(|x: u64| Add<u64>(x, 1), 3), LambdaTest2::inline_apply2(|x: u64| Mul<u64>(x, x), LambdaTest::inline_apply(|y: u64| y, 3)))
    }
    private fun test_lambda() {
        {
          let a: u64 = LambdaTest::inline_apply_test();
          if Eq<u64>(a, 1) {
            Tuple()
          } else {
            Abort(0)
          };
          Tuple()
        }
    }
} // end 0x42::LambdaTest


// -- Model dump after env processor unused checks:
module 0x42::LambdaTest1 {
    public inline fun inline_apply(f: |u64|u64,b: u64): u64 {
        (f)(b)
    }
    public inline fun inline_apply1(f: |u64|u64,b: u64): u64 {
        LambdaTest1::inline_mul(Add<u64>((f)(b), 1), LambdaTest1::inline_mul(3, 4))
    }
    public inline fun inline_mul(a: u64,b: u64): u64 {
        Mul<u64>(a, b)
    }
} // end 0x42::LambdaTest1
module 0x42::LambdaTest2 {
    use 0x42::LambdaTest1; // resolved as: 0x42::LambdaTest1
    use std::vector;
    public inline fun foreach<T>(v: &vector<T>,action: |&T|) {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, vector::length<T>(v)) {
              (action)(vector::borrow<T>(v, i));
              i: u64 = Add<u64>(i, 1);
              Tuple()
            } else {
              break
            }
          }
        }
    }
    public inline fun inline_apply2(g: |u64|u64,c: u64): u64 {
        Add<u64>(LambdaTest1::inline_apply1(|z: u64| z, (g)(LambdaTest1::inline_mul(c, LambdaTest1::inline_apply(|x: u64| x, 3)))), 2)
    }
    public inline fun inline_apply3(g: |u64|u64,c: u64): u64 {
        Add<u64>(LambdaTest1::inline_apply1(g, LambdaTest1::inline_mul(c, LambdaTest1::inline_apply(|x: u64| LambdaTest1::inline_apply(|y: u64| y, x), 3))), 4)
    }
    public fun test_inline_lambda() {
        {
          let v: vector<u64> = Vector<u64>(1, 2, 3);
          {
            let product: u64 = 1;
            LambdaTest2::foreach<u64>(Borrow(Immutable)(v), |e: &u64| product: u64 = LambdaTest1::inline_mul(product, Deref(e)));
            Tuple()
          }
        }
    }
} // end 0x42::LambdaTest2
module 0x42::LambdaTest {
    use 0x42::LambdaTest2; // resolved as: 0x42::LambdaTest2
    public inline fun inline_apply(f: |u64|u64,b: u64): u64 {
        (f)(b)
    }
    public inline fun inline_apply_test(): u64 {
        Add<u64>(LambdaTest2::inline_apply2(|x: u64| Add<u64>(x, 1), 3), LambdaTest2::inline_apply2(|x: u64| Mul<u64>(x, x), LambdaTest::inline_apply(|y: u64| y, 3)))
    }
    private fun test_lambda() {
        {
          let a: u64 = LambdaTest::inline_apply_test();
          if Eq<u64>(a, 1) {
            Tuple()
          } else {
            Abort(0)
          };
          Tuple()
        }
    }
} // end 0x42::LambdaTest


// -- Model dump after env processor type parameter check:
module 0x42::LambdaTest1 {
    public inline fun inline_apply(f: |u64|u64,b: u64): u64 {
        (f)(b)
    }
    public inline fun inline_apply1(f: |u64|u64,b: u64): u64 {
        LambdaTest1::inline_mul(Add<u64>((f)(b), 1), LambdaTest1::inline_mul(3, 4))
    }
    public inline fun inline_mul(a: u64,b: u64): u64 {
        Mul<u64>(a, b)
    }
} // end 0x42::LambdaTest1
module 0x42::LambdaTest2 {
    use 0x42::LambdaTest1; // resolved as: 0x42::LambdaTest1
    use std::vector;
    public inline fun foreach<T>(v: &vector<T>,action: |&T|) {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, vector::length<T>(v)) {
              (action)(vector::borrow<T>(v, i));
              i: u64 = Add<u64>(i, 1);
              Tuple()
            } else {
              break
            }
          }
        }
    }
    public inline fun inline_apply2(g: |u64|u64,c: u64): u64 {
        Add<u64>(LambdaTest1::inline_apply1(|z: u64| z, (g)(LambdaTest1::inline_mul(c, LambdaTest1::inline_apply(|x: u64| x, 3)))), 2)
    }
    public inline fun inline_apply3(g: |u64|u64,c: u64): u64 {
        Add<u64>(LambdaTest1::inline_apply1(g, LambdaTest1::inline_mul(c, LambdaTest1::inline_apply(|x: u64| LambdaTest1::inline_apply(|y: u64| y, x), 3))), 4)
    }
    public fun test_inline_lambda() {
        {
          let v: vector<u64> = Vector<u64>(1, 2, 3);
          {
            let product: u64 = 1;
            LambdaTest2::foreach<u64>(Borrow(Immutable)(v), |e: &u64| product: u64 = LambdaTest1::inline_mul(product, Deref(e)));
            Tuple()
          }
        }
    }
} // end 0x42::LambdaTest2
module 0x42::LambdaTest {
    use 0x42::LambdaTest2; // resolved as: 0x42::LambdaTest2
    public inline fun inline_apply(f: |u64|u64,b: u64): u64 {
        (f)(b)
    }
    public inline fun inline_apply_test(): u64 {
        Add<u64>(LambdaTest2::inline_apply2(|x: u64| Add<u64>(x, 1), 3), LambdaTest2::inline_apply2(|x: u64| Mul<u64>(x, x), LambdaTest::inline_apply(|y: u64| y, 3)))
    }
    private fun test_lambda() {
        {
          let a: u64 = LambdaTest::inline_apply_test();
          if Eq<u64>(a, 1) {
            Tuple()
          } else {
            Abort(0)
          };
          Tuple()
        }
    }
} // end 0x42::LambdaTest


// -- Model dump after env processor check recursive struct definition:
module 0x42::LambdaTest1 {
    public inline fun inline_apply(f: |u64|u64,b: u64): u64 {
        (f)(b)
    }
    public inline fun inline_apply1(f: |u64|u64,b: u64): u64 {
        LambdaTest1::inline_mul(Add<u64>((f)(b), 1), LambdaTest1::inline_mul(3, 4))
    }
    public inline fun inline_mul(a: u64,b: u64): u64 {
        Mul<u64>(a, b)
    }
} // end 0x42::LambdaTest1
module 0x42::LambdaTest2 {
    use 0x42::LambdaTest1; // resolved as: 0x42::LambdaTest1
    use std::vector;
    public inline fun foreach<T>(v: &vector<T>,action: |&T|) {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, vector::length<T>(v)) {
              (action)(vector::borrow<T>(v, i));
              i: u64 = Add<u64>(i, 1);
              Tuple()
            } else {
              break
            }
          }
        }
    }
    public inline fun inline_apply2(g: |u64|u64,c: u64): u64 {
        Add<u64>(LambdaTest1::inline_apply1(|z: u64| z, (g)(LambdaTest1::inline_mul(c, LambdaTest1::inline_apply(|x: u64| x, 3)))), 2)
    }
    public inline fun inline_apply3(g: |u64|u64,c: u64): u64 {
        Add<u64>(LambdaTest1::inline_apply1(g, LambdaTest1::inline_mul(c, LambdaTest1::inline_apply(|x: u64| LambdaTest1::inline_apply(|y: u64| y, x), 3))), 4)
    }
    public fun test_inline_lambda() {
        {
          let v: vector<u64> = Vector<u64>(1, 2, 3);
          {
            let product: u64 = 1;
            LambdaTest2::foreach<u64>(Borrow(Immutable)(v), |e: &u64| product: u64 = LambdaTest1::inline_mul(product, Deref(e)));
            Tuple()
          }
        }
    }
} // end 0x42::LambdaTest2
module 0x42::LambdaTest {
    use 0x42::LambdaTest2; // resolved as: 0x42::LambdaTest2
    public inline fun inline_apply(f: |u64|u64,b: u64): u64 {
        (f)(b)
    }
    public inline fun inline_apply_test(): u64 {
        Add<u64>(LambdaTest2::inline_apply2(|x: u64| Add<u64>(x, 1), 3), LambdaTest2::inline_apply2(|x: u64| Mul<u64>(x, x), LambdaTest::inline_apply(|y: u64| y, 3)))
    }
    private fun test_lambda() {
        {
          let a: u64 = LambdaTest::inline_apply_test();
          if Eq<u64>(a, 1) {
            Tuple()
          } else {
            Abort(0)
          };
          Tuple()
        }
    }
} // end 0x42::LambdaTest


// -- Model dump after env processor check cyclic type instantiation:
module 0x42::LambdaTest1 {
    public inline fun inline_apply(f: |u64|u64,b: u64): u64 {
        (f)(b)
    }
    public inline fun inline_apply1(f: |u64|u64,b: u64): u64 {
        LambdaTest1::inline_mul(Add<u64>((f)(b), 1), LambdaTest1::inline_mul(3, 4))
    }
    public inline fun inline_mul(a: u64,b: u64): u64 {
        Mul<u64>(a, b)
    }
} // end 0x42::LambdaTest1
module 0x42::LambdaTest2 {
    use 0x42::LambdaTest1; // resolved as: 0x42::LambdaTest1
    use std::vector;
    public inline fun foreach<T>(v: &vector<T>,action: |&T|) {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, vector::length<T>(v)) {
              (action)(vector::borrow<T>(v, i));
              i: u64 = Add<u64>(i, 1);
              Tuple()
            } else {
              break
            }
          }
        }
    }
    public inline fun inline_apply2(g: |u64|u64,c: u64): u64 {
        Add<u64>(LambdaTest1::inline_apply1(|z: u64| z, (g)(LambdaTest1::inline_mul(c, LambdaTest1::inline_apply(|x: u64| x, 3)))), 2)
    }
    public inline fun inline_apply3(g: |u64|u64,c: u64): u64 {
        Add<u64>(LambdaTest1::inline_apply1(g, LambdaTest1::inline_mul(c, LambdaTest1::inline_apply(|x: u64| LambdaTest1::inline_apply(|y: u64| y, x), 3))), 4)
    }
    public fun test_inline_lambda() {
        {
          let v: vector<u64> = Vector<u64>(1, 2, 3);
          {
            let product: u64 = 1;
            LambdaTest2::foreach<u64>(Borrow(Immutable)(v), |e: &u64| product: u64 = LambdaTest1::inline_mul(product, Deref(e)));
            Tuple()
          }
        }
    }
} // end 0x42::LambdaTest2
module 0x42::LambdaTest {
    use 0x42::LambdaTest2; // resolved as: 0x42::LambdaTest2
    public inline fun inline_apply(f: |u64|u64,b: u64): u64 {
        (f)(b)
    }
    public inline fun inline_apply_test(): u64 {
        Add<u64>(LambdaTest2::inline_apply2(|x: u64| Add<u64>(x, 1), 3), LambdaTest2::inline_apply2(|x: u64| Mul<u64>(x, x), LambdaTest::inline_apply(|y: u64| y, 3)))
    }
    private fun test_lambda() {
        {
          let a: u64 = LambdaTest::inline_apply_test();
          if Eq<u64>(a, 1) {
            Tuple()
          } else {
            Abort(0)
          };
          Tuple()
        }
    }
} // end 0x42::LambdaTest


// -- Model dump after env processor unused struct params check:
module 0x42::LambdaTest1 {
    public inline fun inline_apply(f: |u64|u64,b: u64): u64 {
        (f)(b)
    }
    public inline fun inline_apply1(f: |u64|u64,b: u64): u64 {
        LambdaTest1::inline_mul(Add<u64>((f)(b), 1), LambdaTest1::inline_mul(3, 4))
    }
    public inline fun inline_mul(a: u64,b: u64): u64 {
        Mul<u64>(a, b)
    }
} // end 0x42::LambdaTest1
module 0x42::LambdaTest2 {
    use 0x42::LambdaTest1; // resolved as: 0x42::LambdaTest1
    use std::vector;
    public inline fun foreach<T>(v: &vector<T>,action: |&T|) {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, vector::length<T>(v)) {
              (action)(vector::borrow<T>(v, i));
              i: u64 = Add<u64>(i, 1);
              Tuple()
            } else {
              break
            }
          }
        }
    }
    public inline fun inline_apply2(g: |u64|u64,c: u64): u64 {
        Add<u64>(LambdaTest1::inline_apply1(|z: u64| z, (g)(LambdaTest1::inline_mul(c, LambdaTest1::inline_apply(|x: u64| x, 3)))), 2)
    }
    public inline fun inline_apply3(g: |u64|u64,c: u64): u64 {
        Add<u64>(LambdaTest1::inline_apply1(g, LambdaTest1::inline_mul(c, LambdaTest1::inline_apply(|x: u64| LambdaTest1::inline_apply(|y: u64| y, x), 3))), 4)
    }
    public fun test_inline_lambda() {
        {
          let v: vector<u64> = Vector<u64>(1, 2, 3);
          {
            let product: u64 = 1;
            LambdaTest2::foreach<u64>(Borrow(Immutable)(v), |e: &u64| product: u64 = LambdaTest1::inline_mul(product, Deref(e)));
            Tuple()
          }
        }
    }
} // end 0x42::LambdaTest2
module 0x42::LambdaTest {
    use 0x42::LambdaTest2; // resolved as: 0x42::LambdaTest2
    public inline fun inline_apply(f: |u64|u64,b: u64): u64 {
        (f)(b)
    }
    public inline fun inline_apply_test(): u64 {
        Add<u64>(LambdaTest2::inline_apply2(|x: u64| Add<u64>(x, 1), 3), LambdaTest2::inline_apply2(|x: u64| Mul<u64>(x, x), LambdaTest::inline_apply(|y: u64| y, 3)))
    }
    private fun test_lambda() {
        {
          let a: u64 = LambdaTest::inline_apply_test();
          if Eq<u64>(a, 1) {
            Tuple()
          } else {
            Abort(0)
          };
          Tuple()
        }
    }
} // end 0x42::LambdaTest


// -- Model dump after env processor access and use check before inlining:
module 0x42::LambdaTest1 {
    public inline fun inline_apply(f: |u64|u64,b: u64): u64 {
        (f)(b)
    }
    public inline fun inline_apply1(f: |u64|u64,b: u64): u64 {
        LambdaTest1::inline_mul(Add<u64>((f)(b), 1), LambdaTest1::inline_mul(3, 4))
    }
    public inline fun inline_mul(a: u64,b: u64): u64 {
        Mul<u64>(a, b)
    }
} // end 0x42::LambdaTest1
module 0x42::LambdaTest2 {
    use 0x42::LambdaTest1; // resolved as: 0x42::LambdaTest1
    use std::vector;
    public inline fun foreach<T>(v: &vector<T>,action: |&T|) {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, vector::length<T>(v)) {
              (action)(vector::borrow<T>(v, i));
              i: u64 = Add<u64>(i, 1);
              Tuple()
            } else {
              break
            }
          }
        }
    }
    public inline fun inline_apply2(g: |u64|u64,c: u64): u64 {
        Add<u64>(LambdaTest1::inline_apply1(|z: u64| z, (g)(LambdaTest1::inline_mul(c, LambdaTest1::inline_apply(|x: u64| x, 3)))), 2)
    }
    public inline fun inline_apply3(g: |u64|u64,c: u64): u64 {
        Add<u64>(LambdaTest1::inline_apply1(g, LambdaTest1::inline_mul(c, LambdaTest1::inline_apply(|x: u64| LambdaTest1::inline_apply(|y: u64| y, x), 3))), 4)
    }
    public fun test_inline_lambda() {
        {
          let v: vector<u64> = Vector<u64>(1, 2, 3);
          {
            let product: u64 = 1;
            LambdaTest2::foreach<u64>(Borrow(Immutable)(v), |e: &u64| product: u64 = LambdaTest1::inline_mul(product, Deref(e)));
            Tuple()
          }
        }
    }
} // end 0x42::LambdaTest2
module 0x42::LambdaTest {
    use 0x42::LambdaTest2; // resolved as: 0x42::LambdaTest2
    public inline fun inline_apply(f: |u64|u64,b: u64): u64 {
        (f)(b)
    }
    public inline fun inline_apply_test(): u64 {
        Add<u64>(LambdaTest2::inline_apply2(|x: u64| Add<u64>(x, 1), 3), LambdaTest2::inline_apply2(|x: u64| Mul<u64>(x, x), LambdaTest::inline_apply(|y: u64| y, 3)))
    }
    private fun test_lambda() {
        {
          let a: u64 = LambdaTest::inline_apply_test();
          if Eq<u64>(a, 1) {
            Tuple()
          } else {
            Abort(0)
          };
          Tuple()
        }
    }
} // end 0x42::LambdaTest


// -- Model dump after env processor inlining:
module 0x42::LambdaTest1 {
    public inline fun inline_apply(f: |u64|u64,b: u64): u64 {
        (f)(b)
    }
    public inline fun inline_apply1(f: |u64|u64,b: u64): u64 {
        {
          let (a: u64, b: u64): (u64, u64) = Tuple(Add<u64>((f)(b), 1), {
            let (a: u64, b: u64): (u64, u64) = Tuple(3, 4);
            Mul<u64>(a, b)
          });
          Mul<u64>(a, b)
        }
    }
    public inline fun inline_mul(a: u64,b: u64): u64 {
        Mul<u64>(a, b)
    }
} // end 0x42::LambdaTest1
module 0x42::LambdaTest2 {
    use 0x42::LambdaTest1; // resolved as: 0x42::LambdaTest1
    use std::vector;
    public inline fun foreach<T>(v: &vector<T>,action: |&T|) {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, vector::length<T>(v)) {
              (action)(vector::borrow<T>(v, i));
              i: u64 = Add<u64>(i, 1);
              Tuple()
            } else {
              break
            }
          }
        }
    }
    public inline fun inline_apply2(g: |u64|u64,c: u64): u64 {
        Add<u64>({
          let (b: u64): (u64) = Tuple((g)({
            let (a: u64, b: u64): (u64, u64) = Tuple(c, {
              let (b: u64): (u64) = Tuple(3);
              {
                let (x: u64): (u64) = Tuple(b);
                x
              }
            });
            Mul<u64>(a, b)
          }));
          {
            let (a: u64, b: u64): (u64, u64) = Tuple(Add<u64>({
              let (z: u64): (u64) = Tuple(b);
              z
            }, 1), {
              let (a: u64, b: u64): (u64, u64) = Tuple(3, 4);
              Mul<u64>(a, b)
            });
            Mul<u64>(a, b)
          }
        }, 2)
    }
    public inline fun inline_apply3(g: |u64|u64,c: u64): u64 {
        Add<u64>(LambdaTest1::inline_apply1(g, LambdaTest1::inline_mul(c, LambdaTest1::inline_apply(|x: u64| LambdaTest1::inline_apply(|y: u64| y, x), 3))), 4)
    }
    public fun test_inline_lambda() {
        {
          let v: vector<u64> = Vector<u64>(1, 2, 3);
          {
            let product: u64 = 1;
            {
              let (v: &vector<u64>): (&vector<u64>) = Tuple(Borrow(Immutable)(v));
              {
                let i: u64 = 0;
                loop {
                  if Lt<u64>(i, vector::length<u64>(v)) {
                    {
                      let (e: &u64): (&u64) = Tuple(vector::borrow<u64>(v, i));
                      product: u64 = {
                        let (a: u64, b: u64): (u64, u64) = Tuple(product, Deref(e));
                        Mul<u64>(a, b)
                      }
                    };
                    i: u64 = Add<u64>(i, 1);
                    Tuple()
                  } else {
                    break
                  }
                }
              }
            };
            Tuple()
          }
        }
    }
} // end 0x42::LambdaTest2
module 0x42::LambdaTest {
    use 0x42::LambdaTest2; // resolved as: 0x42::LambdaTest2
    public inline fun inline_apply(f: |u64|u64,b: u64): u64 {
        (f)(b)
    }
    public inline fun inline_apply_test(): u64 {
        Add<u64>({
          let (c: u64): (u64) = Tuple(3);
          Add<u64>({
            let (b: u64): (u64) = Tuple({
              let (x: u64): (u64) = Tuple({
                let (a: u64, b: u64): (u64, u64) = Tuple(c, {
                  let (b: u64): (u64) = Tuple(3);
                  {
                    let (x: u64): (u64) = Tuple(b);
                    x
                  }
                });
                Mul<u64>(a, b)
              });
              Add<u64>(x, 1)
            });
            {
              let (a: u64, b: u64): (u64, u64) = Tuple(Add<u64>({
                let (z: u64): (u64) = Tuple(b);
                z
              }, 1), {
                let (a: u64, b: u64): (u64, u64) = Tuple(3, 4);
                Mul<u64>(a, b)
              });
              Mul<u64>(a, b)
            }
          }, 2)
        }, {
          let (c: u64): (u64) = Tuple({
            let (b: u64): (u64) = Tuple(3);
            {
              let (y: u64): (u64) = Tuple(b);
              y
            }
          });
          Add<u64>({
            let (b: u64): (u64) = Tuple({
              let (x: u64): (u64) = Tuple({
                let (a: u64, b: u64): (u64, u64) = Tuple(c, {
                  let (b: u64): (u64) = Tuple(3);
                  {
                    let (x: u64): (u64) = Tuple(b);
                    x
                  }
                });
                Mul<u64>(a, b)
              });
              Mul<u64>(x, x)
            });
            {
              let (a: u64, b: u64): (u64, u64) = Tuple(Add<u64>({
                let (z: u64): (u64) = Tuple(b);
                z
              }, 1), {
                let (a: u64, b: u64): (u64, u64) = Tuple(3, 4);
                Mul<u64>(a, b)
              });
              Mul<u64>(a, b)
            }
          }, 2)
        })
    }
    private fun test_lambda() {
        {
          let a: u64 = {
            let (): ();
            Add<u64>({
              let (c: u64): (u64) = Tuple(3);
              Add<u64>({
                let (b: u64): (u64) = Tuple({
                  let (x: u64): (u64) = Tuple({
                    let (a: u64, b: u64): (u64, u64) = Tuple(c, {
                      let (b: u64): (u64) = Tuple(3);
                      {
                        let (x: u64): (u64) = Tuple(b);
                        x
                      }
                    });
                    Mul<u64>(a, b)
                  });
                  Add<u64>(x, 1)
                });
                {
                  let (a: u64, b: u64): (u64, u64) = Tuple(Add<u64>({
                    let (z: u64): (u64) = Tuple(b);
                    z
                  }, 1), {
                    let (a: u64, b: u64): (u64, u64) = Tuple(3, 4);
                    Mul<u64>(a, b)
                  });
                  Mul<u64>(a, b)
                }
              }, 2)
            }, {
              let (c: u64): (u64) = Tuple({
                let (b: u64): (u64) = Tuple(3);
                {
                  let (y: u64): (u64) = Tuple(b);
                  y
                }
              });
              Add<u64>({
                let (b: u64): (u64) = Tuple({
                  let (x: u64): (u64) = Tuple({
                    let (a: u64, b: u64): (u64, u64) = Tuple(c, {
                      let (b: u64): (u64) = Tuple(3);
                      {
                        let (x: u64): (u64) = Tuple(b);
                        x
                      }
                    });
                    Mul<u64>(a, b)
                  });
                  Mul<u64>(x, x)
                });
                {
                  let (a: u64, b: u64): (u64, u64) = Tuple(Add<u64>({
                    let (z: u64): (u64) = Tuple(b);
                    z
                  }, 1), {
                    let (a: u64, b: u64): (u64, u64) = Tuple(3, 4);
                    Mul<u64>(a, b)
                  });
                  Mul<u64>(a, b)
                }
              }, 2)
            })
          };
          if Eq<u64>(a, 1) {
            Tuple()
          } else {
            Abort(0)
          };
          Tuple()
        }
    }
} // end 0x42::LambdaTest


// -- Model dump after env processor access and use check after inlining:
module 0x42::LambdaTest1 {
    public inline fun inline_apply(f: |u64|u64,b: u64): u64 {
        (f)(b)
    }
    public inline fun inline_apply1(f: |u64|u64,b: u64): u64 {
        {
          let (a: u64, b: u64): (u64, u64) = Tuple(Add<u64>((f)(b), 1), {
            let (a: u64, b: u64): (u64, u64) = Tuple(3, 4);
            Mul<u64>(a, b)
          });
          Mul<u64>(a, b)
        }
    }
    public inline fun inline_mul(a: u64,b: u64): u64 {
        Mul<u64>(a, b)
    }
} // end 0x42::LambdaTest1
module 0x42::LambdaTest2 {
    use 0x42::LambdaTest1; // resolved as: 0x42::LambdaTest1
    use std::vector;
    public inline fun foreach<T>(v: &vector<T>,action: |&T|) {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, vector::length<T>(v)) {
              (action)(vector::borrow<T>(v, i));
              i: u64 = Add<u64>(i, 1);
              Tuple()
            } else {
              break
            }
          }
        }
    }
    public inline fun inline_apply2(g: |u64|u64,c: u64): u64 {
        Add<u64>({
          let (b: u64): (u64) = Tuple((g)({
            let (a: u64, b: u64): (u64, u64) = Tuple(c, {
              let (b: u64): (u64) = Tuple(3);
              {
                let (x: u64): (u64) = Tuple(b);
                x
              }
            });
            Mul<u64>(a, b)
          }));
          {
            let (a: u64, b: u64): (u64, u64) = Tuple(Add<u64>({
              let (z: u64): (u64) = Tuple(b);
              z
            }, 1), {
              let (a: u64, b: u64): (u64, u64) = Tuple(3, 4);
              Mul<u64>(a, b)
            });
            Mul<u64>(a, b)
          }
        }, 2)
    }
    public inline fun inline_apply3(g: |u64|u64,c: u64): u64 {
        Add<u64>(LambdaTest1::inline_apply1(g, LambdaTest1::inline_mul(c, LambdaTest1::inline_apply(|x: u64| LambdaTest1::inline_apply(|y: u64| y, x), 3))), 4)
    }
    public fun test_inline_lambda() {
        {
          let v: vector<u64> = Vector<u64>(1, 2, 3);
          {
            let product: u64 = 1;
            {
              let (v: &vector<u64>): (&vector<u64>) = Tuple(Borrow(Immutable)(v));
              {
                let i: u64 = 0;
                loop {
                  if Lt<u64>(i, vector::length<u64>(v)) {
                    {
                      let (e: &u64): (&u64) = Tuple(vector::borrow<u64>(v, i));
                      product: u64 = {
                        let (a: u64, b: u64): (u64, u64) = Tuple(product, Deref(e));
                        Mul<u64>(a, b)
                      }
                    };
                    i: u64 = Add<u64>(i, 1);
                    Tuple()
                  } else {
                    break
                  }
                }
              }
            };
            Tuple()
          }
        }
    }
} // end 0x42::LambdaTest2
module 0x42::LambdaTest {
    use 0x42::LambdaTest2; // resolved as: 0x42::LambdaTest2
    public inline fun inline_apply(f: |u64|u64,b: u64): u64 {
        (f)(b)
    }
    public inline fun inline_apply_test(): u64 {
        Add<u64>({
          let (c: u64): (u64) = Tuple(3);
          Add<u64>({
            let (b: u64): (u64) = Tuple({
              let (x: u64): (u64) = Tuple({
                let (a: u64, b: u64): (u64, u64) = Tuple(c, {
                  let (b: u64): (u64) = Tuple(3);
                  {
                    let (x: u64): (u64) = Tuple(b);
                    x
                  }
                });
                Mul<u64>(a, b)
              });
              Add<u64>(x, 1)
            });
            {
              let (a: u64, b: u64): (u64, u64) = Tuple(Add<u64>({
                let (z: u64): (u64) = Tuple(b);
                z
              }, 1), {
                let (a: u64, b: u64): (u64, u64) = Tuple(3, 4);
                Mul<u64>(a, b)
              });
              Mul<u64>(a, b)
            }
          }, 2)
        }, {
          let (c: u64): (u64) = Tuple({
            let (b: u64): (u64) = Tuple(3);
            {
              let (y: u64): (u64) = Tuple(b);
              y
            }
          });
          Add<u64>({
            let (b: u64): (u64) = Tuple({
              let (x: u64): (u64) = Tuple({
                let (a: u64, b: u64): (u64, u64) = Tuple(c, {
                  let (b: u64): (u64) = Tuple(3);
                  {
                    let (x: u64): (u64) = Tuple(b);
                    x
                  }
                });
                Mul<u64>(a, b)
              });
              Mul<u64>(x, x)
            });
            {
              let (a: u64, b: u64): (u64, u64) = Tuple(Add<u64>({
                let (z: u64): (u64) = Tuple(b);
                z
              }, 1), {
                let (a: u64, b: u64): (u64, u64) = Tuple(3, 4);
                Mul<u64>(a, b)
              });
              Mul<u64>(a, b)
            }
          }, 2)
        })
    }
    private fun test_lambda() {
        {
          let a: u64 = {
            let (): ();
            Add<u64>({
              let (c: u64): (u64) = Tuple(3);
              Add<u64>({
                let (b: u64): (u64) = Tuple({
                  let (x: u64): (u64) = Tuple({
                    let (a: u64, b: u64): (u64, u64) = Tuple(c, {
                      let (b: u64): (u64) = Tuple(3);
                      {
                        let (x: u64): (u64) = Tuple(b);
                        x
                      }
                    });
                    Mul<u64>(a, b)
                  });
                  Add<u64>(x, 1)
                });
                {
                  let (a: u64, b: u64): (u64, u64) = Tuple(Add<u64>({
                    let (z: u64): (u64) = Tuple(b);
                    z
                  }, 1), {
                    let (a: u64, b: u64): (u64, u64) = Tuple(3, 4);
                    Mul<u64>(a, b)
                  });
                  Mul<u64>(a, b)
                }
              }, 2)
            }, {
              let (c: u64): (u64) = Tuple({
                let (b: u64): (u64) = Tuple(3);
                {
                  let (y: u64): (u64) = Tuple(b);
                  y
                }
              });
              Add<u64>({
                let (b: u64): (u64) = Tuple({
                  let (x: u64): (u64) = Tuple({
                    let (a: u64, b: u64): (u64, u64) = Tuple(c, {
                      let (b: u64): (u64) = Tuple(3);
                      {
                        let (x: u64): (u64) = Tuple(b);
                        x
                      }
                    });
                    Mul<u64>(a, b)
                  });
                  Mul<u64>(x, x)
                });
                {
                  let (a: u64, b: u64): (u64, u64) = Tuple(Add<u64>({
                    let (z: u64): (u64) = Tuple(b);
                    z
                  }, 1), {
                    let (a: u64, b: u64): (u64, u64) = Tuple(3, 4);
                    Mul<u64>(a, b)
                  });
                  Mul<u64>(a, b)
                }
              }, 2)
            })
          };
          if Eq<u64>(a, 1) {
            Tuple()
          } else {
            Abort(0)
          };
          Tuple()
        }
    }
} // end 0x42::LambdaTest


// -- Model dump after env processor acquires check:
module 0x42::LambdaTest1 {
    public inline fun inline_apply(f: |u64|u64,b: u64): u64 {
        (f)(b)
    }
    public inline fun inline_apply1(f: |u64|u64,b: u64): u64 {
        {
          let (a: u64, b: u64): (u64, u64) = Tuple(Add<u64>((f)(b), 1), {
            let (a: u64, b: u64): (u64, u64) = Tuple(3, 4);
            Mul<u64>(a, b)
          });
          Mul<u64>(a, b)
        }
    }
    public inline fun inline_mul(a: u64,b: u64): u64 {
        Mul<u64>(a, b)
    }
} // end 0x42::LambdaTest1
module 0x42::LambdaTest2 {
    use 0x42::LambdaTest1; // resolved as: 0x42::LambdaTest1
    use std::vector;
    public inline fun foreach<T>(v: &vector<T>,action: |&T|) {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, vector::length<T>(v)) {
              (action)(vector::borrow<T>(v, i));
              i: u64 = Add<u64>(i, 1);
              Tuple()
            } else {
              break
            }
          }
        }
    }
    public inline fun inline_apply2(g: |u64|u64,c: u64): u64 {
        Add<u64>({
          let (b: u64): (u64) = Tuple((g)({
            let (a: u64, b: u64): (u64, u64) = Tuple(c, {
              let (b: u64): (u64) = Tuple(3);
              {
                let (x: u64): (u64) = Tuple(b);
                x
              }
            });
            Mul<u64>(a, b)
          }));
          {
            let (a: u64, b: u64): (u64, u64) = Tuple(Add<u64>({
              let (z: u64): (u64) = Tuple(b);
              z
            }, 1), {
              let (a: u64, b: u64): (u64, u64) = Tuple(3, 4);
              Mul<u64>(a, b)
            });
            Mul<u64>(a, b)
          }
        }, 2)
    }
    public inline fun inline_apply3(g: |u64|u64,c: u64): u64 {
        Add<u64>(LambdaTest1::inline_apply1(g, LambdaTest1::inline_mul(c, LambdaTest1::inline_apply(|x: u64| LambdaTest1::inline_apply(|y: u64| y, x), 3))), 4)
    }
    public fun test_inline_lambda() {
        {
          let v: vector<u64> = Vector<u64>(1, 2, 3);
          {
            let product: u64 = 1;
            {
              let (v: &vector<u64>): (&vector<u64>) = Tuple(Borrow(Immutable)(v));
              {
                let i: u64 = 0;
                loop {
                  if Lt<u64>(i, vector::length<u64>(v)) {
                    {
                      let (e: &u64): (&u64) = Tuple(vector::borrow<u64>(v, i));
                      product: u64 = {
                        let (a: u64, b: u64): (u64, u64) = Tuple(product, Deref(e));
                        Mul<u64>(a, b)
                      }
                    };
                    i: u64 = Add<u64>(i, 1);
                    Tuple()
                  } else {
                    break
                  }
                }
              }
            };
            Tuple()
          }
        }
    }
} // end 0x42::LambdaTest2
module 0x42::LambdaTest {
    use 0x42::LambdaTest2; // resolved as: 0x42::LambdaTest2
    public inline fun inline_apply(f: |u64|u64,b: u64): u64 {
        (f)(b)
    }
    public inline fun inline_apply_test(): u64 {
        Add<u64>({
          let (c: u64): (u64) = Tuple(3);
          Add<u64>({
            let (b: u64): (u64) = Tuple({
              let (x: u64): (u64) = Tuple({
                let (a: u64, b: u64): (u64, u64) = Tuple(c, {
                  let (b: u64): (u64) = Tuple(3);
                  {
                    let (x: u64): (u64) = Tuple(b);
                    x
                  }
                });
                Mul<u64>(a, b)
              });
              Add<u64>(x, 1)
            });
            {
              let (a: u64, b: u64): (u64, u64) = Tuple(Add<u64>({
                let (z: u64): (u64) = Tuple(b);
                z
              }, 1), {
                let (a: u64, b: u64): (u64, u64) = Tuple(3, 4);
                Mul<u64>(a, b)
              });
              Mul<u64>(a, b)
            }
          }, 2)
        }, {
          let (c: u64): (u64) = Tuple({
            let (b: u64): (u64) = Tuple(3);
            {
              let (y: u64): (u64) = Tuple(b);
              y
            }
          });
          Add<u64>({
            let (b: u64): (u64) = Tuple({
              let (x: u64): (u64) = Tuple({
                let (a: u64, b: u64): (u64, u64) = Tuple(c, {
                  let (b: u64): (u64) = Tuple(3);
                  {
                    let (x: u64): (u64) = Tuple(b);
                    x
                  }
                });
                Mul<u64>(a, b)
              });
              Mul<u64>(x, x)
            });
            {
              let (a: u64, b: u64): (u64, u64) = Tuple(Add<u64>({
                let (z: u64): (u64) = Tuple(b);
                z
              }, 1), {
                let (a: u64, b: u64): (u64, u64) = Tuple(3, 4);
                Mul<u64>(a, b)
              });
              Mul<u64>(a, b)
            }
          }, 2)
        })
    }
    private fun test_lambda() {
        {
          let a: u64 = {
            let (): ();
            Add<u64>({
              let (c: u64): (u64) = Tuple(3);
              Add<u64>({
                let (b: u64): (u64) = Tuple({
                  let (x: u64): (u64) = Tuple({
                    let (a: u64, b: u64): (u64, u64) = Tuple(c, {
                      let (b: u64): (u64) = Tuple(3);
                      {
                        let (x: u64): (u64) = Tuple(b);
                        x
                      }
                    });
                    Mul<u64>(a, b)
                  });
                  Add<u64>(x, 1)
                });
                {
                  let (a: u64, b: u64): (u64, u64) = Tuple(Add<u64>({
                    let (z: u64): (u64) = Tuple(b);
                    z
                  }, 1), {
                    let (a: u64, b: u64): (u64, u64) = Tuple(3, 4);
                    Mul<u64>(a, b)
                  });
                  Mul<u64>(a, b)
                }
              }, 2)
            }, {
              let (c: u64): (u64) = Tuple({
                let (b: u64): (u64) = Tuple(3);
                {
                  let (y: u64): (u64) = Tuple(b);
                  y
                }
              });
              Add<u64>({
                let (b: u64): (u64) = Tuple({
                  let (x: u64): (u64) = Tuple({
                    let (a: u64, b: u64): (u64, u64) = Tuple(c, {
                      let (b: u64): (u64) = Tuple(3);
                      {
                        let (x: u64): (u64) = Tuple(b);
                        x
                      }
                    });
                    Mul<u64>(a, b)
                  });
                  Mul<u64>(x, x)
                });
                {
                  let (a: u64, b: u64): (u64, u64) = Tuple(Add<u64>({
                    let (z: u64): (u64) = Tuple(b);
                    z
                  }, 1), {
                    let (a: u64, b: u64): (u64, u64) = Tuple(3, 4);
                    Mul<u64>(a, b)
                  });
                  Mul<u64>(a, b)
                }
              }, 2)
            })
          };
          if Eq<u64>(a, 1) {
            Tuple()
          } else {
            Abort(0)
          };
          Tuple()
        }
    }
} // end 0x42::LambdaTest


// -- Model dump after env processor simplifier:
module 0x42::LambdaTest1 {
    public inline fun inline_apply(f: |u64|u64,b: u64): u64 {
        (f)(b)
    }
    public inline fun inline_apply1(f: |u64|u64,b: u64): u64 {
        {
          let (a: u64, b: u64): (u64, u64) = Tuple(Add<u64>((f)(b), 1), 12);
          Mul<u64>(a, 12)
        }
    }
    public inline fun inline_mul(a: u64,b: u64): u64 {
        Mul<u64>(a, b)
    }
} // end 0x42::LambdaTest1
module 0x42::LambdaTest2 {
    use 0x42::LambdaTest1; // resolved as: 0x42::LambdaTest1
    use std::vector;
    public inline fun foreach<T>(v: &vector<T>,action: |&T|) {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, vector::length<T>(v)) {
              (action)(vector::borrow<T>(v, i));
              i: u64 = Add<u64>(i, 1);
              Tuple()
            } else {
              break
            }
          }
        }
    }
    public inline fun inline_apply2(g: |u64|u64,c: u64): u64 {
        Add<u64>({
          let (b: u64): (u64) = Tuple((g)({
            let (a: u64, b: u64): (u64, u64) = Tuple(c, 3);
            Mul<u64>(a, 3)
          }));
          {
            let (a: u64, b: u64): (u64, u64) = Tuple(Add<u64>({
              let (z: u64): (u64) = Tuple(b);
              z
            }, 1), 12);
            Mul<u64>(a, 12)
          }
        }, 2)
    }
    public inline fun inline_apply3(g: |u64|u64,c: u64): u64 {
        Add<u64>(LambdaTest1::inline_apply1(g, LambdaTest1::inline_mul(c, LambdaTest1::inline_apply(|x: u64| LambdaTest1::inline_apply(|y: u64| y, x), 3))), 4)
    }
    public fun test_inline_lambda() {
        {
          let product: u64 = 1;
          {
            let (v: &vector<u64>): (&vector<u64>) = Tuple(Borrow(Immutable)([Number(1), Number(2), Number(3)]));
            {
              let i: u64 = 0;
              loop {
                if Lt<u64>(i, vector::length<u64>(v)) {
                  {
                    let (e: &u64): (&u64) = Tuple(vector::borrow<u64>(v, i));
                    product: u64 = {
                      let (a: u64, b: u64): (u64, u64) = Tuple(product, Deref(e));
                      Mul<u64>(a, b)
                    }
                  };
                  i: u64 = Add<u64>(i, 1);
                  Tuple()
                } else {
                  break
                }
              }
            }
          };
          Tuple()
        }
    }
} // end 0x42::LambdaTest2
module 0x42::LambdaTest {
    use 0x42::LambdaTest2; // resolved as: 0x42::LambdaTest2
    public inline fun inline_apply(f: |u64|u64,b: u64): u64 {
        (f)(b)
    }
    public inline fun inline_apply_test(): u64 {
        1120
    }
    private fun test_lambda() {
        if false {
          Tuple()
        } else {
          Abort(0)
        };
        Tuple()
    }
} // end 0x42::LambdaTest



Diagnostics:
error: Currently, lambda expressions must explicitly declare `move` capture of free variables, except when appearing as an argument to an inline functioncall.
   ┌─ tests/lambda/inline-parity/lambda_typed.move:40:29
   │
40 │         LambdaTest1::inline_apply(|y: u64|y, x)
   │                                   ^^^^^^^^^

error: Currently, lambda expressions must explicitly declare `move` capture of free variables, except when appearing as an argument to an inline functioncall.
   ┌─ tests/lambda/inline-parity/lambda_typed.move:39:59
   │
39 │           LambdaTest1::inline_mul(c, LambdaTest1::inline_apply(|x:u64| {
   │ ╭──────────────────────────────────────────────────────────────^
40 │ │         LambdaTest1::inline_apply(|y: u64|y, x)
41 │ │         },
   │ ╰─────────^
