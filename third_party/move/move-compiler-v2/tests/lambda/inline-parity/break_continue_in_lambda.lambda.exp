// -- Model dump before env processor pipeline:
module 0xc0ffee::m {
    public fun bar(): u64 {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, 10) {
              i: u64 = Add<u64>(i, 1);
              if Eq<u64>(i, 5) {
                m::brk2(|(): ()| break);
                m::brk2(|(): ()| loop {
                  if true {
                    break
                  } else {
                    break
                  }
                });
                m::brk2(|(): ()| loop {
                  if true {
                    continue
                  } else {
                    break
                  }
                });
                Tuple()
              } else {
                Tuple()
              }
            } else {
              break
            }
          };
          i
        }
    }
    private fun brk() {
        break;
        Tuple()
    }
    private fun brk2(f: |()|) {
        (f)();
        Tuple()
    }
    private fun brk3() {
        loop {
          if true {
            break;
            Tuple()
          } else {
            break
          }
        }
    }
    private fun brk4() {
        loop {
          if true {
            continue;
            Tuple()
          } else {
            break
          }
        }
    }
    private fun broken() {
        break;
        Tuple()
    }
    private fun continued() {
        continue;
        Tuple()
    }
    public fun foo(): u64 {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, 10) {
              i: u64 = Add<u64>(i, 1);
              if Eq<u64>(i, 5) {
                m::brk();
                m::brk3();
                m::brk4();
                Tuple()
              } else {
                Tuple()
              }
            } else {
              break
            }
          };
          i
        }
    }
} // end 0xc0ffee::m


// -- Model dump after env processor unused checks:
module 0xc0ffee::m {
    public fun bar(): u64 {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, 10) {
              i: u64 = Add<u64>(i, 1);
              if Eq<u64>(i, 5) {
                m::brk2(|(): ()| break);
                m::brk2(|(): ()| loop {
                  if true {
                    break
                  } else {
                    break
                  }
                });
                m::brk2(|(): ()| loop {
                  if true {
                    continue
                  } else {
                    break
                  }
                });
                Tuple()
              } else {
                Tuple()
              }
            } else {
              break
            }
          };
          i
        }
    }
    private fun brk() {
        break;
        Tuple()
    }
    private fun brk2(f: |()|) {
        (f)();
        Tuple()
    }
    private fun brk3() {
        loop {
          if true {
            break;
            Tuple()
          } else {
            break
          }
        }
    }
    private fun brk4() {
        loop {
          if true {
            continue;
            Tuple()
          } else {
            break
          }
        }
    }
    private fun broken() {
        break;
        Tuple()
    }
    private fun continued() {
        continue;
        Tuple()
    }
    public fun foo(): u64 {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, 10) {
              i: u64 = Add<u64>(i, 1);
              if Eq<u64>(i, 5) {
                m::brk();
                m::brk3();
                m::brk4();
                Tuple()
              } else {
                Tuple()
              }
            } else {
              break
            }
          };
          i
        }
    }
} // end 0xc0ffee::m


// -- Model dump after env processor type parameter check:
module 0xc0ffee::m {
    public fun bar(): u64 {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, 10) {
              i: u64 = Add<u64>(i, 1);
              if Eq<u64>(i, 5) {
                m::brk2(|(): ()| break);
                m::brk2(|(): ()| loop {
                  if true {
                    break
                  } else {
                    break
                  }
                });
                m::brk2(|(): ()| loop {
                  if true {
                    continue
                  } else {
                    break
                  }
                });
                Tuple()
              } else {
                Tuple()
              }
            } else {
              break
            }
          };
          i
        }
    }
    private fun brk() {
        break;
        Tuple()
    }
    private fun brk2(f: |()|) {
        (f)();
        Tuple()
    }
    private fun brk3() {
        loop {
          if true {
            break;
            Tuple()
          } else {
            break
          }
        }
    }
    private fun brk4() {
        loop {
          if true {
            continue;
            Tuple()
          } else {
            break
          }
        }
    }
    private fun broken() {
        break;
        Tuple()
    }
    private fun continued() {
        continue;
        Tuple()
    }
    public fun foo(): u64 {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, 10) {
              i: u64 = Add<u64>(i, 1);
              if Eq<u64>(i, 5) {
                m::brk();
                m::brk3();
                m::brk4();
                Tuple()
              } else {
                Tuple()
              }
            } else {
              break
            }
          };
          i
        }
    }
} // end 0xc0ffee::m


// -- Model dump after env processor check recursive struct definition:
module 0xc0ffee::m {
    public fun bar(): u64 {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, 10) {
              i: u64 = Add<u64>(i, 1);
              if Eq<u64>(i, 5) {
                m::brk2(|(): ()| break);
                m::brk2(|(): ()| loop {
                  if true {
                    break
                  } else {
                    break
                  }
                });
                m::brk2(|(): ()| loop {
                  if true {
                    continue
                  } else {
                    break
                  }
                });
                Tuple()
              } else {
                Tuple()
              }
            } else {
              break
            }
          };
          i
        }
    }
    private fun brk() {
        break;
        Tuple()
    }
    private fun brk2(f: |()|) {
        (f)();
        Tuple()
    }
    private fun brk3() {
        loop {
          if true {
            break;
            Tuple()
          } else {
            break
          }
        }
    }
    private fun brk4() {
        loop {
          if true {
            continue;
            Tuple()
          } else {
            break
          }
        }
    }
    private fun broken() {
        break;
        Tuple()
    }
    private fun continued() {
        continue;
        Tuple()
    }
    public fun foo(): u64 {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, 10) {
              i: u64 = Add<u64>(i, 1);
              if Eq<u64>(i, 5) {
                m::brk();
                m::brk3();
                m::brk4();
                Tuple()
              } else {
                Tuple()
              }
            } else {
              break
            }
          };
          i
        }
    }
} // end 0xc0ffee::m


// -- Model dump after env processor check cyclic type instantiation:
module 0xc0ffee::m {
    public fun bar(): u64 {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, 10) {
              i: u64 = Add<u64>(i, 1);
              if Eq<u64>(i, 5) {
                m::brk2(|(): ()| break);
                m::brk2(|(): ()| loop {
                  if true {
                    break
                  } else {
                    break
                  }
                });
                m::brk2(|(): ()| loop {
                  if true {
                    continue
                  } else {
                    break
                  }
                });
                Tuple()
              } else {
                Tuple()
              }
            } else {
              break
            }
          };
          i
        }
    }
    private fun brk() {
        break;
        Tuple()
    }
    private fun brk2(f: |()|) {
        (f)();
        Tuple()
    }
    private fun brk3() {
        loop {
          if true {
            break;
            Tuple()
          } else {
            break
          }
        }
    }
    private fun brk4() {
        loop {
          if true {
            continue;
            Tuple()
          } else {
            break
          }
        }
    }
    private fun broken() {
        break;
        Tuple()
    }
    private fun continued() {
        continue;
        Tuple()
    }
    public fun foo(): u64 {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, 10) {
              i: u64 = Add<u64>(i, 1);
              if Eq<u64>(i, 5) {
                m::brk();
                m::brk3();
                m::brk4();
                Tuple()
              } else {
                Tuple()
              }
            } else {
              break
            }
          };
          i
        }
    }
} // end 0xc0ffee::m


// -- Model dump after env processor unused struct params check:
module 0xc0ffee::m {
    public fun bar(): u64 {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, 10) {
              i: u64 = Add<u64>(i, 1);
              if Eq<u64>(i, 5) {
                m::brk2(|(): ()| break);
                m::brk2(|(): ()| loop {
                  if true {
                    break
                  } else {
                    break
                  }
                });
                m::brk2(|(): ()| loop {
                  if true {
                    continue
                  } else {
                    break
                  }
                });
                Tuple()
              } else {
                Tuple()
              }
            } else {
              break
            }
          };
          i
        }
    }
    private fun brk() {
        break;
        Tuple()
    }
    private fun brk2(f: |()|) {
        (f)();
        Tuple()
    }
    private fun brk3() {
        loop {
          if true {
            break;
            Tuple()
          } else {
            break
          }
        }
    }
    private fun brk4() {
        loop {
          if true {
            continue;
            Tuple()
          } else {
            break
          }
        }
    }
    private fun broken() {
        break;
        Tuple()
    }
    private fun continued() {
        continue;
        Tuple()
    }
    public fun foo(): u64 {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, 10) {
              i: u64 = Add<u64>(i, 1);
              if Eq<u64>(i, 5) {
                m::brk();
                m::brk3();
                m::brk4();
                Tuple()
              } else {
                Tuple()
              }
            } else {
              break
            }
          };
          i
        }
    }
} // end 0xc0ffee::m


// -- Model dump after env processor access and use check before inlining:
module 0xc0ffee::m {
    public fun bar(): u64 {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, 10) {
              i: u64 = Add<u64>(i, 1);
              if Eq<u64>(i, 5) {
                m::brk2(|(): ()| break);
                m::brk2(|(): ()| loop {
                  if true {
                    break
                  } else {
                    break
                  }
                });
                m::brk2(|(): ()| loop {
                  if true {
                    continue
                  } else {
                    break
                  }
                });
                Tuple()
              } else {
                Tuple()
              }
            } else {
              break
            }
          };
          i
        }
    }
    private fun brk() {
        break;
        Tuple()
    }
    private fun brk2(f: |()|) {
        (f)();
        Tuple()
    }
    private fun brk3() {
        loop {
          if true {
            break;
            Tuple()
          } else {
            break
          }
        }
    }
    private fun brk4() {
        loop {
          if true {
            continue;
            Tuple()
          } else {
            break
          }
        }
    }
    private fun broken() {
        break;
        Tuple()
    }
    private fun continued() {
        continue;
        Tuple()
    }
    public fun foo(): u64 {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, 10) {
              i: u64 = Add<u64>(i, 1);
              if Eq<u64>(i, 5) {
                m::brk();
                m::brk3();
                m::brk4();
                Tuple()
              } else {
                Tuple()
              }
            } else {
              break
            }
          };
          i
        }
    }
} // end 0xc0ffee::m


// -- Model dump after env processor inlining:
module 0xc0ffee::m {
    public fun bar(): u64 {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, 10) {
              i: u64 = Add<u64>(i, 1);
              if Eq<u64>(i, 5) {
                m::brk2(|(): ()| break);
                m::brk2(|(): ()| loop {
                  if true {
                    break
                  } else {
                    break
                  }
                });
                m::brk2(|(): ()| loop {
                  if true {
                    continue
                  } else {
                    break
                  }
                });
                Tuple()
              } else {
                Tuple()
              }
            } else {
              break
            }
          };
          i
        }
    }
    private fun brk() {
        break;
        Tuple()
    }
    private fun brk2(f: |()|) {
        (f)();
        Tuple()
    }
    private fun brk3() {
        loop {
          if true {
            break;
            Tuple()
          } else {
            break
          }
        }
    }
    private fun brk4() {
        loop {
          if true {
            continue;
            Tuple()
          } else {
            break
          }
        }
    }
    private fun broken() {
        break;
        Tuple()
    }
    private fun continued() {
        continue;
        Tuple()
    }
    public fun foo(): u64 {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, 10) {
              i: u64 = Add<u64>(i, 1);
              if Eq<u64>(i, 5) {
                m::brk();
                m::brk3();
                m::brk4();
                Tuple()
              } else {
                Tuple()
              }
            } else {
              break
            }
          };
          i
        }
    }
} // end 0xc0ffee::m


// -- Model dump after env processor access and use check after inlining:
module 0xc0ffee::m {
    public fun bar(): u64 {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, 10) {
              i: u64 = Add<u64>(i, 1);
              if Eq<u64>(i, 5) {
                m::brk2(|(): ()| break);
                m::brk2(|(): ()| loop {
                  if true {
                    break
                  } else {
                    break
                  }
                });
                m::brk2(|(): ()| loop {
                  if true {
                    continue
                  } else {
                    break
                  }
                });
                Tuple()
              } else {
                Tuple()
              }
            } else {
              break
            }
          };
          i
        }
    }
    private fun brk() {
        break;
        Tuple()
    }
    private fun brk2(f: |()|) {
        (f)();
        Tuple()
    }
    private fun brk3() {
        loop {
          if true {
            break;
            Tuple()
          } else {
            break
          }
        }
    }
    private fun brk4() {
        loop {
          if true {
            continue;
            Tuple()
          } else {
            break
          }
        }
    }
    private fun broken() {
        break;
        Tuple()
    }
    private fun continued() {
        continue;
        Tuple()
    }
    public fun foo(): u64 {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, 10) {
              i: u64 = Add<u64>(i, 1);
              if Eq<u64>(i, 5) {
                m::brk();
                m::brk3();
                m::brk4();
                Tuple()
              } else {
                Tuple()
              }
            } else {
              break
            }
          };
          i
        }
    }
} // end 0xc0ffee::m


// -- Model dump after env processor acquires check:
module 0xc0ffee::m {
    public fun bar(): u64 {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, 10) {
              i: u64 = Add<u64>(i, 1);
              if Eq<u64>(i, 5) {
                m::brk2(|(): ()| break);
                m::brk2(|(): ()| loop {
                  if true {
                    break
                  } else {
                    break
                  }
                });
                m::brk2(|(): ()| loop {
                  if true {
                    continue
                  } else {
                    break
                  }
                });
                Tuple()
              } else {
                Tuple()
              }
            } else {
              break
            }
          };
          i
        }
    }
    private fun brk() {
        break;
        Tuple()
    }
    private fun brk2(f: |()|) {
        (f)();
        Tuple()
    }
    private fun brk3() {
        loop {
          if true {
            break;
            Tuple()
          } else {
            break
          }
        }
    }
    private fun brk4() {
        loop {
          if true {
            continue;
            Tuple()
          } else {
            break
          }
        }
    }
    private fun broken() {
        break;
        Tuple()
    }
    private fun continued() {
        continue;
        Tuple()
    }
    public fun foo(): u64 {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, 10) {
              i: u64 = Add<u64>(i, 1);
              if Eq<u64>(i, 5) {
                m::brk();
                m::brk3();
                m::brk4();
                Tuple()
              } else {
                Tuple()
              }
            } else {
              break
            }
          };
          i
        }
    }
} // end 0xc0ffee::m


// -- Model dump after env processor simplifier:
module 0xc0ffee::m {
    public fun bar(): u64 {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, 10) {
              i: u64 = Add<u64>(i, 1);
              if Eq<u64>(i, 5) {
                m::brk2(|(): ()| break);
                m::brk2(|(): ()| loop {
                  if true {
                    break
                  } else {
                    break
                  }
                });
                m::brk2(|(): ()| loop {
                  if true {
                    continue
                  } else {
                    break
                  }
                });
                Tuple()
              } else {
                Tuple()
              }
            } else {
              break
            }
          };
          i
        }
    }
    private fun brk() {
        break;
        Tuple()
    }
    private fun brk2(f: |()|) {
        (f)();
        Tuple()
    }
    private fun brk3() {
        loop {
          if true {
            break;
            Tuple()
          } else {
            break
          }
        }
    }
    private fun brk4() {
        loop {
          if true {
            continue;
            Tuple()
          } else {
            break
          }
        }
    }
    private fun broken() {
        break;
        Tuple()
    }
    private fun continued() {
        continue;
        Tuple()
    }
    public fun foo(): u64 {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, 10) {
              i: u64 = Add<u64>(i, 1);
              if Eq<u64>(i, 5) {
                m::brk();
                m::brk3();
                m::brk4();
                Tuple()
              } else {
                Tuple()
              }
            } else {
              break
            }
          };
          i
        }
    }
} // end 0xc0ffee::m



Diagnostics:
error: Currently, lambda expressions must explicitly declare `move` capture of free variables, except when appearing as an argument to an inline function call.
   ┌─ tests/lambda/inline-parity/break_continue_in_lambda.move:40:22
   │
40 │                 brk2(| | break);
   │                      ^^^^^^^^^

error: Currently, lambda expressions must explicitly declare `move` capture of free variables, except when appearing as an argument to an inline function call.
   ┌─ tests/lambda/inline-parity/break_continue_in_lambda.move:41:8
   │
41 │         brk2(| | while (true) { break });
   │              ^^^^^^^^^^^^^^^^^^^^^^^^^^

error: Currently, lambda expressions must explicitly declare `move` capture of free variables, except when appearing as an argument to an inline function call.
   ┌─ tests/lambda/inline-parity/break_continue_in_lambda.move:42:8
   │
42 │         brk2(| | while (true) { continue });
   │              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
