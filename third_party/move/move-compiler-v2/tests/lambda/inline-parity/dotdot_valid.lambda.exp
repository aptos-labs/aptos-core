// -- Model dump before env processor pipeline:
module 0x42::test {
    enum E1 {
        A {
            0: u8,
            1: bool,
        }
        B {
            0: u8,
        }
        C {
            x: u8,
            y: S1,
        }
    }
    struct S0 {
        dummy_field: bool,
    }
    struct S1 {
        0: u8,
    }
    struct S2 {
        0: bool,
        1: S0,
    }
    struct S3 {
        x: bool,
        y: u8,
    }
    struct S4<T> {
        x: T,
        y: S3,
    }
    struct S5<T,U> {
        0: T,
        1: U,
    }
    struct S6<T,U> {
        x: T,
        y: U,
    }
    struct S7 {
        0: u8,
        1: u16,
        2: u32,
        3: u64,
    }
    private fun lambda_param(f: |S2|bool): bool {
        {
          let x: S2 = pack test::S2(true, pack test::S0(false));
          (f)(x)
        }
    }
    private fun nested1(x: S4<bool>) {
        {
          let test::S4<bool>{ x: _x, y: _ } = x;
          {
            let test::S4<bool>{ x: _, y: _y } = x;
            {
              let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _ } } = x;
              {
                let test::S4<bool>{ x: _, y: test::S3{ x: _x, y: _ } } = x;
                {
                  let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                  {
                    let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _y } } = x;
                    {
                      let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                      Tuple()
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun nested1_ref(x: &S4<bool>) {
        {
          let test::S4<bool>{ x: _x, y: _ } = x;
          {
            let test::S4<bool>{ x: _, y: _y } = x;
            {
              let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _ } } = x;
              {
                let test::S4<bool>{ x: _, y: test::S3{ x: _x, y: _ } } = x;
                {
                  let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                  {
                    let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _y } } = x;
                    {
                      let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                      Tuple()
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun nested2(x: S5<bool, S1>) {
        {
          let test::S5<bool, S1>{ 0: _, 1: test::S1{ 0: _ } } = x;
          Tuple()
        }
    }
    private fun nested2_ref(x: &S5<bool, S1>) {
        {
          let test::S5<bool, S1>{ 0: _, 1: test::S1{ 0: _ } } = x;
          Tuple()
        }
    }
    private fun nested3(x: S5<bool, S4<bool>>) {
        {
          let test::S5<bool, S4<bool>>{ 0: _, 1: test::S4<bool>{ x: _, y: _ } } = x;
          Tuple()
        }
    }
    private fun nested3_ref(x: &S5<bool, S4<bool>>) {
        {
          let test::S5<bool, S4<bool>>{ 0: _, 1: test::S4<bool>{ x: _, y: _ } } = x;
          Tuple()
        }
    }
    private fun nested4(x: S4<S1>) {
        {
          let test::S4<S1>{ x: test::S1{ 0: _ }, y: _ } = x;
          Tuple()
        }
    }
    private fun nested4_ref(x: &S4<S1>) {
        {
          let test::S4<S1>{ x: test::S1{ 0: _ }, y: _ } = x;
          Tuple()
        }
    }
    private fun simple_0(x: S0) {
        {
          let test::S0{ dummy_field: _ } = x;
          Tuple()
        }
    }
    private fun simple_0_ref(x: &S0) {
        {
          let test::S0{ dummy_field: _ } = x;
          Tuple()
        }
    }
    private fun simple_1(x: S1) {
        {
          let test::S1{ 0: _ } = x;
          Tuple()
        }
    }
    private fun simple_1_ref(x: &mut S1) {
        {
          let test::S1{ 0: _ } = x;
          Tuple()
        }
    }
    private fun simple_2(x: S2) {
        {
          let test::S2{ 0: _, 1: _ } = x;
          {
            let test::S2{ 0: _x, 1: _ } = x;
            {
              let test::S2{ 0: _, 1: _x } = x;
              {
                let test::S2{ 0: _, 1: _ } = x;
                {
                  let test::S2{ 0: _, 1: _ } = x;
                  {
                    let test::S2{ 0: _x, 1: _y } = x;
                    {
                      let test::S2{ 0: _x, 1: _y } = x;
                      {
                        let test::S2{ 0: _x, 1: _y } = x;
                        Tuple()
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun simple_2_ref(x: &S2) {
        {
          let test::S2{ 0: _, 1: _ } = x;
          {
            let test::S2{ 0: _x, 1: _ } = x;
            {
              let test::S2{ 0: _, 1: _x } = x;
              {
                let test::S2{ 0: _, 1: _ } = x;
                {
                  let test::S2{ 0: _, 1: _ } = x;
                  {
                    let test::S2{ 0: _x, 1: _y } = x;
                    {
                      let test::S2{ 0: _x, 1: _y } = x;
                      {
                        let test::S2{ 0: _x, 1: _y } = x;
                        Tuple()
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun simple_3(x: S3) {
        {
          let test::S3{ x: _, y: _ } = x;
          {
            let test::S3{ x: _x, y: _ } = x;
            {
              let test::S3{ x: _, y: _y } = x;
              Tuple()
            }
          }
        }
    }
    private fun simple_3_ref(x: S3) {
        {
          let test::S3{ x: _, y: _ } = x;
          {
            let test::S3{ x: _x, y: _ } = x;
            {
              let test::S3{ x: _, y: _y } = x;
              Tuple()
            }
          }
        }
    }
    private fun simple_4(x: E1): u8 {
        match (x) {
          test::E1::A{ 0: x, 1: _ } => {
            x
          }
          test::E1::B{ 0: x } => {
            x
          }
          test::E1::C{ x, y: _ } => {
            x
          }
        }

    }
    private fun simple_4_ref(x: &E1): &u8 {
        match (x) {
          test::E1::A{ 0: x, 1: _ } => {
            x
          }
          test::E1::B{ 0: x } => {
            x
          }
        }

    }
    private fun simple_5(x: E1): u8 {
        match (x) {
          test::E1::A{ 0: _, 1: y } => {
            if y {
              1
            } else {
              0
            }
          }
          test::E1::B{ 0: x } => {
            x
          }
          test::E1::C{ x: _, y: test::S1{ 0: x } } => {
            x
          }
        }

    }
    private fun simple_6(x: &S7) {
        {
          let test::S7{ 0: _w, 1: _, 2: _, 3: _z } = x;
          {
            let test::S7{ 0: _w, 1: _x, 2: _y, 3: _z } = x;
            Tuple()
          }
        }
    }
    private fun test_lambda_param(): bool {
        test::lambda_param(|test::S2{ 0: x, 1: _ }| x)
    }
} // end 0x42::test


// -- Model dump after env processor unused checks:
module 0x42::test {
    enum E1 {
        A {
            0: u8,
            1: bool,
        }
        B {
            0: u8,
        }
        C {
            x: u8,
            y: S1,
        }
    }
    struct S0 {
        dummy_field: bool,
    }
    struct S1 {
        0: u8,
    }
    struct S2 {
        0: bool,
        1: S0,
    }
    struct S3 {
        x: bool,
        y: u8,
    }
    struct S4<T> {
        x: T,
        y: S3,
    }
    struct S5<T,U> {
        0: T,
        1: U,
    }
    struct S6<T,U> {
        x: T,
        y: U,
    }
    struct S7 {
        0: u8,
        1: u16,
        2: u32,
        3: u64,
    }
    private fun lambda_param(f: |S2|bool): bool {
        {
          let x: S2 = pack test::S2(true, pack test::S0(false));
          (f)(x)
        }
    }
    private fun nested1(x: S4<bool>) {
        {
          let test::S4<bool>{ x: _x, y: _ } = x;
          {
            let test::S4<bool>{ x: _, y: _y } = x;
            {
              let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _ } } = x;
              {
                let test::S4<bool>{ x: _, y: test::S3{ x: _x, y: _ } } = x;
                {
                  let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                  {
                    let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _y } } = x;
                    {
                      let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                      Tuple()
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun nested1_ref(x: &S4<bool>) {
        {
          let test::S4<bool>{ x: _x, y: _ } = x;
          {
            let test::S4<bool>{ x: _, y: _y } = x;
            {
              let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _ } } = x;
              {
                let test::S4<bool>{ x: _, y: test::S3{ x: _x, y: _ } } = x;
                {
                  let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                  {
                    let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _y } } = x;
                    {
                      let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                      Tuple()
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun nested2(x: S5<bool, S1>) {
        {
          let test::S5<bool, S1>{ 0: _, 1: test::S1{ 0: _ } } = x;
          Tuple()
        }
    }
    private fun nested2_ref(x: &S5<bool, S1>) {
        {
          let test::S5<bool, S1>{ 0: _, 1: test::S1{ 0: _ } } = x;
          Tuple()
        }
    }
    private fun nested3(x: S5<bool, S4<bool>>) {
        {
          let test::S5<bool, S4<bool>>{ 0: _, 1: test::S4<bool>{ x: _, y: _ } } = x;
          Tuple()
        }
    }
    private fun nested3_ref(x: &S5<bool, S4<bool>>) {
        {
          let test::S5<bool, S4<bool>>{ 0: _, 1: test::S4<bool>{ x: _, y: _ } } = x;
          Tuple()
        }
    }
    private fun nested4(x: S4<S1>) {
        {
          let test::S4<S1>{ x: test::S1{ 0: _ }, y: _ } = x;
          Tuple()
        }
    }
    private fun nested4_ref(x: &S4<S1>) {
        {
          let test::S4<S1>{ x: test::S1{ 0: _ }, y: _ } = x;
          Tuple()
        }
    }
    private fun simple_0(x: S0) {
        {
          let test::S0{ dummy_field: _ } = x;
          Tuple()
        }
    }
    private fun simple_0_ref(x: &S0) {
        {
          let test::S0{ dummy_field: _ } = x;
          Tuple()
        }
    }
    private fun simple_1(x: S1) {
        {
          let test::S1{ 0: _ } = x;
          Tuple()
        }
    }
    private fun simple_1_ref(x: &mut S1) {
        {
          let test::S1{ 0: _ } = x;
          Tuple()
        }
    }
    private fun simple_2(x: S2) {
        {
          let test::S2{ 0: _, 1: _ } = x;
          {
            let test::S2{ 0: _x, 1: _ } = x;
            {
              let test::S2{ 0: _, 1: _x } = x;
              {
                let test::S2{ 0: _, 1: _ } = x;
                {
                  let test::S2{ 0: _, 1: _ } = x;
                  {
                    let test::S2{ 0: _x, 1: _y } = x;
                    {
                      let test::S2{ 0: _x, 1: _y } = x;
                      {
                        let test::S2{ 0: _x, 1: _y } = x;
                        Tuple()
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun simple_2_ref(x: &S2) {
        {
          let test::S2{ 0: _, 1: _ } = x;
          {
            let test::S2{ 0: _x, 1: _ } = x;
            {
              let test::S2{ 0: _, 1: _x } = x;
              {
                let test::S2{ 0: _, 1: _ } = x;
                {
                  let test::S2{ 0: _, 1: _ } = x;
                  {
                    let test::S2{ 0: _x, 1: _y } = x;
                    {
                      let test::S2{ 0: _x, 1: _y } = x;
                      {
                        let test::S2{ 0: _x, 1: _y } = x;
                        Tuple()
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun simple_3(x: S3) {
        {
          let test::S3{ x: _, y: _ } = x;
          {
            let test::S3{ x: _x, y: _ } = x;
            {
              let test::S3{ x: _, y: _y } = x;
              Tuple()
            }
          }
        }
    }
    private fun simple_3_ref(x: S3) {
        {
          let test::S3{ x: _, y: _ } = x;
          {
            let test::S3{ x: _x, y: _ } = x;
            {
              let test::S3{ x: _, y: _y } = x;
              Tuple()
            }
          }
        }
    }
    private fun simple_4(x: E1): u8 {
        match (x) {
          test::E1::A{ 0: x, 1: _ } => {
            x
          }
          test::E1::B{ 0: x } => {
            x
          }
          test::E1::C{ x, y: _ } => {
            x
          }
        }

    }
    private fun simple_4_ref(x: &E1): &u8 {
        match (x) {
          test::E1::A{ 0: x, 1: _ } => {
            x
          }
          test::E1::B{ 0: x } => {
            x
          }
        }

    }
    private fun simple_5(x: E1): u8 {
        match (x) {
          test::E1::A{ 0: _, 1: y } => {
            if y {
              1
            } else {
              0
            }
          }
          test::E1::B{ 0: x } => {
            x
          }
          test::E1::C{ x: _, y: test::S1{ 0: x } } => {
            x
          }
        }

    }
    private fun simple_6(x: &S7) {
        {
          let test::S7{ 0: _w, 1: _, 2: _, 3: _z } = x;
          {
            let test::S7{ 0: _w, 1: _x, 2: _y, 3: _z } = x;
            Tuple()
          }
        }
    }
    private fun test_lambda_param(): bool {
        test::lambda_param(|test::S2{ 0: x, 1: _ }| x)
    }
} // end 0x42::test


// -- Model dump after env processor type parameter check:
module 0x42::test {
    enum E1 {
        A {
            0: u8,
            1: bool,
        }
        B {
            0: u8,
        }
        C {
            x: u8,
            y: S1,
        }
    }
    struct S0 {
        dummy_field: bool,
    }
    struct S1 {
        0: u8,
    }
    struct S2 {
        0: bool,
        1: S0,
    }
    struct S3 {
        x: bool,
        y: u8,
    }
    struct S4<T> {
        x: T,
        y: S3,
    }
    struct S5<T,U> {
        0: T,
        1: U,
    }
    struct S6<T,U> {
        x: T,
        y: U,
    }
    struct S7 {
        0: u8,
        1: u16,
        2: u32,
        3: u64,
    }
    private fun lambda_param(f: |S2|bool): bool {
        {
          let x: S2 = pack test::S2(true, pack test::S0(false));
          (f)(x)
        }
    }
    private fun nested1(x: S4<bool>) {
        {
          let test::S4<bool>{ x: _x, y: _ } = x;
          {
            let test::S4<bool>{ x: _, y: _y } = x;
            {
              let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _ } } = x;
              {
                let test::S4<bool>{ x: _, y: test::S3{ x: _x, y: _ } } = x;
                {
                  let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                  {
                    let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _y } } = x;
                    {
                      let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                      Tuple()
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun nested1_ref(x: &S4<bool>) {
        {
          let test::S4<bool>{ x: _x, y: _ } = x;
          {
            let test::S4<bool>{ x: _, y: _y } = x;
            {
              let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _ } } = x;
              {
                let test::S4<bool>{ x: _, y: test::S3{ x: _x, y: _ } } = x;
                {
                  let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                  {
                    let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _y } } = x;
                    {
                      let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                      Tuple()
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun nested2(x: S5<bool, S1>) {
        {
          let test::S5<bool, S1>{ 0: _, 1: test::S1{ 0: _ } } = x;
          Tuple()
        }
    }
    private fun nested2_ref(x: &S5<bool, S1>) {
        {
          let test::S5<bool, S1>{ 0: _, 1: test::S1{ 0: _ } } = x;
          Tuple()
        }
    }
    private fun nested3(x: S5<bool, S4<bool>>) {
        {
          let test::S5<bool, S4<bool>>{ 0: _, 1: test::S4<bool>{ x: _, y: _ } } = x;
          Tuple()
        }
    }
    private fun nested3_ref(x: &S5<bool, S4<bool>>) {
        {
          let test::S5<bool, S4<bool>>{ 0: _, 1: test::S4<bool>{ x: _, y: _ } } = x;
          Tuple()
        }
    }
    private fun nested4(x: S4<S1>) {
        {
          let test::S4<S1>{ x: test::S1{ 0: _ }, y: _ } = x;
          Tuple()
        }
    }
    private fun nested4_ref(x: &S4<S1>) {
        {
          let test::S4<S1>{ x: test::S1{ 0: _ }, y: _ } = x;
          Tuple()
        }
    }
    private fun simple_0(x: S0) {
        {
          let test::S0{ dummy_field: _ } = x;
          Tuple()
        }
    }
    private fun simple_0_ref(x: &S0) {
        {
          let test::S0{ dummy_field: _ } = x;
          Tuple()
        }
    }
    private fun simple_1(x: S1) {
        {
          let test::S1{ 0: _ } = x;
          Tuple()
        }
    }
    private fun simple_1_ref(x: &mut S1) {
        {
          let test::S1{ 0: _ } = x;
          Tuple()
        }
    }
    private fun simple_2(x: S2) {
        {
          let test::S2{ 0: _, 1: _ } = x;
          {
            let test::S2{ 0: _x, 1: _ } = x;
            {
              let test::S2{ 0: _, 1: _x } = x;
              {
                let test::S2{ 0: _, 1: _ } = x;
                {
                  let test::S2{ 0: _, 1: _ } = x;
                  {
                    let test::S2{ 0: _x, 1: _y } = x;
                    {
                      let test::S2{ 0: _x, 1: _y } = x;
                      {
                        let test::S2{ 0: _x, 1: _y } = x;
                        Tuple()
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun simple_2_ref(x: &S2) {
        {
          let test::S2{ 0: _, 1: _ } = x;
          {
            let test::S2{ 0: _x, 1: _ } = x;
            {
              let test::S2{ 0: _, 1: _x } = x;
              {
                let test::S2{ 0: _, 1: _ } = x;
                {
                  let test::S2{ 0: _, 1: _ } = x;
                  {
                    let test::S2{ 0: _x, 1: _y } = x;
                    {
                      let test::S2{ 0: _x, 1: _y } = x;
                      {
                        let test::S2{ 0: _x, 1: _y } = x;
                        Tuple()
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun simple_3(x: S3) {
        {
          let test::S3{ x: _, y: _ } = x;
          {
            let test::S3{ x: _x, y: _ } = x;
            {
              let test::S3{ x: _, y: _y } = x;
              Tuple()
            }
          }
        }
    }
    private fun simple_3_ref(x: S3) {
        {
          let test::S3{ x: _, y: _ } = x;
          {
            let test::S3{ x: _x, y: _ } = x;
            {
              let test::S3{ x: _, y: _y } = x;
              Tuple()
            }
          }
        }
    }
    private fun simple_4(x: E1): u8 {
        match (x) {
          test::E1::A{ 0: x, 1: _ } => {
            x
          }
          test::E1::B{ 0: x } => {
            x
          }
          test::E1::C{ x, y: _ } => {
            x
          }
        }

    }
    private fun simple_4_ref(x: &E1): &u8 {
        match (x) {
          test::E1::A{ 0: x, 1: _ } => {
            x
          }
          test::E1::B{ 0: x } => {
            x
          }
        }

    }
    private fun simple_5(x: E1): u8 {
        match (x) {
          test::E1::A{ 0: _, 1: y } => {
            if y {
              1
            } else {
              0
            }
          }
          test::E1::B{ 0: x } => {
            x
          }
          test::E1::C{ x: _, y: test::S1{ 0: x } } => {
            x
          }
        }

    }
    private fun simple_6(x: &S7) {
        {
          let test::S7{ 0: _w, 1: _, 2: _, 3: _z } = x;
          {
            let test::S7{ 0: _w, 1: _x, 2: _y, 3: _z } = x;
            Tuple()
          }
        }
    }
    private fun test_lambda_param(): bool {
        test::lambda_param(|test::S2{ 0: x, 1: _ }| x)
    }
} // end 0x42::test


// -- Model dump after env processor check recursive struct definition:
module 0x42::test {
    enum E1 {
        A {
            0: u8,
            1: bool,
        }
        B {
            0: u8,
        }
        C {
            x: u8,
            y: S1,
        }
    }
    struct S0 {
        dummy_field: bool,
    }
    struct S1 {
        0: u8,
    }
    struct S2 {
        0: bool,
        1: S0,
    }
    struct S3 {
        x: bool,
        y: u8,
    }
    struct S4<T> {
        x: T,
        y: S3,
    }
    struct S5<T,U> {
        0: T,
        1: U,
    }
    struct S6<T,U> {
        x: T,
        y: U,
    }
    struct S7 {
        0: u8,
        1: u16,
        2: u32,
        3: u64,
    }
    private fun lambda_param(f: |S2|bool): bool {
        {
          let x: S2 = pack test::S2(true, pack test::S0(false));
          (f)(x)
        }
    }
    private fun nested1(x: S4<bool>) {
        {
          let test::S4<bool>{ x: _x, y: _ } = x;
          {
            let test::S4<bool>{ x: _, y: _y } = x;
            {
              let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _ } } = x;
              {
                let test::S4<bool>{ x: _, y: test::S3{ x: _x, y: _ } } = x;
                {
                  let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                  {
                    let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _y } } = x;
                    {
                      let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                      Tuple()
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun nested1_ref(x: &S4<bool>) {
        {
          let test::S4<bool>{ x: _x, y: _ } = x;
          {
            let test::S4<bool>{ x: _, y: _y } = x;
            {
              let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _ } } = x;
              {
                let test::S4<bool>{ x: _, y: test::S3{ x: _x, y: _ } } = x;
                {
                  let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                  {
                    let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _y } } = x;
                    {
                      let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                      Tuple()
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun nested2(x: S5<bool, S1>) {
        {
          let test::S5<bool, S1>{ 0: _, 1: test::S1{ 0: _ } } = x;
          Tuple()
        }
    }
    private fun nested2_ref(x: &S5<bool, S1>) {
        {
          let test::S5<bool, S1>{ 0: _, 1: test::S1{ 0: _ } } = x;
          Tuple()
        }
    }
    private fun nested3(x: S5<bool, S4<bool>>) {
        {
          let test::S5<bool, S4<bool>>{ 0: _, 1: test::S4<bool>{ x: _, y: _ } } = x;
          Tuple()
        }
    }
    private fun nested3_ref(x: &S5<bool, S4<bool>>) {
        {
          let test::S5<bool, S4<bool>>{ 0: _, 1: test::S4<bool>{ x: _, y: _ } } = x;
          Tuple()
        }
    }
    private fun nested4(x: S4<S1>) {
        {
          let test::S4<S1>{ x: test::S1{ 0: _ }, y: _ } = x;
          Tuple()
        }
    }
    private fun nested4_ref(x: &S4<S1>) {
        {
          let test::S4<S1>{ x: test::S1{ 0: _ }, y: _ } = x;
          Tuple()
        }
    }
    private fun simple_0(x: S0) {
        {
          let test::S0{ dummy_field: _ } = x;
          Tuple()
        }
    }
    private fun simple_0_ref(x: &S0) {
        {
          let test::S0{ dummy_field: _ } = x;
          Tuple()
        }
    }
    private fun simple_1(x: S1) {
        {
          let test::S1{ 0: _ } = x;
          Tuple()
        }
    }
    private fun simple_1_ref(x: &mut S1) {
        {
          let test::S1{ 0: _ } = x;
          Tuple()
        }
    }
    private fun simple_2(x: S2) {
        {
          let test::S2{ 0: _, 1: _ } = x;
          {
            let test::S2{ 0: _x, 1: _ } = x;
            {
              let test::S2{ 0: _, 1: _x } = x;
              {
                let test::S2{ 0: _, 1: _ } = x;
                {
                  let test::S2{ 0: _, 1: _ } = x;
                  {
                    let test::S2{ 0: _x, 1: _y } = x;
                    {
                      let test::S2{ 0: _x, 1: _y } = x;
                      {
                        let test::S2{ 0: _x, 1: _y } = x;
                        Tuple()
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun simple_2_ref(x: &S2) {
        {
          let test::S2{ 0: _, 1: _ } = x;
          {
            let test::S2{ 0: _x, 1: _ } = x;
            {
              let test::S2{ 0: _, 1: _x } = x;
              {
                let test::S2{ 0: _, 1: _ } = x;
                {
                  let test::S2{ 0: _, 1: _ } = x;
                  {
                    let test::S2{ 0: _x, 1: _y } = x;
                    {
                      let test::S2{ 0: _x, 1: _y } = x;
                      {
                        let test::S2{ 0: _x, 1: _y } = x;
                        Tuple()
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun simple_3(x: S3) {
        {
          let test::S3{ x: _, y: _ } = x;
          {
            let test::S3{ x: _x, y: _ } = x;
            {
              let test::S3{ x: _, y: _y } = x;
              Tuple()
            }
          }
        }
    }
    private fun simple_3_ref(x: S3) {
        {
          let test::S3{ x: _, y: _ } = x;
          {
            let test::S3{ x: _x, y: _ } = x;
            {
              let test::S3{ x: _, y: _y } = x;
              Tuple()
            }
          }
        }
    }
    private fun simple_4(x: E1): u8 {
        match (x) {
          test::E1::A{ 0: x, 1: _ } => {
            x
          }
          test::E1::B{ 0: x } => {
            x
          }
          test::E1::C{ x, y: _ } => {
            x
          }
        }

    }
    private fun simple_4_ref(x: &E1): &u8 {
        match (x) {
          test::E1::A{ 0: x, 1: _ } => {
            x
          }
          test::E1::B{ 0: x } => {
            x
          }
        }

    }
    private fun simple_5(x: E1): u8 {
        match (x) {
          test::E1::A{ 0: _, 1: y } => {
            if y {
              1
            } else {
              0
            }
          }
          test::E1::B{ 0: x } => {
            x
          }
          test::E1::C{ x: _, y: test::S1{ 0: x } } => {
            x
          }
        }

    }
    private fun simple_6(x: &S7) {
        {
          let test::S7{ 0: _w, 1: _, 2: _, 3: _z } = x;
          {
            let test::S7{ 0: _w, 1: _x, 2: _y, 3: _z } = x;
            Tuple()
          }
        }
    }
    private fun test_lambda_param(): bool {
        test::lambda_param(|test::S2{ 0: x, 1: _ }| x)
    }
} // end 0x42::test


// -- Model dump after env processor check cyclic type instantiation:
module 0x42::test {
    enum E1 {
        A {
            0: u8,
            1: bool,
        }
        B {
            0: u8,
        }
        C {
            x: u8,
            y: S1,
        }
    }
    struct S0 {
        dummy_field: bool,
    }
    struct S1 {
        0: u8,
    }
    struct S2 {
        0: bool,
        1: S0,
    }
    struct S3 {
        x: bool,
        y: u8,
    }
    struct S4<T> {
        x: T,
        y: S3,
    }
    struct S5<T,U> {
        0: T,
        1: U,
    }
    struct S6<T,U> {
        x: T,
        y: U,
    }
    struct S7 {
        0: u8,
        1: u16,
        2: u32,
        3: u64,
    }
    private fun lambda_param(f: |S2|bool): bool {
        {
          let x: S2 = pack test::S2(true, pack test::S0(false));
          (f)(x)
        }
    }
    private fun nested1(x: S4<bool>) {
        {
          let test::S4<bool>{ x: _x, y: _ } = x;
          {
            let test::S4<bool>{ x: _, y: _y } = x;
            {
              let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _ } } = x;
              {
                let test::S4<bool>{ x: _, y: test::S3{ x: _x, y: _ } } = x;
                {
                  let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                  {
                    let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _y } } = x;
                    {
                      let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                      Tuple()
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun nested1_ref(x: &S4<bool>) {
        {
          let test::S4<bool>{ x: _x, y: _ } = x;
          {
            let test::S4<bool>{ x: _, y: _y } = x;
            {
              let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _ } } = x;
              {
                let test::S4<bool>{ x: _, y: test::S3{ x: _x, y: _ } } = x;
                {
                  let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                  {
                    let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _y } } = x;
                    {
                      let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                      Tuple()
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun nested2(x: S5<bool, S1>) {
        {
          let test::S5<bool, S1>{ 0: _, 1: test::S1{ 0: _ } } = x;
          Tuple()
        }
    }
    private fun nested2_ref(x: &S5<bool, S1>) {
        {
          let test::S5<bool, S1>{ 0: _, 1: test::S1{ 0: _ } } = x;
          Tuple()
        }
    }
    private fun nested3(x: S5<bool, S4<bool>>) {
        {
          let test::S5<bool, S4<bool>>{ 0: _, 1: test::S4<bool>{ x: _, y: _ } } = x;
          Tuple()
        }
    }
    private fun nested3_ref(x: &S5<bool, S4<bool>>) {
        {
          let test::S5<bool, S4<bool>>{ 0: _, 1: test::S4<bool>{ x: _, y: _ } } = x;
          Tuple()
        }
    }
    private fun nested4(x: S4<S1>) {
        {
          let test::S4<S1>{ x: test::S1{ 0: _ }, y: _ } = x;
          Tuple()
        }
    }
    private fun nested4_ref(x: &S4<S1>) {
        {
          let test::S4<S1>{ x: test::S1{ 0: _ }, y: _ } = x;
          Tuple()
        }
    }
    private fun simple_0(x: S0) {
        {
          let test::S0{ dummy_field: _ } = x;
          Tuple()
        }
    }
    private fun simple_0_ref(x: &S0) {
        {
          let test::S0{ dummy_field: _ } = x;
          Tuple()
        }
    }
    private fun simple_1(x: S1) {
        {
          let test::S1{ 0: _ } = x;
          Tuple()
        }
    }
    private fun simple_1_ref(x: &mut S1) {
        {
          let test::S1{ 0: _ } = x;
          Tuple()
        }
    }
    private fun simple_2(x: S2) {
        {
          let test::S2{ 0: _, 1: _ } = x;
          {
            let test::S2{ 0: _x, 1: _ } = x;
            {
              let test::S2{ 0: _, 1: _x } = x;
              {
                let test::S2{ 0: _, 1: _ } = x;
                {
                  let test::S2{ 0: _, 1: _ } = x;
                  {
                    let test::S2{ 0: _x, 1: _y } = x;
                    {
                      let test::S2{ 0: _x, 1: _y } = x;
                      {
                        let test::S2{ 0: _x, 1: _y } = x;
                        Tuple()
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun simple_2_ref(x: &S2) {
        {
          let test::S2{ 0: _, 1: _ } = x;
          {
            let test::S2{ 0: _x, 1: _ } = x;
            {
              let test::S2{ 0: _, 1: _x } = x;
              {
                let test::S2{ 0: _, 1: _ } = x;
                {
                  let test::S2{ 0: _, 1: _ } = x;
                  {
                    let test::S2{ 0: _x, 1: _y } = x;
                    {
                      let test::S2{ 0: _x, 1: _y } = x;
                      {
                        let test::S2{ 0: _x, 1: _y } = x;
                        Tuple()
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun simple_3(x: S3) {
        {
          let test::S3{ x: _, y: _ } = x;
          {
            let test::S3{ x: _x, y: _ } = x;
            {
              let test::S3{ x: _, y: _y } = x;
              Tuple()
            }
          }
        }
    }
    private fun simple_3_ref(x: S3) {
        {
          let test::S3{ x: _, y: _ } = x;
          {
            let test::S3{ x: _x, y: _ } = x;
            {
              let test::S3{ x: _, y: _y } = x;
              Tuple()
            }
          }
        }
    }
    private fun simple_4(x: E1): u8 {
        match (x) {
          test::E1::A{ 0: x, 1: _ } => {
            x
          }
          test::E1::B{ 0: x } => {
            x
          }
          test::E1::C{ x, y: _ } => {
            x
          }
        }

    }
    private fun simple_4_ref(x: &E1): &u8 {
        match (x) {
          test::E1::A{ 0: x, 1: _ } => {
            x
          }
          test::E1::B{ 0: x } => {
            x
          }
        }

    }
    private fun simple_5(x: E1): u8 {
        match (x) {
          test::E1::A{ 0: _, 1: y } => {
            if y {
              1
            } else {
              0
            }
          }
          test::E1::B{ 0: x } => {
            x
          }
          test::E1::C{ x: _, y: test::S1{ 0: x } } => {
            x
          }
        }

    }
    private fun simple_6(x: &S7) {
        {
          let test::S7{ 0: _w, 1: _, 2: _, 3: _z } = x;
          {
            let test::S7{ 0: _w, 1: _x, 2: _y, 3: _z } = x;
            Tuple()
          }
        }
    }
    private fun test_lambda_param(): bool {
        test::lambda_param(|test::S2{ 0: x, 1: _ }| x)
    }
} // end 0x42::test


// -- Model dump after env processor unused struct params check:
module 0x42::test {
    enum E1 {
        A {
            0: u8,
            1: bool,
        }
        B {
            0: u8,
        }
        C {
            x: u8,
            y: S1,
        }
    }
    struct S0 {
        dummy_field: bool,
    }
    struct S1 {
        0: u8,
    }
    struct S2 {
        0: bool,
        1: S0,
    }
    struct S3 {
        x: bool,
        y: u8,
    }
    struct S4<T> {
        x: T,
        y: S3,
    }
    struct S5<T,U> {
        0: T,
        1: U,
    }
    struct S6<T,U> {
        x: T,
        y: U,
    }
    struct S7 {
        0: u8,
        1: u16,
        2: u32,
        3: u64,
    }
    private fun lambda_param(f: |S2|bool): bool {
        {
          let x: S2 = pack test::S2(true, pack test::S0(false));
          (f)(x)
        }
    }
    private fun nested1(x: S4<bool>) {
        {
          let test::S4<bool>{ x: _x, y: _ } = x;
          {
            let test::S4<bool>{ x: _, y: _y } = x;
            {
              let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _ } } = x;
              {
                let test::S4<bool>{ x: _, y: test::S3{ x: _x, y: _ } } = x;
                {
                  let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                  {
                    let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _y } } = x;
                    {
                      let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                      Tuple()
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun nested1_ref(x: &S4<bool>) {
        {
          let test::S4<bool>{ x: _x, y: _ } = x;
          {
            let test::S4<bool>{ x: _, y: _y } = x;
            {
              let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _ } } = x;
              {
                let test::S4<bool>{ x: _, y: test::S3{ x: _x, y: _ } } = x;
                {
                  let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                  {
                    let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _y } } = x;
                    {
                      let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                      Tuple()
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun nested2(x: S5<bool, S1>) {
        {
          let test::S5<bool, S1>{ 0: _, 1: test::S1{ 0: _ } } = x;
          Tuple()
        }
    }
    private fun nested2_ref(x: &S5<bool, S1>) {
        {
          let test::S5<bool, S1>{ 0: _, 1: test::S1{ 0: _ } } = x;
          Tuple()
        }
    }
    private fun nested3(x: S5<bool, S4<bool>>) {
        {
          let test::S5<bool, S4<bool>>{ 0: _, 1: test::S4<bool>{ x: _, y: _ } } = x;
          Tuple()
        }
    }
    private fun nested3_ref(x: &S5<bool, S4<bool>>) {
        {
          let test::S5<bool, S4<bool>>{ 0: _, 1: test::S4<bool>{ x: _, y: _ } } = x;
          Tuple()
        }
    }
    private fun nested4(x: S4<S1>) {
        {
          let test::S4<S1>{ x: test::S1{ 0: _ }, y: _ } = x;
          Tuple()
        }
    }
    private fun nested4_ref(x: &S4<S1>) {
        {
          let test::S4<S1>{ x: test::S1{ 0: _ }, y: _ } = x;
          Tuple()
        }
    }
    private fun simple_0(x: S0) {
        {
          let test::S0{ dummy_field: _ } = x;
          Tuple()
        }
    }
    private fun simple_0_ref(x: &S0) {
        {
          let test::S0{ dummy_field: _ } = x;
          Tuple()
        }
    }
    private fun simple_1(x: S1) {
        {
          let test::S1{ 0: _ } = x;
          Tuple()
        }
    }
    private fun simple_1_ref(x: &mut S1) {
        {
          let test::S1{ 0: _ } = x;
          Tuple()
        }
    }
    private fun simple_2(x: S2) {
        {
          let test::S2{ 0: _, 1: _ } = x;
          {
            let test::S2{ 0: _x, 1: _ } = x;
            {
              let test::S2{ 0: _, 1: _x } = x;
              {
                let test::S2{ 0: _, 1: _ } = x;
                {
                  let test::S2{ 0: _, 1: _ } = x;
                  {
                    let test::S2{ 0: _x, 1: _y } = x;
                    {
                      let test::S2{ 0: _x, 1: _y } = x;
                      {
                        let test::S2{ 0: _x, 1: _y } = x;
                        Tuple()
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun simple_2_ref(x: &S2) {
        {
          let test::S2{ 0: _, 1: _ } = x;
          {
            let test::S2{ 0: _x, 1: _ } = x;
            {
              let test::S2{ 0: _, 1: _x } = x;
              {
                let test::S2{ 0: _, 1: _ } = x;
                {
                  let test::S2{ 0: _, 1: _ } = x;
                  {
                    let test::S2{ 0: _x, 1: _y } = x;
                    {
                      let test::S2{ 0: _x, 1: _y } = x;
                      {
                        let test::S2{ 0: _x, 1: _y } = x;
                        Tuple()
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun simple_3(x: S3) {
        {
          let test::S3{ x: _, y: _ } = x;
          {
            let test::S3{ x: _x, y: _ } = x;
            {
              let test::S3{ x: _, y: _y } = x;
              Tuple()
            }
          }
        }
    }
    private fun simple_3_ref(x: S3) {
        {
          let test::S3{ x: _, y: _ } = x;
          {
            let test::S3{ x: _x, y: _ } = x;
            {
              let test::S3{ x: _, y: _y } = x;
              Tuple()
            }
          }
        }
    }
    private fun simple_4(x: E1): u8 {
        match (x) {
          test::E1::A{ 0: x, 1: _ } => {
            x
          }
          test::E1::B{ 0: x } => {
            x
          }
          test::E1::C{ x, y: _ } => {
            x
          }
        }

    }
    private fun simple_4_ref(x: &E1): &u8 {
        match (x) {
          test::E1::A{ 0: x, 1: _ } => {
            x
          }
          test::E1::B{ 0: x } => {
            x
          }
        }

    }
    private fun simple_5(x: E1): u8 {
        match (x) {
          test::E1::A{ 0: _, 1: y } => {
            if y {
              1
            } else {
              0
            }
          }
          test::E1::B{ 0: x } => {
            x
          }
          test::E1::C{ x: _, y: test::S1{ 0: x } } => {
            x
          }
        }

    }
    private fun simple_6(x: &S7) {
        {
          let test::S7{ 0: _w, 1: _, 2: _, 3: _z } = x;
          {
            let test::S7{ 0: _w, 1: _x, 2: _y, 3: _z } = x;
            Tuple()
          }
        }
    }
    private fun test_lambda_param(): bool {
        test::lambda_param(|test::S2{ 0: x, 1: _ }| x)
    }
} // end 0x42::test


// -- Model dump after env processor access and use check before inlining:
module 0x42::test {
    enum E1 {
        A {
            0: u8,
            1: bool,
        }
        B {
            0: u8,
        }
        C {
            x: u8,
            y: S1,
        }
    }
    struct S0 {
        dummy_field: bool,
    }
    struct S1 {
        0: u8,
    }
    struct S2 {
        0: bool,
        1: S0,
    }
    struct S3 {
        x: bool,
        y: u8,
    }
    struct S4<T> {
        x: T,
        y: S3,
    }
    struct S5<T,U> {
        0: T,
        1: U,
    }
    struct S6<T,U> {
        x: T,
        y: U,
    }
    struct S7 {
        0: u8,
        1: u16,
        2: u32,
        3: u64,
    }
    private fun lambda_param(f: |S2|bool): bool {
        {
          let x: S2 = pack test::S2(true, pack test::S0(false));
          (f)(x)
        }
    }
    private fun nested1(x: S4<bool>) {
        {
          let test::S4<bool>{ x: _x, y: _ } = x;
          {
            let test::S4<bool>{ x: _, y: _y } = x;
            {
              let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _ } } = x;
              {
                let test::S4<bool>{ x: _, y: test::S3{ x: _x, y: _ } } = x;
                {
                  let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                  {
                    let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _y } } = x;
                    {
                      let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                      Tuple()
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun nested1_ref(x: &S4<bool>) {
        {
          let test::S4<bool>{ x: _x, y: _ } = x;
          {
            let test::S4<bool>{ x: _, y: _y } = x;
            {
              let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _ } } = x;
              {
                let test::S4<bool>{ x: _, y: test::S3{ x: _x, y: _ } } = x;
                {
                  let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                  {
                    let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _y } } = x;
                    {
                      let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                      Tuple()
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun nested2(x: S5<bool, S1>) {
        {
          let test::S5<bool, S1>{ 0: _, 1: test::S1{ 0: _ } } = x;
          Tuple()
        }
    }
    private fun nested2_ref(x: &S5<bool, S1>) {
        {
          let test::S5<bool, S1>{ 0: _, 1: test::S1{ 0: _ } } = x;
          Tuple()
        }
    }
    private fun nested3(x: S5<bool, S4<bool>>) {
        {
          let test::S5<bool, S4<bool>>{ 0: _, 1: test::S4<bool>{ x: _, y: _ } } = x;
          Tuple()
        }
    }
    private fun nested3_ref(x: &S5<bool, S4<bool>>) {
        {
          let test::S5<bool, S4<bool>>{ 0: _, 1: test::S4<bool>{ x: _, y: _ } } = x;
          Tuple()
        }
    }
    private fun nested4(x: S4<S1>) {
        {
          let test::S4<S1>{ x: test::S1{ 0: _ }, y: _ } = x;
          Tuple()
        }
    }
    private fun nested4_ref(x: &S4<S1>) {
        {
          let test::S4<S1>{ x: test::S1{ 0: _ }, y: _ } = x;
          Tuple()
        }
    }
    private fun simple_0(x: S0) {
        {
          let test::S0{ dummy_field: _ } = x;
          Tuple()
        }
    }
    private fun simple_0_ref(x: &S0) {
        {
          let test::S0{ dummy_field: _ } = x;
          Tuple()
        }
    }
    private fun simple_1(x: S1) {
        {
          let test::S1{ 0: _ } = x;
          Tuple()
        }
    }
    private fun simple_1_ref(x: &mut S1) {
        {
          let test::S1{ 0: _ } = x;
          Tuple()
        }
    }
    private fun simple_2(x: S2) {
        {
          let test::S2{ 0: _, 1: _ } = x;
          {
            let test::S2{ 0: _x, 1: _ } = x;
            {
              let test::S2{ 0: _, 1: _x } = x;
              {
                let test::S2{ 0: _, 1: _ } = x;
                {
                  let test::S2{ 0: _, 1: _ } = x;
                  {
                    let test::S2{ 0: _x, 1: _y } = x;
                    {
                      let test::S2{ 0: _x, 1: _y } = x;
                      {
                        let test::S2{ 0: _x, 1: _y } = x;
                        Tuple()
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun simple_2_ref(x: &S2) {
        {
          let test::S2{ 0: _, 1: _ } = x;
          {
            let test::S2{ 0: _x, 1: _ } = x;
            {
              let test::S2{ 0: _, 1: _x } = x;
              {
                let test::S2{ 0: _, 1: _ } = x;
                {
                  let test::S2{ 0: _, 1: _ } = x;
                  {
                    let test::S2{ 0: _x, 1: _y } = x;
                    {
                      let test::S2{ 0: _x, 1: _y } = x;
                      {
                        let test::S2{ 0: _x, 1: _y } = x;
                        Tuple()
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun simple_3(x: S3) {
        {
          let test::S3{ x: _, y: _ } = x;
          {
            let test::S3{ x: _x, y: _ } = x;
            {
              let test::S3{ x: _, y: _y } = x;
              Tuple()
            }
          }
        }
    }
    private fun simple_3_ref(x: S3) {
        {
          let test::S3{ x: _, y: _ } = x;
          {
            let test::S3{ x: _x, y: _ } = x;
            {
              let test::S3{ x: _, y: _y } = x;
              Tuple()
            }
          }
        }
    }
    private fun simple_4(x: E1): u8 {
        match (x) {
          test::E1::A{ 0: x, 1: _ } => {
            x
          }
          test::E1::B{ 0: x } => {
            x
          }
          test::E1::C{ x, y: _ } => {
            x
          }
        }

    }
    private fun simple_4_ref(x: &E1): &u8 {
        match (x) {
          test::E1::A{ 0: x, 1: _ } => {
            x
          }
          test::E1::B{ 0: x } => {
            x
          }
        }

    }
    private fun simple_5(x: E1): u8 {
        match (x) {
          test::E1::A{ 0: _, 1: y } => {
            if y {
              1
            } else {
              0
            }
          }
          test::E1::B{ 0: x } => {
            x
          }
          test::E1::C{ x: _, y: test::S1{ 0: x } } => {
            x
          }
        }

    }
    private fun simple_6(x: &S7) {
        {
          let test::S7{ 0: _w, 1: _, 2: _, 3: _z } = x;
          {
            let test::S7{ 0: _w, 1: _x, 2: _y, 3: _z } = x;
            Tuple()
          }
        }
    }
    private fun test_lambda_param(): bool {
        test::lambda_param(|test::S2{ 0: x, 1: _ }| x)
    }
} // end 0x42::test


// -- Model dump after env processor inlining:
module 0x42::test {
    enum E1 {
        A {
            0: u8,
            1: bool,
        }
        B {
            0: u8,
        }
        C {
            x: u8,
            y: S1,
        }
    }
    struct S0 {
        dummy_field: bool,
    }
    struct S1 {
        0: u8,
    }
    struct S2 {
        0: bool,
        1: S0,
    }
    struct S3 {
        x: bool,
        y: u8,
    }
    struct S4<T> {
        x: T,
        y: S3,
    }
    struct S5<T,U> {
        0: T,
        1: U,
    }
    struct S6<T,U> {
        x: T,
        y: U,
    }
    struct S7 {
        0: u8,
        1: u16,
        2: u32,
        3: u64,
    }
    private fun lambda_param(f: |S2|bool): bool {
        {
          let x: S2 = pack test::S2(true, pack test::S0(false));
          (f)(x)
        }
    }
    private fun nested1(x: S4<bool>) {
        {
          let test::S4<bool>{ x: _x, y: _ } = x;
          {
            let test::S4<bool>{ x: _, y: _y } = x;
            {
              let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _ } } = x;
              {
                let test::S4<bool>{ x: _, y: test::S3{ x: _x, y: _ } } = x;
                {
                  let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                  {
                    let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _y } } = x;
                    {
                      let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                      Tuple()
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun nested1_ref(x: &S4<bool>) {
        {
          let test::S4<bool>{ x: _x, y: _ } = x;
          {
            let test::S4<bool>{ x: _, y: _y } = x;
            {
              let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _ } } = x;
              {
                let test::S4<bool>{ x: _, y: test::S3{ x: _x, y: _ } } = x;
                {
                  let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                  {
                    let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _y } } = x;
                    {
                      let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                      Tuple()
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun nested2(x: S5<bool, S1>) {
        {
          let test::S5<bool, S1>{ 0: _, 1: test::S1{ 0: _ } } = x;
          Tuple()
        }
    }
    private fun nested2_ref(x: &S5<bool, S1>) {
        {
          let test::S5<bool, S1>{ 0: _, 1: test::S1{ 0: _ } } = x;
          Tuple()
        }
    }
    private fun nested3(x: S5<bool, S4<bool>>) {
        {
          let test::S5<bool, S4<bool>>{ 0: _, 1: test::S4<bool>{ x: _, y: _ } } = x;
          Tuple()
        }
    }
    private fun nested3_ref(x: &S5<bool, S4<bool>>) {
        {
          let test::S5<bool, S4<bool>>{ 0: _, 1: test::S4<bool>{ x: _, y: _ } } = x;
          Tuple()
        }
    }
    private fun nested4(x: S4<S1>) {
        {
          let test::S4<S1>{ x: test::S1{ 0: _ }, y: _ } = x;
          Tuple()
        }
    }
    private fun nested4_ref(x: &S4<S1>) {
        {
          let test::S4<S1>{ x: test::S1{ 0: _ }, y: _ } = x;
          Tuple()
        }
    }
    private fun simple_0(x: S0) {
        {
          let test::S0{ dummy_field: _ } = x;
          Tuple()
        }
    }
    private fun simple_0_ref(x: &S0) {
        {
          let test::S0{ dummy_field: _ } = x;
          Tuple()
        }
    }
    private fun simple_1(x: S1) {
        {
          let test::S1{ 0: _ } = x;
          Tuple()
        }
    }
    private fun simple_1_ref(x: &mut S1) {
        {
          let test::S1{ 0: _ } = x;
          Tuple()
        }
    }
    private fun simple_2(x: S2) {
        {
          let test::S2{ 0: _, 1: _ } = x;
          {
            let test::S2{ 0: _x, 1: _ } = x;
            {
              let test::S2{ 0: _, 1: _x } = x;
              {
                let test::S2{ 0: _, 1: _ } = x;
                {
                  let test::S2{ 0: _, 1: _ } = x;
                  {
                    let test::S2{ 0: _x, 1: _y } = x;
                    {
                      let test::S2{ 0: _x, 1: _y } = x;
                      {
                        let test::S2{ 0: _x, 1: _y } = x;
                        Tuple()
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun simple_2_ref(x: &S2) {
        {
          let test::S2{ 0: _, 1: _ } = x;
          {
            let test::S2{ 0: _x, 1: _ } = x;
            {
              let test::S2{ 0: _, 1: _x } = x;
              {
                let test::S2{ 0: _, 1: _ } = x;
                {
                  let test::S2{ 0: _, 1: _ } = x;
                  {
                    let test::S2{ 0: _x, 1: _y } = x;
                    {
                      let test::S2{ 0: _x, 1: _y } = x;
                      {
                        let test::S2{ 0: _x, 1: _y } = x;
                        Tuple()
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun simple_3(x: S3) {
        {
          let test::S3{ x: _, y: _ } = x;
          {
            let test::S3{ x: _x, y: _ } = x;
            {
              let test::S3{ x: _, y: _y } = x;
              Tuple()
            }
          }
        }
    }
    private fun simple_3_ref(x: S3) {
        {
          let test::S3{ x: _, y: _ } = x;
          {
            let test::S3{ x: _x, y: _ } = x;
            {
              let test::S3{ x: _, y: _y } = x;
              Tuple()
            }
          }
        }
    }
    private fun simple_4(x: E1): u8 {
        match (x) {
          test::E1::A{ 0: x, 1: _ } => {
            x
          }
          test::E1::B{ 0: x } => {
            x
          }
          test::E1::C{ x, y: _ } => {
            x
          }
        }

    }
    private fun simple_4_ref(x: &E1): &u8 {
        match (x) {
          test::E1::A{ 0: x, 1: _ } => {
            x
          }
          test::E1::B{ 0: x } => {
            x
          }
        }

    }
    private fun simple_5(x: E1): u8 {
        match (x) {
          test::E1::A{ 0: _, 1: y } => {
            if y {
              1
            } else {
              0
            }
          }
          test::E1::B{ 0: x } => {
            x
          }
          test::E1::C{ x: _, y: test::S1{ 0: x } } => {
            x
          }
        }

    }
    private fun simple_6(x: &S7) {
        {
          let test::S7{ 0: _w, 1: _, 2: _, 3: _z } = x;
          {
            let test::S7{ 0: _w, 1: _x, 2: _y, 3: _z } = x;
            Tuple()
          }
        }
    }
    private fun test_lambda_param(): bool {
        test::lambda_param(|test::S2{ 0: x, 1: _ }| x)
    }
} // end 0x42::test


// -- Model dump after env processor access and use check after inlining:
module 0x42::test {
    enum E1 {
        A {
            0: u8,
            1: bool,
        }
        B {
            0: u8,
        }
        C {
            x: u8,
            y: S1,
        }
    }
    struct S0 {
        dummy_field: bool,
    }
    struct S1 {
        0: u8,
    }
    struct S2 {
        0: bool,
        1: S0,
    }
    struct S3 {
        x: bool,
        y: u8,
    }
    struct S4<T> {
        x: T,
        y: S3,
    }
    struct S5<T,U> {
        0: T,
        1: U,
    }
    struct S6<T,U> {
        x: T,
        y: U,
    }
    struct S7 {
        0: u8,
        1: u16,
        2: u32,
        3: u64,
    }
    private fun lambda_param(f: |S2|bool): bool {
        {
          let x: S2 = pack test::S2(true, pack test::S0(false));
          (f)(x)
        }
    }
    private fun nested1(x: S4<bool>) {
        {
          let test::S4<bool>{ x: _x, y: _ } = x;
          {
            let test::S4<bool>{ x: _, y: _y } = x;
            {
              let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _ } } = x;
              {
                let test::S4<bool>{ x: _, y: test::S3{ x: _x, y: _ } } = x;
                {
                  let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                  {
                    let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _y } } = x;
                    {
                      let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                      Tuple()
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun nested1_ref(x: &S4<bool>) {
        {
          let test::S4<bool>{ x: _x, y: _ } = x;
          {
            let test::S4<bool>{ x: _, y: _y } = x;
            {
              let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _ } } = x;
              {
                let test::S4<bool>{ x: _, y: test::S3{ x: _x, y: _ } } = x;
                {
                  let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                  {
                    let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _y } } = x;
                    {
                      let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                      Tuple()
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun nested2(x: S5<bool, S1>) {
        {
          let test::S5<bool, S1>{ 0: _, 1: test::S1{ 0: _ } } = x;
          Tuple()
        }
    }
    private fun nested2_ref(x: &S5<bool, S1>) {
        {
          let test::S5<bool, S1>{ 0: _, 1: test::S1{ 0: _ } } = x;
          Tuple()
        }
    }
    private fun nested3(x: S5<bool, S4<bool>>) {
        {
          let test::S5<bool, S4<bool>>{ 0: _, 1: test::S4<bool>{ x: _, y: _ } } = x;
          Tuple()
        }
    }
    private fun nested3_ref(x: &S5<bool, S4<bool>>) {
        {
          let test::S5<bool, S4<bool>>{ 0: _, 1: test::S4<bool>{ x: _, y: _ } } = x;
          Tuple()
        }
    }
    private fun nested4(x: S4<S1>) {
        {
          let test::S4<S1>{ x: test::S1{ 0: _ }, y: _ } = x;
          Tuple()
        }
    }
    private fun nested4_ref(x: &S4<S1>) {
        {
          let test::S4<S1>{ x: test::S1{ 0: _ }, y: _ } = x;
          Tuple()
        }
    }
    private fun simple_0(x: S0) {
        {
          let test::S0{ dummy_field: _ } = x;
          Tuple()
        }
    }
    private fun simple_0_ref(x: &S0) {
        {
          let test::S0{ dummy_field: _ } = x;
          Tuple()
        }
    }
    private fun simple_1(x: S1) {
        {
          let test::S1{ 0: _ } = x;
          Tuple()
        }
    }
    private fun simple_1_ref(x: &mut S1) {
        {
          let test::S1{ 0: _ } = x;
          Tuple()
        }
    }
    private fun simple_2(x: S2) {
        {
          let test::S2{ 0: _, 1: _ } = x;
          {
            let test::S2{ 0: _x, 1: _ } = x;
            {
              let test::S2{ 0: _, 1: _x } = x;
              {
                let test::S2{ 0: _, 1: _ } = x;
                {
                  let test::S2{ 0: _, 1: _ } = x;
                  {
                    let test::S2{ 0: _x, 1: _y } = x;
                    {
                      let test::S2{ 0: _x, 1: _y } = x;
                      {
                        let test::S2{ 0: _x, 1: _y } = x;
                        Tuple()
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun simple_2_ref(x: &S2) {
        {
          let test::S2{ 0: _, 1: _ } = x;
          {
            let test::S2{ 0: _x, 1: _ } = x;
            {
              let test::S2{ 0: _, 1: _x } = x;
              {
                let test::S2{ 0: _, 1: _ } = x;
                {
                  let test::S2{ 0: _, 1: _ } = x;
                  {
                    let test::S2{ 0: _x, 1: _y } = x;
                    {
                      let test::S2{ 0: _x, 1: _y } = x;
                      {
                        let test::S2{ 0: _x, 1: _y } = x;
                        Tuple()
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun simple_3(x: S3) {
        {
          let test::S3{ x: _, y: _ } = x;
          {
            let test::S3{ x: _x, y: _ } = x;
            {
              let test::S3{ x: _, y: _y } = x;
              Tuple()
            }
          }
        }
    }
    private fun simple_3_ref(x: S3) {
        {
          let test::S3{ x: _, y: _ } = x;
          {
            let test::S3{ x: _x, y: _ } = x;
            {
              let test::S3{ x: _, y: _y } = x;
              Tuple()
            }
          }
        }
    }
    private fun simple_4(x: E1): u8 {
        match (x) {
          test::E1::A{ 0: x, 1: _ } => {
            x
          }
          test::E1::B{ 0: x } => {
            x
          }
          test::E1::C{ x, y: _ } => {
            x
          }
        }

    }
    private fun simple_4_ref(x: &E1): &u8 {
        match (x) {
          test::E1::A{ 0: x, 1: _ } => {
            x
          }
          test::E1::B{ 0: x } => {
            x
          }
        }

    }
    private fun simple_5(x: E1): u8 {
        match (x) {
          test::E1::A{ 0: _, 1: y } => {
            if y {
              1
            } else {
              0
            }
          }
          test::E1::B{ 0: x } => {
            x
          }
          test::E1::C{ x: _, y: test::S1{ 0: x } } => {
            x
          }
        }

    }
    private fun simple_6(x: &S7) {
        {
          let test::S7{ 0: _w, 1: _, 2: _, 3: _z } = x;
          {
            let test::S7{ 0: _w, 1: _x, 2: _y, 3: _z } = x;
            Tuple()
          }
        }
    }
    private fun test_lambda_param(): bool {
        test::lambda_param(|test::S2{ 0: x, 1: _ }| x)
    }
} // end 0x42::test


// -- Model dump after env processor acquires check:
module 0x42::test {
    enum E1 {
        A {
            0: u8,
            1: bool,
        }
        B {
            0: u8,
        }
        C {
            x: u8,
            y: S1,
        }
    }
    struct S0 {
        dummy_field: bool,
    }
    struct S1 {
        0: u8,
    }
    struct S2 {
        0: bool,
        1: S0,
    }
    struct S3 {
        x: bool,
        y: u8,
    }
    struct S4<T> {
        x: T,
        y: S3,
    }
    struct S5<T,U> {
        0: T,
        1: U,
    }
    struct S6<T,U> {
        x: T,
        y: U,
    }
    struct S7 {
        0: u8,
        1: u16,
        2: u32,
        3: u64,
    }
    private fun lambda_param(f: |S2|bool): bool {
        {
          let x: S2 = pack test::S2(true, pack test::S0(false));
          (f)(x)
        }
    }
    private fun nested1(x: S4<bool>) {
        {
          let test::S4<bool>{ x: _x, y: _ } = x;
          {
            let test::S4<bool>{ x: _, y: _y } = x;
            {
              let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _ } } = x;
              {
                let test::S4<bool>{ x: _, y: test::S3{ x: _x, y: _ } } = x;
                {
                  let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                  {
                    let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _y } } = x;
                    {
                      let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                      Tuple()
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun nested1_ref(x: &S4<bool>) {
        {
          let test::S4<bool>{ x: _x, y: _ } = x;
          {
            let test::S4<bool>{ x: _, y: _y } = x;
            {
              let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _ } } = x;
              {
                let test::S4<bool>{ x: _, y: test::S3{ x: _x, y: _ } } = x;
                {
                  let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                  {
                    let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _y } } = x;
                    {
                      let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                      Tuple()
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun nested2(x: S5<bool, S1>) {
        {
          let test::S5<bool, S1>{ 0: _, 1: test::S1{ 0: _ } } = x;
          Tuple()
        }
    }
    private fun nested2_ref(x: &S5<bool, S1>) {
        {
          let test::S5<bool, S1>{ 0: _, 1: test::S1{ 0: _ } } = x;
          Tuple()
        }
    }
    private fun nested3(x: S5<bool, S4<bool>>) {
        {
          let test::S5<bool, S4<bool>>{ 0: _, 1: test::S4<bool>{ x: _, y: _ } } = x;
          Tuple()
        }
    }
    private fun nested3_ref(x: &S5<bool, S4<bool>>) {
        {
          let test::S5<bool, S4<bool>>{ 0: _, 1: test::S4<bool>{ x: _, y: _ } } = x;
          Tuple()
        }
    }
    private fun nested4(x: S4<S1>) {
        {
          let test::S4<S1>{ x: test::S1{ 0: _ }, y: _ } = x;
          Tuple()
        }
    }
    private fun nested4_ref(x: &S4<S1>) {
        {
          let test::S4<S1>{ x: test::S1{ 0: _ }, y: _ } = x;
          Tuple()
        }
    }
    private fun simple_0(x: S0) {
        {
          let test::S0{ dummy_field: _ } = x;
          Tuple()
        }
    }
    private fun simple_0_ref(x: &S0) {
        {
          let test::S0{ dummy_field: _ } = x;
          Tuple()
        }
    }
    private fun simple_1(x: S1) {
        {
          let test::S1{ 0: _ } = x;
          Tuple()
        }
    }
    private fun simple_1_ref(x: &mut S1) {
        {
          let test::S1{ 0: _ } = x;
          Tuple()
        }
    }
    private fun simple_2(x: S2) {
        {
          let test::S2{ 0: _, 1: _ } = x;
          {
            let test::S2{ 0: _x, 1: _ } = x;
            {
              let test::S2{ 0: _, 1: _x } = x;
              {
                let test::S2{ 0: _, 1: _ } = x;
                {
                  let test::S2{ 0: _, 1: _ } = x;
                  {
                    let test::S2{ 0: _x, 1: _y } = x;
                    {
                      let test::S2{ 0: _x, 1: _y } = x;
                      {
                        let test::S2{ 0: _x, 1: _y } = x;
                        Tuple()
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun simple_2_ref(x: &S2) {
        {
          let test::S2{ 0: _, 1: _ } = x;
          {
            let test::S2{ 0: _x, 1: _ } = x;
            {
              let test::S2{ 0: _, 1: _x } = x;
              {
                let test::S2{ 0: _, 1: _ } = x;
                {
                  let test::S2{ 0: _, 1: _ } = x;
                  {
                    let test::S2{ 0: _x, 1: _y } = x;
                    {
                      let test::S2{ 0: _x, 1: _y } = x;
                      {
                        let test::S2{ 0: _x, 1: _y } = x;
                        Tuple()
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun simple_3(x: S3) {
        {
          let test::S3{ x: _, y: _ } = x;
          {
            let test::S3{ x: _x, y: _ } = x;
            {
              let test::S3{ x: _, y: _y } = x;
              Tuple()
            }
          }
        }
    }
    private fun simple_3_ref(x: S3) {
        {
          let test::S3{ x: _, y: _ } = x;
          {
            let test::S3{ x: _x, y: _ } = x;
            {
              let test::S3{ x: _, y: _y } = x;
              Tuple()
            }
          }
        }
    }
    private fun simple_4(x: E1): u8 {
        match (x) {
          test::E1::A{ 0: x, 1: _ } => {
            x
          }
          test::E1::B{ 0: x } => {
            x
          }
          test::E1::C{ x, y: _ } => {
            x
          }
        }

    }
    private fun simple_4_ref(x: &E1): &u8 {
        match (x) {
          test::E1::A{ 0: x, 1: _ } => {
            x
          }
          test::E1::B{ 0: x } => {
            x
          }
        }

    }
    private fun simple_5(x: E1): u8 {
        match (x) {
          test::E1::A{ 0: _, 1: y } => {
            if y {
              1
            } else {
              0
            }
          }
          test::E1::B{ 0: x } => {
            x
          }
          test::E1::C{ x: _, y: test::S1{ 0: x } } => {
            x
          }
        }

    }
    private fun simple_6(x: &S7) {
        {
          let test::S7{ 0: _w, 1: _, 2: _, 3: _z } = x;
          {
            let test::S7{ 0: _w, 1: _x, 2: _y, 3: _z } = x;
            Tuple()
          }
        }
    }
    private fun test_lambda_param(): bool {
        test::lambda_param(|test::S2{ 0: x, 1: _ }| x)
    }
} // end 0x42::test


// -- Model dump after env processor simplifier:
module 0x42::test {
    enum E1 {
        A {
            0: u8,
            1: bool,
        }
        B {
            0: u8,
        }
        C {
            x: u8,
            y: S1,
        }
    }
    struct S0 {
        dummy_field: bool,
    }
    struct S1 {
        0: u8,
    }
    struct S2 {
        0: bool,
        1: S0,
    }
    struct S3 {
        x: bool,
        y: u8,
    }
    struct S4<T> {
        x: T,
        y: S3,
    }
    struct S5<T,U> {
        0: T,
        1: U,
    }
    struct S6<T,U> {
        x: T,
        y: U,
    }
    struct S7 {
        0: u8,
        1: u16,
        2: u32,
        3: u64,
    }
    private fun lambda_param(f: |S2|bool): bool {
        {
          let x: S2 = pack test::S2(true, pack test::S0(false));
          (f)(x)
        }
    }
    private fun nested1(x: S4<bool>) {
        {
          let test::S4<bool>{ x: _x, y: _ } = x;
          {
            let test::S4<bool>{ x: _, y: _y } = x;
            {
              let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _ } } = x;
              {
                let test::S4<bool>{ x: _, y: test::S3{ x: _x, y: _ } } = x;
                {
                  let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                  {
                    let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _y } } = x;
                    {
                      let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                      Tuple()
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun nested1_ref(x: &S4<bool>) {
        {
          let test::S4<bool>{ x: _x, y: _ } = x;
          {
            let test::S4<bool>{ x: _, y: _y } = x;
            {
              let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _ } } = x;
              {
                let test::S4<bool>{ x: _, y: test::S3{ x: _x, y: _ } } = x;
                {
                  let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                  {
                    let test::S4<bool>{ x: _, y: test::S3{ x: _, y: _y } } = x;
                    {
                      let test::S4<bool>{ x: _x2, y: test::S3{ x: _x1, y: _ } } = x;
                      Tuple()
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun nested2(x: S5<bool, S1>) {
        {
          let test::S5<bool, S1>{ 0: _, 1: test::S1{ 0: _ } } = x;
          Tuple()
        }
    }
    private fun nested2_ref(x: &S5<bool, S1>) {
        {
          let test::S5<bool, S1>{ 0: _, 1: test::S1{ 0: _ } } = x;
          Tuple()
        }
    }
    private fun nested3(x: S5<bool, S4<bool>>) {
        {
          let test::S5<bool, S4<bool>>{ 0: _, 1: test::S4<bool>{ x: _, y: _ } } = x;
          Tuple()
        }
    }
    private fun nested3_ref(x: &S5<bool, S4<bool>>) {
        {
          let test::S5<bool, S4<bool>>{ 0: _, 1: test::S4<bool>{ x: _, y: _ } } = x;
          Tuple()
        }
    }
    private fun nested4(x: S4<S1>) {
        {
          let test::S4<S1>{ x: test::S1{ 0: _ }, y: _ } = x;
          Tuple()
        }
    }
    private fun nested4_ref(x: &S4<S1>) {
        {
          let test::S4<S1>{ x: test::S1{ 0: _ }, y: _ } = x;
          Tuple()
        }
    }
    private fun simple_0(x: S0) {
        {
          let test::S0{ dummy_field: _ } = x;
          Tuple()
        }
    }
    private fun simple_0_ref(x: &S0) {
        {
          let test::S0{ dummy_field: _ } = x;
          Tuple()
        }
    }
    private fun simple_1(x: S1) {
        {
          let test::S1{ 0: _ } = x;
          Tuple()
        }
    }
    private fun simple_1_ref(x: &mut S1) {
        {
          let test::S1{ 0: _ } = x;
          Tuple()
        }
    }
    private fun simple_2(x: S2) {
        {
          let test::S2{ 0: _, 1: _ } = x;
          {
            let test::S2{ 0: _x, 1: _ } = x;
            {
              let test::S2{ 0: _, 1: _x } = x;
              {
                let test::S2{ 0: _, 1: _ } = x;
                {
                  let test::S2{ 0: _, 1: _ } = x;
                  {
                    let test::S2{ 0: _x, 1: _y } = x;
                    {
                      let test::S2{ 0: _x, 1: _y } = x;
                      {
                        let test::S2{ 0: _x, 1: _y } = x;
                        Tuple()
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun simple_2_ref(x: &S2) {
        {
          let test::S2{ 0: _, 1: _ } = x;
          {
            let test::S2{ 0: _x, 1: _ } = x;
            {
              let test::S2{ 0: _, 1: _x } = x;
              {
                let test::S2{ 0: _, 1: _ } = x;
                {
                  let test::S2{ 0: _, 1: _ } = x;
                  {
                    let test::S2{ 0: _x, 1: _y } = x;
                    {
                      let test::S2{ 0: _x, 1: _y } = x;
                      {
                        let test::S2{ 0: _x, 1: _y } = x;
                        Tuple()
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun simple_3(x: S3) {
        {
          let test::S3{ x: _, y: _ } = x;
          {
            let test::S3{ x: _x, y: _ } = x;
            {
              let test::S3{ x: _, y: _y } = x;
              Tuple()
            }
          }
        }
    }
    private fun simple_3_ref(x: S3) {
        {
          let test::S3{ x: _, y: _ } = x;
          {
            let test::S3{ x: _x, y: _ } = x;
            {
              let test::S3{ x: _, y: _y } = x;
              Tuple()
            }
          }
        }
    }
    private fun simple_4(x: E1): u8 {
        match (x) {
          test::E1::A{ 0: x, 1: _ } => {
            x
          }
          test::E1::B{ 0: x } => {
            x
          }
          test::E1::C{ x, y: _ } => {
            x
          }
        }

    }
    private fun simple_4_ref(x: &E1): &u8 {
        match (x) {
          test::E1::A{ 0: x, 1: _ } => {
            x
          }
          test::E1::B{ 0: x } => {
            x
          }
        }

    }
    private fun simple_5(x: E1): u8 {
        match (x) {
          test::E1::A{ 0: _, 1: y } => {
            if y {
              1
            } else {
              0
            }
          }
          test::E1::B{ 0: x } => {
            x
          }
          test::E1::C{ x: _, y: test::S1{ 0: x } } => {
            x
          }
        }

    }
    private fun simple_6(x: &S7) {
        {
          let test::S7{ 0: _w, 1: _, 2: _, 3: _z } = x;
          {
            let test::S7{ 0: _w, 1: _x, 2: _y, 3: _z } = x;
            Tuple()
          }
        }
    }
    private fun test_lambda_param(): bool {
        test::lambda_param(|test::S2{ 0: x, 1: _ }| x)
    }
} // end 0x42::test



Diagnostics:
error: Currently, lambda expressions must explicitly declare `move` capture of free variables, except when appearing as an argument to an inline function call.
     tests/lambda/inline-parity/dotdot_valid.move:181:22
    
181          lambda_param(|S2(x, ..)| x)
                          ^^^^^^^^^^^^^
