============ initial bytecode ================

[variant baseline]
fun m::test_for_each_mut() {
     var $t0: vector<u64>
     var $t1: u64
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: &mut vector<u64>
     var $t5: bool
     var $t6: u64
     var $t7: &mut u64
     var $t8: &mut vector<u64>
     var $t9: u64
     var $t10: u64
     var $t11: u64
     var $t12: u64
     var $t13: bool
     var $t14: vector<u64>
     var $t15: vector<u64>
     var $t16: u64
  0: $t0 := ["1", "2", "3"]
  1: $t1 := 0
  2: $t3 := borrow_local($t0)
  3: $t2 := vector::length<u64>($t3)
  4: $t4 := borrow_local($t0)
  5: label L0
  6: $t6 := infer($t1)
  7: $t5 := <($t6, $t2)
  8: if ($t5) goto 9 else goto 19
  9: label L2
 10: $t8 := infer($t4)
 11: $t7 := vector::borrow_mut<u64>($t8, $t1)
 12: $t9 := 2
 13: write_ref($t7, $t9)
 14: $t11 := infer($t1)
 15: $t12 := 1
 16: $t10 := +($t11, $t12)
 17: $t1 := infer($t10)
 18: goto 21
 19: label L3
 20: goto 23
 21: label L4
 22: goto 5
 23: label L1
 24: $t14 := infer($t0)
 25: $t15 := ["2", "3", "4"]
 26: $t13 := ==($t14, $t15)
 27: if ($t13) goto 28 else goto 30
 28: label L5
 29: goto 33
 30: label L6
 31: $t16 := 0
 32: abort($t16)
 33: label L7
 34: return ()
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
fun m::test_for_each_mut() {
     var $t0: vector<u64>
     var $t1: u64
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: &mut vector<u64>
     var $t5: bool
     var $t6: u64
     var $t7: &mut u64
     var $t8: &mut vector<u64>
     var $t9: u64
     var $t10: u64
     var $t11: u64
     var $t12: u64
     var $t13: bool
     var $t14: vector<u64>
     var $t15: vector<u64>
     var $t16: u64
     # live vars:
  0: $t0 := ["1", "2", "3"]
     # live vars: $t0
  1: $t1 := 0
     # live vars: $t0, $t1
  2: $t3 := borrow_local($t0)
     # live vars: $t0, $t1, $t3
  3: $t2 := vector::length<u64>($t3)
     # live vars: $t0, $t1, $t2
  4: $t4 := borrow_local($t0)
     # live vars: $t0, $t1, $t2, $t4
  5: label L0
     # live vars: $t0, $t1, $t2, $t4
  6: $t6 := infer($t1)
     # live vars: $t0, $t1, $t2, $t4, $t6
  7: $t5 := <($t6, $t2)
     # live vars: $t0, $t1, $t2, $t4, $t5
  8: if ($t5) goto 9 else goto 19
     # live vars: $t0, $t1, $t2, $t4
  9: label L2
     # live vars: $t0, $t1, $t2, $t4
 10: $t8 := infer($t4)
     # live vars: $t0, $t1, $t2, $t4, $t8
 11: $t7 := vector::borrow_mut<u64>($t8, $t1)
     # live vars: $t0, $t1, $t2, $t4, $t7
 12: $t9 := 2
     # live vars: $t0, $t1, $t2, $t4, $t7, $t9
 13: write_ref($t7, $t9)
     # live vars: $t0, $t1, $t2, $t4
 14: $t11 := infer($t1)
     # live vars: $t0, $t2, $t4, $t11
 15: $t12 := 1
     # live vars: $t0, $t2, $t4, $t11, $t12
 16: $t10 := +($t11, $t12)
     # live vars: $t0, $t2, $t4, $t10
 17: $t1 := infer($t10)
     # live vars: $t0, $t1, $t2, $t4
 18: goto 21
     # live vars: $t0, $t1, $t2, $t4
 19: label L3
     # live vars: $t0
 20: goto 23
     # live vars: $t0, $t1, $t2, $t4
 21: label L4
     # live vars: $t0, $t1, $t2, $t4
 22: goto 5
     # live vars: $t0
 23: label L1
     # live vars: $t0
 24: $t14 := infer($t0)
     # live vars: $t14
 25: $t15 := ["2", "3", "4"]
     # live vars: $t14, $t15
 26: $t13 := ==($t14, $t15)
     # live vars: $t13
 27: if ($t13) goto 28 else goto 30
     # live vars:
 28: label L5
     # live vars:
 29: goto 33
     # live vars:
 30: label L6
     # live vars:
 31: $t16 := 0
     # live vars: $t16
 32: abort($t16)
     # live vars:
 33: label L7
     # live vars:
 34: return ()
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
fun m::test_for_each_mut() {
     var $t0: vector<u64>
     var $t1: u64
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: &mut vector<u64>
     var $t5: bool
     var $t6: u64
     var $t7: &mut u64
     var $t8: &mut vector<u64>
     var $t9: u64
     var $t10: u64
     var $t11: u64
     var $t12: u64
     var $t13: bool
     var $t14: vector<u64>
     var $t15: vector<u64>
     var $t16: u64
     # live vars:
  0: $t0 := ["1", "2", "3"]
     # live vars: $t0
  1: $t1 := 0
     # live vars: $t0, $t1
  2: $t3 := borrow_local($t0)
     # live vars: $t0, $t1, $t3
  3: $t2 := vector::length<u64>($t3)
     # live vars: $t0, $t1, $t2
  4: $t4 := borrow_local($t0)
     # live vars: $t0, $t1, $t2, $t4
  5: label L0
     # live vars: $t0, $t1, $t2, $t4
  6: $t6 := infer($t1)
     # live vars: $t0, $t1, $t2, $t4, $t6
  7: $t5 := <($t6, $t2)
     # live vars: $t0, $t1, $t2, $t4, $t5
  8: if ($t5) goto 9 else goto 19
     # live vars: $t0, $t1, $t2, $t4
  9: label L2
     # live vars: $t0, $t1, $t2, $t4
 10: $t8 := infer($t4)
     # live vars: $t0, $t1, $t2, $t4, $t8
 11: $t7 := vector::borrow_mut<u64>($t8, $t1)
     # live vars: $t0, $t1, $t2, $t4, $t7
 12: $t9 := 2
     # live vars: $t0, $t1, $t2, $t4, $t7, $t9
 13: write_ref($t7, $t9)
     # live vars: $t0, $t1, $t2, $t4
 14: $t11 := infer($t1)
     # live vars: $t0, $t2, $t4, $t11
 15: $t12 := 1
     # live vars: $t0, $t2, $t4, $t11, $t12
 16: $t10 := +($t11, $t12)
     # live vars: $t0, $t2, $t4, $t10
 17: $t1 := infer($t10)
     # live vars: $t0, $t1, $t2, $t4
 18: goto 21
     # live vars: $t0, $t1, $t2, $t4
 19: label L3
     # live vars: $t0
 20: goto 23
     # live vars: $t0, $t1, $t2, $t4
 21: label L4
     # live vars: $t0, $t1, $t2, $t4
 22: goto 5
     # live vars: $t0
 23: label L1
     # live vars: $t0
 24: $t14 := infer($t0)
     # live vars: $t14
 25: $t15 := ["2", "3", "4"]
     # live vars: $t14, $t15
 26: $t13 := ==($t14, $t15)
     # live vars: $t13
 27: if ($t13) goto 28 else goto 30
     # live vars:
 28: label L5
     # live vars:
 29: goto 33
     # live vars:
 30: label L6
     # live vars:
 31: $t16 := 0
     # live vars: $t16
 32: abort($t16)
     # live vars:
 33: label L7
     # live vars:
 34: return ()
}

============ after ReferenceSafetyProcessor: ================

[variant baseline]
fun m::test_for_each_mut() {
     var $t0: vector<u64>
     var $t1: u64
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: &mut vector<u64>
     var $t5: bool
     var $t6: u64
     var $t7: &mut u64
     var $t8: &mut vector<u64>
     var $t9: u64
     var $t10: u64
     var $t11: u64
     var $t12: u64
     var $t13: bool
     var $t14: vector<u64>
     var $t15: vector<u64>
     var $t16: u64
     # live vars:
     # refs: []
     #
  0: $t0 := ["1", "2", "3"]
     # live vars: $t0
     # refs: []
     #
  1: $t1 := 0
     # live vars: $t0, $t1
     # refs: []
     #
  2: $t3 := borrow_local($t0)
     # live vars: $t0, $t1, $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [local `v`] at line 8
     #
  3: $t2 := vector::length<u64>($t3)
     # live vars: $t0, $t1, $t2
     # refs: []
     #
  4: $t4 := borrow_local($t0)
     # live vars: $t0, $t1, $t2, $t4
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
  5: label L0
     # live vars: $t0, $t1, $t2, $t4
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
  6: $t6 := infer($t1)
     # live vars: $t0, $t1, $t2, $t4, $t6
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
  7: $t5 := <($t6, $t2)
     # live vars: $t0, $t1, $t2, $t4, $t5
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
  8: if ($t5) goto 9 else goto 19
     # live vars: $t0, $t1, $t2, $t4
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
  9: label L2
     # live vars: $t0, $t1, $t2, $t4
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
 10: $t8 := infer($t4)
     # live vars: $t0, $t1, $t2, $t4, $t8
     # refs: [$t4 => #4, $t8 => #8]
     # #4
     #   => (mut) #8 via [] at line 11
     # #8
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
 11: $t7 := vector::borrow_mut<u64>($t8, $t1)
     # live vars: $t0, $t1, $t2, $t4, $t7
     # refs: [$t4 => #4, $t7 => #7]
     # #4
     #   -> (mut) #7 via [] at line 11
     # #7
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
 12: $t9 := 2
     # live vars: $t0, $t1, $t2, $t4, $t7, $t9
     # refs: [$t4 => #4, $t7 => #7]
     # #4
     #   -> (mut) #7 via [] at line 11
     # #7
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
 13: write_ref($t7, $t9)
     # live vars: $t0, $t1, $t2, $t4
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
 14: $t11 := infer($t1)
     # live vars: $t0, $t2, $t4, $t11
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
 15: $t12 := 1
     # live vars: $t0, $t2, $t4, $t11, $t12
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
 16: $t10 := +($t11, $t12)
     # live vars: $t0, $t2, $t4, $t10
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
 17: $t1 := infer($t10)
     # live vars: $t0, $t1, $t2, $t4
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
 18: goto 21
     # live vars: $t0, $t1, $t2, $t4
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
 19: label L3
     # live vars: $t0
     # refs: []
     #
 20: goto 23
     # live vars: $t0, $t1, $t2, $t4
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
 21: label L4
     # live vars: $t0, $t1, $t2, $t4
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
 22: goto 5
     # live vars: $t0
     # refs: []
     #
 23: label L1
     # live vars: $t0
     # refs: []
     #
 24: $t14 := infer($t0)
     # live vars: $t14
     # refs: []
     #
 25: $t15 := ["2", "3", "4"]
     # live vars: $t14, $t15
     # refs: []
     #
 26: $t13 := ==($t14, $t15)
     # live vars: $t13
     # refs: []
     #
 27: if ($t13) goto 28 else goto 30
     # live vars:
     # refs: []
     #
 28: label L5
     # live vars:
     # refs: []
     #
 29: goto 33
     # live vars:
     # refs: []
     #
 30: label L6
     # live vars:
     # refs: []
     #
 31: $t16 := 0
     # live vars: $t16
     # refs: []
     #
 32: abort($t16)
     # live vars:
     # refs: []
     #
 33: label L7
     # live vars:
     # refs: []
     #
 34: return ()
}

============ after AbortAnalysisProcessor: ================

[variant baseline]
fun m::test_for_each_mut() {
     var $t0: vector<u64>
     var $t1: u64
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: &mut vector<u64>
     var $t5: bool
     var $t6: u64
     var $t7: &mut u64
     var $t8: &mut vector<u64>
     var $t9: u64
     var $t10: u64
     var $t11: u64
     var $t12: u64
     var $t13: bool
     var $t14: vector<u64>
     var $t15: vector<u64>
     var $t16: u64
     # abort state: {returns,aborts}
     # live vars:
     # refs: []
     #
  0: $t0 := ["1", "2", "3"]
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
  1: $t1 := 0
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  2: $t3 := borrow_local($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [local `v`] at line 8
     #
  3: $t2 := vector::length<u64>($t3)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
  4: $t4 := borrow_local($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t4
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
  5: label L0
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t4
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
  6: $t6 := infer($t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t4, $t6
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
  7: $t5 := <($t6, $t2)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t4, $t5
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
  8: if ($t5) goto 9 else goto 19
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t4
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
  9: label L2
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t4
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
 10: $t8 := infer($t4)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t4, $t8
     # refs: [$t4 => #4, $t8 => #8]
     # #4
     #   => (mut) #8 via [] at line 11
     # #8
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
 11: $t7 := vector::borrow_mut<u64>($t8, $t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t4, $t7
     # refs: [$t4 => #4, $t7 => #7]
     # #4
     #   -> (mut) #7 via [] at line 11
     # #7
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
 12: $t9 := 2
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t4, $t7, $t9
     # refs: [$t4 => #4, $t7 => #7]
     # #4
     #   -> (mut) #7 via [] at line 11
     # #7
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
 13: write_ref($t7, $t9)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t4
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
 14: $t11 := infer($t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t2, $t4, $t11
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
 15: $t12 := 1
     # abort state: {returns,aborts}
     # live vars: $t0, $t2, $t4, $t11, $t12
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
 16: $t10 := +($t11, $t12)
     # abort state: {returns,aborts}
     # live vars: $t0, $t2, $t4, $t10
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
 17: $t1 := infer($t10)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t4
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
 18: goto 21
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t4
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
 19: label L3
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
 20: goto 23
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t4
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
 21: label L4
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t4
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => (mut) #4 via [local `v`] at line 9
     #
 22: goto 5
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
 23: label L1
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
 24: $t14 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t14
     # refs: []
     #
 25: $t15 := ["2", "3", "4"]
     # abort state: {returns,aborts}
     # live vars: $t14, $t15
     # refs: []
     #
 26: $t13 := ==($t14, $t15)
     # abort state: {returns,aborts}
     # live vars: $t13
     # refs: []
     #
 27: if ($t13) goto 28 else goto 30
     # abort state: {returns}
     # live vars:
     # refs: []
     #
 28: label L5
     # abort state: {returns}
     # live vars:
     # refs: []
     #
 29: goto 33
     # abort state: {aborts}
     # live vars:
     # refs: []
     #
 30: label L6
     # abort state: {aborts}
     # live vars:
     # refs: []
     #
 31: $t16 := 0
     # abort state: {aborts}
     # live vars: $t16
     # refs: []
     #
 32: abort($t16)
     # abort state: {returns}
     # live vars:
     # refs: []
     #
 33: label L7
     # abort state: {returns}
     # live vars:
     # refs: []
     #
 34: return ()
}

============ after AbilityProcessor: ================

[variant baseline]
fun m::test_for_each_mut() {
     var $t0: vector<u64>
     var $t1: u64
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: &mut vector<u64>
     var $t5: bool
     var $t6: u64
     var $t7: &mut u64
     var $t8: &mut vector<u64>
     var $t9: u64
     var $t10: u64
     var $t11: u64
     var $t12: u64
     var $t13: bool
     var $t14: vector<u64>
     var $t15: vector<u64>
     var $t16: u64
  0: $t0 := ["1", "2", "3"]
  1: $t1 := 0
  2: $t3 := borrow_local($t0)
  3: $t2 := vector::length<u64>($t3)
  4: $t4 := borrow_local($t0)
  5: label L0
  6: $t6 := copy($t1)
  7: $t5 := <($t6, $t2)
  8: if ($t5) goto 9 else goto 19
  9: label L2
 10: $t8 := copy($t4)
 11: $t7 := vector::borrow_mut<u64>($t8, $t1)
 12: $t9 := 2
 13: write_ref($t7, $t9)
 14: $t11 := move($t1)
 15: $t12 := 1
 16: $t10 := +($t11, $t12)
 17: $t1 := move($t10)
 18: goto 22
 19: label L3
 20: drop($t4)
 21: goto 24
 22: label L4
 23: goto 5
 24: label L1
 25: $t14 := move($t0)
 26: $t15 := ["2", "3", "4"]
 27: $t13 := ==($t14, $t15)
 28: if ($t13) goto 29 else goto 31
 29: label L5
 30: goto 34
 31: label L6
 32: $t16 := 0
 33: abort($t16)
 34: label L7
 35: return ()
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
fun m::test_for_each_mut() {
     var $t0: vector<u64>
     var $t1: u64
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: &mut vector<u64>
     var $t5: bool
     var $t6: u64
     var $t7: &mut u64
     var $t8: &mut vector<u64>
     var $t9: u64
     var $t10: u64
     var $t11: u64
     var $t12: u64
     var $t13: bool
     var $t14: vector<u64>
     var $t15: vector<u64>
     var $t16: u64
     # live vars:
  0: $t0 := ["1", "2", "3"]
     # live vars: $t0
  1: $t1 := 0
     # live vars: $t0, $t1
  2: $t3 := borrow_local($t0)
     # live vars: $t0, $t1, $t3
  3: $t2 := vector::length<u64>($t3)
     # live vars: $t0, $t1, $t2
  4: $t4 := borrow_local($t0)
     # live vars: $t0, $t1, $t2, $t4
  5: label L0
     # live vars: $t0, $t1, $t2, $t4
  6: $t6 := copy($t1)
     # live vars: $t0, $t1, $t2, $t4, $t6
  7: $t5 := <($t6, $t2)
     # live vars: $t0, $t1, $t2, $t4, $t5
  8: if ($t5) goto 9 else goto 19
     # live vars: $t0, $t1, $t2, $t4
  9: label L2
     # live vars: $t0, $t1, $t2, $t4
 10: $t8 := copy($t4)
     # live vars: $t0, $t1, $t2, $t4, $t8
 11: $t7 := vector::borrow_mut<u64>($t8, $t1)
     # live vars: $t0, $t1, $t2, $t4, $t7
 12: $t9 := 2
     # live vars: $t0, $t1, $t2, $t4, $t7, $t9
 13: write_ref($t7, $t9)
     # live vars: $t0, $t1, $t2, $t4
 14: $t11 := move($t1)
     # live vars: $t0, $t2, $t4, $t11
 15: $t12 := 1
     # live vars: $t0, $t2, $t4, $t11, $t12
 16: $t10 := +($t11, $t12)
     # live vars: $t0, $t2, $t4, $t10
 17: $t1 := move($t10)
     # live vars: $t0, $t1, $t2, $t4
 18: goto 5
     # live vars: $t0, $t1, $t2, $t4
 19: label L3
     # live vars: $t0, $t4
 20: drop($t4)
     # live vars: $t0
 21: $t14 := move($t0)
     # live vars: $t14
 22: $t15 := ["2", "3", "4"]
     # live vars: $t14, $t15
 23: $t13 := ==($t14, $t15)
     # live vars: $t13
 24: if ($t13) goto 25 else goto 27
     # live vars:
 25: label L5
     # live vars:
 26: return ()
     # live vars:
 27: label L6
     # live vars:
 28: $t16 := 0
     # live vars: $t16
 29: abort($t16)
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
fun m::test_for_each_mut() {
     var $t0: vector<u64>
     var $t1: u64
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: &mut vector<u64>
     var $t5: bool
     var $t6: u64
     var $t7: &mut u64
     var $t8: &mut vector<u64>
     var $t9: u64
     var $t10: u64
     var $t11: u64
     var $t12: u64
     var $t13: bool
     var $t14: vector<u64>
     var $t15: vector<u64>
     var $t16: u64
     # live vars:
  0: $t0 := ["1", "2", "3"]
     # live vars: $t0
  1: $t1 := 0
     # live vars: $t0, $t1
  2: $t3 := borrow_local($t0)
     # live vars: $t0, $t1, $t3
  3: $t2 := vector::length<u64>($t3)
     # live vars: $t0, $t1, $t2
  4: $t4 := borrow_local($t0)
     # live vars: $t0, $t1, $t2, $t4
  5: label L0
     # live vars: $t0, $t1, $t2, $t4
  6: $t6 := copy($t1)
     # live vars: $t0, $t1, $t2, $t4, $t6
  7: $t5 := <($t6, $t2)
     # live vars: $t0, $t1, $t2, $t4, $t5
  8: if ($t5) goto 9 else goto 19
     # live vars: $t0, $t1, $t2, $t4
  9: label L2
     # live vars: $t0, $t1, $t2, $t4
 10: $t8 := copy($t4)
     # live vars: $t0, $t1, $t2, $t4, $t8
 11: $t7 := vector::borrow_mut<u64>($t8, $t1)
     # live vars: $t0, $t1, $t2, $t4, $t7
 12: $t9 := 2
     # live vars: $t0, $t1, $t2, $t4, $t7, $t9
 13: write_ref($t7, $t9)
     # live vars: $t0, $t1, $t2, $t4
 14: $t11 := move($t1)
     # live vars: $t0, $t2, $t4, $t11
 15: $t12 := 1
     # live vars: $t0, $t2, $t4, $t11, $t12
 16: $t10 := +($t11, $t12)
     # live vars: $t0, $t2, $t4, $t10
 17: $t1 := move($t10)
     # live vars: $t0, $t1, $t2, $t4
 18: goto 5
     # live vars: $t0, $t1, $t2, $t4
 19: label L3
     # live vars: $t0, $t4
 20: drop($t4)
     # live vars: $t0
 21: $t14 := move($t0)
     # live vars: $t14
 22: $t15 := ["2", "3", "4"]
     # live vars: $t14, $t15
 23: $t13 := ==($t14, $t15)
     # live vars: $t13
 24: if ($t13) goto 25 else goto 27
     # live vars:
 25: label L5
     # live vars:
 26: return ()
     # live vars:
 27: label L6
     # live vars:
 28: $t16 := 0
     # live vars: $t16
 29: abort($t16)
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
fun m::test_for_each_mut() {
     var $t0: vector<u64>
     var $t1: u64
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: &mut vector<u64>
     var $t5: bool
     var $t6: u64
     var $t7: &mut u64
     var $t8: &mut vector<u64>
     var $t9: u64 [unused]
     var $t10: u64 [unused]
     var $t11: u64 [unused]
     var $t12: u64
     var $t13: bool [unused]
     var $t14: vector<u64>
     var $t15: vector<u64>
     var $t16: u64 [unused]
     # live vars:
  0: $t0 := ["1", "2", "3"]
     # live vars: $t0
  1: $t1 := 0
     # live vars: $t0, $t1
  2: $t3 := borrow_local($t0)
     # live vars: $t0, $t1, $t3
  3: $t2 := vector::length<u64>($t3)
     # live vars: $t0, $t1, $t2
  4: $t4 := borrow_local($t0)
     # live vars: $t0, $t1, $t2, $t4
  5: label L0
     # live vars: $t0, $t1, $t2, $t4
  6: $t6 := copy($t1)
     # live vars: $t0, $t1, $t2, $t4, $t6
  7: $t5 := <($t6, $t2)
     # live vars: $t0, $t1, $t2, $t4, $t5
  8: if ($t5) goto 9 else goto 19
     # live vars: $t0, $t1, $t2, $t4
  9: label L2
     # live vars: $t0, $t1, $t2, $t4
 10: $t8 := copy($t4)
     # live vars: $t0, $t1, $t2, $t4, $t8
 11: $t7 := vector::borrow_mut<u64>($t8, $t1)
     # live vars: $t0, $t1, $t2, $t4, $t7
 12: $t6 := 2
     # live vars: $t0, $t1, $t2, $t4, $t6, $t7
 13: write_ref($t7, $t6)
     # live vars: $t0, $t1, $t2, $t4
 14: $t6 := move($t1)
     # live vars: $t0, $t2, $t4, $t6
 15: $t12 := 1
     # live vars: $t0, $t2, $t4, $t6, $t12
 16: $t6 := +($t6, $t12)
     # live vars: $t0, $t2, $t4, $t6
 17: $t1 := move($t6)
     # live vars: $t0, $t1, $t2, $t4
 18: goto 5
     # live vars: $t0, $t1, $t2, $t4
 19: label L3
     # live vars: $t0, $t4
 20: drop($t4)
     # live vars: $t0
 21: $t14 := move($t0)
     # live vars: $t14
 22: $t15 := ["2", "3", "4"]
     # live vars: $t14, $t15
 23: $t5 := ==($t14, $t15)
     # live vars: $t5
 24: if ($t5) goto 25 else goto 27
     # live vars:
 25: label L5
     # live vars:
 26: return ()
     # live vars:
 27: label L6
     # live vars:
 28: $t1 := 0
     # live vars: $t1
 29: abort($t1)
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
fun m::test_for_each_mut() {
     var $t0: vector<u64>
     var $t1: u64
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: &mut vector<u64>
     var $t5: bool
     var $t6: u64
     var $t7: &mut u64
     var $t8: &mut vector<u64>
     var $t9: u64 [unused]
     var $t10: u64 [unused]
     var $t11: u64 [unused]
     var $t12: u64
     var $t13: bool [unused]
     var $t14: vector<u64>
     var $t15: vector<u64>
     var $t16: u64 [unused]
     # live vars:
  0: $t0 := ["1", "2", "3"]
     # live vars: $t0
  1: $t1 := 0
     # live vars: $t0, $t1
  2: $t3 := borrow_local($t0)
     # live vars: $t0, $t1, $t3
  3: $t2 := vector::length<u64>($t3)
     # live vars: $t0, $t1, $t2
  4: $t4 := borrow_local($t0)
     # live vars: $t0, $t1, $t2, $t4
  5: label L0
     # live vars: $t0, $t1, $t2, $t4
  6: $t6 := copy($t1)
     # live vars: $t0, $t1, $t2, $t4, $t6
  7: $t5 := <($t6, $t2)
     # live vars: $t0, $t1, $t2, $t4, $t5
  8: if ($t5) goto 9 else goto 19
     # live vars: $t0, $t1, $t2, $t4
  9: label L2
     # live vars: $t0, $t1, $t2, $t4
 10: $t8 := copy($t4)
     # live vars: $t0, $t1, $t2, $t4, $t8
 11: $t7 := vector::borrow_mut<u64>($t8, $t1)
     # live vars: $t0, $t1, $t2, $t4, $t7
 12: $t6 := 2
     # live vars: $t0, $t1, $t2, $t4, $t6, $t7
 13: write_ref($t7, $t6)
     # live vars: $t0, $t1, $t2, $t4
 14: $t6 := move($t1)
     # live vars: $t0, $t2, $t4, $t6
 15: $t12 := 1
     # live vars: $t0, $t2, $t4, $t6, $t12
 16: $t6 := +($t6, $t12)
     # live vars: $t0, $t2, $t4, $t6
 17: $t1 := move($t6)
     # live vars: $t0, $t1, $t2, $t4
 18: goto 5
     # live vars: $t0, $t1, $t2, $t4
 19: label L3
     # live vars: $t0, $t4
 20: drop($t4)
     # live vars: $t0
 21: $t14 := move($t0)
     # live vars: $t14
 22: $t15 := ["2", "3", "4"]
     # live vars: $t14, $t15
 23: $t5 := ==($t14, $t15)
     # live vars: $t5
 24: if ($t5) goto 25 else goto 27
     # live vars:
 25: label L5
     # live vars:
 26: return ()
     # live vars:
 27: label L6
     # live vars:
 28: $t1 := 0
     # live vars: $t1
 29: abort($t1)
}


============ disassembled file-format ==================
// Move bytecode v7
module 42.m {


test_for_each_mut() /* def_idx: 0 */ {
L0:	loc0: vector<u64>
L1:	loc1: u64
L2:	loc2: u64
L3:	loc3: &mut vector<u64>
L4:	loc4: &mut u64
B0:
	0: LdConst[0](Vector(U64): [3, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0])
	1: StLoc[0](loc0: vector<u64>)
	2: LdU64(0)
	3: StLoc[1](loc1: u64)
	4: ImmBorrowLoc[0](loc0: vector<u64>)
	5: VecLen(1)
	6: StLoc[2](loc2: u64)
	7: MutBorrowLoc[0](loc0: vector<u64>)
	8: StLoc[3](loc3: &mut vector<u64>)
B1:
	9: CopyLoc[1](loc1: u64)
	10: CopyLoc[2](loc2: u64)
	11: Lt
	12: BrFalse(25)
B2:
	13: CopyLoc[3](loc3: &mut vector<u64>)
	14: CopyLoc[1](loc1: u64)
	15: VecMutBorrow(1)
	16: StLoc[4](loc4: &mut u64)
	17: LdU64(2)
	18: MoveLoc[4](loc4: &mut u64)
	19: WriteRef
	20: MoveLoc[1](loc1: u64)
	21: LdU64(1)
	22: Add
	23: StLoc[1](loc1: u64)
	24: Branch(9)
B3:
	25: MoveLoc[3](loc3: &mut vector<u64>)
	26: Pop
	27: MoveLoc[0](loc0: vector<u64>)
	28: LdConst[1](Vector(U64): [3, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0])
	29: Eq
	30: BrFalse(32)
B4:
	31: Ret
B5:
	32: LdU64(0)
	33: Abort
}
}
============ bytecode verification succeeded ========
