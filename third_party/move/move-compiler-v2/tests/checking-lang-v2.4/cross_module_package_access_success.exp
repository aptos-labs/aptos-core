// -- Model dump before first bytecode pipeline
module 0xc0ffee::m {
    struct Empty {
        dummy_field: bool,
    }
    struct S {
        x: u64,
    }
    struct S2 {
        x: u64,
        s: S,
    }
    enum Wrapper {
        V1 {
            0: u64,
        }
        V2 {
            0: u64,
        }
    }
    public fun make(x: u64): Wrapper {
        pack m::Wrapper::V1(x)
    }
} // end 0xc0ffee::m
module 0xc0ffee::m_friend {
    struct T {
        x: u64,
    }
} // end 0xc0ffee::m_friend
module 0xc0ffee::n {
    use 0xc0ffee::m; // resolved as: 0xc0ffee::m
    private fun test() {
        {
          let x: m::Wrapper = m::make(22);
          if Eq<u64>(select_variants m::Wrapper.V1.0|m::Wrapper.V2.0<m::Wrapper>(x), 22) {
            Tuple()
          } else {
            Abort(1)
          };
          Tuple()
        }
    }
} // end 0xc0ffee::n
module 0xc0ffee::n2 {
    use 0xc0ffee::m::{Wrapper}; // resolved as: 0xc0ffee::m
    private fun test_pack() {
        {
          let _x: m::Wrapper = pack m::Wrapper::V1(22);
          Tuple()
        }
    }
} // end 0xc0ffee::n2
module 0xc0ffee::n3 {
    use 0xc0ffee::m::{Wrapper}; // resolved as: 0xc0ffee::m
    private fun test_unpack(w: m::Wrapper) {
        {
          let m::Wrapper::V1{ 0: _x } = w;
          Tuple()
        }
    }
} // end 0xc0ffee::n3
module 0xc0ffee::n4 {
    use 0xc0ffee::m::{Wrapper}; // resolved as: 0xc0ffee::m
    private fun test_select_variant(w: m::Wrapper): u64 {
        select_variants m::Wrapper.V1.0|m::Wrapper.V2.0<m::Wrapper>(w)
    }
} // end 0xc0ffee::n4
module 0xc0ffee::n5 {
    use 0xc0ffee::m::{Wrapper}; // resolved as: 0xc0ffee::m
    private fun test_test_variant(w: m::Wrapper): bool {
        test_variants m::Wrapper::V1(w)
    }
} // end 0xc0ffee::n5
module 0xc0ffee::n6 {
    use 0xc0ffee::m::{Wrapper}; // resolved as: 0xc0ffee::m
    private fun test_match(w: m::Wrapper): bool {
        match (w) {
          m::Wrapper::V1{ 0: _ } => {
            true
          }
          m::Wrapper::V2{ 0: _ } => {
            false
          }
        }

    }
} // end 0xc0ffee::n6
module 0xc0ffee::n7 {
    use 0xc0ffee::m::{S}; // resolved as: 0xc0ffee::m
    private fun test_pack_struct(): m::S {
        pack m::S(22)
    }
} // end 0xc0ffee::n7
module 0xc0ffee::n8 {
    use 0xc0ffee::m::{S}; // resolved as: 0xc0ffee::m
    private fun test_pack_struct(): m::S {
        {
          let (): ();
          pack m::S(22)
        }
    }
    private inline fun test_pack_struct_inline(): m::S {
        pack m::S(22)
    }
} // end 0xc0ffee::n8
module 0xc0ffee::n9 {
    use 0xc0ffee::m::{S}; // resolved as: 0xc0ffee::m
    use 0xc0ffee::m::{S2}; // resolved as: 0xc0ffee::m
    private inline fun test_inline(x: ||) {
        (x)()
    }
    private fun test_pack_unpack_struct_in_lambda() {
        {
          let (): ();
          {
            let (): ();
            {
              let x: m::S2 = pack m::S2(22, pack m::S(33));
              {
                let m::S2{ x: _x, s: m::S{ x: _y } } = x;
                Tuple()
              }
            }
          }
        }
    }
} // end 0xc0ffee::n9
module 0xc0ffee::n_friend {
    use 0xc0ffee::m_friend::{T}; // resolved as: 0xc0ffee::m_friend
    private fun test_pack_friend_struct(): m_friend::T {
        pack m_friend::T(22)
    }
} // end 0xc0ffee::n_friend

// -- Sourcified model before first bytecode pipeline
module 0xc0ffee::m {
    friend 0xc0ffee::n;
    friend 0xc0ffee::n2;
    friend 0xc0ffee::n3;
    friend 0xc0ffee::n4;
    friend 0xc0ffee::n5;
    friend 0xc0ffee::n6;
    friend 0xc0ffee::n7;
    friend 0xc0ffee::n8;
    friend 0xc0ffee::n9;
    struct Empty {
    }
    struct S {
        x: u64,
    }
    struct S2 {
        x: u64,
        s: S,
    }
    enum Wrapper has drop {
        V1 {
            0: u64,
        }
        V2 {
            0: u64,
        }
    }
    public fun make(x: u64): Wrapper {
        Wrapper::V1(x)
    }
}
module 0xc0ffee::m_friend {
    friend 0xc0ffee::n_friend;
    struct T {
        x: u64,
    }
}
module 0xc0ffee::n {
    use 0xc0ffee::m;
    fun test() {
        let x = m::make(22);
        if (x.0 == 22) () else abort 1;
    }
}
module 0xc0ffee::n2 {
    use 0xc0ffee::m;
    fun test_pack() {
        let _x = m::Wrapper::V1(22);
    }
}
module 0xc0ffee::n3 {
    use 0xc0ffee::m;
    fun test_unpack(w: m::Wrapper) {
        let m::Wrapper::V1(_x) = w;
    }
}
module 0xc0ffee::n4 {
    use 0xc0ffee::m;
    fun test_select_variant(w: m::Wrapper): u64 {
        w.0
    }
}
module 0xc0ffee::n5 {
    use 0xc0ffee::m;
    fun test_test_variant(w: m::Wrapper): bool {
        w is V1
    }
}
module 0xc0ffee::n6 {
    use 0xc0ffee::m;
    fun test_match(w: m::Wrapper): bool {
        match (w) {
            m::Wrapper::V1(_) => true,
            m::Wrapper::V2(_) => false,
        }
    }
}
module 0xc0ffee::n7 {
    use 0xc0ffee::m;
    fun test_pack_struct(): m::S {
        m::S{x: 22}
    }
}
module 0xc0ffee::n8 {
    use 0xc0ffee::m;
    fun test_pack_struct(): m::S {
        let ();
        m::S{x: 22}
    }
    inline fun test_pack_struct_inline(): m::S {
        m::S{x: 22}
    }
}
module 0xc0ffee::n9 {
    use 0xc0ffee::m;
    use 0xc0ffee::m;
    inline fun test_inline(x: ||) {
        x()
    }
    fun test_pack_unpack_struct_in_lambda() {
        let ();
        let ();
        let x = m::S2{x: 22, s: m::S{x: 33}};
        let m::S2{x: _x, s: m::S{x: _y}} = x;
    }
}
module 0xc0ffee::n_friend {
    use 0xc0ffee::m_friend;
    fun test_pack_friend_struct(): m_friend::T {
        m_friend::T{x: 22}
    }
}

============ bytecode before first stackless bytecode pipeline ================

[variant baseline]
public fun m::make($t0: u64): 0xc0ffee::m::Wrapper {
     var $t1: 0xc0ffee::m::Wrapper
  0: $t1 := pack_variant 0xc0ffee::m::Wrapper::V1($t0)
  1: return $t1
}


[variant baseline]
fun n::test() {
     var $t0: 0xc0ffee::m::Wrapper
     var $t1: u64
     var $t2: bool
     var $t3: u64
     var $t4: &0xc0ffee::m::Wrapper
     var $t5: &u64
     var $t6: u64
     var $t7: u64
  0: $t1 := 22
  1: $t0 := m::make($t1)
  2: $t4 := borrow_local($t0)
  3: $t5 := borrow_variant_field<0xc0ffee::m::Wrapper::V1|V2>.0($t4)
  4: $t3 := read_ref($t5)
  5: $t6 := 22
  6: $t2 := ==($t3, $t6)
  7: if ($t2) goto 8 else goto 10
  8: label L0
  9: goto 13
 10: label L1
 11: $t7 := 1
 12: abort($t7)
 13: label L2
 14: return ()
}


[variant baseline]
fun n2::test_pack() {
     var $t0: 0xc0ffee::m::Wrapper
     var $t1: u64
  0: $t1 := 22
  1: $t0 := pack_variant 0xc0ffee::m::Wrapper::V1($t1)
  2: return ()
}


[variant baseline]
fun n3::test_unpack($t0: 0xc0ffee::m::Wrapper) {
     var $t1: u64
  0: $t1 := unpack_variant 0xc0ffee::m::Wrapper::V1($t0)
  1: return ()
}


[variant baseline]
fun n4::test_select_variant($t0: 0xc0ffee::m::Wrapper): u64 {
     var $t1: u64
     var $t2: &0xc0ffee::m::Wrapper
     var $t3: &u64
  0: $t2 := borrow_local($t0)
  1: $t3 := borrow_variant_field<0xc0ffee::m::Wrapper::V1|V2>.0($t2)
  2: $t1 := read_ref($t3)
  3: return $t1
}


[variant baseline]
fun n5::test_test_variant($t0: 0xc0ffee::m::Wrapper): bool {
     var $t1: bool
     var $t2: &0xc0ffee::m::Wrapper
  0: $t2 := borrow_local($t0)
  1: $t1 := test_variant 0xc0ffee::m::Wrapper::V1($t2)
  2: return $t1
}


[variant baseline]
fun n6::test_match($t0: 0xc0ffee::m::Wrapper): bool {
     var $t1: bool
     var $t2: &0xc0ffee::m::Wrapper
     var $t3: bool
     var $t4: u64
     var $t5: u64
     var $t6: u64
  0: $t2 := borrow_local($t0)
  1: $t3 := test_variant 0xc0ffee::m::Wrapper::V1($t2)
  2: if ($t3) goto 3 else goto 7
  3: label L2
  4: $t4 := unpack_variant 0xc0ffee::m::Wrapper::V1($t0)
  5: $t1 := true
  6: goto 17
  7: label L1
  8: $t3 := test_variant 0xc0ffee::m::Wrapper::V2($t2)
  9: if ($t3) goto 10 else goto 14
 10: label L4
 11: $t5 := unpack_variant 0xc0ffee::m::Wrapper::V2($t0)
 12: $t1 := false
 13: goto 17
 14: label L3
 15: $t6 := 14566554180833181697
 16: abort($t6)
 17: label L0
 18: return $t1
}


[variant baseline]
fun n7::test_pack_struct(): 0xc0ffee::m::S {
     var $t0: 0xc0ffee::m::S
     var $t1: u64
  0: $t1 := 22
  1: $t0 := pack 0xc0ffee::m::S($t1)
  2: return $t0
}


[variant baseline]
fun n8::test_pack_struct(): 0xc0ffee::m::S {
     var $t0: 0xc0ffee::m::S
     var $t1: u64
  0: $t1 := 22
  1: $t0 := pack 0xc0ffee::m::S($t1)
  2: return $t0
}


[variant baseline]
fun n9::test_pack_unpack_struct_in_lambda() {
     var $t0: 0xc0ffee::m::S2
     var $t1: u64
     var $t2: 0xc0ffee::m::S
     var $t3: u64
     var $t4: u64
     var $t5: u64
     var $t6: 0xc0ffee::m::S
  0: $t1 := 22
  1: $t3 := 33
  2: $t2 := pack 0xc0ffee::m::S($t3)
  3: $t0 := pack 0xc0ffee::m::S2($t1, $t2)
  4: ($t4, $t6) := unpack 0xc0ffee::m::S2($t0)
  5: $t5 := unpack 0xc0ffee::m::S($t6)
  6: return ()
}


[variant baseline]
fun n_friend::test_pack_friend_struct(): 0xc0ffee::m_friend::T {
     var $t0: 0xc0ffee::m_friend::T
     var $t1: u64
  0: $t1 := 22
  1: $t0 := pack 0xc0ffee::m_friend::T($t1)
  2: return $t0
}

// -- Model dump before second bytecode pipeline
module 0xc0ffee::m {
    struct Empty {
        dummy_field: bool,
    }
    struct S {
        x: u64,
    }
    struct S2 {
        x: u64,
        s: S,
    }
    enum Wrapper {
        V1 {
            0: u64,
        }
        V2 {
            0: u64,
        }
    }
    public fun make(x: u64): Wrapper {
        pack m::Wrapper::V1(x)
    }
} // end 0xc0ffee::m
module 0xc0ffee::m_friend {
    struct T {
        x: u64,
    }
} // end 0xc0ffee::m_friend
module 0xc0ffee::n {
    use 0xc0ffee::m; // resolved as: 0xc0ffee::m
    private fun test() {
        {
          let x: m::Wrapper = m::make(22);
          if Eq<u64>(select_variants m::Wrapper.V1.0|m::Wrapper.V2.0<m::Wrapper>(x), 22) {
            Tuple()
          } else {
            Abort(1)
          };
          Tuple()
        }
    }
} // end 0xc0ffee::n
module 0xc0ffee::n2 {
    use 0xc0ffee::m::{Wrapper}; // resolved as: 0xc0ffee::m
    private fun test_pack() {
        {
          let _x: m::Wrapper = pack m::Wrapper::V1(22);
          Tuple()
        }
    }
} // end 0xc0ffee::n2
module 0xc0ffee::n3 {
    use 0xc0ffee::m::{Wrapper}; // resolved as: 0xc0ffee::m
    private fun test_unpack(w: m::Wrapper) {
        {
          let m::Wrapper::V1{ 0: _x } = w;
          Tuple()
        }
    }
} // end 0xc0ffee::n3
module 0xc0ffee::n4 {
    use 0xc0ffee::m::{Wrapper}; // resolved as: 0xc0ffee::m
    private fun test_select_variant(w: m::Wrapper): u64 {
        select_variants m::Wrapper.V1.0|m::Wrapper.V2.0<m::Wrapper>(w)
    }
} // end 0xc0ffee::n4
module 0xc0ffee::n5 {
    use 0xc0ffee::m::{Wrapper}; // resolved as: 0xc0ffee::m
    private fun test_test_variant(w: m::Wrapper): bool {
        test_variants m::Wrapper::V1(w)
    }
} // end 0xc0ffee::n5
module 0xc0ffee::n6 {
    use 0xc0ffee::m::{Wrapper}; // resolved as: 0xc0ffee::m
    private fun test_match(w: m::Wrapper): bool {
        match (w) {
          m::Wrapper::V1{ 0: _ } => {
            true
          }
          m::Wrapper::V2{ 0: _ } => {
            false
          }
        }

    }
} // end 0xc0ffee::n6
module 0xc0ffee::n7 {
    use 0xc0ffee::m::{S}; // resolved as: 0xc0ffee::m
    private fun test_pack_struct(): m::S {
        pack m::S(22)
    }
} // end 0xc0ffee::n7
module 0xc0ffee::n8 {
    use 0xc0ffee::m::{S}; // resolved as: 0xc0ffee::m
    private fun test_pack_struct(): m::S {
        pack m::S(22)
    }
    private inline fun test_pack_struct_inline(): m::S {
        pack m::S(22)
    }
} // end 0xc0ffee::n8
module 0xc0ffee::n9 {
    use 0xc0ffee::m::{S}; // resolved as: 0xc0ffee::m
    use 0xc0ffee::m::{S2}; // resolved as: 0xc0ffee::m
    private inline fun test_inline(x: ||) {
        (x)()
    }
    private fun test_pack_unpack_struct_in_lambda() {
        {
          let x: m::S2 = pack m::S2(22, pack m::S(33));
          {
            let m::S2{ x: _x, s: m::S{ x: _y } } = x;
            Tuple()
          }
        }
    }
} // end 0xc0ffee::n9
module 0xc0ffee::n_friend {
    use 0xc0ffee::m_friend::{T}; // resolved as: 0xc0ffee::m_friend
    private fun test_pack_friend_struct(): m_friend::T {
        pack m_friend::T(22)
    }
} // end 0xc0ffee::n_friend

============ bytecode before second stackless bytecode pipeline ================

[variant baseline]
public fun m::make($t0: u64): 0xc0ffee::m::Wrapper {
     var $t1: 0xc0ffee::m::Wrapper
  0: $t1 := pack_variant 0xc0ffee::m::Wrapper::V1($t0)
  1: return $t1
}


[variant baseline]
fun n::test() {
     var $t0: 0xc0ffee::m::Wrapper
     var $t1: u64
     var $t2: bool
     var $t3: u64
     var $t4: &0xc0ffee::m::Wrapper
     var $t5: &u64
     var $t6: u64
     var $t7: u64
  0: $t1 := 22
  1: $t0 := m::make($t1)
  2: $t4 := borrow_local($t0)
  3: $t5 := borrow_variant_field<0xc0ffee::m::Wrapper::V1|V2>.0($t4)
  4: $t3 := read_ref($t5)
  5: $t6 := 22
  6: $t2 := ==($t3, $t6)
  7: if ($t2) goto 8 else goto 10
  8: label L0
  9: goto 13
 10: label L1
 11: $t7 := 1
 12: abort($t7)
 13: label L2
 14: return ()
}


[variant baseline]
fun n2::test_pack() {
     var $t0: 0xc0ffee::m::Wrapper
     var $t1: u64
  0: $t1 := 22
  1: $t0 := pack_variant 0xc0ffee::m::Wrapper::V1($t1)
  2: return ()
}


[variant baseline]
fun n3::test_unpack($t0: 0xc0ffee::m::Wrapper) {
     var $t1: u64
  0: $t1 := unpack_variant 0xc0ffee::m::Wrapper::V1($t0)
  1: return ()
}


[variant baseline]
fun n4::test_select_variant($t0: 0xc0ffee::m::Wrapper): u64 {
     var $t1: u64
     var $t2: &0xc0ffee::m::Wrapper
     var $t3: &u64
  0: $t2 := borrow_local($t0)
  1: $t3 := borrow_variant_field<0xc0ffee::m::Wrapper::V1|V2>.0($t2)
  2: $t1 := read_ref($t3)
  3: return $t1
}


[variant baseline]
fun n5::test_test_variant($t0: 0xc0ffee::m::Wrapper): bool {
     var $t1: bool
     var $t2: &0xc0ffee::m::Wrapper
  0: $t2 := borrow_local($t0)
  1: $t1 := test_variant 0xc0ffee::m::Wrapper::V1($t2)
  2: return $t1
}


[variant baseline]
fun n6::test_match($t0: 0xc0ffee::m::Wrapper): bool {
     var $t1: bool
     var $t2: &0xc0ffee::m::Wrapper
     var $t3: bool
     var $t4: u64
     var $t5: u64
     var $t6: u64
  0: $t2 := borrow_local($t0)
  1: $t3 := test_variant 0xc0ffee::m::Wrapper::V1($t2)
  2: if ($t3) goto 3 else goto 7
  3: label L2
  4: $t4 := unpack_variant 0xc0ffee::m::Wrapper::V1($t0)
  5: $t1 := true
  6: goto 17
  7: label L1
  8: $t3 := test_variant 0xc0ffee::m::Wrapper::V2($t2)
  9: if ($t3) goto 10 else goto 14
 10: label L4
 11: $t5 := unpack_variant 0xc0ffee::m::Wrapper::V2($t0)
 12: $t1 := false
 13: goto 17
 14: label L3
 15: $t6 := 14566554180833181697
 16: abort($t6)
 17: label L0
 18: return $t1
}


[variant baseline]
fun n7::test_pack_struct(): 0xc0ffee::m::S {
     var $t0: 0xc0ffee::m::S
     var $t1: u64
  0: $t1 := 22
  1: $t0 := pack 0xc0ffee::m::S($t1)
  2: return $t0
}


[variant baseline]
fun n8::test_pack_struct(): 0xc0ffee::m::S {
     var $t0: 0xc0ffee::m::S
     var $t1: u64
  0: $t1 := 22
  1: $t0 := pack 0xc0ffee::m::S($t1)
  2: return $t0
}


[variant baseline]
fun n9::test_pack_unpack_struct_in_lambda() {
     var $t0: 0xc0ffee::m::S2
     var $t1: u64
     var $t2: 0xc0ffee::m::S
     var $t3: u64
     var $t4: u64
     var $t5: u64
     var $t6: 0xc0ffee::m::S
  0: $t1 := 22
  1: $t3 := 33
  2: $t2 := pack 0xc0ffee::m::S($t3)
  3: $t0 := pack 0xc0ffee::m::S2($t1, $t2)
  4: ($t4, $t6) := unpack 0xc0ffee::m::S2($t0)
  5: $t5 := unpack 0xc0ffee::m::S($t6)
  6: return ()
}


[variant baseline]
fun n_friend::test_pack_friend_struct(): 0xc0ffee::m_friend::T {
     var $t0: 0xc0ffee::m_friend::T
     var $t1: u64
  0: $t1 := 22
  1: $t0 := pack 0xc0ffee::m_friend::T($t1)
  2: return $t0
}


============ disassembled file-format ==================
// Bytecode version v10
module 0xc0ffee::m
friend 0xc0ffee::n
friend 0xc0ffee::n2
friend 0xc0ffee::n3
friend 0xc0ffee::n4
friend 0xc0ffee::n5
friend 0xc0ffee::n6
friend 0xc0ffee::n7
friend 0xc0ffee::n8
friend 0xc0ffee::n9
struct Empty
  dummy_field: bool

struct S
  x: u64

struct S2
  x: u64
  s: S

enum Wrapper has drop
  V1
    _0: u64
  V2
    _0: u64

// Function definition at index 0
#[pack] friend fun pack$Empty(l0: bool): Empty
    local l1: bool
    move_loc l0
    pack Empty
    ret

// Function definition at index 1
#[unpack] friend fun unpack$Empty(l0: Empty): bool
    local l1: Empty
    move_loc l0
    unpack Empty
    ret

// Function definition at index 2
#[pack] friend fun pack$S(l0: u64): S
    local l1: u64
    move_loc l0
    pack S
    ret

// Function definition at index 3
#[unpack] friend fun unpack$S(l0: S): u64
    local l1: S
    move_loc l0
    unpack S
    ret

// Function definition at index 4
#[borrow=0] friend fun borrow$S$0(l0: &S): &u64
    local l1: &S
    move_loc l0
    borrow_field S, x
    ret

// Function definition at index 5
#[borrow_mut=0] friend fun borrow_mut$S$0(l0: &mut S): &mut u64
    local l1: &mut S
    move_loc l0
    mut_borrow_field S, x
    ret

// Function definition at index 6
#[pack] friend fun pack$S2(l0: u64, l1: S): S2
    local l2: u64
    local l3: S
    move_loc l0
    move_loc l1
    pack S2
    ret

// Function definition at index 7
#[unpack] friend fun unpack$S2(l0: S2): (u64, S)
    local l1: S2
    move_loc l0
    unpack S2
    ret

// Function definition at index 8
#[borrow=0] friend fun borrow$S2$0(l0: &S2): &u64
    local l1: &S2
    move_loc l0
    borrow_field S2, x
    ret

// Function definition at index 9
#[borrow=1] friend fun borrow$S2$1(l0: &S2): &S
    local l1: &S2
    move_loc l0
    borrow_field S2, s
    ret

// Function definition at index 10
#[borrow_mut=0] friend fun borrow_mut$S2$0(l0: &mut S2): &mut u64
    local l1: &mut S2
    move_loc l0
    mut_borrow_field S2, x
    ret

// Function definition at index 11
#[borrow_mut=1] friend fun borrow_mut$S2$1(l0: &mut S2): &mut S
    local l1: &mut S2
    move_loc l0
    mut_borrow_field S2, s
    ret

// Function definition at index 12
#[test_variant=0] friend fun test_variant$Wrapper$V1(l0: &Wrapper): bool
    local l1: &Wrapper
    move_loc l0
    test_variant Wrapper, V1
    ret

// Function definition at index 13
#[test_variant=1] friend fun test_variant$Wrapper$V2(l0: &Wrapper): bool
    local l1: &Wrapper
    move_loc l0
    test_variant Wrapper, V2
    ret

// Function definition at index 14
#[pack_variant=0] friend fun pack$Wrapper$V1(l0: u64): Wrapper
    local l1: u64
    move_loc l0
    pack_variant Wrapper, V1
    ret

// Function definition at index 15
#[pack_variant=1] friend fun pack$Wrapper$V2(l0: u64): Wrapper
    local l1: u64
    move_loc l0
    pack_variant Wrapper, V2
    ret

// Function definition at index 16
#[unpack_variant=0] friend fun unpack$Wrapper$V1(l0: Wrapper): u64
    local l1: Wrapper
    move_loc l0
    unpack_variant Wrapper, V1
    ret

// Function definition at index 17
#[unpack_variant=1] friend fun unpack$Wrapper$V2(l0: Wrapper): u64
    local l1: Wrapper
    move_loc l0
    unpack_variant Wrapper, V2
    ret

// Function definition at index 18
#[borrow=0] friend fun borrow$Wrapper$0$0(l0: &Wrapper): &u64
    local l1: &Wrapper
    move_loc l0
    borrow_variant_field Wrapper, V1::_0, V2::_0
    ret

// Function definition at index 19
#[borrow_mut=0] friend fun borrow_mut$Wrapper$0$0(l0: &mut Wrapper): &mut u64
    local l1: &mut Wrapper
    move_loc l0
    mut_borrow_variant_field Wrapper, V1::_0, V2::_0
    ret

// Function definition at index 20
#[persistent] public fun make(l0: u64): Wrapper
    move_loc l0
    pack_variant Wrapper, V1
    ret

// Bytecode version v10
module 0xc0ffee::m_friend
friend 0xc0ffee::n_friend
struct T
  x: u64

// Function definition at index 0
#[pack] friend fun pack$T(l0: u64): T
    local l1: u64
    move_loc l0
    pack T
    ret

// Function definition at index 1
#[unpack] friend fun unpack$T(l0: T): u64
    local l1: T
    move_loc l0
    unpack T
    ret

// Function definition at index 2
#[borrow=0] friend fun borrow$T$0(l0: &T): &u64
    local l1: &T
    move_loc l0
    borrow_field T, x
    ret

// Function definition at index 3
#[borrow_mut=0] friend fun borrow_mut$T$0(l0: &mut T): &mut u64
    local l1: &mut T
    move_loc l0
    mut_borrow_field T, x
    ret

// Bytecode version v10
module 0xc0ffee::n
use 0xc0ffee::m
// Function definition at index 0
fun test()
    local l0: m::Wrapper
    ld_u64 22
    call m::make
    st_loc l0
    borrow_loc l0
    call m::borrow$Wrapper$0$0
    // @5
    read_ref
    ld_u64 22
    eq
    br_false l0
    ret
    // @10
l0: ld_u64 1
    abort

// Bytecode version v10
module 0xc0ffee::n2
use 0xc0ffee::m
// Function definition at index 0
fun test_pack()
    ld_u64 22
    call m::pack$Wrapper$V1
    pop
    ret

// Bytecode version v10
module 0xc0ffee::n3
use 0xc0ffee::m
// Function definition at index 0
fun test_unpack(l0: m::Wrapper)
    move_loc l0
    call m::unpack$Wrapper$V1
    pop
    ret

// Bytecode version v10
module 0xc0ffee::n4
use 0xc0ffee::m
// Function definition at index 0
fun test_select_variant(l0: m::Wrapper): u64
    borrow_loc l0
    call m::borrow$Wrapper$0$0
    read_ref
    ret

// Bytecode version v10
module 0xc0ffee::n5
use 0xc0ffee::m
// Function definition at index 0
fun test_test_variant(l0: m::Wrapper): bool
    borrow_loc l0
    call m::test_variant$Wrapper$V1
    ret

// Bytecode version v10
module 0xc0ffee::n6
use 0xc0ffee::m
// Function definition at index 0
fun test_match(l0: m::Wrapper): bool
    local l1: &m::Wrapper
    borrow_loc l0
    st_loc l1
    copy_loc l1
    call m::test_variant$Wrapper$V1
    br_false l0
    // @5
    move_loc l1
    pop
    move_loc l0
    call m::unpack$Wrapper$V1
    pop
    // @10
    ld_true
    ret
l0: move_loc l1
    call m::test_variant$Wrapper$V2
    br_false l1
    // @15
    move_loc l0
    call m::unpack$Wrapper$V2
    pop
    ld_false
    ret
    // @20
l1: ld_u64 14566554180833181697
    abort

// Bytecode version v10
module 0xc0ffee::n7
use 0xc0ffee::m
// Function definition at index 0
fun test_pack_struct(): m::S
    ld_u64 22
    call m::pack$S
    ret

// Bytecode version v10
module 0xc0ffee::n8
use 0xc0ffee::m
// Function definition at index 0
fun test_pack_struct(): m::S
    ld_u64 22
    call m::pack$S
    ret

// Bytecode version v10
module 0xc0ffee::n9
use 0xc0ffee::m
// Function definition at index 0
fun test_pack_unpack_struct_in_lambda()
    ld_u64 22
    ld_u64 33
    call m::pack$S
    call m::pack$S2
    call m::unpack$S2
    // @5
    call m::unpack$S
    pop
    pop
    ret

// Bytecode version v10
module 0xc0ffee::n_friend
use 0xc0ffee::m_friend
// Function definition at index 0
fun test_pack_friend_struct(): m_friend::T
    ld_u64 22
    call m_friend::pack$T
    ret


============ bytecode verification succeeded ========
