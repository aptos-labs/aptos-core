// -- Model dump before first bytecode pipeline
module 0x42::valid_fv {
    enum E1 {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<i64>,
        }
    }
    enum E2 {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<i128>,
        }
    }
    enum E3<T> {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<T>,
        }
    }
    struct S1 {
        x: u64,
        y: i64,
        z: i128,
    }
    struct S2 {
        x: S1,
        y: i64,
        z: i128,
    }
    struct S3<T> {
        x: T,
        y: S1,
        z: S2,
    }
    private fun test1(fv1: |i64|i64 has copy + drop,x: i64): i64 {
        {
          let fv2: |i64|i64 has copy + drop = closure#0valid_fv::__lambda__1__test1();
          (fv1)(x)
        }
    }
    private fun test10(fv: |E2|i64 has copy + drop,a: i64,b: i128): i64 {
        {
          let s1: S1 = pack valid_fv::S1(1, -1, -2);
          {
            let s2: S2 = pack valid_fv::S2(s1, -1, -2);
            {
              let e: E2 = pack valid_fv::E2::V2(s2);
              (fv)(e)
            }
          }
        }
    }
    private fun test11(fv: |E3<i64>|i64 has copy + drop,a: i64,b: i128): i64 {
        {
          let s1: S1 = pack valid_fv::S1(1, -1, -2);
          {
            let s2: S2 = pack valid_fv::S2(s1, -1, -2);
            {
              let s3: S3<i64> = pack valid_fv::S3<i64>(-1, s1, s2);
              {
                let e: E3<i64> = pack valid_fv::E3::V3<i64>(s3);
                (fv)(e)
              }
            }
          }
        }
    }
    private fun test12(fv: |E3<i128>|i64 has copy + drop,a: i64,b: i128): i64 {
        {
          let s1: S1 = pack valid_fv::S1(1, -1, -2);
          {
            let s2: S2 = pack valid_fv::S2(s1, -1, -2);
            {
              let s3: S3<i128> = pack valid_fv::S3<i128>(-1, s1, s2);
              {
                let e: E3<i128> = pack valid_fv::E3::V3<i128>(s3);
                (fv)(e)
              }
            }
          }
        }
    }
    private fun test2(fv1: |i128|i128 has copy + drop,x: i128): i128 {
        {
          let fv2: |i128|i128 has copy + drop = closure#0valid_fv::__lambda__1__test2();
          (fv1)(x)
        }
    }
    private fun test3(fv1: ||i64|i64|i64 has copy + drop,x: i64): i64 {
        (fv1)(closure#0valid_fv::test_64())
    }
    private fun test4(fv1: ||i128|i128|i128 has copy + drop,x: i128): i128 {
        (fv1)(closure#0valid_fv::test_128())
    }
    private fun test5(fv: |S1|i64 has copy + drop,a: i64,b: i128): i64 {
        {
          let s1: S1 = pack valid_fv::S1(1, a, b);
          (fv)(s1)
        }
    }
    private fun test6(fv: |S2|i64 has copy + drop,a: i64,b: i128): i64 {
        {
          let s1: S1 = pack valid_fv::S1(1, a, b);
          {
            let s2: S2 = pack valid_fv::S2(s1, a, b);
            (fv)(s2)
          }
        }
    }
    private fun test7(fv: |S3<i64>|i64 has copy + drop,a: i64,b: i128): i64 {
        {
          let s1: S1 = pack valid_fv::S1(1, a, b);
          {
            let s2: S2 = pack valid_fv::S2(s1, a, b);
            {
              let s3: S3<i64> = pack valid_fv::S3<i64>(a, s1, s2);
              (fv)(s3)
            }
          }
        }
    }
    private fun test8(fv: |S3<i128>|i64 has copy + drop,a: i64,b: i128): i64 {
        {
          let s1: S1 = pack valid_fv::S1(1, a, b);
          {
            let s2: S2 = pack valid_fv::S2(s1, a, b);
            {
              let s3: S3<i128> = pack valid_fv::S3<i128>(b, s1, s2);
              (fv)(s3)
            }
          }
        }
    }
    private fun test9(fv: |E1|i64 has copy + drop,a: i64,b: i128): i64 {
        {
          let s1: S1 = pack valid_fv::S1(1, -1, -2);
          {
            let e: E1 = pack valid_fv::E1::V1(s1);
            (fv)(e)
          }
        }
    }
    private fun test_128(x: i128): i128 {
        Add<i128>(x, x)
    }
    private fun test_64(x: i64): i64 {
        Add<i64>(x, x)
    }
    private fun __lambda__1__test1(x: i64): i64 {
        Mul<i64>(x, x)
    }
    private fun __lambda__1__test2(x: i128): i128 {
        Mul<i128>(x, x)
    }
} // end 0x42::valid_fv

// -- Sourcified model before first bytecode pipeline
module 0x42::valid_fv {
    enum E1 has copy, drop {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<i64>,
        }
    }
    enum E2 has copy, drop {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<i128>,
        }
    }
    enum E3<T> has copy, drop {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<T>,
        }
    }
    struct S1 has copy, drop {
        x: u64,
        y: i64,
        z: i128,
    }
    struct S2 has copy, drop {
        x: S1,
        y: i64,
        z: i128,
    }
    struct S3<T> has copy, drop {
        x: T,
        y: S1,
        z: S2,
    }
    fun test1(fv1: |i64|i64 has copy + drop, x: i64): i64 {
        let fv2: |i64|i64 has copy + drop = |arg0| lambda__1__test1(arg0);
        fv1(x)
    }
    fun test10(fv: |E2|i64 has copy + drop, a: i64, b: i128): i64 {
        let s1 = S1{x: 1, y: -1i64, z: -2i128};
        let s2 = S2{x: s1, y: -1i64, z: -2i128};
        let e = E2::V2{s: s2};
        fv(e)
    }
    fun test11(fv: |E3<i64>|i64 has copy + drop, a: i64, b: i128): i64 {
        let s1 = S1{x: 1, y: -1i64, z: -2i128};
        let s2 = S2{x: s1, y: -1i64, z: -2i128};
        let s3 = S3<i64>{x: -1i64, y: s1, z: s2};
        let e = E3::V3<i64>{s: s3};
        fv(e)
    }
    fun test12(fv: |E3<i128>|i64 has copy + drop, a: i64, b: i128): i64 {
        let s1 = S1{x: 1, y: -1i64, z: -2i128};
        let s2 = S2{x: s1, y: -1i64, z: -2i128};
        let s3 = S3<i128>{x: -1i128, y: s1, z: s2};
        let e = E3::V3<i128>{s: s3};
        fv(e)
    }
    fun test2(fv1: |i128|i128 has copy + drop, x: i128): i128 {
        let fv2: |i128|i128 has copy + drop = |arg0| lambda__1__test2(arg0);
        fv1(x)
    }
    fun test3(fv1: ||i64|i64|i64 has copy + drop, x: i64): i64 {
        fv1(|arg0| test_64(arg0))
    }
    fun test4(fv1: ||i128|i128|i128 has copy + drop, x: i128): i128 {
        fv1(|arg0| test_128(arg0))
    }
    fun test5(fv: |S1|i64 has copy + drop, a: i64, b: i128): i64 {
        let s1 = S1{x: 1, y: a, z: b};
        fv(s1)
    }
    fun test6(fv: |S2|i64 has copy + drop, a: i64, b: i128): i64 {
        let s1 = S1{x: 1, y: a, z: b};
        let s2 = S2{x: s1, y: a, z: b};
        fv(s2)
    }
    fun test7(fv: |S3<i64>|i64 has copy + drop, a: i64, b: i128): i64 {
        let s1 = S1{x: 1, y: a, z: b};
        let s2 = S2{x: s1, y: a, z: b};
        let s3 = S3<i64>{x: a, y: s1, z: s2};
        fv(s3)
    }
    fun test8(fv: |S3<i128>|i64 has copy + drop, a: i64, b: i128): i64 {
        let s1 = S1{x: 1, y: a, z: b};
        let s2 = S2{x: s1, y: a, z: b};
        let s3 = S3<i128>{x: b, y: s1, z: s2};
        fv(s3)
    }
    fun test9(fv: |E1|i64 has copy + drop, a: i64, b: i128): i64 {
        let s1 = S1{x: 1, y: -1i64, z: -2i128};
        let e = E1::V1{s: s1};
        fv(e)
    }
    fun test_128(x: i128): i128 {
        x + x
    }
    fun test_64(x: i64): i64 {
        x + x
    }
    fun lambda__1__test1(x: i64): i64 {
        x * x
    }
    fun lambda__1__test2(x: i128): i128 {
        x * x
    }
}

============ bytecode before first stackless bytecode pipeline ================

[variant baseline]
fun valid_fv::test1($t0: |i64|i64 has copy + drop, $t1: i64): i64 {
     var $t2: i64
     var $t3: |i64|i64 has copy + drop
  0: $t3 := closure#0 valid_fv::__lambda__1__test1()
  1: $t2 := invoke($t1, $t0)
  2: return $t2
}


[variant baseline]
fun valid_fv::test10($t0: |0x42::valid_fv::E2|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     var $t7: i128
     var $t8: 0x42::valid_fv::S2
     var $t9: 0x42::valid_fv::S1
     var $t10: i64
     var $t11: i128
     var $t12: 0x42::valid_fv::E2
  0: $t5 := 1
  1: $t6 := -1
  2: $t7 := -2
  3: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t7)
  4: $t9 := infer($t4)
  5: $t10 := -1
  6: $t11 := -2
  7: $t8 := pack 0x42::valid_fv::S2($t9, $t10, $t11)
  8: $t12 := pack_variant 0x42::valid_fv::E2::V2($t8)
  9: $t3 := invoke($t12, $t0)
 10: return $t3
}


[variant baseline]
fun valid_fv::test11($t0: |0x42::valid_fv::E3<i64>|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     var $t7: i128
     var $t8: 0x42::valid_fv::S2
     var $t9: 0x42::valid_fv::S1
     var $t10: i64
     var $t11: i128
     var $t12: 0x42::valid_fv::S3<i64>
     var $t13: i64
     var $t14: 0x42::valid_fv::S1
     var $t15: 0x42::valid_fv::E3<i64>
  0: $t5 := 1
  1: $t6 := -1
  2: $t7 := -2
  3: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t7)
  4: $t9 := infer($t4)
  5: $t10 := -1
  6: $t11 := -2
  7: $t8 := pack 0x42::valid_fv::S2($t9, $t10, $t11)
  8: $t13 := -1
  9: $t14 := infer($t4)
 10: $t12 := pack 0x42::valid_fv::S3<i64>($t13, $t14, $t8)
 11: $t15 := pack_variant 0x42::valid_fv::E3<i64>::V3($t12)
 12: $t3 := invoke($t15, $t0)
 13: return $t3
}


[variant baseline]
fun valid_fv::test12($t0: |0x42::valid_fv::E3<i128>|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     var $t7: i128
     var $t8: 0x42::valid_fv::S2
     var $t9: 0x42::valid_fv::S1
     var $t10: i64
     var $t11: i128
     var $t12: 0x42::valid_fv::S3<i128>
     var $t13: i128
     var $t14: 0x42::valid_fv::S1
     var $t15: 0x42::valid_fv::E3<i128>
  0: $t5 := 1
  1: $t6 := -1
  2: $t7 := -2
  3: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t7)
  4: $t9 := infer($t4)
  5: $t10 := -1
  6: $t11 := -2
  7: $t8 := pack 0x42::valid_fv::S2($t9, $t10, $t11)
  8: $t13 := -1
  9: $t14 := infer($t4)
 10: $t12 := pack 0x42::valid_fv::S3<i128>($t13, $t14, $t8)
 11: $t15 := pack_variant 0x42::valid_fv::E3<i128>::V3($t12)
 12: $t3 := invoke($t15, $t0)
 13: return $t3
}


[variant baseline]
fun valid_fv::test2($t0: |i128|i128 has copy + drop, $t1: i128): i128 {
     var $t2: i128
     var $t3: |i128|i128 has copy + drop
  0: $t3 := closure#0 valid_fv::__lambda__1__test2()
  1: $t2 := invoke($t1, $t0)
  2: return $t2
}


[variant baseline]
fun valid_fv::test3($t0: ||i64|i64|i64 has copy + drop, $t1: i64): i64 {
     var $t2: i64
     var $t3: |i64|i64
  0: $t3 := closure#0 valid_fv::test_64()
  1: $t2 := invoke($t3, $t0)
  2: return $t2
}


[variant baseline]
fun valid_fv::test4($t0: ||i128|i128|i128 has copy + drop, $t1: i128): i128 {
     var $t2: i128
     var $t3: |i128|i128
  0: $t3 := closure#0 valid_fv::test_128()
  1: $t2 := invoke($t3, $t0)
  2: return $t2
}


[variant baseline]
fun valid_fv::test5($t0: |0x42::valid_fv::S1|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
  0: $t5 := 1
  1: $t6 := infer($t1)
  2: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t2)
  3: $t3 := invoke($t4, $t0)
  4: return $t3
}


[variant baseline]
fun valid_fv::test6($t0: |0x42::valid_fv::S2|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     var $t7: 0x42::valid_fv::S2
     var $t8: 0x42::valid_fv::S1
     var $t9: i64
  0: $t5 := 1
  1: $t6 := infer($t1)
  2: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t2)
  3: $t8 := infer($t4)
  4: $t9 := infer($t1)
  5: $t7 := pack 0x42::valid_fv::S2($t8, $t9, $t2)
  6: $t3 := invoke($t7, $t0)
  7: return $t3
}


[variant baseline]
fun valid_fv::test7($t0: |0x42::valid_fv::S3<i64>|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     var $t7: 0x42::valid_fv::S2
     var $t8: 0x42::valid_fv::S1
     var $t9: i64
     var $t10: 0x42::valid_fv::S3<i64>
     var $t11: i64
     var $t12: 0x42::valid_fv::S1
  0: $t5 := 1
  1: $t6 := infer($t1)
  2: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t2)
  3: $t8 := infer($t4)
  4: $t9 := infer($t1)
  5: $t7 := pack 0x42::valid_fv::S2($t8, $t9, $t2)
  6: $t11 := infer($t1)
  7: $t12 := infer($t4)
  8: $t10 := pack 0x42::valid_fv::S3<i64>($t11, $t12, $t7)
  9: $t3 := invoke($t10, $t0)
 10: return $t3
}


[variant baseline]
fun valid_fv::test8($t0: |0x42::valid_fv::S3<i128>|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     var $t7: 0x42::valid_fv::S2
     var $t8: 0x42::valid_fv::S1
     var $t9: i64
     var $t10: 0x42::valid_fv::S3<i128>
     var $t11: i128
     var $t12: 0x42::valid_fv::S1
  0: $t5 := 1
  1: $t6 := infer($t1)
  2: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t2)
  3: $t8 := infer($t4)
  4: $t9 := infer($t1)
  5: $t7 := pack 0x42::valid_fv::S2($t8, $t9, $t2)
  6: $t11 := infer($t2)
  7: $t12 := infer($t4)
  8: $t10 := pack 0x42::valid_fv::S3<i128>($t11, $t12, $t7)
  9: $t3 := invoke($t10, $t0)
 10: return $t3
}


[variant baseline]
fun valid_fv::test9($t0: |0x42::valid_fv::E1|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     var $t7: i128
     var $t8: 0x42::valid_fv::E1
  0: $t5 := 1
  1: $t6 := -1
  2: $t7 := -2
  3: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t7)
  4: $t8 := pack_variant 0x42::valid_fv::E1::V1($t4)
  5: $t3 := invoke($t8, $t0)
  6: return $t3
}


[variant baseline]
fun valid_fv::test_128($t0: i128): i128 {
     var $t1: i128
     var $t2: i128
  0: $t2 := infer($t0)
  1: $t1 := +($t2, $t0)
  2: return $t1
}


[variant baseline]
fun valid_fv::test_64($t0: i64): i64 {
     var $t1: i64
     var $t2: i64
  0: $t2 := infer($t0)
  1: $t1 := +($t2, $t0)
  2: return $t1
}


[variant baseline]
fun valid_fv::__lambda__1__test1($t0: i64): i64 {
     var $t1: i64
     var $t2: i64
  0: $t2 := infer($t0)
  1: $t1 := *($t2, $t0)
  2: return $t1
}


[variant baseline]
fun valid_fv::__lambda__1__test2($t0: i128): i128 {
     var $t1: i128
     var $t2: i128
  0: $t2 := infer($t0)
  1: $t1 := *($t2, $t0)
  2: return $t1
}


Diagnostics:
warning: This assignment/binding to the left-hand-side variable `fv2` is unused. Consider removing this assignment/binding, or prefixing the left-hand-side variable with an underscore (e.g., `_fv2`), or renaming to `_`
   ┌─ tests/integers/signed/valid_func_val.move:35:44
   │
35 │         let fv2: |i64| i64 has copy+drop = |x| x * x; // function value involving i64
   │                                            ^^^^^^^^^

warning: This assignment/binding to the left-hand-side variable `fv2` is unused. Consider removing this assignment/binding, or prefixing the left-hand-side variable with an underscore (e.g., `_fv2`), or renaming to `_`
   ┌─ tests/integers/signed/valid_func_val.move:40:46
   │
40 │         let fv2: |i128| i128 has copy+drop = |x| x * x;
   │                                              ^^^^^^^^^

warning: Unused value of parameter `x`. Consider removing the parameter, or prefixing with an underscore (e.g., `_x`), or binding to `_`
   ┌─ tests/integers/signed/valid_func_val.move:44:52
   │
44 │     fun test3(fv1: |(|i64|i64)| i64 has copy+drop, x: i64) : i64 { // function value involving nested function value with i64
   │                                                    ^

warning: Unused value of parameter `x`. Consider removing the parameter, or prefixing with an underscore (e.g., `_x`), or binding to `_`
   ┌─ tests/integers/signed/valid_func_val.move:48:55
   │
48 │     fun test4(fv1: |(|i128|i128)| i128 has copy+drop, x: i128) : i128 { // function value involving nested function value with i128
   │                                                       ^

warning: Unused value of parameter `a`. Consider removing the parameter, or prefixing with an underscore (e.g., `_a`), or binding to `_`
   ┌─ tests/integers/signed/valid_func_val.move:77:43
   │
77 │     fun test9(fv: |E1| i64 has copy+drop, a: i64, b: i128) : i64 {
   │                                           ^

warning: Unused value of parameter `b`. Consider removing the parameter, or prefixing with an underscore (e.g., `_b`), or binding to `_`
   ┌─ tests/integers/signed/valid_func_val.move:77:51
   │
77 │     fun test9(fv: |E1| i64 has copy+drop, a: i64, b: i128) : i64 {
   │                                                   ^

warning: Unused value of parameter `a`. Consider removing the parameter, or prefixing with an underscore (e.g., `_a`), or binding to `_`
   ┌─ tests/integers/signed/valid_func_val.move:83:44
   │
83 │     fun test10(fv: |E2| i64 has copy+drop, a: i64, b: i128) : i64 {
   │                                            ^

warning: Unused value of parameter `b`. Consider removing the parameter, or prefixing with an underscore (e.g., `_b`), or binding to `_`
   ┌─ tests/integers/signed/valid_func_val.move:83:52
   │
83 │     fun test10(fv: |E2| i64 has copy+drop, a: i64, b: i128) : i64 {
   │                                                    ^

warning: Unused value of parameter `a`. Consider removing the parameter, or prefixing with an underscore (e.g., `_a`), or binding to `_`
   ┌─ tests/integers/signed/valid_func_val.move:90:49
   │
90 │     fun test11(fv: |E3<i64>| i64 has copy+drop, a: i64, b: i128) : i64 {
   │                                                 ^

warning: Unused value of parameter `b`. Consider removing the parameter, or prefixing with an underscore (e.g., `_b`), or binding to `_`
   ┌─ tests/integers/signed/valid_func_val.move:90:57
   │
90 │     fun test11(fv: |E3<i64>| i64 has copy+drop, a: i64, b: i128) : i64 {
   │                                                         ^

warning: Unused value of parameter `a`. Consider removing the parameter, or prefixing with an underscore (e.g., `_a`), or binding to `_`
   ┌─ tests/integers/signed/valid_func_val.move:98:50
   │
98 │     fun test12(fv: |E3<i128>| i64 has copy+drop, a: i64, b: i128) : i64 {
   │                                                  ^

warning: Unused value of parameter `b`. Consider removing the parameter, or prefixing with an underscore (e.g., `_b`), or binding to `_`
   ┌─ tests/integers/signed/valid_func_val.move:98:58
   │
98 │     fun test12(fv: |E3<i128>| i64 has copy+drop, a: i64, b: i128) : i64 {
   │                                                          ^

============ after AbortAnalysisProcessor: ================

[variant baseline]
fun valid_fv::test1($t0: |i64|i64 has copy + drop, $t1: i64): i64 {
     var $t2: i64
     var $t3: |i64|i64 has copy + drop
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := closure#0 valid_fv::__lambda__1__test1()
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  1: $t2 := invoke($t1, $t0)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
fun valid_fv::test10($t0: |0x42::valid_fv::E2|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     var $t7: i128
     var $t8: 0x42::valid_fv::S2
     var $t9: 0x42::valid_fv::S1
     var $t10: i64
     var $t11: i128
     var $t12: 0x42::valid_fv::E2
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
  0: $t5 := 1
     # abort state: {returns,aborts}
     # live vars: $t0, $t5
     # refs: []
     #
  1: $t6 := -1
     # abort state: {returns,aborts}
     # live vars: $t0, $t5, $t6
     # refs: []
     #
  2: $t7 := -2
     # abort state: {returns,aborts}
     # live vars: $t0, $t5, $t6, $t7
     # refs: []
     #
  3: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t7)
     # abort state: {returns,aborts}
     # live vars: $t0, $t4
     # refs: []
     #
  4: $t9 := infer($t4)
     # abort state: {returns,aborts}
     # live vars: $t0, $t9
     # refs: []
     #
  5: $t10 := -1
     # abort state: {returns,aborts}
     # live vars: $t0, $t9, $t10
     # refs: []
     #
  6: $t11 := -2
     # abort state: {returns,aborts}
     # live vars: $t0, $t9, $t10, $t11
     # refs: []
     #
  7: $t8 := pack 0x42::valid_fv::S2($t9, $t10, $t11)
     # abort state: {returns,aborts}
     # live vars: $t0, $t8
     # refs: []
     #
  8: $t12 := pack_variant 0x42::valid_fv::E2::V2($t8)
     # abort state: {returns,aborts}
     # live vars: $t0, $t12
     # refs: []
     #
  9: $t3 := invoke($t12, $t0)
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 10: return $t3
}


[variant baseline]
fun valid_fv::test11($t0: |0x42::valid_fv::E3<i64>|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     var $t7: i128
     var $t8: 0x42::valid_fv::S2
     var $t9: 0x42::valid_fv::S1
     var $t10: i64
     var $t11: i128
     var $t12: 0x42::valid_fv::S3<i64>
     var $t13: i64
     var $t14: 0x42::valid_fv::S1
     var $t15: 0x42::valid_fv::E3<i64>
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
  0: $t5 := 1
     # abort state: {returns,aborts}
     # live vars: $t0, $t5
     # refs: []
     #
  1: $t6 := -1
     # abort state: {returns,aborts}
     # live vars: $t0, $t5, $t6
     # refs: []
     #
  2: $t7 := -2
     # abort state: {returns,aborts}
     # live vars: $t0, $t5, $t6, $t7
     # refs: []
     #
  3: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t7)
     # abort state: {returns,aborts}
     # live vars: $t0, $t4
     # refs: []
     #
  4: $t9 := infer($t4)
     # abort state: {returns,aborts}
     # live vars: $t0, $t4, $t9
     # refs: []
     #
  5: $t10 := -1
     # abort state: {returns,aborts}
     # live vars: $t0, $t4, $t9, $t10
     # refs: []
     #
  6: $t11 := -2
     # abort state: {returns,aborts}
     # live vars: $t0, $t4, $t9, $t10, $t11
     # refs: []
     #
  7: $t8 := pack 0x42::valid_fv::S2($t9, $t10, $t11)
     # abort state: {returns,aborts}
     # live vars: $t0, $t4, $t8
     # refs: []
     #
  8: $t13 := -1
     # abort state: {returns,aborts}
     # live vars: $t0, $t4, $t8, $t13
     # refs: []
     #
  9: $t14 := infer($t4)
     # abort state: {returns,aborts}
     # live vars: $t0, $t8, $t13, $t14
     # refs: []
     #
 10: $t12 := pack 0x42::valid_fv::S3<i64>($t13, $t14, $t8)
     # abort state: {returns,aborts}
     # live vars: $t0, $t12
     # refs: []
     #
 11: $t15 := pack_variant 0x42::valid_fv::E3<i64>::V3($t12)
     # abort state: {returns,aborts}
     # live vars: $t0, $t15
     # refs: []
     #
 12: $t3 := invoke($t15, $t0)
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 13: return $t3
}


[variant baseline]
fun valid_fv::test12($t0: |0x42::valid_fv::E3<i128>|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     var $t7: i128
     var $t8: 0x42::valid_fv::S2
     var $t9: 0x42::valid_fv::S1
     var $t10: i64
     var $t11: i128
     var $t12: 0x42::valid_fv::S3<i128>
     var $t13: i128
     var $t14: 0x42::valid_fv::S1
     var $t15: 0x42::valid_fv::E3<i128>
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
  0: $t5 := 1
     # abort state: {returns,aborts}
     # live vars: $t0, $t5
     # refs: []
     #
  1: $t6 := -1
     # abort state: {returns,aborts}
     # live vars: $t0, $t5, $t6
     # refs: []
     #
  2: $t7 := -2
     # abort state: {returns,aborts}
     # live vars: $t0, $t5, $t6, $t7
     # refs: []
     #
  3: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t7)
     # abort state: {returns,aborts}
     # live vars: $t0, $t4
     # refs: []
     #
  4: $t9 := infer($t4)
     # abort state: {returns,aborts}
     # live vars: $t0, $t4, $t9
     # refs: []
     #
  5: $t10 := -1
     # abort state: {returns,aborts}
     # live vars: $t0, $t4, $t9, $t10
     # refs: []
     #
  6: $t11 := -2
     # abort state: {returns,aborts}
     # live vars: $t0, $t4, $t9, $t10, $t11
     # refs: []
     #
  7: $t8 := pack 0x42::valid_fv::S2($t9, $t10, $t11)
     # abort state: {returns,aborts}
     # live vars: $t0, $t4, $t8
     # refs: []
     #
  8: $t13 := -1
     # abort state: {returns,aborts}
     # live vars: $t0, $t4, $t8, $t13
     # refs: []
     #
  9: $t14 := infer($t4)
     # abort state: {returns,aborts}
     # live vars: $t0, $t8, $t13, $t14
     # refs: []
     #
 10: $t12 := pack 0x42::valid_fv::S3<i128>($t13, $t14, $t8)
     # abort state: {returns,aborts}
     # live vars: $t0, $t12
     # refs: []
     #
 11: $t15 := pack_variant 0x42::valid_fv::E3<i128>::V3($t12)
     # abort state: {returns,aborts}
     # live vars: $t0, $t15
     # refs: []
     #
 12: $t3 := invoke($t15, $t0)
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 13: return $t3
}


[variant baseline]
fun valid_fv::test2($t0: |i128|i128 has copy + drop, $t1: i128): i128 {
     var $t2: i128
     var $t3: |i128|i128 has copy + drop
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := closure#0 valid_fv::__lambda__1__test2()
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  1: $t2 := invoke($t1, $t0)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
fun valid_fv::test3($t0: ||i64|i64|i64 has copy + drop, $t1: i64): i64 {
     var $t2: i64
     var $t3: |i64|i64
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := closure#0 valid_fv::test_64()
     # abort state: {returns,aborts}
     # live vars: $t0, $t3
     # refs: []
     #
  1: $t2 := invoke($t3, $t0)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
fun valid_fv::test4($t0: ||i128|i128|i128 has copy + drop, $t1: i128): i128 {
     var $t2: i128
     var $t3: |i128|i128
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := closure#0 valid_fv::test_128()
     # abort state: {returns,aborts}
     # live vars: $t0, $t3
     # refs: []
     #
  1: $t2 := invoke($t3, $t0)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
fun valid_fv::test5($t0: |0x42::valid_fv::S1|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
  0: $t5 := 1
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t5
     # refs: []
     #
  1: $t6 := infer($t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t2, $t5, $t6
     # refs: []
     #
  2: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t2)
     # abort state: {returns,aborts}
     # live vars: $t0, $t4
     # refs: []
     #
  3: $t3 := invoke($t4, $t0)
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
  4: return $t3
}


[variant baseline]
fun valid_fv::test6($t0: |0x42::valid_fv::S2|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     var $t7: 0x42::valid_fv::S2
     var $t8: 0x42::valid_fv::S1
     var $t9: i64
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
  0: $t5 := 1
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t5
     # refs: []
     #
  1: $t6 := infer($t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t5, $t6
     # refs: []
     #
  2: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t2)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t4
     # refs: []
     #
  3: $t8 := infer($t4)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t8
     # refs: []
     #
  4: $t9 := infer($t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t2, $t8, $t9
     # refs: []
     #
  5: $t7 := pack 0x42::valid_fv::S2($t8, $t9, $t2)
     # abort state: {returns,aborts}
     # live vars: $t0, $t7
     # refs: []
     #
  6: $t3 := invoke($t7, $t0)
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
  7: return $t3
}


[variant baseline]
fun valid_fv::test7($t0: |0x42::valid_fv::S3<i64>|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     var $t7: 0x42::valid_fv::S2
     var $t8: 0x42::valid_fv::S1
     var $t9: i64
     var $t10: 0x42::valid_fv::S3<i64>
     var $t11: i64
     var $t12: 0x42::valid_fv::S1
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
  0: $t5 := 1
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t5
     # refs: []
     #
  1: $t6 := infer($t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t5, $t6
     # refs: []
     #
  2: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t2)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t4
     # refs: []
     #
  3: $t8 := infer($t4)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t4, $t8
     # refs: []
     #
  4: $t9 := infer($t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t4, $t8, $t9
     # refs: []
     #
  5: $t7 := pack 0x42::valid_fv::S2($t8, $t9, $t2)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t7
     # refs: []
     #
  6: $t11 := infer($t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t4, $t7, $t11
     # refs: []
     #
  7: $t12 := infer($t4)
     # abort state: {returns,aborts}
     # live vars: $t0, $t7, $t11, $t12
     # refs: []
     #
  8: $t10 := pack 0x42::valid_fv::S3<i64>($t11, $t12, $t7)
     # abort state: {returns,aborts}
     # live vars: $t0, $t10
     # refs: []
     #
  9: $t3 := invoke($t10, $t0)
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 10: return $t3
}


[variant baseline]
fun valid_fv::test8($t0: |0x42::valid_fv::S3<i128>|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     var $t7: 0x42::valid_fv::S2
     var $t8: 0x42::valid_fv::S1
     var $t9: i64
     var $t10: 0x42::valid_fv::S3<i128>
     var $t11: i128
     var $t12: 0x42::valid_fv::S1
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
  0: $t5 := 1
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t5
     # refs: []
     #
  1: $t6 := infer($t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t5, $t6
     # refs: []
     #
  2: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t2)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t4
     # refs: []
     #
  3: $t8 := infer($t4)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2, $t4, $t8
     # refs: []
     #
  4: $t9 := infer($t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t2, $t4, $t8, $t9
     # refs: []
     #
  5: $t7 := pack 0x42::valid_fv::S2($t8, $t9, $t2)
     # abort state: {returns,aborts}
     # live vars: $t0, $t2, $t4, $t7
     # refs: []
     #
  6: $t11 := infer($t2)
     # abort state: {returns,aborts}
     # live vars: $t0, $t4, $t7, $t11
     # refs: []
     #
  7: $t12 := infer($t4)
     # abort state: {returns,aborts}
     # live vars: $t0, $t7, $t11, $t12
     # refs: []
     #
  8: $t10 := pack 0x42::valid_fv::S3<i128>($t11, $t12, $t7)
     # abort state: {returns,aborts}
     # live vars: $t0, $t10
     # refs: []
     #
  9: $t3 := invoke($t10, $t0)
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 10: return $t3
}


[variant baseline]
fun valid_fv::test9($t0: |0x42::valid_fv::E1|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     var $t7: i128
     var $t8: 0x42::valid_fv::E1
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
  0: $t5 := 1
     # abort state: {returns,aborts}
     # live vars: $t0, $t5
     # refs: []
     #
  1: $t6 := -1
     # abort state: {returns,aborts}
     # live vars: $t0, $t5, $t6
     # refs: []
     #
  2: $t7 := -2
     # abort state: {returns,aborts}
     # live vars: $t0, $t5, $t6, $t7
     # refs: []
     #
  3: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t7)
     # abort state: {returns,aborts}
     # live vars: $t0, $t4
     # refs: []
     #
  4: $t8 := pack_variant 0x42::valid_fv::E1::V1($t4)
     # abort state: {returns,aborts}
     # live vars: $t0, $t8
     # refs: []
     #
  5: $t3 := invoke($t8, $t0)
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
  6: return $t3
}


[variant baseline]
fun valid_fv::test_128($t0: i128): i128 {
     var $t1: i128
     var $t2: i128
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t2
     # refs: []
     #
  1: $t1 := +($t2, $t0)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  2: return $t1
}


[variant baseline]
fun valid_fv::test_64($t0: i64): i64 {
     var $t1: i64
     var $t2: i64
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t2
     # refs: []
     #
  1: $t1 := +($t2, $t0)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  2: return $t1
}


[variant baseline]
fun valid_fv::__lambda__1__test1($t0: i64): i64 {
     var $t1: i64
     var $t2: i64
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t2
     # refs: []
     #
  1: $t1 := *($t2, $t0)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  2: return $t1
}


[variant baseline]
fun valid_fv::__lambda__1__test2($t0: i128): i128 {
     var $t1: i128
     var $t2: i128
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t2
     # refs: []
     #
  1: $t1 := *($t2, $t0)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  2: return $t1
}

// -- Model dump before second bytecode pipeline
module 0x42::valid_fv {
    enum E1 {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<i64>,
        }
    }
    enum E2 {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<i128>,
        }
    }
    enum E3<T> {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<T>,
        }
    }
    struct S1 {
        x: u64,
        y: i64,
        z: i128,
    }
    struct S2 {
        x: S1,
        y: i64,
        z: i128,
    }
    struct S3<T> {
        x: T,
        y: S1,
        z: S2,
    }
    private fun test1(fv1: |i64|i64 has copy + drop,x: i64): i64 {
        {
          let fv2: |i64|i64 has copy + drop = closure#0valid_fv::__lambda__1__test1();
          (fv1)(x)
        }
    }
    private fun test10(fv: |E2|i64 has copy + drop,a: i64,b: i128): i64 {
        {
          let s1: S1 = pack valid_fv::S1(1, -1, -2);
          {
            let s2: S2 = pack valid_fv::S2(s1, -1, -2);
            {
              let e: E2 = pack valid_fv::E2::V2(s2);
              (fv)(e)
            }
          }
        }
    }
    private fun test11(fv: |E3<i64>|i64 has copy + drop,a: i64,b: i128): i64 {
        {
          let s1: S1 = pack valid_fv::S1(1, -1, -2);
          {
            let s2: S2 = pack valid_fv::S2(s1, -1, -2);
            {
              let s3: S3<i64> = pack valid_fv::S3<i64>(-1, s1, s2);
              {
                let e: E3<i64> = pack valid_fv::E3::V3<i64>(s3);
                (fv)(e)
              }
            }
          }
        }
    }
    private fun test12(fv: |E3<i128>|i64 has copy + drop,a: i64,b: i128): i64 {
        {
          let s1: S1 = pack valid_fv::S1(1, -1, -2);
          {
            let s2: S2 = pack valid_fv::S2(s1, -1, -2);
            {
              let s3: S3<i128> = pack valid_fv::S3<i128>(-1, s1, s2);
              {
                let e: E3<i128> = pack valid_fv::E3::V3<i128>(s3);
                (fv)(e)
              }
            }
          }
        }
    }
    private fun test2(fv1: |i128|i128 has copy + drop,x: i128): i128 {
        {
          let fv2: |i128|i128 has copy + drop = closure#0valid_fv::__lambda__1__test2();
          (fv1)(x)
        }
    }
    private fun test3(fv1: ||i64|i64|i64 has copy + drop,x: i64): i64 {
        (fv1)(closure#0valid_fv::test_64())
    }
    private fun test4(fv1: ||i128|i128|i128 has copy + drop,x: i128): i128 {
        (fv1)(closure#0valid_fv::test_128())
    }
    private fun test5(fv: |S1|i64 has copy + drop,a: i64,b: i128): i64 {
        {
          let s1: S1 = pack valid_fv::S1(1, a, b);
          (fv)(s1)
        }
    }
    private fun test6(fv: |S2|i64 has copy + drop,a: i64,b: i128): i64 {
        {
          let s1: S1 = pack valid_fv::S1(1, a, b);
          {
            let s2: S2 = pack valid_fv::S2(s1, a, b);
            (fv)(s2)
          }
        }
    }
    private fun test7(fv: |S3<i64>|i64 has copy + drop,a: i64,b: i128): i64 {
        {
          let s1: S1 = pack valid_fv::S1(1, a, b);
          {
            let s2: S2 = pack valid_fv::S2(s1, a, b);
            {
              let s3: S3<i64> = pack valid_fv::S3<i64>(a, s1, s2);
              (fv)(s3)
            }
          }
        }
    }
    private fun test8(fv: |S3<i128>|i64 has copy + drop,a: i64,b: i128): i64 {
        {
          let s1: S1 = pack valid_fv::S1(1, a, b);
          {
            let s2: S2 = pack valid_fv::S2(s1, a, b);
            {
              let s3: S3<i128> = pack valid_fv::S3<i128>(b, s1, s2);
              (fv)(s3)
            }
          }
        }
    }
    private fun test9(fv: |E1|i64 has copy + drop,a: i64,b: i128): i64 {
        {
          let s1: S1 = pack valid_fv::S1(1, -1, -2);
          {
            let e: E1 = pack valid_fv::E1::V1(s1);
            (fv)(e)
          }
        }
    }
    private fun test_128(x: i128): i128 {
        Add<i128>(x, x)
    }
    private fun test_64(x: i64): i64 {
        Add<i64>(x, x)
    }
    private fun __lambda__1__test1(x: i64): i64 {
        Mul<i64>(x, x)
    }
    private fun __lambda__1__test2(x: i128): i128 {
        Mul<i128>(x, x)
    }
} // end 0x42::valid_fv

============ bytecode before second stackless bytecode pipeline ================

[variant baseline]
fun valid_fv::test1($t0: |i64|i64 has copy + drop, $t1: i64): i64 {
     var $t2: i64
     var $t3: |i64|i64 has copy + drop
  0: $t3 := closure#0 valid_fv::__lambda__1__test1()
  1: $t2 := invoke($t1, $t0)
  2: return $t2
}


[variant baseline]
fun valid_fv::test10($t0: |0x42::valid_fv::E2|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     var $t7: i128
     var $t8: 0x42::valid_fv::S2
     var $t9: 0x42::valid_fv::S1
     var $t10: i64
     var $t11: i128
     var $t12: 0x42::valid_fv::E2
  0: $t5 := 1
  1: $t6 := -1
  2: $t7 := -2
  3: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t7)
  4: $t9 := infer($t4)
  5: $t10 := -1
  6: $t11 := -2
  7: $t8 := pack 0x42::valid_fv::S2($t9, $t10, $t11)
  8: $t12 := pack_variant 0x42::valid_fv::E2::V2($t8)
  9: $t3 := invoke($t12, $t0)
 10: return $t3
}


[variant baseline]
fun valid_fv::test11($t0: |0x42::valid_fv::E3<i64>|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     var $t7: i128
     var $t8: 0x42::valid_fv::S2
     var $t9: 0x42::valid_fv::S1
     var $t10: i64
     var $t11: i128
     var $t12: 0x42::valid_fv::S3<i64>
     var $t13: i64
     var $t14: 0x42::valid_fv::S1
     var $t15: 0x42::valid_fv::E3<i64>
  0: $t5 := 1
  1: $t6 := -1
  2: $t7 := -2
  3: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t7)
  4: $t9 := infer($t4)
  5: $t10 := -1
  6: $t11 := -2
  7: $t8 := pack 0x42::valid_fv::S2($t9, $t10, $t11)
  8: $t13 := -1
  9: $t14 := infer($t4)
 10: $t12 := pack 0x42::valid_fv::S3<i64>($t13, $t14, $t8)
 11: $t15 := pack_variant 0x42::valid_fv::E3<i64>::V3($t12)
 12: $t3 := invoke($t15, $t0)
 13: return $t3
}


[variant baseline]
fun valid_fv::test12($t0: |0x42::valid_fv::E3<i128>|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     var $t7: i128
     var $t8: 0x42::valid_fv::S2
     var $t9: 0x42::valid_fv::S1
     var $t10: i64
     var $t11: i128
     var $t12: 0x42::valid_fv::S3<i128>
     var $t13: i128
     var $t14: 0x42::valid_fv::S1
     var $t15: 0x42::valid_fv::E3<i128>
  0: $t5 := 1
  1: $t6 := -1
  2: $t7 := -2
  3: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t7)
  4: $t9 := infer($t4)
  5: $t10 := -1
  6: $t11 := -2
  7: $t8 := pack 0x42::valid_fv::S2($t9, $t10, $t11)
  8: $t13 := -1
  9: $t14 := infer($t4)
 10: $t12 := pack 0x42::valid_fv::S3<i128>($t13, $t14, $t8)
 11: $t15 := pack_variant 0x42::valid_fv::E3<i128>::V3($t12)
 12: $t3 := invoke($t15, $t0)
 13: return $t3
}


[variant baseline]
fun valid_fv::test2($t0: |i128|i128 has copy + drop, $t1: i128): i128 {
     var $t2: i128
     var $t3: |i128|i128 has copy + drop
  0: $t3 := closure#0 valid_fv::__lambda__1__test2()
  1: $t2 := invoke($t1, $t0)
  2: return $t2
}


[variant baseline]
fun valid_fv::test3($t0: ||i64|i64|i64 has copy + drop, $t1: i64): i64 {
     var $t2: i64
     var $t3: |i64|i64
  0: $t3 := closure#0 valid_fv::test_64()
  1: $t2 := invoke($t3, $t0)
  2: return $t2
}


[variant baseline]
fun valid_fv::test4($t0: ||i128|i128|i128 has copy + drop, $t1: i128): i128 {
     var $t2: i128
     var $t3: |i128|i128
  0: $t3 := closure#0 valid_fv::test_128()
  1: $t2 := invoke($t3, $t0)
  2: return $t2
}


[variant baseline]
fun valid_fv::test5($t0: |0x42::valid_fv::S1|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
  0: $t5 := 1
  1: $t6 := infer($t1)
  2: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t2)
  3: $t3 := invoke($t4, $t0)
  4: return $t3
}


[variant baseline]
fun valid_fv::test6($t0: |0x42::valid_fv::S2|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     var $t7: 0x42::valid_fv::S2
     var $t8: 0x42::valid_fv::S1
     var $t9: i64
  0: $t5 := 1
  1: $t6 := infer($t1)
  2: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t2)
  3: $t8 := infer($t4)
  4: $t9 := infer($t1)
  5: $t7 := pack 0x42::valid_fv::S2($t8, $t9, $t2)
  6: $t3 := invoke($t7, $t0)
  7: return $t3
}


[variant baseline]
fun valid_fv::test7($t0: |0x42::valid_fv::S3<i64>|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     var $t7: 0x42::valid_fv::S2
     var $t8: 0x42::valid_fv::S1
     var $t9: i64
     var $t10: 0x42::valid_fv::S3<i64>
     var $t11: i64
     var $t12: 0x42::valid_fv::S1
  0: $t5 := 1
  1: $t6 := infer($t1)
  2: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t2)
  3: $t8 := infer($t4)
  4: $t9 := infer($t1)
  5: $t7 := pack 0x42::valid_fv::S2($t8, $t9, $t2)
  6: $t11 := infer($t1)
  7: $t12 := infer($t4)
  8: $t10 := pack 0x42::valid_fv::S3<i64>($t11, $t12, $t7)
  9: $t3 := invoke($t10, $t0)
 10: return $t3
}


[variant baseline]
fun valid_fv::test8($t0: |0x42::valid_fv::S3<i128>|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     var $t7: 0x42::valid_fv::S2
     var $t8: 0x42::valid_fv::S1
     var $t9: i64
     var $t10: 0x42::valid_fv::S3<i128>
     var $t11: i128
     var $t12: 0x42::valid_fv::S1
  0: $t5 := 1
  1: $t6 := infer($t1)
  2: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t2)
  3: $t8 := infer($t4)
  4: $t9 := infer($t1)
  5: $t7 := pack 0x42::valid_fv::S2($t8, $t9, $t2)
  6: $t11 := infer($t2)
  7: $t12 := infer($t4)
  8: $t10 := pack 0x42::valid_fv::S3<i128>($t11, $t12, $t7)
  9: $t3 := invoke($t10, $t0)
 10: return $t3
}


[variant baseline]
fun valid_fv::test9($t0: |0x42::valid_fv::E1|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     var $t7: i128
     var $t8: 0x42::valid_fv::E1
  0: $t5 := 1
  1: $t6 := -1
  2: $t7 := -2
  3: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t7)
  4: $t8 := pack_variant 0x42::valid_fv::E1::V1($t4)
  5: $t3 := invoke($t8, $t0)
  6: return $t3
}


[variant baseline]
fun valid_fv::test_128($t0: i128): i128 {
     var $t1: i128
     var $t2: i128
  0: $t2 := infer($t0)
  1: $t1 := +($t2, $t0)
  2: return $t1
}


[variant baseline]
fun valid_fv::test_64($t0: i64): i64 {
     var $t1: i64
     var $t2: i64
  0: $t2 := infer($t0)
  1: $t1 := +($t2, $t0)
  2: return $t1
}


[variant baseline]
fun valid_fv::__lambda__1__test1($t0: i64): i64 {
     var $t1: i64
     var $t2: i64
  0: $t2 := infer($t0)
  1: $t1 := *($t2, $t0)
  2: return $t1
}


[variant baseline]
fun valid_fv::__lambda__1__test2($t0: i128): i128 {
     var $t1: i128
     var $t2: i128
  0: $t2 := infer($t0)
  1: $t1 := *($t2, $t0)
  2: return $t1
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
fun valid_fv::test1($t0: |i64|i64 has copy + drop, $t1: i64): i64 {
     var $t2: i64 [unused]
     var $t3: |i64|i64 has copy + drop
     # live vars: $t0, $t1
  0: $t3 := closure#0 valid_fv::__lambda__1__test1()
     # live vars: $t0, $t1
  1: $t1 := invoke($t1, $t0)
     # live vars: $t1
  2: return $t1
}


[variant baseline]
fun valid_fv::test10($t0: |0x42::valid_fv::E2|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64 [unused]
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64 [unused]
     var $t7: i128 [unused]
     var $t8: 0x42::valid_fv::S2
     var $t9: 0x42::valid_fv::S1 [unused]
     var $t10: i64 [unused]
     var $t11: i128 [unused]
     var $t12: 0x42::valid_fv::E2
     # live vars: $t0, $t1, $t2
  0: $t5 := 1
     # live vars: $t0, $t5
  1: $t1 := -1
     # live vars: $t0, $t1, $t5
  2: $t2 := -2
     # live vars: $t0, $t1, $t2, $t5
  3: $t4 := pack 0x42::valid_fv::S1($t5, $t1, $t2)
     # live vars: $t0, $t4
  4: $t4 := move($t4)
     # live vars: $t0, $t4
  5: $t1 := -1
     # live vars: $t0, $t1, $t4
  6: $t2 := -2
     # live vars: $t0, $t1, $t2, $t4
  7: $t8 := pack 0x42::valid_fv::S2($t4, $t1, $t2)
     # live vars: $t0, $t8
  8: $t12 := pack_variant 0x42::valid_fv::E2::V2($t8)
     # live vars: $t0, $t12
  9: $t1 := invoke($t12, $t0)
     # live vars: $t1
 10: return $t1
}


[variant baseline]
fun valid_fv::test11($t0: |0x42::valid_fv::E3<i64>|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64 [unused]
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64 [unused]
     var $t7: i128 [unused]
     var $t8: 0x42::valid_fv::S2
     var $t9: 0x42::valid_fv::S1
     var $t10: i64 [unused]
     var $t11: i128 [unused]
     var $t12: 0x42::valid_fv::S3<i64>
     var $t13: i64 [unused]
     var $t14: 0x42::valid_fv::S1 [unused]
     var $t15: 0x42::valid_fv::E3<i64>
     # live vars: $t0, $t1, $t2
  0: $t5 := 1
     # live vars: $t0, $t5
  1: $t1 := -1
     # live vars: $t0, $t1, $t5
  2: $t2 := -2
     # live vars: $t0, $t1, $t2, $t5
  3: $t4 := pack 0x42::valid_fv::S1($t5, $t1, $t2)
     # live vars: $t0, $t4
  4: $t9 := copy($t4)
     # live vars: $t0, $t4, $t9
  5: $t1 := -1
     # live vars: $t0, $t1, $t4, $t9
  6: $t2 := -2
     # live vars: $t0, $t1, $t2, $t4, $t9
  7: $t8 := pack 0x42::valid_fv::S2($t9, $t1, $t2)
     # live vars: $t0, $t4, $t8
  8: $t1 := -1
     # live vars: $t0, $t1, $t4, $t8
  9: $t4 := move($t4)
     # live vars: $t0, $t1, $t4, $t8
 10: $t12 := pack 0x42::valid_fv::S3<i64>($t1, $t4, $t8)
     # live vars: $t0, $t12
 11: $t15 := pack_variant 0x42::valid_fv::E3<i64>::V3($t12)
     # live vars: $t0, $t15
 12: $t1 := invoke($t15, $t0)
     # live vars: $t1
 13: return $t1
}


[variant baseline]
fun valid_fv::test12($t0: |0x42::valid_fv::E3<i128>|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64 [unused]
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64 [unused]
     var $t7: i128 [unused]
     var $t8: 0x42::valid_fv::S2
     var $t9: 0x42::valid_fv::S1
     var $t10: i64 [unused]
     var $t11: i128 [unused]
     var $t12: 0x42::valid_fv::S3<i128>
     var $t13: i128 [unused]
     var $t14: 0x42::valid_fv::S1 [unused]
     var $t15: 0x42::valid_fv::E3<i128>
     # live vars: $t0, $t1, $t2
  0: $t5 := 1
     # live vars: $t0, $t5
  1: $t1 := -1
     # live vars: $t0, $t1, $t5
  2: $t2 := -2
     # live vars: $t0, $t1, $t2, $t5
  3: $t4 := pack 0x42::valid_fv::S1($t5, $t1, $t2)
     # live vars: $t0, $t4
  4: $t9 := copy($t4)
     # live vars: $t0, $t4, $t9
  5: $t1 := -1
     # live vars: $t0, $t1, $t4, $t9
  6: $t2 := -2
     # live vars: $t0, $t1, $t2, $t4, $t9
  7: $t8 := pack 0x42::valid_fv::S2($t9, $t1, $t2)
     # live vars: $t0, $t4, $t8
  8: $t2 := -1
     # live vars: $t0, $t2, $t4, $t8
  9: $t4 := move($t4)
     # live vars: $t0, $t2, $t4, $t8
 10: $t12 := pack 0x42::valid_fv::S3<i128>($t2, $t4, $t8)
     # live vars: $t0, $t12
 11: $t15 := pack_variant 0x42::valid_fv::E3<i128>::V3($t12)
     # live vars: $t0, $t15
 12: $t1 := invoke($t15, $t0)
     # live vars: $t1
 13: return $t1
}


[variant baseline]
fun valid_fv::test2($t0: |i128|i128 has copy + drop, $t1: i128): i128 {
     var $t2: i128 [unused]
     var $t3: |i128|i128 has copy + drop
     # live vars: $t0, $t1
  0: $t3 := closure#0 valid_fv::__lambda__1__test2()
     # live vars: $t0, $t1
  1: $t1 := invoke($t1, $t0)
     # live vars: $t1
  2: return $t1
}


[variant baseline]
fun valid_fv::test3($t0: ||i64|i64|i64 has copy + drop, $t1: i64): i64 {
     var $t2: i64 [unused]
     var $t3: |i64|i64
     # live vars: $t0, $t1
  0: $t3 := closure#0 valid_fv::test_64()
     # live vars: $t0, $t3
  1: $t1 := invoke($t3, $t0)
     # live vars: $t1
  2: return $t1
}


[variant baseline]
fun valid_fv::test4($t0: ||i128|i128|i128 has copy + drop, $t1: i128): i128 {
     var $t2: i128 [unused]
     var $t3: |i128|i128
     # live vars: $t0, $t1
  0: $t3 := closure#0 valid_fv::test_128()
     # live vars: $t0, $t3
  1: $t1 := invoke($t3, $t0)
     # live vars: $t1
  2: return $t1
}


[variant baseline]
fun valid_fv::test5($t0: |0x42::valid_fv::S1|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64 [unused]
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64 [unused]
     # live vars: $t0, $t1, $t2
  0: $t5 := 1
     # live vars: $t0, $t1, $t2, $t5
  1: $t1 := move($t1)
     # live vars: $t0, $t1, $t2, $t5
  2: $t4 := pack 0x42::valid_fv::S1($t5, $t1, $t2)
     # live vars: $t0, $t4
  3: $t1 := invoke($t4, $t0)
     # live vars: $t1
  4: return $t1
}


[variant baseline]
fun valid_fv::test6($t0: |0x42::valid_fv::S2|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64 [unused]
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     var $t7: 0x42::valid_fv::S2
     var $t8: 0x42::valid_fv::S1 [unused]
     var $t9: i64 [unused]
     # live vars: $t0, $t1, $t2
  0: $t5 := 1
     # live vars: $t0, $t1, $t2, $t5
  1: $t6 := copy($t1)
     # live vars: $t0, $t1, $t2, $t5, $t6
  2: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t2)
     # live vars: $t0, $t1, $t2, $t4
  3: $t4 := move($t4)
     # live vars: $t0, $t1, $t2, $t4
  4: $t1 := move($t1)
     # live vars: $t0, $t1, $t2, $t4
  5: $t7 := pack 0x42::valid_fv::S2($t4, $t1, $t2)
     # live vars: $t0, $t7
  6: $t1 := invoke($t7, $t0)
     # live vars: $t1
  7: return $t1
}


[variant baseline]
fun valid_fv::test7($t0: |0x42::valid_fv::S3<i64>|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64 [unused]
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     var $t7: 0x42::valid_fv::S2
     var $t8: 0x42::valid_fv::S1
     var $t9: i64 [unused]
     var $t10: 0x42::valid_fv::S3<i64>
     var $t11: i64 [unused]
     var $t12: 0x42::valid_fv::S1 [unused]
     # live vars: $t0, $t1, $t2
  0: $t5 := 1
     # live vars: $t0, $t1, $t2, $t5
  1: $t6 := copy($t1)
     # live vars: $t0, $t1, $t2, $t5, $t6
  2: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t2)
     # live vars: $t0, $t1, $t2, $t4
  3: $t8 := copy($t4)
     # live vars: $t0, $t1, $t2, $t4, $t8
  4: $t6 := copy($t1)
     # live vars: $t0, $t1, $t2, $t4, $t6, $t8
  5: $t7 := pack 0x42::valid_fv::S2($t8, $t6, $t2)
     # live vars: $t0, $t1, $t4, $t7
  6: $t1 := move($t1)
     # live vars: $t0, $t1, $t4, $t7
  7: $t4 := move($t4)
     # live vars: $t0, $t1, $t4, $t7
  8: $t10 := pack 0x42::valid_fv::S3<i64>($t1, $t4, $t7)
     # live vars: $t0, $t10
  9: $t1 := invoke($t10, $t0)
     # live vars: $t1
 10: return $t1
}


[variant baseline]
fun valid_fv::test8($t0: |0x42::valid_fv::S3<i128>|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64 [unused]
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64
     var $t7: 0x42::valid_fv::S2
     var $t8: 0x42::valid_fv::S1
     var $t9: i64 [unused]
     var $t10: 0x42::valid_fv::S3<i128>
     var $t11: i128 [unused]
     var $t12: 0x42::valid_fv::S1 [unused]
     # live vars: $t0, $t1, $t2
  0: $t5 := 1
     # live vars: $t0, $t1, $t2, $t5
  1: $t6 := copy($t1)
     # live vars: $t0, $t1, $t2, $t5, $t6
  2: $t4 := pack 0x42::valid_fv::S1($t5, $t6, $t2)
     # live vars: $t0, $t1, $t2, $t4
  3: $t8 := copy($t4)
     # live vars: $t0, $t1, $t2, $t4, $t8
  4: $t1 := move($t1)
     # live vars: $t0, $t1, $t2, $t4, $t8
  5: $t7 := pack 0x42::valid_fv::S2($t8, $t1, $t2)
     # live vars: $t0, $t2, $t4, $t7
  6: $t2 := move($t2)
     # live vars: $t0, $t2, $t4, $t7
  7: $t4 := move($t4)
     # live vars: $t0, $t2, $t4, $t7
  8: $t10 := pack 0x42::valid_fv::S3<i128>($t2, $t4, $t7)
     # live vars: $t0, $t10
  9: $t1 := invoke($t10, $t0)
     # live vars: $t1
 10: return $t1
}


[variant baseline]
fun valid_fv::test9($t0: |0x42::valid_fv::E1|i64 has copy + drop, $t1: i64, $t2: i128): i64 {
     var $t3: i64 [unused]
     var $t4: 0x42::valid_fv::S1
     var $t5: u64
     var $t6: i64 [unused]
     var $t7: i128 [unused]
     var $t8: 0x42::valid_fv::E1
     # live vars: $t0, $t1, $t2
  0: $t5 := 1
     # live vars: $t0, $t5
  1: $t1 := -1
     # live vars: $t0, $t1, $t5
  2: $t2 := -2
     # live vars: $t0, $t1, $t2, $t5
  3: $t4 := pack 0x42::valid_fv::S1($t5, $t1, $t2)
     # live vars: $t0, $t4
  4: $t8 := pack_variant 0x42::valid_fv::E1::V1($t4)
     # live vars: $t0, $t8
  5: $t1 := invoke($t8, $t0)
     # live vars: $t1
  6: return $t1
}


[variant baseline]
fun valid_fv::test_128($t0: i128): i128 {
     var $t1: i128 [unused]
     var $t2: i128
     # live vars: $t0
  0: $t2 := copy($t0)
     # live vars: $t0, $t2
  1: $t0 := +($t2, $t0)
     # live vars: $t0
  2: return $t0
}


[variant baseline]
fun valid_fv::test_64($t0: i64): i64 {
     var $t1: i64 [unused]
     var $t2: i64
     # live vars: $t0
  0: $t2 := copy($t0)
     # live vars: $t0, $t2
  1: $t0 := +($t2, $t0)
     # live vars: $t0
  2: return $t0
}


[variant baseline]
fun valid_fv::__lambda__1__test1($t0: i64): i64 {
     var $t1: i64 [unused]
     var $t2: i64
     # live vars: $t0
  0: $t2 := copy($t0)
     # live vars: $t0, $t2
  1: $t0 := *($t2, $t0)
     # live vars: $t0
  2: return $t0
}


[variant baseline]
fun valid_fv::__lambda__1__test2($t0: i128): i128 {
     var $t1: i128 [unused]
     var $t2: i128
     # live vars: $t0
  0: $t2 := copy($t0)
     # live vars: $t0, $t2
  1: $t0 := *($t2, $t0)
     # live vars: $t0
  2: return $t0
}


============ disassembled file-format ==================
// Move bytecode v9
module 42.valid_fv {
enum E1 has copy, drop {
 V1{
	s: S1
 },
 V2{
	s: S2
 },
 V3{
	s: S3<i64>
 }
}
enum E2 has copy, drop {
 V1{
	s: S1
 },
 V2{
	s: S2
 },
 V3{
	s: S3<i128>
 }
}
enum E3<T> has copy, drop {
 V1{
	s: S1
 },
 V2{
	s: S2
 },
 V3{
	s: S3<T>
 }
}
struct S1 has copy, drop {
	x: u64,
	y: i64,
	z: i128
}
struct S2 has copy, drop {
	x: S1,
	y: i64,
	z: i128
}
struct S3<T> has copy, drop {
	x: T,
	y: S1,
	z: S2
}

test1(fv1: |i64|i64 has copy + drop, x: i64): i64 /* def_idx: 0 */ {
B0:
	0: PackClosure#0 __lambda__1__test1(i64): i64
	1: Pop
	2: MoveLoc[1](x: i64)
	3: MoveLoc[0](fv1: |i64|i64 has copy + drop)
	4: CallClosure(|i64|i64 has copy + drop)
	5: Ret
}
test10(fv: |E2|i64 has copy + drop, a: i64, b: i128): i64 /* def_idx: 1 */ {
B0:
	0: LdU64(1)
	1: LdI64(-1)
	2: LdI128(-2)
	3: Pack[3](S1)
	4: LdI64(-1)
	5: LdI128(-2)
	6: Pack[4](S2)
	7: PackVariant[0](E2/V2)
	8: MoveLoc[0](fv: |E2|i64 has copy + drop)
	9: CallClosure(|E2|i64 has copy + drop)
	10: Ret
}
test11(fv: |E3<i64>|i64 has copy + drop, a: i64, b: i128): i64 /* def_idx: 2 */ {
L3:	s1: S1
L4:	s2: S2
B0:
	0: LdU64(1)
	1: LdI64(-1)
	2: LdI128(-2)
	3: Pack[3](S1)
	4: StLoc[3](s1: S1)
	5: CopyLoc[3](s1: S1)
	6: LdI64(-1)
	7: LdI128(-2)
	8: Pack[4](S2)
	9: StLoc[4](s2: S2)
	10: LdI64(-1)
	11: MoveLoc[3](s1: S1)
	12: MoveLoc[4](s2: S2)
	13: PackGeneric[0](S3<i64>)
	14: PackVariantGeneric[0](E3/V3<i64>)
	15: MoveLoc[0](fv: |E3<i64>|i64 has copy + drop)
	16: CallClosure(|E3<i64>|i64 has copy + drop)
	17: Ret
}
test12(fv: |E3<i128>|i64 has copy + drop, a: i64, b: i128): i64 /* def_idx: 3 */ {
L3:	s1: S1
L4:	s2: S2
B0:
	0: LdU64(1)
	1: LdI64(-1)
	2: LdI128(-2)
	3: Pack[3](S1)
	4: StLoc[3](s1: S1)
	5: CopyLoc[3](s1: S1)
	6: LdI64(-1)
	7: LdI128(-2)
	8: Pack[4](S2)
	9: StLoc[4](s2: S2)
	10: LdI128(-1)
	11: MoveLoc[3](s1: S1)
	12: MoveLoc[4](s2: S2)
	13: PackGeneric[1](S3<i128>)
	14: PackVariantGeneric[1](E3/V3<i128>)
	15: MoveLoc[0](fv: |E3<i128>|i64 has copy + drop)
	16: CallClosure(|E3<i128>|i64 has copy + drop)
	17: Ret
}
test2(fv1: |i128|i128 has copy + drop, x: i128): i128 /* def_idx: 4 */ {
B0:
	0: PackClosure#0 __lambda__1__test2(i128): i128
	1: Pop
	2: MoveLoc[1](x: i128)
	3: MoveLoc[0](fv1: |i128|i128 has copy + drop)
	4: CallClosure(|i128|i128 has copy + drop)
	5: Ret
}
test3(fv1: ||i64|i64|i64 has copy + drop, x: i64): i64 /* def_idx: 5 */ {
B0:
	0: PackClosure#0 test_64(i64): i64
	1: MoveLoc[0](fv1: ||i64|i64|i64 has copy + drop)
	2: CallClosure(||i64|i64|i64 has copy + drop)
	3: Ret
}
test4(fv1: ||i128|i128|i128 has copy + drop, x: i128): i128 /* def_idx: 6 */ {
B0:
	0: PackClosure#0 test_128(i128): i128
	1: MoveLoc[0](fv1: ||i128|i128|i128 has copy + drop)
	2: CallClosure(||i128|i128|i128 has copy + drop)
	3: Ret
}
test5(fv: |S1|i64 has copy + drop, a: i64, b: i128): i64 /* def_idx: 7 */ {
B0:
	0: LdU64(1)
	1: MoveLoc[1](a: i64)
	2: MoveLoc[2](b: i128)
	3: Pack[3](S1)
	4: MoveLoc[0](fv: |S1|i64 has copy + drop)
	5: CallClosure(|S1|i64 has copy + drop)
	6: Ret
}
test6(fv: |S2|i64 has copy + drop, a: i64, b: i128): i64 /* def_idx: 8 */ {
B0:
	0: LdU64(1)
	1: CopyLoc[1](a: i64)
	2: CopyLoc[2](b: i128)
	3: Pack[3](S1)
	4: MoveLoc[1](a: i64)
	5: MoveLoc[2](b: i128)
	6: Pack[4](S2)
	7: MoveLoc[0](fv: |S2|i64 has copy + drop)
	8: CallClosure(|S2|i64 has copy + drop)
	9: Ret
}
test7(fv: |S3<i64>|i64 has copy + drop, a: i64, b: i128): i64 /* def_idx: 9 */ {
L3:	s1: S1
L4:	s2: S2
B0:
	0: LdU64(1)
	1: CopyLoc[1](a: i64)
	2: CopyLoc[2](b: i128)
	3: Pack[3](S1)
	4: StLoc[3](s1: S1)
	5: CopyLoc[3](s1: S1)
	6: CopyLoc[1](a: i64)
	7: MoveLoc[2](b: i128)
	8: Pack[4](S2)
	9: StLoc[4](s2: S2)
	10: MoveLoc[1](a: i64)
	11: MoveLoc[3](s1: S1)
	12: MoveLoc[4](s2: S2)
	13: PackGeneric[0](S3<i64>)
	14: MoveLoc[0](fv: |S3<i64>|i64 has copy + drop)
	15: CallClosure(|S3<i64>|i64 has copy + drop)
	16: Ret
}
test8(fv: |S3<i128>|i64 has copy + drop, a: i64, b: i128): i64 /* def_idx: 10 */ {
L3:	s1: S1
L4:	s2: S2
B0:
	0: LdU64(1)
	1: CopyLoc[1](a: i64)
	2: CopyLoc[2](b: i128)
	3: Pack[3](S1)
	4: StLoc[3](s1: S1)
	5: CopyLoc[3](s1: S1)
	6: MoveLoc[1](a: i64)
	7: CopyLoc[2](b: i128)
	8: Pack[4](S2)
	9: StLoc[4](s2: S2)
	10: MoveLoc[2](b: i128)
	11: MoveLoc[3](s1: S1)
	12: MoveLoc[4](s2: S2)
	13: PackGeneric[1](S3<i128>)
	14: MoveLoc[0](fv: |S3<i128>|i64 has copy + drop)
	15: CallClosure(|S3<i128>|i64 has copy + drop)
	16: Ret
}
test9(fv: |E1|i64 has copy + drop, a: i64, b: i128): i64 /* def_idx: 11 */ {
B0:
	0: LdU64(1)
	1: LdI64(-1)
	2: LdI128(-2)
	3: Pack[3](S1)
	4: PackVariant[2](E1/V1)
	5: MoveLoc[0](fv: |E1|i64 has copy + drop)
	6: CallClosure(|E1|i64 has copy + drop)
	7: Ret
}
test_128(x: i128): i128 /* def_idx: 12 */ {
B0:
	0: CopyLoc[0](x: i128)
	1: MoveLoc[0](x: i128)
	2: Add
	3: Ret
}
test_64(x: i64): i64 /* def_idx: 13 */ {
B0:
	0: CopyLoc[0](x: i64)
	1: MoveLoc[0](x: i64)
	2: Add
	3: Ret
}
__lambda__1__test1(x: i64): i64 /* def_idx: 14 */ {
B0:
	0: CopyLoc[0](x: i64)
	1: MoveLoc[0](x: i64)
	2: Mul
	3: Ret
}
__lambda__1__test2(x: i128): i128 /* def_idx: 15 */ {
B0:
	0: CopyLoc[0](x: i128)
	1: MoveLoc[0](x: i128)
	2: Mul
	3: Ret
}
}
============ bytecode verification succeeded ========
