// -- Model dump before first bytecode pipeline
module 0x42::valid_logic {
    enum E1 {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<i64>,
        }
    }
    enum E2 {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<i128>,
        }
    }
    enum E3<T> {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<T>,
        }
    }
    struct S1 {
        x: u64,
        y: i64,
        z: i128,
    }
    struct S2 {
        x: S1,
        y: i64,
        z: i128,
    }
    struct S3<T> {
        x: T,
        y: S1,
        z: S2,
    }
    private fun test_cmp1(x: i64): bool {
        And(And(And(And(And(Eq<i64>(x, x), Ge<i64>(x, x)), Le<i64>(x, x)), Gt<i64>(x, x)), Lt<i64>(x, x)), Eq<i64>(Borrow(Immutable)(x), Borrow(Immutable)(x)))
    }
    private fun test_cmp2(x: i128): bool {
        And(And(And(And(And(Eq<i128>(x, x), Ge<i128>(x, x)), Le<i128>(x, x)), Gt<i128>(x, x)), Lt<i128>(x, x)), Eq<i128>(Borrow(Immutable)(x), Borrow(Immutable)(x)))
    }
    private fun test_cmp3(s1: S1,s2: S2,s3: S3<i64>): bool {
        And(And(And(And(And(And(Eq<i64>(select valid_logic::S1.y<S1>(s1), select valid_logic::S2.y<S2>(s2)), Le<i64>(select valid_logic::S1.y<S1>(s1), select valid_logic::S3.x<S3<i64>>(s3))), Ge<i64>(select valid_logic::S2.y<S2>(s2), select valid_logic::S3.x<S3<i64>>(s3))), Gt<i64>(select valid_logic::S3.x<S3<i64>>(s3), select valid_logic::S1.y<S1>(s1))), Lt<i64>(select valid_logic::S3.x<S3<i64>>(s3), select valid_logic::S2.y<S2>(s2))), Eq<i64>(Borrow(Immutable)(select valid_logic::S1.y<S1>(s1)), Borrow(Immutable)(select valid_logic::S2.y<S2>(s2)))), Eq<i64>(Borrow(Immutable)(select valid_logic::S1.y<S1>(s1)), Borrow(Immutable)(select valid_logic::S2.y<S2>(s2))))
    }
    private fun test_cmp4(s1: S1,s2: S2,s3: S3<i128>): bool {
        And(And(And(And(And(And(Eq<i128>(select valid_logic::S1.z<S1>(s1), select valid_logic::S2.z<S2>(s2)), Le<i128>(select valid_logic::S1.z<S1>(s1), select valid_logic::S3.x<S3<i128>>(s3))), Ge<i128>(select valid_logic::S2.z<S2>(s2), select valid_logic::S3.x<S3<i128>>(s3))), Gt<i128>(select valid_logic::S3.x<S3<i128>>(s3), select valid_logic::S1.z<S1>(s1))), Lt<i128>(select valid_logic::S3.x<S3<i128>>(s3), select valid_logic::S2.z<S2>(s2))), Eq<i128>(Borrow(Immutable)(select valid_logic::S1.z<S1>(s1)), Borrow(Immutable)(select valid_logic::S2.z<S2>(s2)))), Eq<i128>(Borrow(Immutable)(select valid_logic::S1.z<S1>(s1)), Borrow(Immutable)(select valid_logic::S2.z<S2>(s2))))
    }
    private fun test_mix1(x: i64,y: i64): bool {
        Eq<i64>(Add<i64>(x, y), Add<i64>(y, x))
    }
    private fun test_mix10(x: i128,y: i128): bool {
        Gt<i128>(Mul<i128>(Mod<i128>(x, 2), y), Mul<i128>(Mod<i128>(x, 3), y))
    }
    private fun test_mix2(x: i128,y: i128): bool {
        Le<i128>(Add<i128>(x, Mul<i128>(2, y)), Add<i128>(x, Mul<i128>(3, y)))
    }
    private fun test_mix3(x: i64,y: i64): bool {
        Eq<i64>(Sub<i64>(x, y), Sub<i64>(y, x))
    }
    private fun test_mix4(x: i128,y: i128): bool {
        Gt<i128>(Sub<i128>(x, Mul<i128>(2, y)), Sub<i128>(x, Mul<i128>(3, y)))
    }
    private fun test_mix5(x: i64,y: i64): bool {
        Eq<i64>(Mul<i64>(x, y), Mul<i64>(y, x))
    }
    private fun test_mix6(x: i128,y: i128): bool {
        Gt<i128>(Mul<i128>(Mul<i128>(x, 2), y), Mul<i128>(Mul<i128>(x, 3), y))
    }
    private fun test_mix7(x: i64,y: i64): bool {
        Eq<i64>(Div<i64>(x, y), Div<i64>(y, x))
    }
    private fun test_mix8(x: i128,y: i128): bool {
        Gt<i128>(Mul<i128>(Div<i128>(x, 2), y), Mul<i128>(Div<i128>(x, 3), y))
    }
    private fun test_mix9(x: i64,y: i64): bool {
        Eq<i64>(Mod<i64>(x, y), Mod<i64>(y, x))
    }
} // end 0x42::valid_logic

// -- Sourcified model before first bytecode pipeline
module 0x42::valid_logic {
    enum E1 has copy, drop {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<i64>,
        }
    }
    enum E2 has copy, drop {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<i128>,
        }
    }
    enum E3<T> has copy, drop {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<T>,
        }
    }
    struct S1 has copy, drop {
        x: u64,
        y: i64,
        z: i128,
    }
    struct S2 has copy, drop {
        x: S1,
        y: i64,
        z: i128,
    }
    struct S3<T> has copy, drop {
        x: T,
        y: S1,
        z: S2,
    }
    fun test_cmp1(x: i64): bool {
        x == x && x >= x && x <= x && x > x && x < x && &x == &x
    }
    fun test_cmp2(x: i128): bool {
        x == x && x >= x && x <= x && x > x && x < x && &x == &x
    }
    fun test_cmp3(s1: S1, s2: S2, s3: S3<i64>): bool {
        s1.y == s2.y && s1.y <= s3.x && s2.y >= s3.x && s3.x > s1.y && s3.x < s2.y && &s1.y == &s2.y && &s1.y == &s2.y
    }
    fun test_cmp4(s1: S1, s2: S2, s3: S3<i128>): bool {
        s1.z == s2.z && s1.z <= s3.x && s2.z >= s3.x && s3.x > s1.z && s3.x < s2.z && &s1.z == &s2.z && &s1.z == &s2.z
    }
    fun test_mix1(x: i64, y: i64): bool {
        x + y == y + x
    }
    fun test_mix10(x: i128, y: i128): bool {
        x % 2i128 * y > x % 3i128 * y
    }
    fun test_mix2(x: i128, y: i128): bool {
        x + 2i128 * y <= x + 3i128 * y
    }
    fun test_mix3(x: i64, y: i64): bool {
        x - y == y - x
    }
    fun test_mix4(x: i128, y: i128): bool {
        x - 2i128 * y > x - 3i128 * y
    }
    fun test_mix5(x: i64, y: i64): bool {
        x * y == y * x
    }
    fun test_mix6(x: i128, y: i128): bool {
        x * 2i128 * y > x * 3i128 * y
    }
    fun test_mix7(x: i64, y: i64): bool {
        x / y == y / x
    }
    fun test_mix8(x: i128, y: i128): bool {
        x / 2i128 * y > x / 3i128 * y
    }
    fun test_mix9(x: i64, y: i64): bool {
        x % y == y % x
    }
}

============ bytecode before first stackless bytecode pipeline ================

[variant baseline]
fun valid_logic::test_cmp1($t0: i64): bool {
     var $t1: bool
     var $t2: bool
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: i64
     var $t8: i64
     var $t9: i64
     var $t10: i64
     var $t11: i64
     var $t12: &i64
     var $t13: &i64
  0: $t7 := infer($t0)
  1: $t6 := ==($t7, $t0)
  2: if ($t6) goto 3 else goto 7
  3: label L0
  4: $t8 := infer($t0)
  5: $t5 := >=($t8, $t0)
  6: goto 9
  7: label L1
  8: $t5 := false
  9: label L2
 10: if ($t5) goto 11 else goto 15
 11: label L3
 12: $t9 := infer($t0)
 13: $t4 := <=($t9, $t0)
 14: goto 17
 15: label L4
 16: $t4 := false
 17: label L5
 18: if ($t4) goto 19 else goto 23
 19: label L6
 20: $t10 := infer($t0)
 21: $t3 := >($t10, $t0)
 22: goto 25
 23: label L7
 24: $t3 := false
 25: label L8
 26: if ($t3) goto 27 else goto 31
 27: label L9
 28: $t11 := infer($t0)
 29: $t2 := <($t11, $t0)
 30: goto 33
 31: label L10
 32: $t2 := false
 33: label L11
 34: if ($t2) goto 35 else goto 40
 35: label L12
 36: $t12 := borrow_local($t0)
 37: $t13 := borrow_local($t0)
 38: $t1 := ==($t12, $t13)
 39: goto 42
 40: label L13
 41: $t1 := false
 42: label L14
 43: return $t1
}


[variant baseline]
fun valid_logic::test_cmp2($t0: i128): bool {
     var $t1: bool
     var $t2: bool
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
     var $t11: i128
     var $t12: &i128
     var $t13: &i128
  0: $t7 := infer($t0)
  1: $t6 := ==($t7, $t0)
  2: if ($t6) goto 3 else goto 7
  3: label L0
  4: $t8 := infer($t0)
  5: $t5 := >=($t8, $t0)
  6: goto 9
  7: label L1
  8: $t5 := false
  9: label L2
 10: if ($t5) goto 11 else goto 15
 11: label L3
 12: $t9 := infer($t0)
 13: $t4 := <=($t9, $t0)
 14: goto 17
 15: label L4
 16: $t4 := false
 17: label L5
 18: if ($t4) goto 19 else goto 23
 19: label L6
 20: $t10 := infer($t0)
 21: $t3 := >($t10, $t0)
 22: goto 25
 23: label L7
 24: $t3 := false
 25: label L8
 26: if ($t3) goto 27 else goto 31
 27: label L9
 28: $t11 := infer($t0)
 29: $t2 := <($t11, $t0)
 30: goto 33
 31: label L10
 32: $t2 := false
 33: label L11
 34: if ($t2) goto 35 else goto 40
 35: label L12
 36: $t12 := borrow_local($t0)
 37: $t13 := borrow_local($t0)
 38: $t1 := ==($t12, $t13)
 39: goto 42
 40: label L13
 41: $t1 := false
 42: label L14
 43: return $t1
}


[variant baseline]
fun valid_logic::test_cmp3($t0: 0x42::valid_logic::S1, $t1: 0x42::valid_logic::S2, $t2: 0x42::valid_logic::S3<i64>): bool {
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: bool
     var $t8: bool
     var $t9: bool
     var $t10: i64
     var $t11: &0x42::valid_logic::S1
     var $t12: &i64
     var $t13: i64
     var $t14: &0x42::valid_logic::S2
     var $t15: &i64
     var $t16: i64
     var $t17: &0x42::valid_logic::S1
     var $t18: &i64
     var $t19: i64
     var $t20: &0x42::valid_logic::S3<i64>
     var $t21: &i64
     var $t22: i64
     var $t23: &0x42::valid_logic::S2
     var $t24: &i64
     var $t25: i64
     var $t26: &0x42::valid_logic::S3<i64>
     var $t27: &i64
     var $t28: i64
     var $t29: &0x42::valid_logic::S3<i64>
     var $t30: &i64
     var $t31: i64
     var $t32: &0x42::valid_logic::S1
     var $t33: &i64
     var $t34: i64
     var $t35: &0x42::valid_logic::S3<i64>
     var $t36: &i64
     var $t37: i64
     var $t38: &0x42::valid_logic::S2
     var $t39: &i64
     var $t40: &i64
     var $t41: &0x42::valid_logic::S1
     var $t42: &i64
     var $t43: &0x42::valid_logic::S2
     var $t44: &i64
     var $t45: &0x42::valid_logic::S1
     var $t46: &i64
     var $t47: &0x42::valid_logic::S2
  0: $t11 := borrow_local($t0)
  1: $t12 := borrow_field<0x42::valid_logic::S1>.y($t11)
  2: $t10 := read_ref($t12)
  3: $t14 := borrow_local($t1)
  4: $t15 := borrow_field<0x42::valid_logic::S2>.y($t14)
  5: $t13 := read_ref($t15)
  6: $t9 := ==($t10, $t13)
  7: if ($t9) goto 8 else goto 17
  8: label L0
  9: $t17 := borrow_local($t0)
 10: $t18 := borrow_field<0x42::valid_logic::S1>.y($t17)
 11: $t16 := read_ref($t18)
 12: $t20 := borrow_local($t2)
 13: $t21 := borrow_field<0x42::valid_logic::S3<i64>>.x($t20)
 14: $t19 := read_ref($t21)
 15: $t8 := <=($t16, $t19)
 16: goto 19
 17: label L1
 18: $t8 := false
 19: label L2
 20: if ($t8) goto 21 else goto 30
 21: label L3
 22: $t23 := borrow_local($t1)
 23: $t24 := borrow_field<0x42::valid_logic::S2>.y($t23)
 24: $t22 := read_ref($t24)
 25: $t26 := borrow_local($t2)
 26: $t27 := borrow_field<0x42::valid_logic::S3<i64>>.x($t26)
 27: $t25 := read_ref($t27)
 28: $t7 := >=($t22, $t25)
 29: goto 32
 30: label L4
 31: $t7 := false
 32: label L5
 33: if ($t7) goto 34 else goto 43
 34: label L6
 35: $t29 := borrow_local($t2)
 36: $t30 := borrow_field<0x42::valid_logic::S3<i64>>.x($t29)
 37: $t28 := read_ref($t30)
 38: $t32 := borrow_local($t0)
 39: $t33 := borrow_field<0x42::valid_logic::S1>.y($t32)
 40: $t31 := read_ref($t33)
 41: $t6 := >($t28, $t31)
 42: goto 45
 43: label L7
 44: $t6 := false
 45: label L8
 46: if ($t6) goto 47 else goto 56
 47: label L9
 48: $t35 := borrow_local($t2)
 49: $t36 := borrow_field<0x42::valid_logic::S3<i64>>.x($t35)
 50: $t34 := read_ref($t36)
 51: $t38 := borrow_local($t1)
 52: $t39 := borrow_field<0x42::valid_logic::S2>.y($t38)
 53: $t37 := read_ref($t39)
 54: $t5 := <($t34, $t37)
 55: goto 58
 56: label L10
 57: $t5 := false
 58: label L11
 59: if ($t5) goto 60 else goto 67
 60: label L12
 61: $t41 := borrow_local($t0)
 62: $t40 := borrow_field<0x42::valid_logic::S1>.y($t41)
 63: $t43 := borrow_local($t1)
 64: $t42 := borrow_field<0x42::valid_logic::S2>.y($t43)
 65: $t4 := ==($t40, $t42)
 66: goto 69
 67: label L13
 68: $t4 := false
 69: label L14
 70: if ($t4) goto 71 else goto 78
 71: label L15
 72: $t45 := borrow_local($t0)
 73: $t44 := borrow_field<0x42::valid_logic::S1>.y($t45)
 74: $t47 := borrow_local($t1)
 75: $t46 := borrow_field<0x42::valid_logic::S2>.y($t47)
 76: $t3 := ==($t44, $t46)
 77: goto 80
 78: label L16
 79: $t3 := false
 80: label L17
 81: return $t3
}


[variant baseline]
fun valid_logic::test_cmp4($t0: 0x42::valid_logic::S1, $t1: 0x42::valid_logic::S2, $t2: 0x42::valid_logic::S3<i128>): bool {
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: bool
     var $t8: bool
     var $t9: bool
     var $t10: i128
     var $t11: &0x42::valid_logic::S1
     var $t12: &i128
     var $t13: i128
     var $t14: &0x42::valid_logic::S2
     var $t15: &i128
     var $t16: i128
     var $t17: &0x42::valid_logic::S1
     var $t18: &i128
     var $t19: i128
     var $t20: &0x42::valid_logic::S3<i128>
     var $t21: &i128
     var $t22: i128
     var $t23: &0x42::valid_logic::S2
     var $t24: &i128
     var $t25: i128
     var $t26: &0x42::valid_logic::S3<i128>
     var $t27: &i128
     var $t28: i128
     var $t29: &0x42::valid_logic::S3<i128>
     var $t30: &i128
     var $t31: i128
     var $t32: &0x42::valid_logic::S1
     var $t33: &i128
     var $t34: i128
     var $t35: &0x42::valid_logic::S3<i128>
     var $t36: &i128
     var $t37: i128
     var $t38: &0x42::valid_logic::S2
     var $t39: &i128
     var $t40: &i128
     var $t41: &0x42::valid_logic::S1
     var $t42: &i128
     var $t43: &0x42::valid_logic::S2
     var $t44: &i128
     var $t45: &0x42::valid_logic::S1
     var $t46: &i128
     var $t47: &0x42::valid_logic::S2
  0: $t11 := borrow_local($t0)
  1: $t12 := borrow_field<0x42::valid_logic::S1>.z($t11)
  2: $t10 := read_ref($t12)
  3: $t14 := borrow_local($t1)
  4: $t15 := borrow_field<0x42::valid_logic::S2>.z($t14)
  5: $t13 := read_ref($t15)
  6: $t9 := ==($t10, $t13)
  7: if ($t9) goto 8 else goto 17
  8: label L0
  9: $t17 := borrow_local($t0)
 10: $t18 := borrow_field<0x42::valid_logic::S1>.z($t17)
 11: $t16 := read_ref($t18)
 12: $t20 := borrow_local($t2)
 13: $t21 := borrow_field<0x42::valid_logic::S3<i128>>.x($t20)
 14: $t19 := read_ref($t21)
 15: $t8 := <=($t16, $t19)
 16: goto 19
 17: label L1
 18: $t8 := false
 19: label L2
 20: if ($t8) goto 21 else goto 30
 21: label L3
 22: $t23 := borrow_local($t1)
 23: $t24 := borrow_field<0x42::valid_logic::S2>.z($t23)
 24: $t22 := read_ref($t24)
 25: $t26 := borrow_local($t2)
 26: $t27 := borrow_field<0x42::valid_logic::S3<i128>>.x($t26)
 27: $t25 := read_ref($t27)
 28: $t7 := >=($t22, $t25)
 29: goto 32
 30: label L4
 31: $t7 := false
 32: label L5
 33: if ($t7) goto 34 else goto 43
 34: label L6
 35: $t29 := borrow_local($t2)
 36: $t30 := borrow_field<0x42::valid_logic::S3<i128>>.x($t29)
 37: $t28 := read_ref($t30)
 38: $t32 := borrow_local($t0)
 39: $t33 := borrow_field<0x42::valid_logic::S1>.z($t32)
 40: $t31 := read_ref($t33)
 41: $t6 := >($t28, $t31)
 42: goto 45
 43: label L7
 44: $t6 := false
 45: label L8
 46: if ($t6) goto 47 else goto 56
 47: label L9
 48: $t35 := borrow_local($t2)
 49: $t36 := borrow_field<0x42::valid_logic::S3<i128>>.x($t35)
 50: $t34 := read_ref($t36)
 51: $t38 := borrow_local($t1)
 52: $t39 := borrow_field<0x42::valid_logic::S2>.z($t38)
 53: $t37 := read_ref($t39)
 54: $t5 := <($t34, $t37)
 55: goto 58
 56: label L10
 57: $t5 := false
 58: label L11
 59: if ($t5) goto 60 else goto 67
 60: label L12
 61: $t41 := borrow_local($t0)
 62: $t40 := borrow_field<0x42::valid_logic::S1>.z($t41)
 63: $t43 := borrow_local($t1)
 64: $t42 := borrow_field<0x42::valid_logic::S2>.z($t43)
 65: $t4 := ==($t40, $t42)
 66: goto 69
 67: label L13
 68: $t4 := false
 69: label L14
 70: if ($t4) goto 71 else goto 78
 71: label L15
 72: $t45 := borrow_local($t0)
 73: $t44 := borrow_field<0x42::valid_logic::S1>.z($t45)
 74: $t47 := borrow_local($t1)
 75: $t46 := borrow_field<0x42::valid_logic::S2>.z($t47)
 76: $t3 := ==($t44, $t46)
 77: goto 80
 78: label L16
 79: $t3 := false
 80: label L17
 81: return $t3
}


[variant baseline]
fun valid_logic::test_mix1($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
  0: $t4 := infer($t0)
  1: $t3 := +($t4, $t1)
  2: $t6 := infer($t1)
  3: $t5 := +($t6, $t0)
  4: $t2 := ==($t3, $t5)
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix10($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
  0: $t5 := infer($t0)
  1: $t6 := 2
  2: $t4 := %($t5, $t6)
  3: $t3 := *($t4, $t1)
  4: $t9 := infer($t0)
  5: $t10 := 3
  6: $t8 := %($t9, $t10)
  7: $t7 := *($t8, $t1)
  8: $t2 := >($t3, $t7)
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix2($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
  0: $t4 := infer($t0)
  1: $t6 := 2
  2: $t5 := *($t6, $t1)
  3: $t3 := +($t4, $t5)
  4: $t8 := infer($t0)
  5: $t10 := 3
  6: $t9 := *($t10, $t1)
  7: $t7 := +($t8, $t9)
  8: $t2 := <=($t3, $t7)
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix3($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
  0: $t4 := infer($t0)
  1: $t3 := -($t4, $t1)
  2: $t6 := infer($t1)
  3: $t5 := -($t6, $t0)
  4: $t2 := ==($t3, $t5)
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix4($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
  0: $t4 := infer($t0)
  1: $t6 := 2
  2: $t5 := *($t6, $t1)
  3: $t3 := -($t4, $t5)
  4: $t8 := infer($t0)
  5: $t10 := 3
  6: $t9 := *($t10, $t1)
  7: $t7 := -($t8, $t9)
  8: $t2 := >($t3, $t7)
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix5($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
  0: $t4 := infer($t0)
  1: $t3 := *($t4, $t1)
  2: $t6 := infer($t1)
  3: $t5 := *($t6, $t0)
  4: $t2 := ==($t3, $t5)
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix6($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
  0: $t5 := infer($t0)
  1: $t6 := 2
  2: $t4 := *($t5, $t6)
  3: $t3 := *($t4, $t1)
  4: $t9 := infer($t0)
  5: $t10 := 3
  6: $t8 := *($t9, $t10)
  7: $t7 := *($t8, $t1)
  8: $t2 := >($t3, $t7)
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix7($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
  0: $t4 := infer($t0)
  1: $t3 := /($t4, $t1)
  2: $t6 := infer($t1)
  3: $t5 := /($t6, $t0)
  4: $t2 := ==($t3, $t5)
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix8($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
  0: $t5 := infer($t0)
  1: $t6 := 2
  2: $t4 := /($t5, $t6)
  3: $t3 := *($t4, $t1)
  4: $t9 := infer($t0)
  5: $t10 := 3
  6: $t8 := /($t9, $t10)
  7: $t7 := *($t8, $t1)
  8: $t2 := >($t3, $t7)
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix9($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
  0: $t4 := infer($t0)
  1: $t3 := %($t4, $t1)
  2: $t6 := infer($t1)
  3: $t5 := %($t6, $t0)
  4: $t2 := ==($t3, $t5)
  5: return $t2
}

============ after AbortAnalysisProcessor: ================

[variant baseline]
fun valid_logic::test_cmp1($t0: i64): bool {
     var $t1: bool
     var $t2: bool
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: i64
     var $t8: i64
     var $t9: i64
     var $t10: i64
     var $t11: i64
     var $t12: &i64
     var $t13: &i64
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  0: $t7 := infer($t0)
     # abort state: {returns}
     # live vars: $t0, $t7
     # refs: []
     #
  1: $t6 := ==($t7, $t0)
     # abort state: {returns}
     # live vars: $t0, $t6
     # refs: []
     #
  2: if ($t6) goto 3 else goto 7
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  3: label L0
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  4: $t8 := infer($t0)
     # abort state: {returns}
     # live vars: $t0, $t8
     # refs: []
     #
  5: $t5 := >=($t8, $t0)
     # abort state: {returns}
     # live vars: $t0, $t5
     # refs: []
     #
  6: goto 9
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  7: label L1
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  8: $t5 := false
     # abort state: {returns}
     # live vars: $t0, $t5
     # refs: []
     #
  9: label L2
     # abort state: {returns}
     # live vars: $t0, $t5
     # refs: []
     #
 10: if ($t5) goto 11 else goto 15
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 11: label L3
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 12: $t9 := infer($t0)
     # abort state: {returns}
     # live vars: $t0, $t9
     # refs: []
     #
 13: $t4 := <=($t9, $t0)
     # abort state: {returns}
     # live vars: $t0, $t4
     # refs: []
     #
 14: goto 17
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 15: label L4
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 16: $t4 := false
     # abort state: {returns}
     # live vars: $t0, $t4
     # refs: []
     #
 17: label L5
     # abort state: {returns}
     # live vars: $t0, $t4
     # refs: []
     #
 18: if ($t4) goto 19 else goto 23
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 19: label L6
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 20: $t10 := infer($t0)
     # abort state: {returns}
     # live vars: $t0, $t10
     # refs: []
     #
 21: $t3 := >($t10, $t0)
     # abort state: {returns}
     # live vars: $t0, $t3
     # refs: []
     #
 22: goto 25
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 23: label L7
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 24: $t3 := false
     # abort state: {returns}
     # live vars: $t0, $t3
     # refs: []
     #
 25: label L8
     # abort state: {returns}
     # live vars: $t0, $t3
     # refs: []
     #
 26: if ($t3) goto 27 else goto 31
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 27: label L9
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 28: $t11 := infer($t0)
     # abort state: {returns}
     # live vars: $t0, $t11
     # refs: []
     #
 29: $t2 := <($t11, $t0)
     # abort state: {returns}
     # live vars: $t0, $t2
     # refs: []
     #
 30: goto 33
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 31: label L10
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 32: $t2 := false
     # abort state: {returns}
     # live vars: $t0, $t2
     # refs: []
     #
 33: label L11
     # abort state: {returns}
     # live vars: $t0, $t2
     # refs: []
     #
 34: if ($t2) goto 35 else goto 40
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 35: label L12
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 36: $t12 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t0, $t12
     # refs: [$t12 => #12]
     # #12
     #   <no edges>
     # #root
     #   => #12 via [local `x`] at line 27
     #
 37: $t13 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t12, $t13
     # refs: [$t12 => #12, $t13 => #13]
     # #12
     #   <no edges>
     # #13
     #   => #12 via [] at line 27
     # #root
     #   => #13 via [local `x`] at line 27
     #
 38: $t1 := ==($t12, $t13)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
 39: goto 42
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 40: label L13
     # abort state: {returns}
     # live vars:
     # refs: []
     #
 41: $t1 := false
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
 42: label L14
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
 43: return $t1
}


[variant baseline]
fun valid_logic::test_cmp2($t0: i128): bool {
     var $t1: bool
     var $t2: bool
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
     var $t11: i128
     var $t12: &i128
     var $t13: &i128
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  0: $t7 := infer($t0)
     # abort state: {returns}
     # live vars: $t0, $t7
     # refs: []
     #
  1: $t6 := ==($t7, $t0)
     # abort state: {returns}
     # live vars: $t0, $t6
     # refs: []
     #
  2: if ($t6) goto 3 else goto 7
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  3: label L0
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  4: $t8 := infer($t0)
     # abort state: {returns}
     # live vars: $t0, $t8
     # refs: []
     #
  5: $t5 := >=($t8, $t0)
     # abort state: {returns}
     # live vars: $t0, $t5
     # refs: []
     #
  6: goto 9
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  7: label L1
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  8: $t5 := false
     # abort state: {returns}
     # live vars: $t0, $t5
     # refs: []
     #
  9: label L2
     # abort state: {returns}
     # live vars: $t0, $t5
     # refs: []
     #
 10: if ($t5) goto 11 else goto 15
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 11: label L3
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 12: $t9 := infer($t0)
     # abort state: {returns}
     # live vars: $t0, $t9
     # refs: []
     #
 13: $t4 := <=($t9, $t0)
     # abort state: {returns}
     # live vars: $t0, $t4
     # refs: []
     #
 14: goto 17
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 15: label L4
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 16: $t4 := false
     # abort state: {returns}
     # live vars: $t0, $t4
     # refs: []
     #
 17: label L5
     # abort state: {returns}
     # live vars: $t0, $t4
     # refs: []
     #
 18: if ($t4) goto 19 else goto 23
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 19: label L6
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 20: $t10 := infer($t0)
     # abort state: {returns}
     # live vars: $t0, $t10
     # refs: []
     #
 21: $t3 := >($t10, $t0)
     # abort state: {returns}
     # live vars: $t0, $t3
     # refs: []
     #
 22: goto 25
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 23: label L7
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 24: $t3 := false
     # abort state: {returns}
     # live vars: $t0, $t3
     # refs: []
     #
 25: label L8
     # abort state: {returns}
     # live vars: $t0, $t3
     # refs: []
     #
 26: if ($t3) goto 27 else goto 31
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 27: label L9
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 28: $t11 := infer($t0)
     # abort state: {returns}
     # live vars: $t0, $t11
     # refs: []
     #
 29: $t2 := <($t11, $t0)
     # abort state: {returns}
     # live vars: $t0, $t2
     # refs: []
     #
 30: goto 33
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 31: label L10
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 32: $t2 := false
     # abort state: {returns}
     # live vars: $t0, $t2
     # refs: []
     #
 33: label L11
     # abort state: {returns}
     # live vars: $t0, $t2
     # refs: []
     #
 34: if ($t2) goto 35 else goto 40
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 35: label L12
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 36: $t12 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t0, $t12
     # refs: [$t12 => #12]
     # #12
     #   <no edges>
     # #root
     #   => #12 via [local `x`] at line 31
     #
 37: $t13 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t12, $t13
     # refs: [$t12 => #12, $t13 => #13]
     # #12
     #   <no edges>
     # #13
     #   => #12 via [] at line 31
     # #root
     #   => #13 via [local `x`] at line 31
     #
 38: $t1 := ==($t12, $t13)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
 39: goto 42
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 40: label L13
     # abort state: {returns}
     # live vars:
     # refs: []
     #
 41: $t1 := false
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
 42: label L14
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
 43: return $t1
}


[variant baseline]
fun valid_logic::test_cmp3($t0: 0x42::valid_logic::S1, $t1: 0x42::valid_logic::S2, $t2: 0x42::valid_logic::S3<i64>): bool {
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: bool
     var $t8: bool
     var $t9: bool
     var $t10: i64
     var $t11: &0x42::valid_logic::S1
     var $t12: &i64
     var $t13: i64
     var $t14: &0x42::valid_logic::S2
     var $t15: &i64
     var $t16: i64
     var $t17: &0x42::valid_logic::S1
     var $t18: &i64
     var $t19: i64
     var $t20: &0x42::valid_logic::S3<i64>
     var $t21: &i64
     var $t22: i64
     var $t23: &0x42::valid_logic::S2
     var $t24: &i64
     var $t25: i64
     var $t26: &0x42::valid_logic::S3<i64>
     var $t27: &i64
     var $t28: i64
     var $t29: &0x42::valid_logic::S3<i64>
     var $t30: &i64
     var $t31: i64
     var $t32: &0x42::valid_logic::S1
     var $t33: &i64
     var $t34: i64
     var $t35: &0x42::valid_logic::S3<i64>
     var $t36: &i64
     var $t37: i64
     var $t38: &0x42::valid_logic::S2
     var $t39: &i64
     var $t40: &i64
     var $t41: &0x42::valid_logic::S1
     var $t42: &i64
     var $t43: &0x42::valid_logic::S2
     var $t44: &i64
     var $t45: &0x42::valid_logic::S1
     var $t46: &i64
     var $t47: &0x42::valid_logic::S2
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
  0: $t11 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t11
     # refs: [$t11 => #11]
     # #11
     #   <no edges>
     # #root
     #   => #11 via [local `s1`] at line 35
     #
  1: $t12 := borrow_field<0x42::valid_logic::S1>.y($t11)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t12
     # refs: [$t12 => #12]
     # #12
     #   <no edges>
     # #root
     #   => #12 via [local `s1`, field `y`] at line 35
     #
  2: $t10 := read_ref($t12)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t10
     # refs: []
     #
  3: $t14 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t10, $t14
     # refs: [$t14 => #14]
     # #14
     #   <no edges>
     # #root
     #   => #14 via [local `s2`] at line 35
     #
  4: $t15 := borrow_field<0x42::valid_logic::S2>.y($t14)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t10, $t15
     # refs: [$t15 => #15]
     # #15
     #   <no edges>
     # #root
     #   => #15 via [local `s2`, field `y`] at line 35
     #
  5: $t13 := read_ref($t15)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t10, $t13
     # refs: []
     #
  6: $t9 := ==($t10, $t13)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t9
     # refs: []
     #
  7: if ($t9) goto 8 else goto 17
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
  8: label L0
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
  9: $t17 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t17
     # refs: [$t17 => #17]
     # #17
     #   <no edges>
     # #root
     #   => #17 via [local `s1`] at line 35
     #
 10: $t18 := borrow_field<0x42::valid_logic::S1>.y($t17)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t18
     # refs: [$t18 => #18]
     # #18
     #   <no edges>
     # #root
     #   => #18 via [local `s1`, field `y`] at line 35
     #
 11: $t16 := read_ref($t18)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t16
     # refs: []
     #
 12: $t20 := borrow_local($t2)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t16, $t20
     # refs: [$t20 => #20]
     # #20
     #   <no edges>
     # #root
     #   => #20 via [local `s3`] at line 35
     #
 13: $t21 := borrow_field<0x42::valid_logic::S3<i64>>.x($t20)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t16, $t21
     # refs: [$t21 => #21]
     # #21
     #   <no edges>
     # #root
     #   => #21 via [local `s3`, field `x`] at line 35
     #
 14: $t19 := read_ref($t21)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t16, $t19
     # refs: []
     #
 15: $t8 := <=($t16, $t19)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t8
     # refs: []
     #
 16: goto 19
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 17: label L1
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 18: $t8 := false
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t8
     # refs: []
     #
 19: label L2
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t8
     # refs: []
     #
 20: if ($t8) goto 21 else goto 30
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 21: label L3
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 22: $t23 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t23
     # refs: [$t23 => #23]
     # #23
     #   <no edges>
     # #root
     #   => #23 via [local `s2`] at line 35
     #
 23: $t24 := borrow_field<0x42::valid_logic::S2>.y($t23)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t24
     # refs: [$t24 => #24]
     # #24
     #   <no edges>
     # #root
     #   => #24 via [local `s2`, field `y`] at line 35
     #
 24: $t22 := read_ref($t24)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t22
     # refs: []
     #
 25: $t26 := borrow_local($t2)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t22, $t26
     # refs: [$t26 => #26]
     # #26
     #   <no edges>
     # #root
     #   => #26 via [local `s3`] at line 35
     #
 26: $t27 := borrow_field<0x42::valid_logic::S3<i64>>.x($t26)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t22, $t27
     # refs: [$t27 => #27]
     # #27
     #   <no edges>
     # #root
     #   => #27 via [local `s3`, field `x`] at line 35
     #
 27: $t25 := read_ref($t27)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t22, $t25
     # refs: []
     #
 28: $t7 := >=($t22, $t25)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t7
     # refs: []
     #
 29: goto 32
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 30: label L4
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 31: $t7 := false
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t7
     # refs: []
     #
 32: label L5
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t7
     # refs: []
     #
 33: if ($t7) goto 34 else goto 43
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 34: label L6
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 35: $t29 := borrow_local($t2)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t29
     # refs: [$t29 => #29]
     # #29
     #   <no edges>
     # #root
     #   => #29 via [local `s3`] at line 35
     #
 36: $t30 := borrow_field<0x42::valid_logic::S3<i64>>.x($t29)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t30
     # refs: [$t30 => #30]
     # #30
     #   <no edges>
     # #root
     #   => #30 via [local `s3`, field `x`] at line 35
     #
 37: $t28 := read_ref($t30)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t28
     # refs: []
     #
 38: $t32 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t28, $t32
     # refs: [$t32 => #32]
     # #32
     #   <no edges>
     # #root
     #   => #32 via [local `s1`] at line 35
     #
 39: $t33 := borrow_field<0x42::valid_logic::S1>.y($t32)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t28, $t33
     # refs: [$t33 => #33]
     # #33
     #   <no edges>
     # #root
     #   => #33 via [local `s1`, field `y`] at line 35
     #
 40: $t31 := read_ref($t33)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t28, $t31
     # refs: []
     #
 41: $t6 := >($t28, $t31)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t6
     # refs: []
     #
 42: goto 45
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 43: label L7
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 44: $t6 := false
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t6
     # refs: []
     #
 45: label L8
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t6
     # refs: []
     #
 46: if ($t6) goto 47 else goto 56
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 47: label L9
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 48: $t35 := borrow_local($t2)
     # abort state: {returns}
     # live vars: $t0, $t1, $t35
     # refs: [$t35 => #35]
     # #35
     #   <no edges>
     # #root
     #   => #35 via [local `s3`] at line 35
     #
 49: $t36 := borrow_field<0x42::valid_logic::S3<i64>>.x($t35)
     # abort state: {returns}
     # live vars: $t0, $t1, $t36
     # refs: [$t36 => #36]
     # #36
     #   <no edges>
     # #root
     #   => #36 via [local `s3`, field `x`] at line 35
     #
 50: $t34 := read_ref($t36)
     # abort state: {returns}
     # live vars: $t0, $t1, $t34
     # refs: []
     #
 51: $t38 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t0, $t1, $t34, $t38
     # refs: [$t38 => #38]
     # #38
     #   <no edges>
     # #root
     #   => #38 via [local `s2`] at line 35
     #
 52: $t39 := borrow_field<0x42::valid_logic::S2>.y($t38)
     # abort state: {returns}
     # live vars: $t0, $t1, $t34, $t39
     # refs: [$t39 => #39]
     # #39
     #   <no edges>
     # #root
     #   => #39 via [local `s2`, field `y`] at line 35
     #
 53: $t37 := read_ref($t39)
     # abort state: {returns}
     # live vars: $t0, $t1, $t34, $t37
     # refs: []
     #
 54: $t5 := <($t34, $t37)
     # abort state: {returns}
     # live vars: $t0, $t1, $t5
     # refs: []
     #
 55: goto 58
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 56: label L10
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 57: $t5 := false
     # abort state: {returns}
     # live vars: $t0, $t1, $t5
     # refs: []
     #
 58: label L11
     # abort state: {returns}
     # live vars: $t0, $t1, $t5
     # refs: []
     #
 59: if ($t5) goto 60 else goto 67
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 60: label L12
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 61: $t41 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t0, $t1, $t41
     # refs: [$t41 => #41]
     # #41
     #   <no edges>
     # #root
     #   => #41 via [local `s1`] at line 35
     #
 62: $t40 := borrow_field<0x42::valid_logic::S1>.y($t41)
     # abort state: {returns}
     # live vars: $t0, $t1, $t40
     # refs: [$t40 => #40]
     # #40
     #   <no edges>
     # #root
     #   => #40 via [local `s1`, field `y`] at line 35
     #
 63: $t43 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t0, $t1, $t40, $t43
     # refs: [$t40 => #40, $t43 => #43]
     # #40
     #   <no edges>
     # #43
     #   <no edges>
     # #root
     #   => #40 via [local `s1`, field `y`] at line 35
     #   => #43 via [local `s2`] at line 35
     #
 64: $t42 := borrow_field<0x42::valid_logic::S2>.y($t43)
     # abort state: {returns}
     # live vars: $t0, $t1, $t40, $t42
     # refs: [$t40 => #40, $t42 => #42]
     # #40
     #   <no edges>
     # #42
     #   <no edges>
     # #root
     #   => #40 via [local `s1`, field `y`] at line 35
     #   => #42 via [local `s2`, field `y`] at line 35
     #
 65: $t4 := ==($t40, $t42)
     # abort state: {returns}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
 66: goto 69
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 67: label L13
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 68: $t4 := false
     # abort state: {returns}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
 69: label L14
     # abort state: {returns}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
 70: if ($t4) goto 71 else goto 78
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 71: label L15
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 72: $t45 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t1, $t45
     # refs: [$t45 => #45]
     # #45
     #   <no edges>
     # #root
     #   => #45 via [local `s1`] at line 35
     #
 73: $t44 := borrow_field<0x42::valid_logic::S1>.y($t45)
     # abort state: {returns}
     # live vars: $t1, $t44
     # refs: [$t44 => #44]
     # #44
     #   <no edges>
     # #root
     #   => #44 via [local `s1`, field `y`] at line 35
     #
 74: $t47 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t44, $t47
     # refs: [$t44 => #44, $t47 => #47]
     # #44
     #   <no edges>
     # #47
     #   <no edges>
     # #root
     #   => #44 via [local `s1`, field `y`] at line 35
     #   => #47 via [local `s2`] at line 35
     #
 75: $t46 := borrow_field<0x42::valid_logic::S2>.y($t47)
     # abort state: {returns}
     # live vars: $t44, $t46
     # refs: [$t44 => #44, $t46 => #46]
     # #44
     #   <no edges>
     # #46
     #   <no edges>
     # #root
     #   => #44 via [local `s1`, field `y`] at line 35
     #   => #46 via [local `s2`, field `y`] at line 35
     #
 76: $t3 := ==($t44, $t46)
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 77: goto 80
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 78: label L16
     # abort state: {returns}
     # live vars:
     # refs: []
     #
 79: $t3 := false
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 80: label L17
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 81: return $t3
}


[variant baseline]
fun valid_logic::test_cmp4($t0: 0x42::valid_logic::S1, $t1: 0x42::valid_logic::S2, $t2: 0x42::valid_logic::S3<i128>): bool {
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: bool
     var $t8: bool
     var $t9: bool
     var $t10: i128
     var $t11: &0x42::valid_logic::S1
     var $t12: &i128
     var $t13: i128
     var $t14: &0x42::valid_logic::S2
     var $t15: &i128
     var $t16: i128
     var $t17: &0x42::valid_logic::S1
     var $t18: &i128
     var $t19: i128
     var $t20: &0x42::valid_logic::S3<i128>
     var $t21: &i128
     var $t22: i128
     var $t23: &0x42::valid_logic::S2
     var $t24: &i128
     var $t25: i128
     var $t26: &0x42::valid_logic::S3<i128>
     var $t27: &i128
     var $t28: i128
     var $t29: &0x42::valid_logic::S3<i128>
     var $t30: &i128
     var $t31: i128
     var $t32: &0x42::valid_logic::S1
     var $t33: &i128
     var $t34: i128
     var $t35: &0x42::valid_logic::S3<i128>
     var $t36: &i128
     var $t37: i128
     var $t38: &0x42::valid_logic::S2
     var $t39: &i128
     var $t40: &i128
     var $t41: &0x42::valid_logic::S1
     var $t42: &i128
     var $t43: &0x42::valid_logic::S2
     var $t44: &i128
     var $t45: &0x42::valid_logic::S1
     var $t46: &i128
     var $t47: &0x42::valid_logic::S2
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
  0: $t11 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t11
     # refs: [$t11 => #11]
     # #11
     #   <no edges>
     # #root
     #   => #11 via [local `s1`] at line 39
     #
  1: $t12 := borrow_field<0x42::valid_logic::S1>.z($t11)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t12
     # refs: [$t12 => #12]
     # #12
     #   <no edges>
     # #root
     #   => #12 via [local `s1`, field `z`] at line 39
     #
  2: $t10 := read_ref($t12)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t10
     # refs: []
     #
  3: $t14 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t10, $t14
     # refs: [$t14 => #14]
     # #14
     #   <no edges>
     # #root
     #   => #14 via [local `s2`] at line 39
     #
  4: $t15 := borrow_field<0x42::valid_logic::S2>.z($t14)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t10, $t15
     # refs: [$t15 => #15]
     # #15
     #   <no edges>
     # #root
     #   => #15 via [local `s2`, field `z`] at line 39
     #
  5: $t13 := read_ref($t15)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t10, $t13
     # refs: []
     #
  6: $t9 := ==($t10, $t13)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t9
     # refs: []
     #
  7: if ($t9) goto 8 else goto 17
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
  8: label L0
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
  9: $t17 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t17
     # refs: [$t17 => #17]
     # #17
     #   <no edges>
     # #root
     #   => #17 via [local `s1`] at line 39
     #
 10: $t18 := borrow_field<0x42::valid_logic::S1>.z($t17)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t18
     # refs: [$t18 => #18]
     # #18
     #   <no edges>
     # #root
     #   => #18 via [local `s1`, field `z`] at line 39
     #
 11: $t16 := read_ref($t18)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t16
     # refs: []
     #
 12: $t20 := borrow_local($t2)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t16, $t20
     # refs: [$t20 => #20]
     # #20
     #   <no edges>
     # #root
     #   => #20 via [local `s3`] at line 39
     #
 13: $t21 := borrow_field<0x42::valid_logic::S3<i128>>.x($t20)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t16, $t21
     # refs: [$t21 => #21]
     # #21
     #   <no edges>
     # #root
     #   => #21 via [local `s3`, field `x`] at line 39
     #
 14: $t19 := read_ref($t21)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t16, $t19
     # refs: []
     #
 15: $t8 := <=($t16, $t19)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t8
     # refs: []
     #
 16: goto 19
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 17: label L1
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 18: $t8 := false
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t8
     # refs: []
     #
 19: label L2
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t8
     # refs: []
     #
 20: if ($t8) goto 21 else goto 30
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 21: label L3
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 22: $t23 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t23
     # refs: [$t23 => #23]
     # #23
     #   <no edges>
     # #root
     #   => #23 via [local `s2`] at line 39
     #
 23: $t24 := borrow_field<0x42::valid_logic::S2>.z($t23)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t24
     # refs: [$t24 => #24]
     # #24
     #   <no edges>
     # #root
     #   => #24 via [local `s2`, field `z`] at line 39
     #
 24: $t22 := read_ref($t24)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t22
     # refs: []
     #
 25: $t26 := borrow_local($t2)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t22, $t26
     # refs: [$t26 => #26]
     # #26
     #   <no edges>
     # #root
     #   => #26 via [local `s3`] at line 39
     #
 26: $t27 := borrow_field<0x42::valid_logic::S3<i128>>.x($t26)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t22, $t27
     # refs: [$t27 => #27]
     # #27
     #   <no edges>
     # #root
     #   => #27 via [local `s3`, field `x`] at line 39
     #
 27: $t25 := read_ref($t27)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t22, $t25
     # refs: []
     #
 28: $t7 := >=($t22, $t25)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t7
     # refs: []
     #
 29: goto 32
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 30: label L4
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 31: $t7 := false
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t7
     # refs: []
     #
 32: label L5
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t7
     # refs: []
     #
 33: if ($t7) goto 34 else goto 43
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 34: label L6
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 35: $t29 := borrow_local($t2)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t29
     # refs: [$t29 => #29]
     # #29
     #   <no edges>
     # #root
     #   => #29 via [local `s3`] at line 39
     #
 36: $t30 := borrow_field<0x42::valid_logic::S3<i128>>.x($t29)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t30
     # refs: [$t30 => #30]
     # #30
     #   <no edges>
     # #root
     #   => #30 via [local `s3`, field `x`] at line 39
     #
 37: $t28 := read_ref($t30)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t28
     # refs: []
     #
 38: $t32 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t28, $t32
     # refs: [$t32 => #32]
     # #32
     #   <no edges>
     # #root
     #   => #32 via [local `s1`] at line 39
     #
 39: $t33 := borrow_field<0x42::valid_logic::S1>.z($t32)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t28, $t33
     # refs: [$t33 => #33]
     # #33
     #   <no edges>
     # #root
     #   => #33 via [local `s1`, field `z`] at line 39
     #
 40: $t31 := read_ref($t33)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t28, $t31
     # refs: []
     #
 41: $t6 := >($t28, $t31)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t6
     # refs: []
     #
 42: goto 45
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 43: label L7
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 44: $t6 := false
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t6
     # refs: []
     #
 45: label L8
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t6
     # refs: []
     #
 46: if ($t6) goto 47 else goto 56
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 47: label L9
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 48: $t35 := borrow_local($t2)
     # abort state: {returns}
     # live vars: $t0, $t1, $t35
     # refs: [$t35 => #35]
     # #35
     #   <no edges>
     # #root
     #   => #35 via [local `s3`] at line 39
     #
 49: $t36 := borrow_field<0x42::valid_logic::S3<i128>>.x($t35)
     # abort state: {returns}
     # live vars: $t0, $t1, $t36
     # refs: [$t36 => #36]
     # #36
     #   <no edges>
     # #root
     #   => #36 via [local `s3`, field `x`] at line 39
     #
 50: $t34 := read_ref($t36)
     # abort state: {returns}
     # live vars: $t0, $t1, $t34
     # refs: []
     #
 51: $t38 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t0, $t1, $t34, $t38
     # refs: [$t38 => #38]
     # #38
     #   <no edges>
     # #root
     #   => #38 via [local `s2`] at line 39
     #
 52: $t39 := borrow_field<0x42::valid_logic::S2>.z($t38)
     # abort state: {returns}
     # live vars: $t0, $t1, $t34, $t39
     # refs: [$t39 => #39]
     # #39
     #   <no edges>
     # #root
     #   => #39 via [local `s2`, field `z`] at line 39
     #
 53: $t37 := read_ref($t39)
     # abort state: {returns}
     # live vars: $t0, $t1, $t34, $t37
     # refs: []
     #
 54: $t5 := <($t34, $t37)
     # abort state: {returns}
     # live vars: $t0, $t1, $t5
     # refs: []
     #
 55: goto 58
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 56: label L10
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 57: $t5 := false
     # abort state: {returns}
     # live vars: $t0, $t1, $t5
     # refs: []
     #
 58: label L11
     # abort state: {returns}
     # live vars: $t0, $t1, $t5
     # refs: []
     #
 59: if ($t5) goto 60 else goto 67
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 60: label L12
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 61: $t41 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t0, $t1, $t41
     # refs: [$t41 => #41]
     # #41
     #   <no edges>
     # #root
     #   => #41 via [local `s1`] at line 39
     #
 62: $t40 := borrow_field<0x42::valid_logic::S1>.z($t41)
     # abort state: {returns}
     # live vars: $t0, $t1, $t40
     # refs: [$t40 => #40]
     # #40
     #   <no edges>
     # #root
     #   => #40 via [local `s1`, field `z`] at line 39
     #
 63: $t43 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t0, $t1, $t40, $t43
     # refs: [$t40 => #40, $t43 => #43]
     # #40
     #   <no edges>
     # #43
     #   <no edges>
     # #root
     #   => #40 via [local `s1`, field `z`] at line 39
     #   => #43 via [local `s2`] at line 39
     #
 64: $t42 := borrow_field<0x42::valid_logic::S2>.z($t43)
     # abort state: {returns}
     # live vars: $t0, $t1, $t40, $t42
     # refs: [$t40 => #40, $t42 => #42]
     # #40
     #   <no edges>
     # #42
     #   <no edges>
     # #root
     #   => #40 via [local `s1`, field `z`] at line 39
     #   => #42 via [local `s2`, field `z`] at line 39
     #
 65: $t4 := ==($t40, $t42)
     # abort state: {returns}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
 66: goto 69
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 67: label L13
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 68: $t4 := false
     # abort state: {returns}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
 69: label L14
     # abort state: {returns}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
 70: if ($t4) goto 71 else goto 78
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 71: label L15
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 72: $t45 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t1, $t45
     # refs: [$t45 => #45]
     # #45
     #   <no edges>
     # #root
     #   => #45 via [local `s1`] at line 39
     #
 73: $t44 := borrow_field<0x42::valid_logic::S1>.z($t45)
     # abort state: {returns}
     # live vars: $t1, $t44
     # refs: [$t44 => #44]
     # #44
     #   <no edges>
     # #root
     #   => #44 via [local `s1`, field `z`] at line 39
     #
 74: $t47 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t44, $t47
     # refs: [$t44 => #44, $t47 => #47]
     # #44
     #   <no edges>
     # #47
     #   <no edges>
     # #root
     #   => #44 via [local `s1`, field `z`] at line 39
     #   => #47 via [local `s2`] at line 39
     #
 75: $t46 := borrow_field<0x42::valid_logic::S2>.z($t47)
     # abort state: {returns}
     # live vars: $t44, $t46
     # refs: [$t44 => #44, $t46 => #46]
     # #44
     #   <no edges>
     # #46
     #   <no edges>
     # #root
     #   => #44 via [local `s1`, field `z`] at line 39
     #   => #46 via [local `s2`, field `z`] at line 39
     #
 76: $t3 := ==($t44, $t46)
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 77: goto 80
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 78: label L16
     # abort state: {returns}
     # live vars:
     # refs: []
     #
 79: $t3 := false
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 80: label L17
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 81: return $t3
}


[variant baseline]
fun valid_logic::test_mix1($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t4 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
  1: $t3 := +($t4, $t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t3
     # refs: []
     #
  2: $t6 := infer($t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t3, $t6
     # refs: []
     #
  3: $t5 := +($t6, $t0)
     # abort state: {returns}
     # live vars: $t3, $t5
     # refs: []
     #
  4: $t2 := ==($t3, $t5)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix10($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t5 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t5
     # refs: []
     #
  1: $t6 := 2
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t5, $t6
     # refs: []
     #
  2: $t4 := %($t5, $t6)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
  3: $t3 := *($t4, $t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t3
     # refs: []
     #
  4: $t9 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t9
     # refs: []
     #
  5: $t10 := 3
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t9, $t10
     # refs: []
     #
  6: $t8 := %($t9, $t10)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t8
     # refs: []
     #
  7: $t7 := *($t8, $t1)
     # abort state: {returns}
     # live vars: $t3, $t7
     # refs: []
     #
  8: $t2 := >($t3, $t7)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix2($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t4 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
  1: $t6 := 2
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t6
     # refs: []
     #
  2: $t5 := *($t6, $t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5
     # refs: []
     #
  3: $t3 := +($t4, $t5)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t3
     # refs: []
     #
  4: $t8 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t8
     # refs: []
     #
  5: $t10 := 3
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t8, $t10
     # refs: []
     #
  6: $t9 := *($t10, $t1)
     # abort state: {returns,aborts}
     # live vars: $t3, $t8, $t9
     # refs: []
     #
  7: $t7 := +($t8, $t9)
     # abort state: {returns}
     # live vars: $t3, $t7
     # refs: []
     #
  8: $t2 := <=($t3, $t7)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix3($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t4 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
  1: $t3 := -($t4, $t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t3
     # refs: []
     #
  2: $t6 := infer($t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t3, $t6
     # refs: []
     #
  3: $t5 := -($t6, $t0)
     # abort state: {returns}
     # live vars: $t3, $t5
     # refs: []
     #
  4: $t2 := ==($t3, $t5)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix4($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t4 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
  1: $t6 := 2
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t6
     # refs: []
     #
  2: $t5 := *($t6, $t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5
     # refs: []
     #
  3: $t3 := -($t4, $t5)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t3
     # refs: []
     #
  4: $t8 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t8
     # refs: []
     #
  5: $t10 := 3
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t8, $t10
     # refs: []
     #
  6: $t9 := *($t10, $t1)
     # abort state: {returns,aborts}
     # live vars: $t3, $t8, $t9
     # refs: []
     #
  7: $t7 := -($t8, $t9)
     # abort state: {returns}
     # live vars: $t3, $t7
     # refs: []
     #
  8: $t2 := >($t3, $t7)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix5($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t4 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
  1: $t3 := *($t4, $t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t3
     # refs: []
     #
  2: $t6 := infer($t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t3, $t6
     # refs: []
     #
  3: $t5 := *($t6, $t0)
     # abort state: {returns}
     # live vars: $t3, $t5
     # refs: []
     #
  4: $t2 := ==($t3, $t5)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix6($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t5 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t5
     # refs: []
     #
  1: $t6 := 2
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t5, $t6
     # refs: []
     #
  2: $t4 := *($t5, $t6)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
  3: $t3 := *($t4, $t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t3
     # refs: []
     #
  4: $t9 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t9
     # refs: []
     #
  5: $t10 := 3
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t9, $t10
     # refs: []
     #
  6: $t8 := *($t9, $t10)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t8
     # refs: []
     #
  7: $t7 := *($t8, $t1)
     # abort state: {returns}
     # live vars: $t3, $t7
     # refs: []
     #
  8: $t2 := >($t3, $t7)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix7($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t4 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
  1: $t3 := /($t4, $t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t3
     # refs: []
     #
  2: $t6 := infer($t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t3, $t6
     # refs: []
     #
  3: $t5 := /($t6, $t0)
     # abort state: {returns}
     # live vars: $t3, $t5
     # refs: []
     #
  4: $t2 := ==($t3, $t5)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix8($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t5 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t5
     # refs: []
     #
  1: $t6 := 2
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t5, $t6
     # refs: []
     #
  2: $t4 := /($t5, $t6)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
  3: $t3 := *($t4, $t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t3
     # refs: []
     #
  4: $t9 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t9
     # refs: []
     #
  5: $t10 := 3
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t9, $t10
     # refs: []
     #
  6: $t8 := /($t9, $t10)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t8
     # refs: []
     #
  7: $t7 := *($t8, $t1)
     # abort state: {returns}
     # live vars: $t3, $t7
     # refs: []
     #
  8: $t2 := >($t3, $t7)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix9($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t4 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
  1: $t3 := %($t4, $t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t3
     # refs: []
     #
  2: $t6 := infer($t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t3, $t6
     # refs: []
     #
  3: $t5 := %($t6, $t0)
     # abort state: {returns}
     # live vars: $t3, $t5
     # refs: []
     #
  4: $t2 := ==($t3, $t5)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  5: return $t2
}

// -- Model dump before second bytecode pipeline
module 0x42::valid_logic {
    enum E1 {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<i64>,
        }
    }
    enum E2 {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<i128>,
        }
    }
    enum E3<T> {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<T>,
        }
    }
    struct S1 {
        x: u64,
        y: i64,
        z: i128,
    }
    struct S2 {
        x: S1,
        y: i64,
        z: i128,
    }
    struct S3<T> {
        x: T,
        y: S1,
        z: S2,
    }
    private fun test_cmp1(x: i64): bool {
        And(And(And(And(And(Eq<i64>(x, x), Ge<i64>(x, x)), Le<i64>(x, x)), Gt<i64>(x, x)), Lt<i64>(x, x)), Eq<i64>(Borrow(Immutable)(x), Borrow(Immutable)(x)))
    }
    private fun test_cmp2(x: i128): bool {
        And(And(And(And(And(Eq<i128>(x, x), Ge<i128>(x, x)), Le<i128>(x, x)), Gt<i128>(x, x)), Lt<i128>(x, x)), Eq<i128>(Borrow(Immutable)(x), Borrow(Immutable)(x)))
    }
    private fun test_cmp3(s1: S1,s2: S2,s3: S3<i64>): bool {
        And(And(And(And(And(And(Eq<i64>(select valid_logic::S1.y<S1>(s1), select valid_logic::S2.y<S2>(s2)), Le<i64>(select valid_logic::S1.y<S1>(s1), select valid_logic::S3.x<S3<i64>>(s3))), Ge<i64>(select valid_logic::S2.y<S2>(s2), select valid_logic::S3.x<S3<i64>>(s3))), Gt<i64>(select valid_logic::S3.x<S3<i64>>(s3), select valid_logic::S1.y<S1>(s1))), Lt<i64>(select valid_logic::S3.x<S3<i64>>(s3), select valid_logic::S2.y<S2>(s2))), Eq<i64>(Borrow(Immutable)(select valid_logic::S1.y<S1>(s1)), Borrow(Immutable)(select valid_logic::S2.y<S2>(s2)))), Eq<i64>(Borrow(Immutable)(select valid_logic::S1.y<S1>(s1)), Borrow(Immutable)(select valid_logic::S2.y<S2>(s2))))
    }
    private fun test_cmp4(s1: S1,s2: S2,s3: S3<i128>): bool {
        And(And(And(And(And(And(Eq<i128>(select valid_logic::S1.z<S1>(s1), select valid_logic::S2.z<S2>(s2)), Le<i128>(select valid_logic::S1.z<S1>(s1), select valid_logic::S3.x<S3<i128>>(s3))), Ge<i128>(select valid_logic::S2.z<S2>(s2), select valid_logic::S3.x<S3<i128>>(s3))), Gt<i128>(select valid_logic::S3.x<S3<i128>>(s3), select valid_logic::S1.z<S1>(s1))), Lt<i128>(select valid_logic::S3.x<S3<i128>>(s3), select valid_logic::S2.z<S2>(s2))), Eq<i128>(Borrow(Immutable)(select valid_logic::S1.z<S1>(s1)), Borrow(Immutable)(select valid_logic::S2.z<S2>(s2)))), Eq<i128>(Borrow(Immutable)(select valid_logic::S1.z<S1>(s1)), Borrow(Immutable)(select valid_logic::S2.z<S2>(s2))))
    }
    private fun test_mix1(x: i64,y: i64): bool {
        Eq<i64>(Add<i64>(x, y), Add<i64>(y, x))
    }
    private fun test_mix10(x: i128,y: i128): bool {
        Gt<i128>(Mul<i128>(Mod<i128>(x, 2), y), Mul<i128>(Mod<i128>(x, 3), y))
    }
    private fun test_mix2(x: i128,y: i128): bool {
        Le<i128>(Add<i128>(x, Mul<i128>(2, y)), Add<i128>(x, Mul<i128>(3, y)))
    }
    private fun test_mix3(x: i64,y: i64): bool {
        Eq<i64>(Sub<i64>(x, y), Sub<i64>(y, x))
    }
    private fun test_mix4(x: i128,y: i128): bool {
        Gt<i128>(Sub<i128>(x, Mul<i128>(2, y)), Sub<i128>(x, Mul<i128>(3, y)))
    }
    private fun test_mix5(x: i64,y: i64): bool {
        Eq<i64>(Mul<i64>(x, y), Mul<i64>(y, x))
    }
    private fun test_mix6(x: i128,y: i128): bool {
        Gt<i128>(Mul<i128>(Mul<i128>(x, 2), y), Mul<i128>(Mul<i128>(x, 3), y))
    }
    private fun test_mix7(x: i64,y: i64): bool {
        Eq<i64>(Div<i64>(x, y), Div<i64>(y, x))
    }
    private fun test_mix8(x: i128,y: i128): bool {
        Gt<i128>(Mul<i128>(Div<i128>(x, 2), y), Mul<i128>(Div<i128>(x, 3), y))
    }
    private fun test_mix9(x: i64,y: i64): bool {
        Eq<i64>(Mod<i64>(x, y), Mod<i64>(y, x))
    }
} // end 0x42::valid_logic

============ bytecode before second stackless bytecode pipeline ================

[variant baseline]
fun valid_logic::test_cmp1($t0: i64): bool {
     var $t1: bool
     var $t2: bool
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: i64
     var $t8: i64
     var $t9: i64
     var $t10: i64
     var $t11: i64
     var $t12: &i64
     var $t13: &i64
  0: $t7 := infer($t0)
  1: $t6 := ==($t7, $t0)
  2: if ($t6) goto 3 else goto 7
  3: label L0
  4: $t8 := infer($t0)
  5: $t5 := >=($t8, $t0)
  6: goto 9
  7: label L1
  8: $t5 := false
  9: label L2
 10: if ($t5) goto 11 else goto 15
 11: label L3
 12: $t9 := infer($t0)
 13: $t4 := <=($t9, $t0)
 14: goto 17
 15: label L4
 16: $t4 := false
 17: label L5
 18: if ($t4) goto 19 else goto 23
 19: label L6
 20: $t10 := infer($t0)
 21: $t3 := >($t10, $t0)
 22: goto 25
 23: label L7
 24: $t3 := false
 25: label L8
 26: if ($t3) goto 27 else goto 31
 27: label L9
 28: $t11 := infer($t0)
 29: $t2 := <($t11, $t0)
 30: goto 33
 31: label L10
 32: $t2 := false
 33: label L11
 34: if ($t2) goto 35 else goto 40
 35: label L12
 36: $t12 := borrow_local($t0)
 37: $t13 := borrow_local($t0)
 38: $t1 := ==($t12, $t13)
 39: goto 42
 40: label L13
 41: $t1 := false
 42: label L14
 43: return $t1
}


[variant baseline]
fun valid_logic::test_cmp2($t0: i128): bool {
     var $t1: bool
     var $t2: bool
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
     var $t11: i128
     var $t12: &i128
     var $t13: &i128
  0: $t7 := infer($t0)
  1: $t6 := ==($t7, $t0)
  2: if ($t6) goto 3 else goto 7
  3: label L0
  4: $t8 := infer($t0)
  5: $t5 := >=($t8, $t0)
  6: goto 9
  7: label L1
  8: $t5 := false
  9: label L2
 10: if ($t5) goto 11 else goto 15
 11: label L3
 12: $t9 := infer($t0)
 13: $t4 := <=($t9, $t0)
 14: goto 17
 15: label L4
 16: $t4 := false
 17: label L5
 18: if ($t4) goto 19 else goto 23
 19: label L6
 20: $t10 := infer($t0)
 21: $t3 := >($t10, $t0)
 22: goto 25
 23: label L7
 24: $t3 := false
 25: label L8
 26: if ($t3) goto 27 else goto 31
 27: label L9
 28: $t11 := infer($t0)
 29: $t2 := <($t11, $t0)
 30: goto 33
 31: label L10
 32: $t2 := false
 33: label L11
 34: if ($t2) goto 35 else goto 40
 35: label L12
 36: $t12 := borrow_local($t0)
 37: $t13 := borrow_local($t0)
 38: $t1 := ==($t12, $t13)
 39: goto 42
 40: label L13
 41: $t1 := false
 42: label L14
 43: return $t1
}


[variant baseline]
fun valid_logic::test_cmp3($t0: 0x42::valid_logic::S1, $t1: 0x42::valid_logic::S2, $t2: 0x42::valid_logic::S3<i64>): bool {
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: bool
     var $t8: bool
     var $t9: bool
     var $t10: i64
     var $t11: &0x42::valid_logic::S1
     var $t12: &i64
     var $t13: i64
     var $t14: &0x42::valid_logic::S2
     var $t15: &i64
     var $t16: i64
     var $t17: &0x42::valid_logic::S1
     var $t18: &i64
     var $t19: i64
     var $t20: &0x42::valid_logic::S3<i64>
     var $t21: &i64
     var $t22: i64
     var $t23: &0x42::valid_logic::S2
     var $t24: &i64
     var $t25: i64
     var $t26: &0x42::valid_logic::S3<i64>
     var $t27: &i64
     var $t28: i64
     var $t29: &0x42::valid_logic::S3<i64>
     var $t30: &i64
     var $t31: i64
     var $t32: &0x42::valid_logic::S1
     var $t33: &i64
     var $t34: i64
     var $t35: &0x42::valid_logic::S3<i64>
     var $t36: &i64
     var $t37: i64
     var $t38: &0x42::valid_logic::S2
     var $t39: &i64
     var $t40: &i64
     var $t41: &0x42::valid_logic::S1
     var $t42: &i64
     var $t43: &0x42::valid_logic::S2
     var $t44: &i64
     var $t45: &0x42::valid_logic::S1
     var $t46: &i64
     var $t47: &0x42::valid_logic::S2
  0: $t11 := borrow_local($t0)
  1: $t12 := borrow_field<0x42::valid_logic::S1>.y($t11)
  2: $t10 := read_ref($t12)
  3: $t14 := borrow_local($t1)
  4: $t15 := borrow_field<0x42::valid_logic::S2>.y($t14)
  5: $t13 := read_ref($t15)
  6: $t9 := ==($t10, $t13)
  7: if ($t9) goto 8 else goto 17
  8: label L0
  9: $t17 := borrow_local($t0)
 10: $t18 := borrow_field<0x42::valid_logic::S1>.y($t17)
 11: $t16 := read_ref($t18)
 12: $t20 := borrow_local($t2)
 13: $t21 := borrow_field<0x42::valid_logic::S3<i64>>.x($t20)
 14: $t19 := read_ref($t21)
 15: $t8 := <=($t16, $t19)
 16: goto 19
 17: label L1
 18: $t8 := false
 19: label L2
 20: if ($t8) goto 21 else goto 30
 21: label L3
 22: $t23 := borrow_local($t1)
 23: $t24 := borrow_field<0x42::valid_logic::S2>.y($t23)
 24: $t22 := read_ref($t24)
 25: $t26 := borrow_local($t2)
 26: $t27 := borrow_field<0x42::valid_logic::S3<i64>>.x($t26)
 27: $t25 := read_ref($t27)
 28: $t7 := >=($t22, $t25)
 29: goto 32
 30: label L4
 31: $t7 := false
 32: label L5
 33: if ($t7) goto 34 else goto 43
 34: label L6
 35: $t29 := borrow_local($t2)
 36: $t30 := borrow_field<0x42::valid_logic::S3<i64>>.x($t29)
 37: $t28 := read_ref($t30)
 38: $t32 := borrow_local($t0)
 39: $t33 := borrow_field<0x42::valid_logic::S1>.y($t32)
 40: $t31 := read_ref($t33)
 41: $t6 := >($t28, $t31)
 42: goto 45
 43: label L7
 44: $t6 := false
 45: label L8
 46: if ($t6) goto 47 else goto 56
 47: label L9
 48: $t35 := borrow_local($t2)
 49: $t36 := borrow_field<0x42::valid_logic::S3<i64>>.x($t35)
 50: $t34 := read_ref($t36)
 51: $t38 := borrow_local($t1)
 52: $t39 := borrow_field<0x42::valid_logic::S2>.y($t38)
 53: $t37 := read_ref($t39)
 54: $t5 := <($t34, $t37)
 55: goto 58
 56: label L10
 57: $t5 := false
 58: label L11
 59: if ($t5) goto 60 else goto 67
 60: label L12
 61: $t41 := borrow_local($t0)
 62: $t40 := borrow_field<0x42::valid_logic::S1>.y($t41)
 63: $t43 := borrow_local($t1)
 64: $t42 := borrow_field<0x42::valid_logic::S2>.y($t43)
 65: $t4 := ==($t40, $t42)
 66: goto 69
 67: label L13
 68: $t4 := false
 69: label L14
 70: if ($t4) goto 71 else goto 78
 71: label L15
 72: $t45 := borrow_local($t0)
 73: $t44 := borrow_field<0x42::valid_logic::S1>.y($t45)
 74: $t47 := borrow_local($t1)
 75: $t46 := borrow_field<0x42::valid_logic::S2>.y($t47)
 76: $t3 := ==($t44, $t46)
 77: goto 80
 78: label L16
 79: $t3 := false
 80: label L17
 81: return $t3
}


[variant baseline]
fun valid_logic::test_cmp4($t0: 0x42::valid_logic::S1, $t1: 0x42::valid_logic::S2, $t2: 0x42::valid_logic::S3<i128>): bool {
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: bool
     var $t8: bool
     var $t9: bool
     var $t10: i128
     var $t11: &0x42::valid_logic::S1
     var $t12: &i128
     var $t13: i128
     var $t14: &0x42::valid_logic::S2
     var $t15: &i128
     var $t16: i128
     var $t17: &0x42::valid_logic::S1
     var $t18: &i128
     var $t19: i128
     var $t20: &0x42::valid_logic::S3<i128>
     var $t21: &i128
     var $t22: i128
     var $t23: &0x42::valid_logic::S2
     var $t24: &i128
     var $t25: i128
     var $t26: &0x42::valid_logic::S3<i128>
     var $t27: &i128
     var $t28: i128
     var $t29: &0x42::valid_logic::S3<i128>
     var $t30: &i128
     var $t31: i128
     var $t32: &0x42::valid_logic::S1
     var $t33: &i128
     var $t34: i128
     var $t35: &0x42::valid_logic::S3<i128>
     var $t36: &i128
     var $t37: i128
     var $t38: &0x42::valid_logic::S2
     var $t39: &i128
     var $t40: &i128
     var $t41: &0x42::valid_logic::S1
     var $t42: &i128
     var $t43: &0x42::valid_logic::S2
     var $t44: &i128
     var $t45: &0x42::valid_logic::S1
     var $t46: &i128
     var $t47: &0x42::valid_logic::S2
  0: $t11 := borrow_local($t0)
  1: $t12 := borrow_field<0x42::valid_logic::S1>.z($t11)
  2: $t10 := read_ref($t12)
  3: $t14 := borrow_local($t1)
  4: $t15 := borrow_field<0x42::valid_logic::S2>.z($t14)
  5: $t13 := read_ref($t15)
  6: $t9 := ==($t10, $t13)
  7: if ($t9) goto 8 else goto 17
  8: label L0
  9: $t17 := borrow_local($t0)
 10: $t18 := borrow_field<0x42::valid_logic::S1>.z($t17)
 11: $t16 := read_ref($t18)
 12: $t20 := borrow_local($t2)
 13: $t21 := borrow_field<0x42::valid_logic::S3<i128>>.x($t20)
 14: $t19 := read_ref($t21)
 15: $t8 := <=($t16, $t19)
 16: goto 19
 17: label L1
 18: $t8 := false
 19: label L2
 20: if ($t8) goto 21 else goto 30
 21: label L3
 22: $t23 := borrow_local($t1)
 23: $t24 := borrow_field<0x42::valid_logic::S2>.z($t23)
 24: $t22 := read_ref($t24)
 25: $t26 := borrow_local($t2)
 26: $t27 := borrow_field<0x42::valid_logic::S3<i128>>.x($t26)
 27: $t25 := read_ref($t27)
 28: $t7 := >=($t22, $t25)
 29: goto 32
 30: label L4
 31: $t7 := false
 32: label L5
 33: if ($t7) goto 34 else goto 43
 34: label L6
 35: $t29 := borrow_local($t2)
 36: $t30 := borrow_field<0x42::valid_logic::S3<i128>>.x($t29)
 37: $t28 := read_ref($t30)
 38: $t32 := borrow_local($t0)
 39: $t33 := borrow_field<0x42::valid_logic::S1>.z($t32)
 40: $t31 := read_ref($t33)
 41: $t6 := >($t28, $t31)
 42: goto 45
 43: label L7
 44: $t6 := false
 45: label L8
 46: if ($t6) goto 47 else goto 56
 47: label L9
 48: $t35 := borrow_local($t2)
 49: $t36 := borrow_field<0x42::valid_logic::S3<i128>>.x($t35)
 50: $t34 := read_ref($t36)
 51: $t38 := borrow_local($t1)
 52: $t39 := borrow_field<0x42::valid_logic::S2>.z($t38)
 53: $t37 := read_ref($t39)
 54: $t5 := <($t34, $t37)
 55: goto 58
 56: label L10
 57: $t5 := false
 58: label L11
 59: if ($t5) goto 60 else goto 67
 60: label L12
 61: $t41 := borrow_local($t0)
 62: $t40 := borrow_field<0x42::valid_logic::S1>.z($t41)
 63: $t43 := borrow_local($t1)
 64: $t42 := borrow_field<0x42::valid_logic::S2>.z($t43)
 65: $t4 := ==($t40, $t42)
 66: goto 69
 67: label L13
 68: $t4 := false
 69: label L14
 70: if ($t4) goto 71 else goto 78
 71: label L15
 72: $t45 := borrow_local($t0)
 73: $t44 := borrow_field<0x42::valid_logic::S1>.z($t45)
 74: $t47 := borrow_local($t1)
 75: $t46 := borrow_field<0x42::valid_logic::S2>.z($t47)
 76: $t3 := ==($t44, $t46)
 77: goto 80
 78: label L16
 79: $t3 := false
 80: label L17
 81: return $t3
}


[variant baseline]
fun valid_logic::test_mix1($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
  0: $t4 := infer($t0)
  1: $t3 := +($t4, $t1)
  2: $t6 := infer($t1)
  3: $t5 := +($t6, $t0)
  4: $t2 := ==($t3, $t5)
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix10($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
  0: $t5 := infer($t0)
  1: $t6 := 2
  2: $t4 := %($t5, $t6)
  3: $t3 := *($t4, $t1)
  4: $t9 := infer($t0)
  5: $t10 := 3
  6: $t8 := %($t9, $t10)
  7: $t7 := *($t8, $t1)
  8: $t2 := >($t3, $t7)
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix2($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
  0: $t4 := infer($t0)
  1: $t6 := 2
  2: $t5 := *($t6, $t1)
  3: $t3 := +($t4, $t5)
  4: $t8 := infer($t0)
  5: $t10 := 3
  6: $t9 := *($t10, $t1)
  7: $t7 := +($t8, $t9)
  8: $t2 := <=($t3, $t7)
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix3($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
  0: $t4 := infer($t0)
  1: $t3 := -($t4, $t1)
  2: $t6 := infer($t1)
  3: $t5 := -($t6, $t0)
  4: $t2 := ==($t3, $t5)
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix4($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
  0: $t4 := infer($t0)
  1: $t6 := 2
  2: $t5 := *($t6, $t1)
  3: $t3 := -($t4, $t5)
  4: $t8 := infer($t0)
  5: $t10 := 3
  6: $t9 := *($t10, $t1)
  7: $t7 := -($t8, $t9)
  8: $t2 := >($t3, $t7)
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix5($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
  0: $t4 := infer($t0)
  1: $t3 := *($t4, $t1)
  2: $t6 := infer($t1)
  3: $t5 := *($t6, $t0)
  4: $t2 := ==($t3, $t5)
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix6($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
  0: $t5 := infer($t0)
  1: $t6 := 2
  2: $t4 := *($t5, $t6)
  3: $t3 := *($t4, $t1)
  4: $t9 := infer($t0)
  5: $t10 := 3
  6: $t8 := *($t9, $t10)
  7: $t7 := *($t8, $t1)
  8: $t2 := >($t3, $t7)
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix7($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
  0: $t4 := infer($t0)
  1: $t3 := /($t4, $t1)
  2: $t6 := infer($t1)
  3: $t5 := /($t6, $t0)
  4: $t2 := ==($t3, $t5)
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix8($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
  0: $t5 := infer($t0)
  1: $t6 := 2
  2: $t4 := /($t5, $t6)
  3: $t3 := *($t4, $t1)
  4: $t9 := infer($t0)
  5: $t10 := 3
  6: $t8 := /($t9, $t10)
  7: $t7 := *($t8, $t1)
  8: $t2 := >($t3, $t7)
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix9($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
  0: $t4 := infer($t0)
  1: $t3 := %($t4, $t1)
  2: $t6 := infer($t1)
  3: $t5 := %($t6, $t0)
  4: $t2 := ==($t3, $t5)
  5: return $t2
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
fun valid_logic::test_cmp1($t0: i64): bool {
     var $t1: bool
     var $t2: bool
     var $t3: bool
     var $t4: bool
     var $t5: bool [unused]
     var $t6: bool
     var $t7: i64
     var $t8: i64 [unused]
     var $t9: i64 [unused]
     var $t10: i64 [unused]
     var $t11: i64 [unused]
     var $t12: &i64
     var $t13: &i64
     # live vars: $t0
  0: $t7 := copy($t0)
     # live vars: $t0, $t7
  1: $t6 := ==($t7, $t0)
     # live vars: $t0, $t6
  2: if ($t6) goto 3 else goto 41
     # live vars: $t0
  3: label L0
     # live vars: $t0
  4: $t7 := copy($t0)
     # live vars: $t0, $t7
  5: $t6 := >=($t7, $t0)
     # live vars: $t0, $t6
  6: label L2
     # live vars: $t0, $t6
  7: if ($t6) goto 8 else goto 38
     # live vars: $t0
  8: label L3
     # live vars: $t0
  9: $t7 := copy($t0)
     # live vars: $t0, $t7
 10: $t4 := <=($t7, $t0)
     # live vars: $t0, $t4
 11: label L5
     # live vars: $t0, $t4
 12: if ($t4) goto 13 else goto 35
     # live vars: $t0
 13: label L6
     # live vars: $t0
 14: $t7 := copy($t0)
     # live vars: $t0, $t7
 15: $t3 := >($t7, $t0)
     # live vars: $t0, $t3
 16: label L8
     # live vars: $t0, $t3
 17: if ($t3) goto 18 else goto 32
     # live vars: $t0
 18: label L9
     # live vars: $t0
 19: $t7 := copy($t0)
     # live vars: $t0, $t7
 20: $t2 := <($t7, $t0)
     # live vars: $t0, $t2
 21: label L11
     # live vars: $t0, $t2
 22: if ($t2) goto 23 else goto 29
     # live vars: $t0
 23: label L12
     # live vars: $t0
 24: $t12 := borrow_local($t0)
     # live vars: $t0, $t12
 25: $t13 := borrow_local($t0)
     # live vars: $t12, $t13
 26: $t1 := ==($t12, $t13)
     # live vars: $t1
 27: label L14
     # live vars: $t1
 28: return $t1
     # live vars: $t0
 29: label L13
     # live vars:
 30: $t1 := false
     # live vars: $t1
 31: goto 27
     # live vars: $t0
 32: label L10
     # live vars: $t0
 33: $t2 := false
     # live vars: $t0, $t2
 34: goto 21
     # live vars: $t0
 35: label L7
     # live vars: $t0
 36: $t3 := false
     # live vars: $t0, $t3
 37: goto 16
     # live vars: $t0
 38: label L4
     # live vars: $t0
 39: $t4 := false
     # live vars: $t0, $t4
 40: goto 11
     # live vars: $t0
 41: label L1
     # live vars: $t0
 42: $t6 := false
     # live vars: $t0, $t6
 43: goto 6
}


[variant baseline]
fun valid_logic::test_cmp2($t0: i128): bool {
     var $t1: bool
     var $t2: bool
     var $t3: bool
     var $t4: bool
     var $t5: bool [unused]
     var $t6: bool
     var $t7: i128
     var $t8: i128 [unused]
     var $t9: i128 [unused]
     var $t10: i128 [unused]
     var $t11: i128 [unused]
     var $t12: &i128
     var $t13: &i128
     # live vars: $t0
  0: $t7 := copy($t0)
     # live vars: $t0, $t7
  1: $t6 := ==($t7, $t0)
     # live vars: $t0, $t6
  2: if ($t6) goto 3 else goto 41
     # live vars: $t0
  3: label L0
     # live vars: $t0
  4: $t7 := copy($t0)
     # live vars: $t0, $t7
  5: $t6 := >=($t7, $t0)
     # live vars: $t0, $t6
  6: label L2
     # live vars: $t0, $t6
  7: if ($t6) goto 8 else goto 38
     # live vars: $t0
  8: label L3
     # live vars: $t0
  9: $t7 := copy($t0)
     # live vars: $t0, $t7
 10: $t4 := <=($t7, $t0)
     # live vars: $t0, $t4
 11: label L5
     # live vars: $t0, $t4
 12: if ($t4) goto 13 else goto 35
     # live vars: $t0
 13: label L6
     # live vars: $t0
 14: $t7 := copy($t0)
     # live vars: $t0, $t7
 15: $t3 := >($t7, $t0)
     # live vars: $t0, $t3
 16: label L8
     # live vars: $t0, $t3
 17: if ($t3) goto 18 else goto 32
     # live vars: $t0
 18: label L9
     # live vars: $t0
 19: $t7 := copy($t0)
     # live vars: $t0, $t7
 20: $t2 := <($t7, $t0)
     # live vars: $t0, $t2
 21: label L11
     # live vars: $t0, $t2
 22: if ($t2) goto 23 else goto 29
     # live vars: $t0
 23: label L12
     # live vars: $t0
 24: $t12 := borrow_local($t0)
     # live vars: $t0, $t12
 25: $t13 := borrow_local($t0)
     # live vars: $t12, $t13
 26: $t1 := ==($t12, $t13)
     # live vars: $t1
 27: label L14
     # live vars: $t1
 28: return $t1
     # live vars: $t0
 29: label L13
     # live vars:
 30: $t1 := false
     # live vars: $t1
 31: goto 27
     # live vars: $t0
 32: label L10
     # live vars: $t0
 33: $t2 := false
     # live vars: $t0, $t2
 34: goto 21
     # live vars: $t0
 35: label L7
     # live vars: $t0
 36: $t3 := false
     # live vars: $t0, $t3
 37: goto 16
     # live vars: $t0
 38: label L4
     # live vars: $t0
 39: $t4 := false
     # live vars: $t0, $t4
 40: goto 11
     # live vars: $t0
 41: label L1
     # live vars: $t0
 42: $t6 := false
     # live vars: $t0, $t6
 43: goto 6
}


[variant baseline]
fun valid_logic::test_cmp3($t0: 0x42::valid_logic::S1, $t1: 0x42::valid_logic::S2, $t2: 0x42::valid_logic::S3<i64>): bool {
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: bool
     var $t8: bool [unused]
     var $t9: bool
     var $t10: i64
     var $t11: &0x42::valid_logic::S1
     var $t12: &i64
     var $t13: i64
     var $t14: &0x42::valid_logic::S2
     var $t15: &i64 [unused]
     var $t16: i64 [unused]
     var $t17: &0x42::valid_logic::S1 [unused]
     var $t18: &i64 [unused]
     var $t19: i64 [unused]
     var $t20: &0x42::valid_logic::S3<i64>
     var $t21: &i64 [unused]
     var $t22: i64 [unused]
     var $t23: &0x42::valid_logic::S2 [unused]
     var $t24: &i64 [unused]
     var $t25: i64 [unused]
     var $t26: &0x42::valid_logic::S3<i64> [unused]
     var $t27: &i64 [unused]
     var $t28: i64 [unused]
     var $t29: &0x42::valid_logic::S3<i64> [unused]
     var $t30: &i64 [unused]
     var $t31: i64 [unused]
     var $t32: &0x42::valid_logic::S1 [unused]
     var $t33: &i64 [unused]
     var $t34: i64 [unused]
     var $t35: &0x42::valid_logic::S3<i64> [unused]
     var $t36: &i64 [unused]
     var $t37: i64 [unused]
     var $t38: &0x42::valid_logic::S2 [unused]
     var $t39: &i64 [unused]
     var $t40: &i64 [unused]
     var $t41: &0x42::valid_logic::S1 [unused]
     var $t42: &i64
     var $t43: &0x42::valid_logic::S2 [unused]
     var $t44: &i64 [unused]
     var $t45: &0x42::valid_logic::S1 [unused]
     var $t46: &i64 [unused]
     var $t47: &0x42::valid_logic::S2 [unused]
     # live vars: $t0, $t1, $t2
  0: $t11 := borrow_local($t0)
     # live vars: $t0, $t1, $t2, $t11
  1: $t12 := borrow_field<0x42::valid_logic::S1>.y($t11)
     # live vars: $t0, $t1, $t2, $t12
  2: $t10 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10
  3: $t14 := borrow_local($t1)
     # live vars: $t0, $t1, $t2, $t10, $t14
  4: $t12 := borrow_field<0x42::valid_logic::S2>.y($t14)
     # live vars: $t0, $t1, $t2, $t10, $t12
  5: $t13 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10, $t13
  6: $t9 := ==($t10, $t13)
     # live vars: $t0, $t1, $t2, $t9
  7: if ($t9) goto 8 else goto 79
     # live vars: $t0, $t1, $t2
  8: label L0
     # live vars: $t0, $t1, $t2
  9: $t11 := borrow_local($t0)
     # live vars: $t0, $t1, $t2, $t11
 10: $t12 := borrow_field<0x42::valid_logic::S1>.y($t11)
     # live vars: $t0, $t1, $t2, $t12
 11: $t10 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10
 12: $t20 := borrow_local($t2)
     # live vars: $t0, $t1, $t2, $t10, $t20
 13: $t12 := borrow_field<0x42::valid_logic::S3<i64>>.x($t20)
     # live vars: $t0, $t1, $t2, $t10, $t12
 14: $t13 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10, $t13
 15: $t9 := <=($t10, $t13)
     # live vars: $t0, $t1, $t2, $t9
 16: label L2
     # live vars: $t0, $t1, $t2, $t9
 17: if ($t9) goto 18 else goto 76
     # live vars: $t0, $t1, $t2
 18: label L3
     # live vars: $t0, $t1, $t2
 19: $t14 := borrow_local($t1)
     # live vars: $t0, $t1, $t2, $t14
 20: $t12 := borrow_field<0x42::valid_logic::S2>.y($t14)
     # live vars: $t0, $t1, $t2, $t12
 21: $t10 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10
 22: $t20 := borrow_local($t2)
     # live vars: $t0, $t1, $t2, $t10, $t20
 23: $t12 := borrow_field<0x42::valid_logic::S3<i64>>.x($t20)
     # live vars: $t0, $t1, $t2, $t10, $t12
 24: $t13 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10, $t13
 25: $t7 := >=($t10, $t13)
     # live vars: $t0, $t1, $t2, $t7
 26: label L5
     # live vars: $t0, $t1, $t2, $t7
 27: if ($t7) goto 28 else goto 73
     # live vars: $t0, $t1, $t2
 28: label L6
     # live vars: $t0, $t1, $t2
 29: $t20 := borrow_local($t2)
     # live vars: $t0, $t1, $t2, $t20
 30: $t12 := borrow_field<0x42::valid_logic::S3<i64>>.x($t20)
     # live vars: $t0, $t1, $t2, $t12
 31: $t10 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10
 32: $t11 := borrow_local($t0)
     # live vars: $t0, $t1, $t2, $t10, $t11
 33: $t12 := borrow_field<0x42::valid_logic::S1>.y($t11)
     # live vars: $t0, $t1, $t2, $t10, $t12
 34: $t13 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10, $t13
 35: $t6 := >($t10, $t13)
     # live vars: $t0, $t1, $t2, $t6
 36: label L8
     # live vars: $t0, $t1, $t2, $t6
 37: if ($t6) goto 38 else goto 70
     # live vars: $t0, $t1, $t2
 38: label L9
     # live vars: $t0, $t1, $t2
 39: $t20 := borrow_local($t2)
     # live vars: $t0, $t1, $t20
 40: $t12 := borrow_field<0x42::valid_logic::S3<i64>>.x($t20)
     # live vars: $t0, $t1, $t12
 41: $t10 := read_ref($t12)
     # live vars: $t0, $t1, $t10
 42: $t14 := borrow_local($t1)
     # live vars: $t0, $t1, $t10, $t14
 43: $t12 := borrow_field<0x42::valid_logic::S2>.y($t14)
     # live vars: $t0, $t1, $t10, $t12
 44: $t13 := read_ref($t12)
     # live vars: $t0, $t1, $t10, $t13
 45: $t5 := <($t10, $t13)
     # live vars: $t0, $t1, $t5
 46: label L11
     # live vars: $t0, $t1, $t5
 47: if ($t5) goto 48 else goto 67
     # live vars: $t0, $t1
 48: label L12
     # live vars: $t0, $t1
 49: $t11 := borrow_local($t0)
     # live vars: $t0, $t1, $t11
 50: $t12 := borrow_field<0x42::valid_logic::S1>.y($t11)
     # live vars: $t0, $t1, $t12
 51: $t14 := borrow_local($t1)
     # live vars: $t0, $t1, $t12, $t14
 52: $t42 := borrow_field<0x42::valid_logic::S2>.y($t14)
     # live vars: $t0, $t1, $t12, $t42
 53: $t4 := ==($t12, $t42)
     # live vars: $t0, $t1, $t4
 54: label L14
     # live vars: $t0, $t1, $t4
 55: if ($t4) goto 56 else goto 64
     # live vars: $t0, $t1
 56: label L15
     # live vars: $t0, $t1
 57: $t11 := borrow_local($t0)
     # live vars: $t1, $t11
 58: $t12 := borrow_field<0x42::valid_logic::S1>.y($t11)
     # live vars: $t1, $t12
 59: $t14 := borrow_local($t1)
     # live vars: $t12, $t14
 60: $t42 := borrow_field<0x42::valid_logic::S2>.y($t14)
     # live vars: $t12, $t42
 61: $t3 := ==($t12, $t42)
     # live vars: $t3
 62: label L17
     # live vars: $t3
 63: return $t3
     # live vars: $t0, $t1
 64: label L16
     # live vars:
 65: $t3 := false
     # live vars: $t3
 66: goto 62
     # live vars: $t0, $t1
 67: label L13
     # live vars: $t0, $t1
 68: $t4 := false
     # live vars: $t0, $t1, $t4
 69: goto 54
     # live vars: $t0, $t1, $t2
 70: label L10
     # live vars: $t0, $t1
 71: $t5 := false
     # live vars: $t0, $t1, $t5
 72: goto 46
     # live vars: $t0, $t1, $t2
 73: label L7
     # live vars: $t0, $t1, $t2
 74: $t6 := false
     # live vars: $t0, $t1, $t2, $t6
 75: goto 36
     # live vars: $t0, $t1, $t2
 76: label L4
     # live vars: $t0, $t1, $t2
 77: $t7 := false
     # live vars: $t0, $t1, $t2, $t7
 78: goto 26
     # live vars: $t0, $t1, $t2
 79: label L1
     # live vars: $t0, $t1, $t2
 80: $t9 := false
     # live vars: $t0, $t1, $t2, $t9
 81: goto 16
}


[variant baseline]
fun valid_logic::test_cmp4($t0: 0x42::valid_logic::S1, $t1: 0x42::valid_logic::S2, $t2: 0x42::valid_logic::S3<i128>): bool {
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: bool
     var $t8: bool [unused]
     var $t9: bool
     var $t10: i128
     var $t11: &0x42::valid_logic::S1
     var $t12: &i128
     var $t13: i128
     var $t14: &0x42::valid_logic::S2
     var $t15: &i128 [unused]
     var $t16: i128 [unused]
     var $t17: &0x42::valid_logic::S1 [unused]
     var $t18: &i128 [unused]
     var $t19: i128 [unused]
     var $t20: &0x42::valid_logic::S3<i128>
     var $t21: &i128 [unused]
     var $t22: i128 [unused]
     var $t23: &0x42::valid_logic::S2 [unused]
     var $t24: &i128 [unused]
     var $t25: i128 [unused]
     var $t26: &0x42::valid_logic::S3<i128> [unused]
     var $t27: &i128 [unused]
     var $t28: i128 [unused]
     var $t29: &0x42::valid_logic::S3<i128> [unused]
     var $t30: &i128 [unused]
     var $t31: i128 [unused]
     var $t32: &0x42::valid_logic::S1 [unused]
     var $t33: &i128 [unused]
     var $t34: i128 [unused]
     var $t35: &0x42::valid_logic::S3<i128> [unused]
     var $t36: &i128 [unused]
     var $t37: i128 [unused]
     var $t38: &0x42::valid_logic::S2 [unused]
     var $t39: &i128 [unused]
     var $t40: &i128 [unused]
     var $t41: &0x42::valid_logic::S1 [unused]
     var $t42: &i128
     var $t43: &0x42::valid_logic::S2 [unused]
     var $t44: &i128 [unused]
     var $t45: &0x42::valid_logic::S1 [unused]
     var $t46: &i128 [unused]
     var $t47: &0x42::valid_logic::S2 [unused]
     # live vars: $t0, $t1, $t2
  0: $t11 := borrow_local($t0)
     # live vars: $t0, $t1, $t2, $t11
  1: $t12 := borrow_field<0x42::valid_logic::S1>.z($t11)
     # live vars: $t0, $t1, $t2, $t12
  2: $t10 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10
  3: $t14 := borrow_local($t1)
     # live vars: $t0, $t1, $t2, $t10, $t14
  4: $t12 := borrow_field<0x42::valid_logic::S2>.z($t14)
     # live vars: $t0, $t1, $t2, $t10, $t12
  5: $t13 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10, $t13
  6: $t9 := ==($t10, $t13)
     # live vars: $t0, $t1, $t2, $t9
  7: if ($t9) goto 8 else goto 79
     # live vars: $t0, $t1, $t2
  8: label L0
     # live vars: $t0, $t1, $t2
  9: $t11 := borrow_local($t0)
     # live vars: $t0, $t1, $t2, $t11
 10: $t12 := borrow_field<0x42::valid_logic::S1>.z($t11)
     # live vars: $t0, $t1, $t2, $t12
 11: $t10 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10
 12: $t20 := borrow_local($t2)
     # live vars: $t0, $t1, $t2, $t10, $t20
 13: $t12 := borrow_field<0x42::valid_logic::S3<i128>>.x($t20)
     # live vars: $t0, $t1, $t2, $t10, $t12
 14: $t13 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10, $t13
 15: $t9 := <=($t10, $t13)
     # live vars: $t0, $t1, $t2, $t9
 16: label L2
     # live vars: $t0, $t1, $t2, $t9
 17: if ($t9) goto 18 else goto 76
     # live vars: $t0, $t1, $t2
 18: label L3
     # live vars: $t0, $t1, $t2
 19: $t14 := borrow_local($t1)
     # live vars: $t0, $t1, $t2, $t14
 20: $t12 := borrow_field<0x42::valid_logic::S2>.z($t14)
     # live vars: $t0, $t1, $t2, $t12
 21: $t10 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10
 22: $t20 := borrow_local($t2)
     # live vars: $t0, $t1, $t2, $t10, $t20
 23: $t12 := borrow_field<0x42::valid_logic::S3<i128>>.x($t20)
     # live vars: $t0, $t1, $t2, $t10, $t12
 24: $t13 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10, $t13
 25: $t7 := >=($t10, $t13)
     # live vars: $t0, $t1, $t2, $t7
 26: label L5
     # live vars: $t0, $t1, $t2, $t7
 27: if ($t7) goto 28 else goto 73
     # live vars: $t0, $t1, $t2
 28: label L6
     # live vars: $t0, $t1, $t2
 29: $t20 := borrow_local($t2)
     # live vars: $t0, $t1, $t2, $t20
 30: $t12 := borrow_field<0x42::valid_logic::S3<i128>>.x($t20)
     # live vars: $t0, $t1, $t2, $t12
 31: $t10 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10
 32: $t11 := borrow_local($t0)
     # live vars: $t0, $t1, $t2, $t10, $t11
 33: $t12 := borrow_field<0x42::valid_logic::S1>.z($t11)
     # live vars: $t0, $t1, $t2, $t10, $t12
 34: $t13 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10, $t13
 35: $t6 := >($t10, $t13)
     # live vars: $t0, $t1, $t2, $t6
 36: label L8
     # live vars: $t0, $t1, $t2, $t6
 37: if ($t6) goto 38 else goto 70
     # live vars: $t0, $t1, $t2
 38: label L9
     # live vars: $t0, $t1, $t2
 39: $t20 := borrow_local($t2)
     # live vars: $t0, $t1, $t20
 40: $t12 := borrow_field<0x42::valid_logic::S3<i128>>.x($t20)
     # live vars: $t0, $t1, $t12
 41: $t10 := read_ref($t12)
     # live vars: $t0, $t1, $t10
 42: $t14 := borrow_local($t1)
     # live vars: $t0, $t1, $t10, $t14
 43: $t12 := borrow_field<0x42::valid_logic::S2>.z($t14)
     # live vars: $t0, $t1, $t10, $t12
 44: $t13 := read_ref($t12)
     # live vars: $t0, $t1, $t10, $t13
 45: $t5 := <($t10, $t13)
     # live vars: $t0, $t1, $t5
 46: label L11
     # live vars: $t0, $t1, $t5
 47: if ($t5) goto 48 else goto 67
     # live vars: $t0, $t1
 48: label L12
     # live vars: $t0, $t1
 49: $t11 := borrow_local($t0)
     # live vars: $t0, $t1, $t11
 50: $t12 := borrow_field<0x42::valid_logic::S1>.z($t11)
     # live vars: $t0, $t1, $t12
 51: $t14 := borrow_local($t1)
     # live vars: $t0, $t1, $t12, $t14
 52: $t42 := borrow_field<0x42::valid_logic::S2>.z($t14)
     # live vars: $t0, $t1, $t12, $t42
 53: $t4 := ==($t12, $t42)
     # live vars: $t0, $t1, $t4
 54: label L14
     # live vars: $t0, $t1, $t4
 55: if ($t4) goto 56 else goto 64
     # live vars: $t0, $t1
 56: label L15
     # live vars: $t0, $t1
 57: $t11 := borrow_local($t0)
     # live vars: $t1, $t11
 58: $t12 := borrow_field<0x42::valid_logic::S1>.z($t11)
     # live vars: $t1, $t12
 59: $t14 := borrow_local($t1)
     # live vars: $t12, $t14
 60: $t42 := borrow_field<0x42::valid_logic::S2>.z($t14)
     # live vars: $t12, $t42
 61: $t3 := ==($t12, $t42)
     # live vars: $t3
 62: label L17
     # live vars: $t3
 63: return $t3
     # live vars: $t0, $t1
 64: label L16
     # live vars:
 65: $t3 := false
     # live vars: $t3
 66: goto 62
     # live vars: $t0, $t1
 67: label L13
     # live vars: $t0, $t1
 68: $t4 := false
     # live vars: $t0, $t1, $t4
 69: goto 54
     # live vars: $t0, $t1, $t2
 70: label L10
     # live vars: $t0, $t1
 71: $t5 := false
     # live vars: $t0, $t1, $t5
 72: goto 46
     # live vars: $t0, $t1, $t2
 73: label L7
     # live vars: $t0, $t1, $t2
 74: $t6 := false
     # live vars: $t0, $t1, $t2, $t6
 75: goto 36
     # live vars: $t0, $t1, $t2
 76: label L4
     # live vars: $t0, $t1, $t2
 77: $t7 := false
     # live vars: $t0, $t1, $t2, $t7
 78: goto 26
     # live vars: $t0, $t1, $t2
 79: label L1
     # live vars: $t0, $t1, $t2
 80: $t9 := false
     # live vars: $t0, $t1, $t2, $t9
 81: goto 16
}


[variant baseline]
fun valid_logic::test_mix1($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64 [unused]
     var $t4: i64
     var $t5: i64 [unused]
     var $t6: i64 [unused]
     # live vars: $t0, $t1
  0: $t4 := copy($t0)
     # live vars: $t0, $t1, $t4
  1: $t4 := +($t4, $t1)
     # live vars: $t0, $t1, $t4
  2: $t1 := move($t1)
     # live vars: $t0, $t1, $t4
  3: $t0 := +($t1, $t0)
     # live vars: $t0, $t4
  4: $t2 := ==($t4, $t0)
     # live vars: $t2
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix10($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128 [unused]
     var $t4: i128 [unused]
     var $t5: i128
     var $t6: i128
     var $t7: i128 [unused]
     var $t8: i128 [unused]
     var $t9: i128 [unused]
     var $t10: i128 [unused]
     # live vars: $t0, $t1
  0: $t5 := copy($t0)
     # live vars: $t0, $t1, $t5
  1: $t6 := 2
     # live vars: $t0, $t1, $t5, $t6
  2: $t5 := %($t5, $t6)
     # live vars: $t0, $t1, $t5
  3: $t5 := *($t5, $t1)
     # live vars: $t0, $t1, $t5
  4: $t0 := move($t0)
     # live vars: $t0, $t1, $t5
  5: $t6 := 3
     # live vars: $t0, $t1, $t5, $t6
  6: $t0 := %($t0, $t6)
     # live vars: $t0, $t1, $t5
  7: $t0 := *($t0, $t1)
     # live vars: $t0, $t5
  8: $t2 := >($t5, $t0)
     # live vars: $t2
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix2($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128 [unused]
     var $t4: i128
     var $t5: i128 [unused]
     var $t6: i128
     var $t7: i128 [unused]
     var $t8: i128 [unused]
     var $t9: i128 [unused]
     var $t10: i128 [unused]
     # live vars: $t0, $t1
  0: $t4 := copy($t0)
     # live vars: $t0, $t1, $t4
  1: $t6 := 2
     # live vars: $t0, $t1, $t4, $t6
  2: $t6 := *($t6, $t1)
     # live vars: $t0, $t1, $t4, $t6
  3: $t4 := +($t4, $t6)
     # live vars: $t0, $t1, $t4
  4: $t0 := move($t0)
     # live vars: $t0, $t1, $t4
  5: $t6 := 3
     # live vars: $t0, $t1, $t4, $t6
  6: $t1 := *($t6, $t1)
     # live vars: $t0, $t1, $t4
  7: $t0 := +($t0, $t1)
     # live vars: $t0, $t4
  8: $t2 := <=($t4, $t0)
     # live vars: $t2
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix3($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64 [unused]
     var $t4: i64
     var $t5: i64 [unused]
     var $t6: i64 [unused]
     # live vars: $t0, $t1
  0: $t4 := copy($t0)
     # live vars: $t0, $t1, $t4
  1: $t4 := -($t4, $t1)
     # live vars: $t0, $t1, $t4
  2: $t1 := move($t1)
     # live vars: $t0, $t1, $t4
  3: $t0 := -($t1, $t0)
     # live vars: $t0, $t4
  4: $t2 := ==($t4, $t0)
     # live vars: $t2
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix4($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128 [unused]
     var $t4: i128
     var $t5: i128 [unused]
     var $t6: i128
     var $t7: i128 [unused]
     var $t8: i128 [unused]
     var $t9: i128 [unused]
     var $t10: i128 [unused]
     # live vars: $t0, $t1
  0: $t4 := copy($t0)
     # live vars: $t0, $t1, $t4
  1: $t6 := 2
     # live vars: $t0, $t1, $t4, $t6
  2: $t6 := *($t6, $t1)
     # live vars: $t0, $t1, $t4, $t6
  3: $t4 := -($t4, $t6)
     # live vars: $t0, $t1, $t4
  4: $t0 := move($t0)
     # live vars: $t0, $t1, $t4
  5: $t6 := 3
     # live vars: $t0, $t1, $t4, $t6
  6: $t1 := *($t6, $t1)
     # live vars: $t0, $t1, $t4
  7: $t0 := -($t0, $t1)
     # live vars: $t0, $t4
  8: $t2 := >($t4, $t0)
     # live vars: $t2
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix5($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64 [unused]
     var $t4: i64
     var $t5: i64 [unused]
     var $t6: i64 [unused]
     # live vars: $t0, $t1
  0: $t4 := copy($t0)
     # live vars: $t0, $t1, $t4
  1: $t4 := *($t4, $t1)
     # live vars: $t0, $t1, $t4
  2: $t1 := move($t1)
     # live vars: $t0, $t1, $t4
  3: $t0 := *($t1, $t0)
     # live vars: $t0, $t4
  4: $t2 := ==($t4, $t0)
     # live vars: $t2
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix6($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128 [unused]
     var $t4: i128 [unused]
     var $t5: i128
     var $t6: i128
     var $t7: i128 [unused]
     var $t8: i128 [unused]
     var $t9: i128 [unused]
     var $t10: i128 [unused]
     # live vars: $t0, $t1
  0: $t5 := copy($t0)
     # live vars: $t0, $t1, $t5
  1: $t6 := 2
     # live vars: $t0, $t1, $t5, $t6
  2: $t5 := *($t5, $t6)
     # live vars: $t0, $t1, $t5
  3: $t5 := *($t5, $t1)
     # live vars: $t0, $t1, $t5
  4: $t0 := move($t0)
     # live vars: $t0, $t1, $t5
  5: $t6 := 3
     # live vars: $t0, $t1, $t5, $t6
  6: $t0 := *($t0, $t6)
     # live vars: $t0, $t1, $t5
  7: $t0 := *($t0, $t1)
     # live vars: $t0, $t5
  8: $t2 := >($t5, $t0)
     # live vars: $t2
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix7($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64 [unused]
     var $t4: i64
     var $t5: i64 [unused]
     var $t6: i64 [unused]
     # live vars: $t0, $t1
  0: $t4 := copy($t0)
     # live vars: $t0, $t1, $t4
  1: $t4 := /($t4, $t1)
     # live vars: $t0, $t1, $t4
  2: $t1 := move($t1)
     # live vars: $t0, $t1, $t4
  3: $t0 := /($t1, $t0)
     # live vars: $t0, $t4
  4: $t2 := ==($t4, $t0)
     # live vars: $t2
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix8($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128 [unused]
     var $t4: i128 [unused]
     var $t5: i128
     var $t6: i128
     var $t7: i128 [unused]
     var $t8: i128 [unused]
     var $t9: i128 [unused]
     var $t10: i128 [unused]
     # live vars: $t0, $t1
  0: $t5 := copy($t0)
     # live vars: $t0, $t1, $t5
  1: $t6 := 2
     # live vars: $t0, $t1, $t5, $t6
  2: $t5 := /($t5, $t6)
     # live vars: $t0, $t1, $t5
  3: $t5 := *($t5, $t1)
     # live vars: $t0, $t1, $t5
  4: $t0 := move($t0)
     # live vars: $t0, $t1, $t5
  5: $t6 := 3
     # live vars: $t0, $t1, $t5, $t6
  6: $t0 := /($t0, $t6)
     # live vars: $t0, $t1, $t5
  7: $t0 := *($t0, $t1)
     # live vars: $t0, $t5
  8: $t2 := >($t5, $t0)
     # live vars: $t2
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix9($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64 [unused]
     var $t4: i64
     var $t5: i64 [unused]
     var $t6: i64 [unused]
     # live vars: $t0, $t1
  0: $t4 := copy($t0)
     # live vars: $t0, $t1, $t4
  1: $t4 := %($t4, $t1)
     # live vars: $t0, $t1, $t4
  2: $t1 := move($t1)
     # live vars: $t0, $t1, $t4
  3: $t0 := %($t1, $t0)
     # live vars: $t0, $t4
  4: $t2 := ==($t4, $t0)
     # live vars: $t2
  5: return $t2
}


============ disassembled file-format ==================
// Move bytecode v9
module 42.valid_logic {
enum E1 has copy, drop {
 V1{
	s: S1
 },
 V2{
	s: S2
 },
 V3{
	s: S3<i64>
 }
}
enum E2 has copy, drop {
 V1{
	s: S1
 },
 V2{
	s: S2
 },
 V3{
	s: S3<i128>
 }
}
enum E3<T> has copy, drop {
 V1{
	s: S1
 },
 V2{
	s: S2
 },
 V3{
	s: S3<T>
 }
}
struct S1 has copy, drop {
	x: u64,
	y: i64,
	z: i128
}
struct S2 has copy, drop {
	x: S1,
	y: i64,
	z: i128
}
struct S3<T> has copy, drop {
	x: T,
	y: S1,
	z: S2
}

test_cmp1(x: i64): bool /* def_idx: 0 */ {
L1:	$t6: bool
L2:	$t4: bool
L3:	$t3: bool
L4:	$t2: bool
L5:	return: bool
B0:
	0: CopyLoc[0](x: i64)
	1: CopyLoc[0](x: i64)
	2: Eq
	3: BrFalse(46)
B1:
	4: CopyLoc[0](x: i64)
	5: CopyLoc[0](x: i64)
	6: Ge
	7: StLoc[1]($t6: bool)
B2:
	8: MoveLoc[1]($t6: bool)
	9: BrFalse(43)
B3:
	10: CopyLoc[0](x: i64)
	11: CopyLoc[0](x: i64)
	12: Le
	13: StLoc[2]($t4: bool)
B4:
	14: MoveLoc[2]($t4: bool)
	15: BrFalse(40)
B5:
	16: CopyLoc[0](x: i64)
	17: CopyLoc[0](x: i64)
	18: Gt
	19: StLoc[3]($t3: bool)
B6:
	20: MoveLoc[3]($t3: bool)
	21: BrFalse(37)
B7:
	22: CopyLoc[0](x: i64)
	23: CopyLoc[0](x: i64)
	24: Lt
	25: StLoc[4]($t2: bool)
B8:
	26: MoveLoc[4]($t2: bool)
	27: BrFalse(34)
B9:
	28: ImmBorrowLoc[0](x: i64)
	29: ImmBorrowLoc[0](x: i64)
	30: Eq
	31: StLoc[5](return: bool)
B10:
	32: MoveLoc[5](return: bool)
	33: Ret
B11:
	34: LdFalse
	35: StLoc[5](return: bool)
	36: Branch(32)
B12:
	37: LdFalse
	38: StLoc[4]($t2: bool)
	39: Branch(26)
B13:
	40: LdFalse
	41: StLoc[3]($t3: bool)
	42: Branch(20)
B14:
	43: LdFalse
	44: StLoc[2]($t4: bool)
	45: Branch(14)
B15:
	46: LdFalse
	47: StLoc[1]($t6: bool)
	48: Branch(8)
}
test_cmp2(x: i128): bool /* def_idx: 1 */ {
L1:	$t6: bool
L2:	$t4: bool
L3:	$t3: bool
L4:	$t2: bool
L5:	return: bool
B0:
	0: CopyLoc[0](x: i128)
	1: CopyLoc[0](x: i128)
	2: Eq
	3: BrFalse(46)
B1:
	4: CopyLoc[0](x: i128)
	5: CopyLoc[0](x: i128)
	6: Ge
	7: StLoc[1]($t6: bool)
B2:
	8: MoveLoc[1]($t6: bool)
	9: BrFalse(43)
B3:
	10: CopyLoc[0](x: i128)
	11: CopyLoc[0](x: i128)
	12: Le
	13: StLoc[2]($t4: bool)
B4:
	14: MoveLoc[2]($t4: bool)
	15: BrFalse(40)
B5:
	16: CopyLoc[0](x: i128)
	17: CopyLoc[0](x: i128)
	18: Gt
	19: StLoc[3]($t3: bool)
B6:
	20: MoveLoc[3]($t3: bool)
	21: BrFalse(37)
B7:
	22: CopyLoc[0](x: i128)
	23: CopyLoc[0](x: i128)
	24: Lt
	25: StLoc[4]($t2: bool)
B8:
	26: MoveLoc[4]($t2: bool)
	27: BrFalse(34)
B9:
	28: ImmBorrowLoc[0](x: i128)
	29: ImmBorrowLoc[0](x: i128)
	30: Eq
	31: StLoc[5](return: bool)
B10:
	32: MoveLoc[5](return: bool)
	33: Ret
B11:
	34: LdFalse
	35: StLoc[5](return: bool)
	36: Branch(32)
B12:
	37: LdFalse
	38: StLoc[4]($t2: bool)
	39: Branch(26)
B13:
	40: LdFalse
	41: StLoc[3]($t3: bool)
	42: Branch(20)
B14:
	43: LdFalse
	44: StLoc[2]($t4: bool)
	45: Branch(14)
B15:
	46: LdFalse
	47: StLoc[1]($t6: bool)
	48: Branch(8)
}
test_cmp3(s1: S1, s2: S2, s3: S3<i64>): bool /* def_idx: 2 */ {
L3:	$t9: bool
L4:	$t7: bool
L5:	$t6: bool
L6:	$t5: bool
L7:	$t4: bool
L8:	return: bool
B0:
	0: ImmBorrowLoc[0](s1: S1)
	1: ImmBorrowField[0](S1.y: i64)
	2: ReadRef
	3: ImmBorrowLoc[1](s2: S2)
	4: ImmBorrowField[1](S2.y: i64)
	5: ReadRef
	6: Eq
	7: BrFalse(79)
B1:
	8: ImmBorrowLoc[0](s1: S1)
	9: ImmBorrowField[0](S1.y: i64)
	10: ReadRef
	11: ImmBorrowLoc[2](s3: S3<i64>)
	12: ImmBorrowFieldGeneric[0](S3.x: T)
	13: ReadRef
	14: Le
	15: StLoc[3]($t9: bool)
B2:
	16: MoveLoc[3]($t9: bool)
	17: BrFalse(76)
B3:
	18: ImmBorrowLoc[1](s2: S2)
	19: ImmBorrowField[1](S2.y: i64)
	20: ReadRef
	21: ImmBorrowLoc[2](s3: S3<i64>)
	22: ImmBorrowFieldGeneric[0](S3.x: T)
	23: ReadRef
	24: Ge
	25: StLoc[4]($t7: bool)
B4:
	26: MoveLoc[4]($t7: bool)
	27: BrFalse(73)
B5:
	28: ImmBorrowLoc[2](s3: S3<i64>)
	29: ImmBorrowFieldGeneric[0](S3.x: T)
	30: ReadRef
	31: ImmBorrowLoc[0](s1: S1)
	32: ImmBorrowField[0](S1.y: i64)
	33: ReadRef
	34: Gt
	35: StLoc[5]($t6: bool)
B6:
	36: MoveLoc[5]($t6: bool)
	37: BrFalse(70)
B7:
	38: ImmBorrowLoc[2](s3: S3<i64>)
	39: ImmBorrowFieldGeneric[0](S3.x: T)
	40: ReadRef
	41: ImmBorrowLoc[1](s2: S2)
	42: ImmBorrowField[1](S2.y: i64)
	43: ReadRef
	44: Lt
	45: StLoc[6]($t5: bool)
B8:
	46: MoveLoc[6]($t5: bool)
	47: BrFalse(67)
B9:
	48: ImmBorrowLoc[0](s1: S1)
	49: ImmBorrowField[0](S1.y: i64)
	50: ImmBorrowLoc[1](s2: S2)
	51: ImmBorrowField[1](S2.y: i64)
	52: Eq
	53: StLoc[7]($t4: bool)
B10:
	54: MoveLoc[7]($t4: bool)
	55: BrFalse(64)
B11:
	56: ImmBorrowLoc[0](s1: S1)
	57: ImmBorrowField[0](S1.y: i64)
	58: ImmBorrowLoc[1](s2: S2)
	59: ImmBorrowField[1](S2.y: i64)
	60: Eq
	61: StLoc[8](return: bool)
B12:
	62: MoveLoc[8](return: bool)
	63: Ret
B13:
	64: LdFalse
	65: StLoc[8](return: bool)
	66: Branch(62)
B14:
	67: LdFalse
	68: StLoc[7]($t4: bool)
	69: Branch(54)
B15:
	70: LdFalse
	71: StLoc[6]($t5: bool)
	72: Branch(46)
B16:
	73: LdFalse
	74: StLoc[5]($t6: bool)
	75: Branch(36)
B17:
	76: LdFalse
	77: StLoc[4]($t7: bool)
	78: Branch(26)
B18:
	79: LdFalse
	80: StLoc[3]($t9: bool)
	81: Branch(16)
}
test_cmp4(s1: S1, s2: S2, s3: S3<i128>): bool /* def_idx: 3 */ {
L3:	$t9: bool
L4:	$t7: bool
L5:	$t6: bool
L6:	$t5: bool
L7:	$t4: bool
L8:	return: bool
B0:
	0: ImmBorrowLoc[0](s1: S1)
	1: ImmBorrowField[3](S1.z: i128)
	2: ReadRef
	3: ImmBorrowLoc[1](s2: S2)
	4: ImmBorrowField[4](S2.z: i128)
	5: ReadRef
	6: Eq
	7: BrFalse(79)
B1:
	8: ImmBorrowLoc[0](s1: S1)
	9: ImmBorrowField[3](S1.z: i128)
	10: ReadRef
	11: ImmBorrowLoc[2](s3: S3<i128>)
	12: ImmBorrowFieldGeneric[1](S3.x: T)
	13: ReadRef
	14: Le
	15: StLoc[3]($t9: bool)
B2:
	16: MoveLoc[3]($t9: bool)
	17: BrFalse(76)
B3:
	18: ImmBorrowLoc[1](s2: S2)
	19: ImmBorrowField[4](S2.z: i128)
	20: ReadRef
	21: ImmBorrowLoc[2](s3: S3<i128>)
	22: ImmBorrowFieldGeneric[1](S3.x: T)
	23: ReadRef
	24: Ge
	25: StLoc[4]($t7: bool)
B4:
	26: MoveLoc[4]($t7: bool)
	27: BrFalse(73)
B5:
	28: ImmBorrowLoc[2](s3: S3<i128>)
	29: ImmBorrowFieldGeneric[1](S3.x: T)
	30: ReadRef
	31: ImmBorrowLoc[0](s1: S1)
	32: ImmBorrowField[3](S1.z: i128)
	33: ReadRef
	34: Gt
	35: StLoc[5]($t6: bool)
B6:
	36: MoveLoc[5]($t6: bool)
	37: BrFalse(70)
B7:
	38: ImmBorrowLoc[2](s3: S3<i128>)
	39: ImmBorrowFieldGeneric[1](S3.x: T)
	40: ReadRef
	41: ImmBorrowLoc[1](s2: S2)
	42: ImmBorrowField[4](S2.z: i128)
	43: ReadRef
	44: Lt
	45: StLoc[6]($t5: bool)
B8:
	46: MoveLoc[6]($t5: bool)
	47: BrFalse(67)
B9:
	48: ImmBorrowLoc[0](s1: S1)
	49: ImmBorrowField[3](S1.z: i128)
	50: ImmBorrowLoc[1](s2: S2)
	51: ImmBorrowField[4](S2.z: i128)
	52: Eq
	53: StLoc[7]($t4: bool)
B10:
	54: MoveLoc[7]($t4: bool)
	55: BrFalse(64)
B11:
	56: ImmBorrowLoc[0](s1: S1)
	57: ImmBorrowField[3](S1.z: i128)
	58: ImmBorrowLoc[1](s2: S2)
	59: ImmBorrowField[4](S2.z: i128)
	60: Eq
	61: StLoc[8](return: bool)
B12:
	62: MoveLoc[8](return: bool)
	63: Ret
B13:
	64: LdFalse
	65: StLoc[8](return: bool)
	66: Branch(62)
B14:
	67: LdFalse
	68: StLoc[7]($t4: bool)
	69: Branch(54)
B15:
	70: LdFalse
	71: StLoc[6]($t5: bool)
	72: Branch(46)
B16:
	73: LdFalse
	74: StLoc[5]($t6: bool)
	75: Branch(36)
B17:
	76: LdFalse
	77: StLoc[4]($t7: bool)
	78: Branch(26)
B18:
	79: LdFalse
	80: StLoc[3]($t9: bool)
	81: Branch(16)
}
test_mix1(x: i64, y: i64): bool /* def_idx: 4 */ {
B0:
	0: CopyLoc[0](x: i64)
	1: CopyLoc[1](y: i64)
	2: Add
	3: MoveLoc[1](y: i64)
	4: MoveLoc[0](x: i64)
	5: Add
	6: Eq
	7: Ret
}
test_mix10(x: i128, y: i128): bool /* def_idx: 5 */ {
B0:
	0: CopyLoc[0](x: i128)
	1: LdI128(2)
	2: Mod
	3: CopyLoc[1](y: i128)
	4: Mul
	5: MoveLoc[0](x: i128)
	6: LdI128(3)
	7: Mod
	8: MoveLoc[1](y: i128)
	9: Mul
	10: Gt
	11: Ret
}
test_mix2(x: i128, y: i128): bool /* def_idx: 6 */ {
B0:
	0: CopyLoc[0](x: i128)
	1: LdI128(2)
	2: CopyLoc[1](y: i128)
	3: Mul
	4: Add
	5: MoveLoc[0](x: i128)
	6: LdI128(3)
	7: MoveLoc[1](y: i128)
	8: Mul
	9: Add
	10: Le
	11: Ret
}
test_mix3(x: i64, y: i64): bool /* def_idx: 7 */ {
B0:
	0: CopyLoc[0](x: i64)
	1: CopyLoc[1](y: i64)
	2: Sub
	3: MoveLoc[1](y: i64)
	4: MoveLoc[0](x: i64)
	5: Sub
	6: Eq
	7: Ret
}
test_mix4(x: i128, y: i128): bool /* def_idx: 8 */ {
B0:
	0: CopyLoc[0](x: i128)
	1: LdI128(2)
	2: CopyLoc[1](y: i128)
	3: Mul
	4: Sub
	5: MoveLoc[0](x: i128)
	6: LdI128(3)
	7: MoveLoc[1](y: i128)
	8: Mul
	9: Sub
	10: Gt
	11: Ret
}
test_mix5(x: i64, y: i64): bool /* def_idx: 9 */ {
B0:
	0: CopyLoc[0](x: i64)
	1: CopyLoc[1](y: i64)
	2: Mul
	3: MoveLoc[1](y: i64)
	4: MoveLoc[0](x: i64)
	5: Mul
	6: Eq
	7: Ret
}
test_mix6(x: i128, y: i128): bool /* def_idx: 10 */ {
B0:
	0: CopyLoc[0](x: i128)
	1: LdI128(2)
	2: Mul
	3: CopyLoc[1](y: i128)
	4: Mul
	5: MoveLoc[0](x: i128)
	6: LdI128(3)
	7: Mul
	8: MoveLoc[1](y: i128)
	9: Mul
	10: Gt
	11: Ret
}
test_mix7(x: i64, y: i64): bool /* def_idx: 11 */ {
B0:
	0: CopyLoc[0](x: i64)
	1: CopyLoc[1](y: i64)
	2: Div
	3: MoveLoc[1](y: i64)
	4: MoveLoc[0](x: i64)
	5: Div
	6: Eq
	7: Ret
}
test_mix8(x: i128, y: i128): bool /* def_idx: 12 */ {
B0:
	0: CopyLoc[0](x: i128)
	1: LdI128(2)
	2: Div
	3: CopyLoc[1](y: i128)
	4: Mul
	5: MoveLoc[0](x: i128)
	6: LdI128(3)
	7: Div
	8: MoveLoc[1](y: i128)
	9: Mul
	10: Gt
	11: Ret
}
test_mix9(x: i64, y: i64): bool /* def_idx: 13 */ {
B0:
	0: CopyLoc[0](x: i64)
	1: CopyLoc[1](y: i64)
	2: Mod
	3: MoveLoc[1](y: i64)
	4: MoveLoc[0](x: i64)
	5: Mod
	6: Eq
	7: Ret
}
}
============ bytecode verification succeeded ========
