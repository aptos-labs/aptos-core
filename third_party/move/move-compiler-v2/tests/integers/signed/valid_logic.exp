// -- Model dump before first bytecode pipeline
module 0x42::valid_logic {
    enum E1 {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<i64>,
        }
    }
    enum E2 {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<i128>,
        }
    }
    enum E3<T> {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<T>,
        }
    }
    struct S1 {
        x: u64,
        y: i64,
        z: i128,
    }
    struct S2 {
        x: S1,
        y: i64,
        z: i128,
    }
    struct S3<T> {
        x: T,
        y: S1,
        z: S2,
    }
    private fun test_cmp1(x: i64): bool {
        And(And(And(And(And(Eq<i64>(x, x), Ge<i64>(x, x)), Le<i64>(x, x)), Gt<i64>(x, x)), Lt<i64>(x, x)), Eq<i64>(Borrow(Immutable)(x), Borrow(Immutable)(x)))
    }
    private fun test_cmp2(x: i128): bool {
        And(And(And(And(And(Eq<i128>(x, x), Ge<i128>(x, x)), Le<i128>(x, x)), Gt<i128>(x, x)), Lt<i128>(x, x)), Eq<i128>(Borrow(Immutable)(x), Borrow(Immutable)(x)))
    }
    private fun test_cmp3(s1: S1,s2: S2,s3: S3<i64>): bool {
        And(And(And(And(And(And(Eq<i64>(select valid_logic::S1.y<S1>(s1), select valid_logic::S2.y<S2>(s2)), Le<i64>(select valid_logic::S1.y<S1>(s1), select valid_logic::S3.x<S3<i64>>(s3))), Ge<i64>(select valid_logic::S2.y<S2>(s2), select valid_logic::S3.x<S3<i64>>(s3))), Gt<i64>(select valid_logic::S3.x<S3<i64>>(s3), select valid_logic::S1.y<S1>(s1))), Lt<i64>(select valid_logic::S3.x<S3<i64>>(s3), select valid_logic::S2.y<S2>(s2))), Eq<i64>(Borrow(Immutable)(select valid_logic::S1.y<S1>(s1)), Borrow(Immutable)(select valid_logic::S2.y<S2>(s2)))), Eq<i64>(Borrow(Immutable)(select valid_logic::S1.y<S1>(s1)), Borrow(Immutable)(select valid_logic::S2.y<S2>(s2))))
    }
    private fun test_cmp4(s1: S1,s2: S2,s3: S3<i128>): bool {
        And(And(And(And(And(And(Eq<i128>(select valid_logic::S1.z<S1>(s1), select valid_logic::S2.z<S2>(s2)), Le<i128>(select valid_logic::S1.z<S1>(s1), select valid_logic::S3.x<S3<i128>>(s3))), Ge<i128>(select valid_logic::S2.z<S2>(s2), select valid_logic::S3.x<S3<i128>>(s3))), Gt<i128>(select valid_logic::S3.x<S3<i128>>(s3), select valid_logic::S1.z<S1>(s1))), Lt<i128>(select valid_logic::S3.x<S3<i128>>(s3), select valid_logic::S2.z<S2>(s2))), Eq<i128>(Borrow(Immutable)(select valid_logic::S1.z<S1>(s1)), Borrow(Immutable)(select valid_logic::S2.z<S2>(s2)))), Eq<i128>(Borrow(Immutable)(select valid_logic::S1.z<S1>(s1)), Borrow(Immutable)(select valid_logic::S2.z<S2>(s2))))
    }
    private fun test_mix1(x: i64,y: i64): bool {
        Eq<i64>(Add<i64>(x, y), Add<i64>(y, x))
    }
    private fun test_mix10(x: i128,y: i128): bool {
        Gt<i128>(Mul<i128>(Mod<i128>(x, 2), y), Mul<i128>(Mod<i128>(x, 3), y))
    }
    private fun test_mix2(x: i128,y: i128): bool {
        Le<i128>(Add<i128>(x, Mul<i128>(2, y)), Add<i128>(x, Mul<i128>(3, y)))
    }
    private fun test_mix3(x: i64,y: i64): bool {
        Eq<i64>(Sub<i64>(x, y), Sub<i64>(y, x))
    }
    private fun test_mix4(x: i128,y: i128): bool {
        Gt<i128>(Sub<i128>(x, Mul<i128>(2, y)), Sub<i128>(x, Mul<i128>(3, y)))
    }
    private fun test_mix5(x: i64,y: i64): bool {
        Eq<i64>(Mul<i64>(x, y), Mul<i64>(y, x))
    }
    private fun test_mix6(x: i128,y: i128): bool {
        Gt<i128>(Mul<i128>(Mul<i128>(x, 2), y), Mul<i128>(Mul<i128>(x, 3), y))
    }
    private fun test_mix7(x: i64,y: i64): bool {
        Eq<i64>(Div<i64>(x, y), Div<i64>(y, x))
    }
    private fun test_mix8(x: i128,y: i128): bool {
        Gt<i128>(Mul<i128>(Div<i128>(x, 2), y), Mul<i128>(Div<i128>(x, 3), y))
    }
    private fun test_mix9(x: i64,y: i64): bool {
        Eq<i64>(Mod<i64>(x, y), Mod<i64>(y, x))
    }
} // end 0x42::valid_logic

// -- Sourcified model before first bytecode pipeline
module 0x42::valid_logic {
    enum E1 has copy, drop {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<i64>,
        }
    }
    enum E2 has copy, drop {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<i128>,
        }
    }
    enum E3<T> has copy, drop {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<T>,
        }
    }
    struct S1 has copy, drop {
        x: u64,
        y: i64,
        z: i128,
    }
    struct S2 has copy, drop {
        x: S1,
        y: i64,
        z: i128,
    }
    struct S3<T> has copy, drop {
        x: T,
        y: S1,
        z: S2,
    }
    fun test_cmp1(x: i64): bool {
        x == x && x >= x && x <= x && x > x && x < x && &x == &x
    }
    fun test_cmp2(x: i128): bool {
        x == x && x >= x && x <= x && x > x && x < x && &x == &x
    }
    fun test_cmp3(s1: S1, s2: S2, s3: S3<i64>): bool {
        s1.y == s2.y && s1.y <= s3.x && s2.y >= s3.x && s3.x > s1.y && s3.x < s2.y && &s1.y == &s2.y && &s1.y == &s2.y
    }
    fun test_cmp4(s1: S1, s2: S2, s3: S3<i128>): bool {
        s1.z == s2.z && s1.z <= s3.x && s2.z >= s3.x && s3.x > s1.z && s3.x < s2.z && &s1.z == &s2.z && &s1.z == &s2.z
    }
    fun test_mix1(x: i64, y: i64): bool {
        x + y == y + x
    }
    fun test_mix10(x: i128, y: i128): bool {
        x % 2i128 * y > x % 3i128 * y
    }
    fun test_mix2(x: i128, y: i128): bool {
        x + 2i128 * y <= x + 3i128 * y
    }
    fun test_mix3(x: i64, y: i64): bool {
        x - y == y - x
    }
    fun test_mix4(x: i128, y: i128): bool {
        x - 2i128 * y > x - 3i128 * y
    }
    fun test_mix5(x: i64, y: i64): bool {
        x * y == y * x
    }
    fun test_mix6(x: i128, y: i128): bool {
        x * 2i128 * y > x * 3i128 * y
    }
    fun test_mix7(x: i64, y: i64): bool {
        x / y == y / x
    }
    fun test_mix8(x: i128, y: i128): bool {
        x / 2i128 * y > x / 3i128 * y
    }
    fun test_mix9(x: i64, y: i64): bool {
        x % y == y % x
    }
}

============ bytecode before first stackless bytecode pipeline ================

[variant baseline]
fun valid_logic::test_cmp1($t0: i64): bool {
     var $t1: bool
     var $t2: bool
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: i64
     var $t8: i64
     var $t9: i64
     var $t10: i64
     var $t11: i64
     var $t12: &i64
     var $t13: &i64
  0: $t7 := infer($t0)
  1: $t6 := ==($t7, $t0)
  2: if ($t6) goto 3 else goto 7
  3: label L0
  4: $t8 := infer($t0)
  5: $t5 := >=($t8, $t0)
  6: goto 9
  7: label L1
  8: $t5 := false
  9: label L2
 10: if ($t5) goto 11 else goto 15
 11: label L3
 12: $t9 := infer($t0)
 13: $t4 := <=($t9, $t0)
 14: goto 17
 15: label L4
 16: $t4 := false
 17: label L5
 18: if ($t4) goto 19 else goto 23
 19: label L6
 20: $t10 := infer($t0)
 21: $t3 := >($t10, $t0)
 22: goto 25
 23: label L7
 24: $t3 := false
 25: label L8
 26: if ($t3) goto 27 else goto 31
 27: label L9
 28: $t11 := infer($t0)
 29: $t2 := <($t11, $t0)
 30: goto 33
 31: label L10
 32: $t2 := false
 33: label L11
 34: if ($t2) goto 35 else goto 40
 35: label L12
 36: $t12 := borrow_local($t0)
 37: $t13 := borrow_local($t0)
 38: $t1 := ==($t12, $t13)
 39: goto 42
 40: label L13
 41: $t1 := false
 42: label L14
 43: return $t1
}


[variant baseline]
fun valid_logic::test_cmp2($t0: i128): bool {
     var $t1: bool
     var $t2: bool
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
     var $t11: i128
     var $t12: &i128
     var $t13: &i128
  0: $t7 := infer($t0)
  1: $t6 := ==($t7, $t0)
  2: if ($t6) goto 3 else goto 7
  3: label L0
  4: $t8 := infer($t0)
  5: $t5 := >=($t8, $t0)
  6: goto 9
  7: label L1
  8: $t5 := false
  9: label L2
 10: if ($t5) goto 11 else goto 15
 11: label L3
 12: $t9 := infer($t0)
 13: $t4 := <=($t9, $t0)
 14: goto 17
 15: label L4
 16: $t4 := false
 17: label L5
 18: if ($t4) goto 19 else goto 23
 19: label L6
 20: $t10 := infer($t0)
 21: $t3 := >($t10, $t0)
 22: goto 25
 23: label L7
 24: $t3 := false
 25: label L8
 26: if ($t3) goto 27 else goto 31
 27: label L9
 28: $t11 := infer($t0)
 29: $t2 := <($t11, $t0)
 30: goto 33
 31: label L10
 32: $t2 := false
 33: label L11
 34: if ($t2) goto 35 else goto 40
 35: label L12
 36: $t12 := borrow_local($t0)
 37: $t13 := borrow_local($t0)
 38: $t1 := ==($t12, $t13)
 39: goto 42
 40: label L13
 41: $t1 := false
 42: label L14
 43: return $t1
}


[variant baseline]
fun valid_logic::test_cmp3($t0: 0x42::valid_logic::S1, $t1: 0x42::valid_logic::S2, $t2: 0x42::valid_logic::S3<i64>): bool {
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: bool
     var $t8: bool
     var $t9: bool
     var $t10: i64
     var $t11: &0x42::valid_logic::S1
     var $t12: &i64
     var $t13: i64
     var $t14: &0x42::valid_logic::S2
     var $t15: &i64
     var $t16: i64
     var $t17: &0x42::valid_logic::S1
     var $t18: &i64
     var $t19: i64
     var $t20: &0x42::valid_logic::S3<i64>
     var $t21: &i64
     var $t22: i64
     var $t23: &0x42::valid_logic::S2
     var $t24: &i64
     var $t25: i64
     var $t26: &0x42::valid_logic::S3<i64>
     var $t27: &i64
     var $t28: i64
     var $t29: &0x42::valid_logic::S3<i64>
     var $t30: &i64
     var $t31: i64
     var $t32: &0x42::valid_logic::S1
     var $t33: &i64
     var $t34: i64
     var $t35: &0x42::valid_logic::S3<i64>
     var $t36: &i64
     var $t37: i64
     var $t38: &0x42::valid_logic::S2
     var $t39: &i64
     var $t40: &i64
     var $t41: &0x42::valid_logic::S1
     var $t42: &i64
     var $t43: &0x42::valid_logic::S2
     var $t44: &i64
     var $t45: &0x42::valid_logic::S1
     var $t46: &i64
     var $t47: &0x42::valid_logic::S2
  0: $t11 := borrow_local($t0)
  1: $t12 := borrow_field<0x42::valid_logic::S1>.y($t11)
  2: $t10 := read_ref($t12)
  3: $t14 := borrow_local($t1)
  4: $t15 := borrow_field<0x42::valid_logic::S2>.y($t14)
  5: $t13 := read_ref($t15)
  6: $t9 := ==($t10, $t13)
  7: if ($t9) goto 8 else goto 17
  8: label L0
  9: $t17 := borrow_local($t0)
 10: $t18 := borrow_field<0x42::valid_logic::S1>.y($t17)
 11: $t16 := read_ref($t18)
 12: $t20 := borrow_local($t2)
 13: $t21 := borrow_field<0x42::valid_logic::S3<i64>>.x($t20)
 14: $t19 := read_ref($t21)
 15: $t8 := <=($t16, $t19)
 16: goto 19
 17: label L1
 18: $t8 := false
 19: label L2
 20: if ($t8) goto 21 else goto 30
 21: label L3
 22: $t23 := borrow_local($t1)
 23: $t24 := borrow_field<0x42::valid_logic::S2>.y($t23)
 24: $t22 := read_ref($t24)
 25: $t26 := borrow_local($t2)
 26: $t27 := borrow_field<0x42::valid_logic::S3<i64>>.x($t26)
 27: $t25 := read_ref($t27)
 28: $t7 := >=($t22, $t25)
 29: goto 32
 30: label L4
 31: $t7 := false
 32: label L5
 33: if ($t7) goto 34 else goto 43
 34: label L6
 35: $t29 := borrow_local($t2)
 36: $t30 := borrow_field<0x42::valid_logic::S3<i64>>.x($t29)
 37: $t28 := read_ref($t30)
 38: $t32 := borrow_local($t0)
 39: $t33 := borrow_field<0x42::valid_logic::S1>.y($t32)
 40: $t31 := read_ref($t33)
 41: $t6 := >($t28, $t31)
 42: goto 45
 43: label L7
 44: $t6 := false
 45: label L8
 46: if ($t6) goto 47 else goto 56
 47: label L9
 48: $t35 := borrow_local($t2)
 49: $t36 := borrow_field<0x42::valid_logic::S3<i64>>.x($t35)
 50: $t34 := read_ref($t36)
 51: $t38 := borrow_local($t1)
 52: $t39 := borrow_field<0x42::valid_logic::S2>.y($t38)
 53: $t37 := read_ref($t39)
 54: $t5 := <($t34, $t37)
 55: goto 58
 56: label L10
 57: $t5 := false
 58: label L11
 59: if ($t5) goto 60 else goto 67
 60: label L12
 61: $t41 := borrow_local($t0)
 62: $t40 := borrow_field<0x42::valid_logic::S1>.y($t41)
 63: $t43 := borrow_local($t1)
 64: $t42 := borrow_field<0x42::valid_logic::S2>.y($t43)
 65: $t4 := ==($t40, $t42)
 66: goto 69
 67: label L13
 68: $t4 := false
 69: label L14
 70: if ($t4) goto 71 else goto 78
 71: label L15
 72: $t45 := borrow_local($t0)
 73: $t44 := borrow_field<0x42::valid_logic::S1>.y($t45)
 74: $t47 := borrow_local($t1)
 75: $t46 := borrow_field<0x42::valid_logic::S2>.y($t47)
 76: $t3 := ==($t44, $t46)
 77: goto 80
 78: label L16
 79: $t3 := false
 80: label L17
 81: return $t3
}


[variant baseline]
fun valid_logic::test_cmp4($t0: 0x42::valid_logic::S1, $t1: 0x42::valid_logic::S2, $t2: 0x42::valid_logic::S3<i128>): bool {
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: bool
     var $t8: bool
     var $t9: bool
     var $t10: i128
     var $t11: &0x42::valid_logic::S1
     var $t12: &i128
     var $t13: i128
     var $t14: &0x42::valid_logic::S2
     var $t15: &i128
     var $t16: i128
     var $t17: &0x42::valid_logic::S1
     var $t18: &i128
     var $t19: i128
     var $t20: &0x42::valid_logic::S3<i128>
     var $t21: &i128
     var $t22: i128
     var $t23: &0x42::valid_logic::S2
     var $t24: &i128
     var $t25: i128
     var $t26: &0x42::valid_logic::S3<i128>
     var $t27: &i128
     var $t28: i128
     var $t29: &0x42::valid_logic::S3<i128>
     var $t30: &i128
     var $t31: i128
     var $t32: &0x42::valid_logic::S1
     var $t33: &i128
     var $t34: i128
     var $t35: &0x42::valid_logic::S3<i128>
     var $t36: &i128
     var $t37: i128
     var $t38: &0x42::valid_logic::S2
     var $t39: &i128
     var $t40: &i128
     var $t41: &0x42::valid_logic::S1
     var $t42: &i128
     var $t43: &0x42::valid_logic::S2
     var $t44: &i128
     var $t45: &0x42::valid_logic::S1
     var $t46: &i128
     var $t47: &0x42::valid_logic::S2
  0: $t11 := borrow_local($t0)
  1: $t12 := borrow_field<0x42::valid_logic::S1>.z($t11)
  2: $t10 := read_ref($t12)
  3: $t14 := borrow_local($t1)
  4: $t15 := borrow_field<0x42::valid_logic::S2>.z($t14)
  5: $t13 := read_ref($t15)
  6: $t9 := ==($t10, $t13)
  7: if ($t9) goto 8 else goto 17
  8: label L0
  9: $t17 := borrow_local($t0)
 10: $t18 := borrow_field<0x42::valid_logic::S1>.z($t17)
 11: $t16 := read_ref($t18)
 12: $t20 := borrow_local($t2)
 13: $t21 := borrow_field<0x42::valid_logic::S3<i128>>.x($t20)
 14: $t19 := read_ref($t21)
 15: $t8 := <=($t16, $t19)
 16: goto 19
 17: label L1
 18: $t8 := false
 19: label L2
 20: if ($t8) goto 21 else goto 30
 21: label L3
 22: $t23 := borrow_local($t1)
 23: $t24 := borrow_field<0x42::valid_logic::S2>.z($t23)
 24: $t22 := read_ref($t24)
 25: $t26 := borrow_local($t2)
 26: $t27 := borrow_field<0x42::valid_logic::S3<i128>>.x($t26)
 27: $t25 := read_ref($t27)
 28: $t7 := >=($t22, $t25)
 29: goto 32
 30: label L4
 31: $t7 := false
 32: label L5
 33: if ($t7) goto 34 else goto 43
 34: label L6
 35: $t29 := borrow_local($t2)
 36: $t30 := borrow_field<0x42::valid_logic::S3<i128>>.x($t29)
 37: $t28 := read_ref($t30)
 38: $t32 := borrow_local($t0)
 39: $t33 := borrow_field<0x42::valid_logic::S1>.z($t32)
 40: $t31 := read_ref($t33)
 41: $t6 := >($t28, $t31)
 42: goto 45
 43: label L7
 44: $t6 := false
 45: label L8
 46: if ($t6) goto 47 else goto 56
 47: label L9
 48: $t35 := borrow_local($t2)
 49: $t36 := borrow_field<0x42::valid_logic::S3<i128>>.x($t35)
 50: $t34 := read_ref($t36)
 51: $t38 := borrow_local($t1)
 52: $t39 := borrow_field<0x42::valid_logic::S2>.z($t38)
 53: $t37 := read_ref($t39)
 54: $t5 := <($t34, $t37)
 55: goto 58
 56: label L10
 57: $t5 := false
 58: label L11
 59: if ($t5) goto 60 else goto 67
 60: label L12
 61: $t41 := borrow_local($t0)
 62: $t40 := borrow_field<0x42::valid_logic::S1>.z($t41)
 63: $t43 := borrow_local($t1)
 64: $t42 := borrow_field<0x42::valid_logic::S2>.z($t43)
 65: $t4 := ==($t40, $t42)
 66: goto 69
 67: label L13
 68: $t4 := false
 69: label L14
 70: if ($t4) goto 71 else goto 78
 71: label L15
 72: $t45 := borrow_local($t0)
 73: $t44 := borrow_field<0x42::valid_logic::S1>.z($t45)
 74: $t47 := borrow_local($t1)
 75: $t46 := borrow_field<0x42::valid_logic::S2>.z($t47)
 76: $t3 := ==($t44, $t46)
 77: goto 80
 78: label L16
 79: $t3 := false
 80: label L17
 81: return $t3
}


[variant baseline]
fun valid_logic::test_mix1($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
  0: $t4 := infer($t0)
  1: $t3 := +($t4, $t1)
  2: $t6 := infer($t1)
  3: $t5 := +($t6, $t0)
  4: $t2 := ==($t3, $t5)
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix10($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
  0: $t5 := infer($t0)
  1: $t6 := 2
  2: $t4 := %($t5, $t6)
  3: $t3 := *($t4, $t1)
  4: $t9 := infer($t0)
  5: $t10 := 3
  6: $t8 := %($t9, $t10)
  7: $t7 := *($t8, $t1)
  8: $t2 := >($t3, $t7)
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix2($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
  0: $t4 := infer($t0)
  1: $t6 := 2
  2: $t5 := *($t6, $t1)
  3: $t3 := +($t4, $t5)
  4: $t8 := infer($t0)
  5: $t10 := 3
  6: $t9 := *($t10, $t1)
  7: $t7 := +($t8, $t9)
  8: $t2 := <=($t3, $t7)
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix3($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
  0: $t4 := infer($t0)
  1: $t3 := -($t4, $t1)
  2: $t6 := infer($t1)
  3: $t5 := -($t6, $t0)
  4: $t2 := ==($t3, $t5)
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix4($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
  0: $t4 := infer($t0)
  1: $t6 := 2
  2: $t5 := *($t6, $t1)
  3: $t3 := -($t4, $t5)
  4: $t8 := infer($t0)
  5: $t10 := 3
  6: $t9 := *($t10, $t1)
  7: $t7 := -($t8, $t9)
  8: $t2 := >($t3, $t7)
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix5($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
  0: $t4 := infer($t0)
  1: $t3 := *($t4, $t1)
  2: $t6 := infer($t1)
  3: $t5 := *($t6, $t0)
  4: $t2 := ==($t3, $t5)
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix6($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
  0: $t5 := infer($t0)
  1: $t6 := 2
  2: $t4 := *($t5, $t6)
  3: $t3 := *($t4, $t1)
  4: $t9 := infer($t0)
  5: $t10 := 3
  6: $t8 := *($t9, $t10)
  7: $t7 := *($t8, $t1)
  8: $t2 := >($t3, $t7)
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix7($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
  0: $t4 := infer($t0)
  1: $t3 := /($t4, $t1)
  2: $t6 := infer($t1)
  3: $t5 := /($t6, $t0)
  4: $t2 := ==($t3, $t5)
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix8($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
  0: $t5 := infer($t0)
  1: $t6 := 2
  2: $t4 := /($t5, $t6)
  3: $t3 := *($t4, $t1)
  4: $t9 := infer($t0)
  5: $t10 := 3
  6: $t8 := /($t9, $t10)
  7: $t7 := *($t8, $t1)
  8: $t2 := >($t3, $t7)
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix9($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
  0: $t4 := infer($t0)
  1: $t3 := %($t4, $t1)
  2: $t6 := infer($t1)
  3: $t5 := %($t6, $t0)
  4: $t2 := ==($t3, $t5)
  5: return $t2
}

============ after AbortAnalysisProcessor: ================

[variant baseline]
fun valid_logic::test_cmp1($t0: i64): bool {
     var $t1: bool
     var $t2: bool
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: i64
     var $t8: i64
     var $t9: i64
     var $t10: i64
     var $t11: i64
     var $t12: &i64
     var $t13: &i64
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  0: $t7 := infer($t0)
     # abort state: {returns}
     # live vars: $t0, $t7
     # refs: []
     #
  1: $t6 := ==($t7, $t0)
     # abort state: {returns}
     # live vars: $t0, $t6
     # refs: []
     #
  2: if ($t6) goto 3 else goto 7
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  3: label L0
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  4: $t8 := infer($t0)
     # abort state: {returns}
     # live vars: $t0, $t8
     # refs: []
     #
  5: $t5 := >=($t8, $t0)
     # abort state: {returns}
     # live vars: $t0, $t5
     # refs: []
     #
  6: goto 9
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  7: label L1
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  8: $t5 := false
     # abort state: {returns}
     # live vars: $t0, $t5
     # refs: []
     #
  9: label L2
     # abort state: {returns}
     # live vars: $t0, $t5
     # refs: []
     #
 10: if ($t5) goto 11 else goto 15
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 11: label L3
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 12: $t9 := infer($t0)
     # abort state: {returns}
     # live vars: $t0, $t9
     # refs: []
     #
 13: $t4 := <=($t9, $t0)
     # abort state: {returns}
     # live vars: $t0, $t4
     # refs: []
     #
 14: goto 17
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 15: label L4
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 16: $t4 := false
     # abort state: {returns}
     # live vars: $t0, $t4
     # refs: []
     #
 17: label L5
     # abort state: {returns}
     # live vars: $t0, $t4
     # refs: []
     #
 18: if ($t4) goto 19 else goto 23
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 19: label L6
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 20: $t10 := infer($t0)
     # abort state: {returns}
     # live vars: $t0, $t10
     # refs: []
     #
 21: $t3 := >($t10, $t0)
     # abort state: {returns}
     # live vars: $t0, $t3
     # refs: []
     #
 22: goto 25
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 23: label L7
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 24: $t3 := false
     # abort state: {returns}
     # live vars: $t0, $t3
     # refs: []
     #
 25: label L8
     # abort state: {returns}
     # live vars: $t0, $t3
     # refs: []
     #
 26: if ($t3) goto 27 else goto 31
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 27: label L9
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 28: $t11 := infer($t0)
     # abort state: {returns}
     # live vars: $t0, $t11
     # refs: []
     #
 29: $t2 := <($t11, $t0)
     # abort state: {returns}
     # live vars: $t0, $t2
     # refs: []
     #
 30: goto 33
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 31: label L10
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 32: $t2 := false
     # abort state: {returns}
     # live vars: $t0, $t2
     # refs: []
     #
 33: label L11
     # abort state: {returns}
     # live vars: $t0, $t2
     # refs: []
     #
 34: if ($t2) goto 35 else goto 40
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 35: label L12
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 36: $t12 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t0, $t12
     # refs: [$t12 => #12]
     # #12
     #   <no edges>
     # #root
     #   => #12 via [local `x`] at line 27
     #
 37: $t13 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t12, $t13
     # refs: [$t12 => #12, $t13 => #13]
     # #12
     #   <no edges>
     # #13
     #   => #12 via [] at line 27
     # #root
     #   => #13 via [local `x`] at line 27
     #
 38: $t1 := ==($t12, $t13)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
 39: goto 42
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 40: label L13
     # abort state: {returns}
     # live vars:
     # refs: []
     #
 41: $t1 := false
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
 42: label L14
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
 43: return $t1
}


[variant baseline]
fun valid_logic::test_cmp2($t0: i128): bool {
     var $t1: bool
     var $t2: bool
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
     var $t11: i128
     var $t12: &i128
     var $t13: &i128
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  0: $t7 := infer($t0)
     # abort state: {returns}
     # live vars: $t0, $t7
     # refs: []
     #
  1: $t6 := ==($t7, $t0)
     # abort state: {returns}
     # live vars: $t0, $t6
     # refs: []
     #
  2: if ($t6) goto 3 else goto 7
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  3: label L0
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  4: $t8 := infer($t0)
     # abort state: {returns}
     # live vars: $t0, $t8
     # refs: []
     #
  5: $t5 := >=($t8, $t0)
     # abort state: {returns}
     # live vars: $t0, $t5
     # refs: []
     #
  6: goto 9
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  7: label L1
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  8: $t5 := false
     # abort state: {returns}
     # live vars: $t0, $t5
     # refs: []
     #
  9: label L2
     # abort state: {returns}
     # live vars: $t0, $t5
     # refs: []
     #
 10: if ($t5) goto 11 else goto 15
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 11: label L3
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 12: $t9 := infer($t0)
     # abort state: {returns}
     # live vars: $t0, $t9
     # refs: []
     #
 13: $t4 := <=($t9, $t0)
     # abort state: {returns}
     # live vars: $t0, $t4
     # refs: []
     #
 14: goto 17
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 15: label L4
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 16: $t4 := false
     # abort state: {returns}
     # live vars: $t0, $t4
     # refs: []
     #
 17: label L5
     # abort state: {returns}
     # live vars: $t0, $t4
     # refs: []
     #
 18: if ($t4) goto 19 else goto 23
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 19: label L6
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 20: $t10 := infer($t0)
     # abort state: {returns}
     # live vars: $t0, $t10
     # refs: []
     #
 21: $t3 := >($t10, $t0)
     # abort state: {returns}
     # live vars: $t0, $t3
     # refs: []
     #
 22: goto 25
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 23: label L7
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 24: $t3 := false
     # abort state: {returns}
     # live vars: $t0, $t3
     # refs: []
     #
 25: label L8
     # abort state: {returns}
     # live vars: $t0, $t3
     # refs: []
     #
 26: if ($t3) goto 27 else goto 31
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 27: label L9
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 28: $t11 := infer($t0)
     # abort state: {returns}
     # live vars: $t0, $t11
     # refs: []
     #
 29: $t2 := <($t11, $t0)
     # abort state: {returns}
     # live vars: $t0, $t2
     # refs: []
     #
 30: goto 33
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 31: label L10
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 32: $t2 := false
     # abort state: {returns}
     # live vars: $t0, $t2
     # refs: []
     #
 33: label L11
     # abort state: {returns}
     # live vars: $t0, $t2
     # refs: []
     #
 34: if ($t2) goto 35 else goto 40
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 35: label L12
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 36: $t12 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t0, $t12
     # refs: [$t12 => #12]
     # #12
     #   <no edges>
     # #root
     #   => #12 via [local `x`] at line 31
     #
 37: $t13 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t12, $t13
     # refs: [$t12 => #12, $t13 => #13]
     # #12
     #   <no edges>
     # #13
     #   => #12 via [] at line 31
     # #root
     #   => #13 via [local `x`] at line 31
     #
 38: $t1 := ==($t12, $t13)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
 39: goto 42
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 40: label L13
     # abort state: {returns}
     # live vars:
     # refs: []
     #
 41: $t1 := false
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
 42: label L14
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
 43: return $t1
}


[variant baseline]
fun valid_logic::test_cmp3($t0: 0x42::valid_logic::S1, $t1: 0x42::valid_logic::S2, $t2: 0x42::valid_logic::S3<i64>): bool {
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: bool
     var $t8: bool
     var $t9: bool
     var $t10: i64
     var $t11: &0x42::valid_logic::S1
     var $t12: &i64
     var $t13: i64
     var $t14: &0x42::valid_logic::S2
     var $t15: &i64
     var $t16: i64
     var $t17: &0x42::valid_logic::S1
     var $t18: &i64
     var $t19: i64
     var $t20: &0x42::valid_logic::S3<i64>
     var $t21: &i64
     var $t22: i64
     var $t23: &0x42::valid_logic::S2
     var $t24: &i64
     var $t25: i64
     var $t26: &0x42::valid_logic::S3<i64>
     var $t27: &i64
     var $t28: i64
     var $t29: &0x42::valid_logic::S3<i64>
     var $t30: &i64
     var $t31: i64
     var $t32: &0x42::valid_logic::S1
     var $t33: &i64
     var $t34: i64
     var $t35: &0x42::valid_logic::S3<i64>
     var $t36: &i64
     var $t37: i64
     var $t38: &0x42::valid_logic::S2
     var $t39: &i64
     var $t40: &i64
     var $t41: &0x42::valid_logic::S1
     var $t42: &i64
     var $t43: &0x42::valid_logic::S2
     var $t44: &i64
     var $t45: &0x42::valid_logic::S1
     var $t46: &i64
     var $t47: &0x42::valid_logic::S2
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
  0: $t11 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t11
     # refs: [$t11 => #11]
     # #11
     #   <no edges>
     # #root
     #   => #11 via [local `s1`] at line 35
     #
  1: $t12 := borrow_field<0x42::valid_logic::S1>.y($t11)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t12
     # refs: [$t12 => #12]
     # #12
     #   <no edges>
     # #root
     #   => #12 via [local `s1`, field `y`] at line 35
     #
  2: $t10 := read_ref($t12)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t10
     # refs: []
     #
  3: $t14 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t10, $t14
     # refs: [$t14 => #14]
     # #14
     #   <no edges>
     # #root
     #   => #14 via [local `s2`] at line 35
     #
  4: $t15 := borrow_field<0x42::valid_logic::S2>.y($t14)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t10, $t15
     # refs: [$t15 => #15]
     # #15
     #   <no edges>
     # #root
     #   => #15 via [local `s2`, field `y`] at line 35
     #
  5: $t13 := read_ref($t15)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t10, $t13
     # refs: []
     #
  6: $t9 := ==($t10, $t13)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t9
     # refs: []
     #
  7: if ($t9) goto 8 else goto 17
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
  8: label L0
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
  9: $t17 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t17
     # refs: [$t17 => #17]
     # #17
     #   <no edges>
     # #root
     #   => #17 via [local `s1`] at line 35
     #
 10: $t18 := borrow_field<0x42::valid_logic::S1>.y($t17)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t18
     # refs: [$t18 => #18]
     # #18
     #   <no edges>
     # #root
     #   => #18 via [local `s1`, field `y`] at line 35
     #
 11: $t16 := read_ref($t18)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t16
     # refs: []
     #
 12: $t20 := borrow_local($t2)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t16, $t20
     # refs: [$t20 => #20]
     # #20
     #   <no edges>
     # #root
     #   => #20 via [local `s3`] at line 35
     #
 13: $t21 := borrow_field<0x42::valid_logic::S3<i64>>.x($t20)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t16, $t21
     # refs: [$t21 => #21]
     # #21
     #   <no edges>
     # #root
     #   => #21 via [local `s3`, field `x`] at line 35
     #
 14: $t19 := read_ref($t21)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t16, $t19
     # refs: []
     #
 15: $t8 := <=($t16, $t19)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t8
     # refs: []
     #
 16: goto 19
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 17: label L1
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 18: $t8 := false
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t8
     # refs: []
     #
 19: label L2
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t8
     # refs: []
     #
 20: if ($t8) goto 21 else goto 30
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 21: label L3
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 22: $t23 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t23
     # refs: [$t23 => #23]
     # #23
     #   <no edges>
     # #root
     #   => #23 via [local `s2`] at line 35
     #
 23: $t24 := borrow_field<0x42::valid_logic::S2>.y($t23)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t24
     # refs: [$t24 => #24]
     # #24
     #   <no edges>
     # #root
     #   => #24 via [local `s2`, field `y`] at line 35
     #
 24: $t22 := read_ref($t24)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t22
     # refs: []
     #
 25: $t26 := borrow_local($t2)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t22, $t26
     # refs: [$t26 => #26]
     # #26
     #   <no edges>
     # #root
     #   => #26 via [local `s3`] at line 35
     #
 26: $t27 := borrow_field<0x42::valid_logic::S3<i64>>.x($t26)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t22, $t27
     # refs: [$t27 => #27]
     # #27
     #   <no edges>
     # #root
     #   => #27 via [local `s3`, field `x`] at line 35
     #
 27: $t25 := read_ref($t27)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t22, $t25
     # refs: []
     #
 28: $t7 := >=($t22, $t25)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t7
     # refs: []
     #
 29: goto 32
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 30: label L4
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 31: $t7 := false
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t7
     # refs: []
     #
 32: label L5
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t7
     # refs: []
     #
 33: if ($t7) goto 34 else goto 43
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 34: label L6
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 35: $t29 := borrow_local($t2)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t29
     # refs: [$t29 => #29]
     # #29
     #   <no edges>
     # #root
     #   => #29 via [local `s3`] at line 35
     #
 36: $t30 := borrow_field<0x42::valid_logic::S3<i64>>.x($t29)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t30
     # refs: [$t30 => #30]
     # #30
     #   <no edges>
     # #root
     #   => #30 via [local `s3`, field `x`] at line 35
     #
 37: $t28 := read_ref($t30)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t28
     # refs: []
     #
 38: $t32 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t28, $t32
     # refs: [$t32 => #32]
     # #32
     #   <no edges>
     # #root
     #   => #32 via [local `s1`] at line 35
     #
 39: $t33 := borrow_field<0x42::valid_logic::S1>.y($t32)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t28, $t33
     # refs: [$t33 => #33]
     # #33
     #   <no edges>
     # #root
     #   => #33 via [local `s1`, field `y`] at line 35
     #
 40: $t31 := read_ref($t33)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t28, $t31
     # refs: []
     #
 41: $t6 := >($t28, $t31)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t6
     # refs: []
     #
 42: goto 45
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 43: label L7
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 44: $t6 := false
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t6
     # refs: []
     #
 45: label L8
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t6
     # refs: []
     #
 46: if ($t6) goto 47 else goto 56
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 47: label L9
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 48: $t35 := borrow_local($t2)
     # abort state: {returns}
     # live vars: $t0, $t1, $t35
     # refs: [$t35 => #35]
     # #35
     #   <no edges>
     # #root
     #   => #35 via [local `s3`] at line 35
     #
 49: $t36 := borrow_field<0x42::valid_logic::S3<i64>>.x($t35)
     # abort state: {returns}
     # live vars: $t0, $t1, $t36
     # refs: [$t36 => #36]
     # #36
     #   <no edges>
     # #root
     #   => #36 via [local `s3`, field `x`] at line 35
     #
 50: $t34 := read_ref($t36)
     # abort state: {returns}
     # live vars: $t0, $t1, $t34
     # refs: []
     #
 51: $t38 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t0, $t1, $t34, $t38
     # refs: [$t38 => #38]
     # #38
     #   <no edges>
     # #root
     #   => #38 via [local `s2`] at line 35
     #
 52: $t39 := borrow_field<0x42::valid_logic::S2>.y($t38)
     # abort state: {returns}
     # live vars: $t0, $t1, $t34, $t39
     # refs: [$t39 => #39]
     # #39
     #   <no edges>
     # #root
     #   => #39 via [local `s2`, field `y`] at line 35
     #
 53: $t37 := read_ref($t39)
     # abort state: {returns}
     # live vars: $t0, $t1, $t34, $t37
     # refs: []
     #
 54: $t5 := <($t34, $t37)
     # abort state: {returns}
     # live vars: $t0, $t1, $t5
     # refs: []
     #
 55: goto 58
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 56: label L10
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 57: $t5 := false
     # abort state: {returns}
     # live vars: $t0, $t1, $t5
     # refs: []
     #
 58: label L11
     # abort state: {returns}
     # live vars: $t0, $t1, $t5
     # refs: []
     #
 59: if ($t5) goto 60 else goto 67
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 60: label L12
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 61: $t41 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t0, $t1, $t41
     # refs: [$t41 => #41]
     # #41
     #   <no edges>
     # #root
     #   => #41 via [local `s1`] at line 35
     #
 62: $t40 := borrow_field<0x42::valid_logic::S1>.y($t41)
     # abort state: {returns}
     # live vars: $t0, $t1, $t40
     # refs: [$t40 => #40]
     # #40
     #   <no edges>
     # #root
     #   => #40 via [local `s1`, field `y`] at line 35
     #
 63: $t43 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t0, $t1, $t40, $t43
     # refs: [$t40 => #40, $t43 => #43]
     # #40
     #   <no edges>
     # #43
     #   <no edges>
     # #root
     #   => #40 via [local `s1`, field `y`] at line 35
     #   => #43 via [local `s2`] at line 35
     #
 64: $t42 := borrow_field<0x42::valid_logic::S2>.y($t43)
     # abort state: {returns}
     # live vars: $t0, $t1, $t40, $t42
     # refs: [$t40 => #40, $t42 => #42]
     # #40
     #   <no edges>
     # #42
     #   <no edges>
     # #root
     #   => #40 via [local `s1`, field `y`] at line 35
     #   => #42 via [local `s2`, field `y`] at line 35
     #
 65: $t4 := ==($t40, $t42)
     # abort state: {returns}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
 66: goto 69
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 67: label L13
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 68: $t4 := false
     # abort state: {returns}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
 69: label L14
     # abort state: {returns}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
 70: if ($t4) goto 71 else goto 78
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 71: label L15
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 72: $t45 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t1, $t45
     # refs: [$t45 => #45]
     # #45
     #   <no edges>
     # #root
     #   => #45 via [local `s1`] at line 35
     #
 73: $t44 := borrow_field<0x42::valid_logic::S1>.y($t45)
     # abort state: {returns}
     # live vars: $t1, $t44
     # refs: [$t44 => #44]
     # #44
     #   <no edges>
     # #root
     #   => #44 via [local `s1`, field `y`] at line 35
     #
 74: $t47 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t44, $t47
     # refs: [$t44 => #44, $t47 => #47]
     # #44
     #   <no edges>
     # #47
     #   <no edges>
     # #root
     #   => #44 via [local `s1`, field `y`] at line 35
     #   => #47 via [local `s2`] at line 35
     #
 75: $t46 := borrow_field<0x42::valid_logic::S2>.y($t47)
     # abort state: {returns}
     # live vars: $t44, $t46
     # refs: [$t44 => #44, $t46 => #46]
     # #44
     #   <no edges>
     # #46
     #   <no edges>
     # #root
     #   => #44 via [local `s1`, field `y`] at line 35
     #   => #46 via [local `s2`, field `y`] at line 35
     #
 76: $t3 := ==($t44, $t46)
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 77: goto 80
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 78: label L16
     # abort state: {returns}
     # live vars:
     # refs: []
     #
 79: $t3 := false
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 80: label L17
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 81: return $t3
}


[variant baseline]
fun valid_logic::test_cmp4($t0: 0x42::valid_logic::S1, $t1: 0x42::valid_logic::S2, $t2: 0x42::valid_logic::S3<i128>): bool {
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: bool
     var $t8: bool
     var $t9: bool
     var $t10: i128
     var $t11: &0x42::valid_logic::S1
     var $t12: &i128
     var $t13: i128
     var $t14: &0x42::valid_logic::S2
     var $t15: &i128
     var $t16: i128
     var $t17: &0x42::valid_logic::S1
     var $t18: &i128
     var $t19: i128
     var $t20: &0x42::valid_logic::S3<i128>
     var $t21: &i128
     var $t22: i128
     var $t23: &0x42::valid_logic::S2
     var $t24: &i128
     var $t25: i128
     var $t26: &0x42::valid_logic::S3<i128>
     var $t27: &i128
     var $t28: i128
     var $t29: &0x42::valid_logic::S3<i128>
     var $t30: &i128
     var $t31: i128
     var $t32: &0x42::valid_logic::S1
     var $t33: &i128
     var $t34: i128
     var $t35: &0x42::valid_logic::S3<i128>
     var $t36: &i128
     var $t37: i128
     var $t38: &0x42::valid_logic::S2
     var $t39: &i128
     var $t40: &i128
     var $t41: &0x42::valid_logic::S1
     var $t42: &i128
     var $t43: &0x42::valid_logic::S2
     var $t44: &i128
     var $t45: &0x42::valid_logic::S1
     var $t46: &i128
     var $t47: &0x42::valid_logic::S2
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
  0: $t11 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t11
     # refs: [$t11 => #11]
     # #11
     #   <no edges>
     # #root
     #   => #11 via [local `s1`] at line 39
     #
  1: $t12 := borrow_field<0x42::valid_logic::S1>.z($t11)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t12
     # refs: [$t12 => #12]
     # #12
     #   <no edges>
     # #root
     #   => #12 via [local `s1`, field `z`] at line 39
     #
  2: $t10 := read_ref($t12)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t10
     # refs: []
     #
  3: $t14 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t10, $t14
     # refs: [$t14 => #14]
     # #14
     #   <no edges>
     # #root
     #   => #14 via [local `s2`] at line 39
     #
  4: $t15 := borrow_field<0x42::valid_logic::S2>.z($t14)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t10, $t15
     # refs: [$t15 => #15]
     # #15
     #   <no edges>
     # #root
     #   => #15 via [local `s2`, field `z`] at line 39
     #
  5: $t13 := read_ref($t15)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t10, $t13
     # refs: []
     #
  6: $t9 := ==($t10, $t13)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t9
     # refs: []
     #
  7: if ($t9) goto 8 else goto 17
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
  8: label L0
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
  9: $t17 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t17
     # refs: [$t17 => #17]
     # #17
     #   <no edges>
     # #root
     #   => #17 via [local `s1`] at line 39
     #
 10: $t18 := borrow_field<0x42::valid_logic::S1>.z($t17)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t18
     # refs: [$t18 => #18]
     # #18
     #   <no edges>
     # #root
     #   => #18 via [local `s1`, field `z`] at line 39
     #
 11: $t16 := read_ref($t18)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t16
     # refs: []
     #
 12: $t20 := borrow_local($t2)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t16, $t20
     # refs: [$t20 => #20]
     # #20
     #   <no edges>
     # #root
     #   => #20 via [local `s3`] at line 39
     #
 13: $t21 := borrow_field<0x42::valid_logic::S3<i128>>.x($t20)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t16, $t21
     # refs: [$t21 => #21]
     # #21
     #   <no edges>
     # #root
     #   => #21 via [local `s3`, field `x`] at line 39
     #
 14: $t19 := read_ref($t21)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t16, $t19
     # refs: []
     #
 15: $t8 := <=($t16, $t19)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t8
     # refs: []
     #
 16: goto 19
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 17: label L1
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 18: $t8 := false
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t8
     # refs: []
     #
 19: label L2
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t8
     # refs: []
     #
 20: if ($t8) goto 21 else goto 30
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 21: label L3
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 22: $t23 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t23
     # refs: [$t23 => #23]
     # #23
     #   <no edges>
     # #root
     #   => #23 via [local `s2`] at line 39
     #
 23: $t24 := borrow_field<0x42::valid_logic::S2>.z($t23)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t24
     # refs: [$t24 => #24]
     # #24
     #   <no edges>
     # #root
     #   => #24 via [local `s2`, field `z`] at line 39
     #
 24: $t22 := read_ref($t24)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t22
     # refs: []
     #
 25: $t26 := borrow_local($t2)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t22, $t26
     # refs: [$t26 => #26]
     # #26
     #   <no edges>
     # #root
     #   => #26 via [local `s3`] at line 39
     #
 26: $t27 := borrow_field<0x42::valid_logic::S3<i128>>.x($t26)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t22, $t27
     # refs: [$t27 => #27]
     # #27
     #   <no edges>
     # #root
     #   => #27 via [local `s3`, field `x`] at line 39
     #
 27: $t25 := read_ref($t27)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t22, $t25
     # refs: []
     #
 28: $t7 := >=($t22, $t25)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t7
     # refs: []
     #
 29: goto 32
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 30: label L4
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 31: $t7 := false
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t7
     # refs: []
     #
 32: label L5
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t7
     # refs: []
     #
 33: if ($t7) goto 34 else goto 43
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 34: label L6
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 35: $t29 := borrow_local($t2)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t29
     # refs: [$t29 => #29]
     # #29
     #   <no edges>
     # #root
     #   => #29 via [local `s3`] at line 39
     #
 36: $t30 := borrow_field<0x42::valid_logic::S3<i128>>.x($t29)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t30
     # refs: [$t30 => #30]
     # #30
     #   <no edges>
     # #root
     #   => #30 via [local `s3`, field `x`] at line 39
     #
 37: $t28 := read_ref($t30)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t28
     # refs: []
     #
 38: $t32 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t28, $t32
     # refs: [$t32 => #32]
     # #32
     #   <no edges>
     # #root
     #   => #32 via [local `s1`] at line 39
     #
 39: $t33 := borrow_field<0x42::valid_logic::S1>.z($t32)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t28, $t33
     # refs: [$t33 => #33]
     # #33
     #   <no edges>
     # #root
     #   => #33 via [local `s1`, field `z`] at line 39
     #
 40: $t31 := read_ref($t33)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t28, $t31
     # refs: []
     #
 41: $t6 := >($t28, $t31)
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t6
     # refs: []
     #
 42: goto 45
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 43: label L7
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 44: $t6 := false
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t6
     # refs: []
     #
 45: label L8
     # abort state: {returns}
     # live vars: $t0, $t1, $t2, $t6
     # refs: []
     #
 46: if ($t6) goto 47 else goto 56
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 47: label L9
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 48: $t35 := borrow_local($t2)
     # abort state: {returns}
     # live vars: $t0, $t1, $t35
     # refs: [$t35 => #35]
     # #35
     #   <no edges>
     # #root
     #   => #35 via [local `s3`] at line 39
     #
 49: $t36 := borrow_field<0x42::valid_logic::S3<i128>>.x($t35)
     # abort state: {returns}
     # live vars: $t0, $t1, $t36
     # refs: [$t36 => #36]
     # #36
     #   <no edges>
     # #root
     #   => #36 via [local `s3`, field `x`] at line 39
     #
 50: $t34 := read_ref($t36)
     # abort state: {returns}
     # live vars: $t0, $t1, $t34
     # refs: []
     #
 51: $t38 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t0, $t1, $t34, $t38
     # refs: [$t38 => #38]
     # #38
     #   <no edges>
     # #root
     #   => #38 via [local `s2`] at line 39
     #
 52: $t39 := borrow_field<0x42::valid_logic::S2>.z($t38)
     # abort state: {returns}
     # live vars: $t0, $t1, $t34, $t39
     # refs: [$t39 => #39]
     # #39
     #   <no edges>
     # #root
     #   => #39 via [local `s2`, field `z`] at line 39
     #
 53: $t37 := read_ref($t39)
     # abort state: {returns}
     # live vars: $t0, $t1, $t34, $t37
     # refs: []
     #
 54: $t5 := <($t34, $t37)
     # abort state: {returns}
     # live vars: $t0, $t1, $t5
     # refs: []
     #
 55: goto 58
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: []
     #
 56: label L10
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 57: $t5 := false
     # abort state: {returns}
     # live vars: $t0, $t1, $t5
     # refs: []
     #
 58: label L11
     # abort state: {returns}
     # live vars: $t0, $t1, $t5
     # refs: []
     #
 59: if ($t5) goto 60 else goto 67
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 60: label L12
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 61: $t41 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t0, $t1, $t41
     # refs: [$t41 => #41]
     # #41
     #   <no edges>
     # #root
     #   => #41 via [local `s1`] at line 39
     #
 62: $t40 := borrow_field<0x42::valid_logic::S1>.z($t41)
     # abort state: {returns}
     # live vars: $t0, $t1, $t40
     # refs: [$t40 => #40]
     # #40
     #   <no edges>
     # #root
     #   => #40 via [local `s1`, field `z`] at line 39
     #
 63: $t43 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t0, $t1, $t40, $t43
     # refs: [$t40 => #40, $t43 => #43]
     # #40
     #   <no edges>
     # #43
     #   <no edges>
     # #root
     #   => #40 via [local `s1`, field `z`] at line 39
     #   => #43 via [local `s2`] at line 39
     #
 64: $t42 := borrow_field<0x42::valid_logic::S2>.z($t43)
     # abort state: {returns}
     # live vars: $t0, $t1, $t40, $t42
     # refs: [$t40 => #40, $t42 => #42]
     # #40
     #   <no edges>
     # #42
     #   <no edges>
     # #root
     #   => #40 via [local `s1`, field `z`] at line 39
     #   => #42 via [local `s2`, field `z`] at line 39
     #
 65: $t4 := ==($t40, $t42)
     # abort state: {returns}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
 66: goto 69
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 67: label L13
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 68: $t4 := false
     # abort state: {returns}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
 69: label L14
     # abort state: {returns}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
 70: if ($t4) goto 71 else goto 78
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 71: label L15
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 72: $t45 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t1, $t45
     # refs: [$t45 => #45]
     # #45
     #   <no edges>
     # #root
     #   => #45 via [local `s1`] at line 39
     #
 73: $t44 := borrow_field<0x42::valid_logic::S1>.z($t45)
     # abort state: {returns}
     # live vars: $t1, $t44
     # refs: [$t44 => #44]
     # #44
     #   <no edges>
     # #root
     #   => #44 via [local `s1`, field `z`] at line 39
     #
 74: $t47 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t44, $t47
     # refs: [$t44 => #44, $t47 => #47]
     # #44
     #   <no edges>
     # #47
     #   <no edges>
     # #root
     #   => #44 via [local `s1`, field `z`] at line 39
     #   => #47 via [local `s2`] at line 39
     #
 75: $t46 := borrow_field<0x42::valid_logic::S2>.z($t47)
     # abort state: {returns}
     # live vars: $t44, $t46
     # refs: [$t44 => #44, $t46 => #46]
     # #44
     #   <no edges>
     # #46
     #   <no edges>
     # #root
     #   => #44 via [local `s1`, field `z`] at line 39
     #   => #46 via [local `s2`, field `z`] at line 39
     #
 76: $t3 := ==($t44, $t46)
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 77: goto 80
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
 78: label L16
     # abort state: {returns}
     # live vars:
     # refs: []
     #
 79: $t3 := false
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 80: label L17
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 81: return $t3
}


[variant baseline]
fun valid_logic::test_mix1($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t4 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
  1: $t3 := +($t4, $t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t3
     # refs: []
     #
  2: $t6 := infer($t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t3, $t6
     # refs: []
     #
  3: $t5 := +($t6, $t0)
     # abort state: {returns}
     # live vars: $t3, $t5
     # refs: []
     #
  4: $t2 := ==($t3, $t5)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix10($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t5 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t5
     # refs: []
     #
  1: $t6 := 2
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t5, $t6
     # refs: []
     #
  2: $t4 := %($t5, $t6)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
  3: $t3 := *($t4, $t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t3
     # refs: []
     #
  4: $t9 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t9
     # refs: []
     #
  5: $t10 := 3
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t9, $t10
     # refs: []
     #
  6: $t8 := %($t9, $t10)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t8
     # refs: []
     #
  7: $t7 := *($t8, $t1)
     # abort state: {returns}
     # live vars: $t3, $t7
     # refs: []
     #
  8: $t2 := >($t3, $t7)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix2($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t4 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
  1: $t6 := 2
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t6
     # refs: []
     #
  2: $t5 := *($t6, $t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5
     # refs: []
     #
  3: $t3 := +($t4, $t5)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t3
     # refs: []
     #
  4: $t8 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t8
     # refs: []
     #
  5: $t10 := 3
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t8, $t10
     # refs: []
     #
  6: $t9 := *($t10, $t1)
     # abort state: {returns,aborts}
     # live vars: $t3, $t8, $t9
     # refs: []
     #
  7: $t7 := +($t8, $t9)
     # abort state: {returns}
     # live vars: $t3, $t7
     # refs: []
     #
  8: $t2 := <=($t3, $t7)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix3($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t4 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
  1: $t3 := -($t4, $t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t3
     # refs: []
     #
  2: $t6 := infer($t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t3, $t6
     # refs: []
     #
  3: $t5 := -($t6, $t0)
     # abort state: {returns}
     # live vars: $t3, $t5
     # refs: []
     #
  4: $t2 := ==($t3, $t5)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix4($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t4 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
  1: $t6 := 2
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t6
     # refs: []
     #
  2: $t5 := *($t6, $t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4, $t5
     # refs: []
     #
  3: $t3 := -($t4, $t5)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t3
     # refs: []
     #
  4: $t8 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t8
     # refs: []
     #
  5: $t10 := 3
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t8, $t10
     # refs: []
     #
  6: $t9 := *($t10, $t1)
     # abort state: {returns,aborts}
     # live vars: $t3, $t8, $t9
     # refs: []
     #
  7: $t7 := -($t8, $t9)
     # abort state: {returns}
     # live vars: $t3, $t7
     # refs: []
     #
  8: $t2 := >($t3, $t7)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix5($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t4 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
  1: $t3 := *($t4, $t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t3
     # refs: []
     #
  2: $t6 := infer($t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t3, $t6
     # refs: []
     #
  3: $t5 := *($t6, $t0)
     # abort state: {returns}
     # live vars: $t3, $t5
     # refs: []
     #
  4: $t2 := ==($t3, $t5)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix6($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t5 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t5
     # refs: []
     #
  1: $t6 := 2
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t5, $t6
     # refs: []
     #
  2: $t4 := *($t5, $t6)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
  3: $t3 := *($t4, $t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t3
     # refs: []
     #
  4: $t9 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t9
     # refs: []
     #
  5: $t10 := 3
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t9, $t10
     # refs: []
     #
  6: $t8 := *($t9, $t10)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t8
     # refs: []
     #
  7: $t7 := *($t8, $t1)
     # abort state: {returns}
     # live vars: $t3, $t7
     # refs: []
     #
  8: $t2 := >($t3, $t7)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix7($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t4 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
  1: $t3 := /($t4, $t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t3
     # refs: []
     #
  2: $t6 := infer($t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t3, $t6
     # refs: []
     #
  3: $t5 := /($t6, $t0)
     # abort state: {returns}
     # live vars: $t3, $t5
     # refs: []
     #
  4: $t2 := ==($t3, $t5)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix8($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t5 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t5
     # refs: []
     #
  1: $t6 := 2
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t5, $t6
     # refs: []
     #
  2: $t4 := /($t5, $t6)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
  3: $t3 := *($t4, $t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t3
     # refs: []
     #
  4: $t9 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t9
     # refs: []
     #
  5: $t10 := 3
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t9, $t10
     # refs: []
     #
  6: $t8 := /($t9, $t10)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t8
     # refs: []
     #
  7: $t7 := *($t8, $t1)
     # abort state: {returns}
     # live vars: $t3, $t7
     # refs: []
     #
  8: $t2 := >($t3, $t7)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix9($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t4 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
  1: $t3 := %($t4, $t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t3
     # refs: []
     #
  2: $t6 := infer($t1)
     # abort state: {returns,aborts}
     # live vars: $t0, $t3, $t6
     # refs: []
     #
  3: $t5 := %($t6, $t0)
     # abort state: {returns}
     # live vars: $t3, $t5
     # refs: []
     #
  4: $t2 := ==($t3, $t5)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  5: return $t2
}

// -- Model dump before second bytecode pipeline
module 0x42::valid_logic {
    enum E1 {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<i64>,
        }
    }
    enum E2 {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<i128>,
        }
    }
    enum E3<T> {
        V1 {
            s: S1,
        }
        V2 {
            s: S2,
        }
        V3 {
            s: S3<T>,
        }
    }
    struct S1 {
        x: u64,
        y: i64,
        z: i128,
    }
    struct S2 {
        x: S1,
        y: i64,
        z: i128,
    }
    struct S3<T> {
        x: T,
        y: S1,
        z: S2,
    }
    private fun test_cmp1(x: i64): bool {
        And(And(And(And(And(Eq<i64>(x, x), Ge<i64>(x, x)), Le<i64>(x, x)), Gt<i64>(x, x)), Lt<i64>(x, x)), Eq<i64>(Borrow(Immutable)(x), Borrow(Immutable)(x)))
    }
    private fun test_cmp2(x: i128): bool {
        And(And(And(And(And(Eq<i128>(x, x), Ge<i128>(x, x)), Le<i128>(x, x)), Gt<i128>(x, x)), Lt<i128>(x, x)), Eq<i128>(Borrow(Immutable)(x), Borrow(Immutable)(x)))
    }
    private fun test_cmp3(s1: S1,s2: S2,s3: S3<i64>): bool {
        And(And(And(And(And(And(Eq<i64>(select valid_logic::S1.y<S1>(s1), select valid_logic::S2.y<S2>(s2)), Le<i64>(select valid_logic::S1.y<S1>(s1), select valid_logic::S3.x<S3<i64>>(s3))), Ge<i64>(select valid_logic::S2.y<S2>(s2), select valid_logic::S3.x<S3<i64>>(s3))), Gt<i64>(select valid_logic::S3.x<S3<i64>>(s3), select valid_logic::S1.y<S1>(s1))), Lt<i64>(select valid_logic::S3.x<S3<i64>>(s3), select valid_logic::S2.y<S2>(s2))), Eq<i64>(Borrow(Immutable)(select valid_logic::S1.y<S1>(s1)), Borrow(Immutable)(select valid_logic::S2.y<S2>(s2)))), Eq<i64>(Borrow(Immutable)(select valid_logic::S1.y<S1>(s1)), Borrow(Immutable)(select valid_logic::S2.y<S2>(s2))))
    }
    private fun test_cmp4(s1: S1,s2: S2,s3: S3<i128>): bool {
        And(And(And(And(And(And(Eq<i128>(select valid_logic::S1.z<S1>(s1), select valid_logic::S2.z<S2>(s2)), Le<i128>(select valid_logic::S1.z<S1>(s1), select valid_logic::S3.x<S3<i128>>(s3))), Ge<i128>(select valid_logic::S2.z<S2>(s2), select valid_logic::S3.x<S3<i128>>(s3))), Gt<i128>(select valid_logic::S3.x<S3<i128>>(s3), select valid_logic::S1.z<S1>(s1))), Lt<i128>(select valid_logic::S3.x<S3<i128>>(s3), select valid_logic::S2.z<S2>(s2))), Eq<i128>(Borrow(Immutable)(select valid_logic::S1.z<S1>(s1)), Borrow(Immutable)(select valid_logic::S2.z<S2>(s2)))), Eq<i128>(Borrow(Immutable)(select valid_logic::S1.z<S1>(s1)), Borrow(Immutable)(select valid_logic::S2.z<S2>(s2))))
    }
    private fun test_mix1(x: i64,y: i64): bool {
        Eq<i64>(Add<i64>(x, y), Add<i64>(y, x))
    }
    private fun test_mix10(x: i128,y: i128): bool {
        Gt<i128>(Mul<i128>(Mod<i128>(x, 2), y), Mul<i128>(Mod<i128>(x, 3), y))
    }
    private fun test_mix2(x: i128,y: i128): bool {
        Le<i128>(Add<i128>(x, Mul<i128>(2, y)), Add<i128>(x, Mul<i128>(3, y)))
    }
    private fun test_mix3(x: i64,y: i64): bool {
        Eq<i64>(Sub<i64>(x, y), Sub<i64>(y, x))
    }
    private fun test_mix4(x: i128,y: i128): bool {
        Gt<i128>(Sub<i128>(x, Mul<i128>(2, y)), Sub<i128>(x, Mul<i128>(3, y)))
    }
    private fun test_mix5(x: i64,y: i64): bool {
        Eq<i64>(Mul<i64>(x, y), Mul<i64>(y, x))
    }
    private fun test_mix6(x: i128,y: i128): bool {
        Gt<i128>(Mul<i128>(Mul<i128>(x, 2), y), Mul<i128>(Mul<i128>(x, 3), y))
    }
    private fun test_mix7(x: i64,y: i64): bool {
        Eq<i64>(Div<i64>(x, y), Div<i64>(y, x))
    }
    private fun test_mix8(x: i128,y: i128): bool {
        Gt<i128>(Mul<i128>(Div<i128>(x, 2), y), Mul<i128>(Div<i128>(x, 3), y))
    }
    private fun test_mix9(x: i64,y: i64): bool {
        Eq<i64>(Mod<i64>(x, y), Mod<i64>(y, x))
    }
} // end 0x42::valid_logic

============ bytecode before second stackless bytecode pipeline ================

[variant baseline]
fun valid_logic::test_cmp1($t0: i64): bool {
     var $t1: bool
     var $t2: bool
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: i64
     var $t8: i64
     var $t9: i64
     var $t10: i64
     var $t11: i64
     var $t12: &i64
     var $t13: &i64
  0: $t7 := infer($t0)
  1: $t6 := ==($t7, $t0)
  2: if ($t6) goto 3 else goto 7
  3: label L0
  4: $t8 := infer($t0)
  5: $t5 := >=($t8, $t0)
  6: goto 9
  7: label L1
  8: $t5 := false
  9: label L2
 10: if ($t5) goto 11 else goto 15
 11: label L3
 12: $t9 := infer($t0)
 13: $t4 := <=($t9, $t0)
 14: goto 17
 15: label L4
 16: $t4 := false
 17: label L5
 18: if ($t4) goto 19 else goto 23
 19: label L6
 20: $t10 := infer($t0)
 21: $t3 := >($t10, $t0)
 22: goto 25
 23: label L7
 24: $t3 := false
 25: label L8
 26: if ($t3) goto 27 else goto 31
 27: label L9
 28: $t11 := infer($t0)
 29: $t2 := <($t11, $t0)
 30: goto 33
 31: label L10
 32: $t2 := false
 33: label L11
 34: if ($t2) goto 35 else goto 40
 35: label L12
 36: $t12 := borrow_local($t0)
 37: $t13 := borrow_local($t0)
 38: $t1 := ==($t12, $t13)
 39: goto 42
 40: label L13
 41: $t1 := false
 42: label L14
 43: return $t1
}


[variant baseline]
fun valid_logic::test_cmp2($t0: i128): bool {
     var $t1: bool
     var $t2: bool
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
     var $t11: i128
     var $t12: &i128
     var $t13: &i128
  0: $t7 := infer($t0)
  1: $t6 := ==($t7, $t0)
  2: if ($t6) goto 3 else goto 7
  3: label L0
  4: $t8 := infer($t0)
  5: $t5 := >=($t8, $t0)
  6: goto 9
  7: label L1
  8: $t5 := false
  9: label L2
 10: if ($t5) goto 11 else goto 15
 11: label L3
 12: $t9 := infer($t0)
 13: $t4 := <=($t9, $t0)
 14: goto 17
 15: label L4
 16: $t4 := false
 17: label L5
 18: if ($t4) goto 19 else goto 23
 19: label L6
 20: $t10 := infer($t0)
 21: $t3 := >($t10, $t0)
 22: goto 25
 23: label L7
 24: $t3 := false
 25: label L8
 26: if ($t3) goto 27 else goto 31
 27: label L9
 28: $t11 := infer($t0)
 29: $t2 := <($t11, $t0)
 30: goto 33
 31: label L10
 32: $t2 := false
 33: label L11
 34: if ($t2) goto 35 else goto 40
 35: label L12
 36: $t12 := borrow_local($t0)
 37: $t13 := borrow_local($t0)
 38: $t1 := ==($t12, $t13)
 39: goto 42
 40: label L13
 41: $t1 := false
 42: label L14
 43: return $t1
}


[variant baseline]
fun valid_logic::test_cmp3($t0: 0x42::valid_logic::S1, $t1: 0x42::valid_logic::S2, $t2: 0x42::valid_logic::S3<i64>): bool {
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: bool
     var $t8: bool
     var $t9: bool
     var $t10: i64
     var $t11: &0x42::valid_logic::S1
     var $t12: &i64
     var $t13: i64
     var $t14: &0x42::valid_logic::S2
     var $t15: &i64
     var $t16: i64
     var $t17: &0x42::valid_logic::S1
     var $t18: &i64
     var $t19: i64
     var $t20: &0x42::valid_logic::S3<i64>
     var $t21: &i64
     var $t22: i64
     var $t23: &0x42::valid_logic::S2
     var $t24: &i64
     var $t25: i64
     var $t26: &0x42::valid_logic::S3<i64>
     var $t27: &i64
     var $t28: i64
     var $t29: &0x42::valid_logic::S3<i64>
     var $t30: &i64
     var $t31: i64
     var $t32: &0x42::valid_logic::S1
     var $t33: &i64
     var $t34: i64
     var $t35: &0x42::valid_logic::S3<i64>
     var $t36: &i64
     var $t37: i64
     var $t38: &0x42::valid_logic::S2
     var $t39: &i64
     var $t40: &i64
     var $t41: &0x42::valid_logic::S1
     var $t42: &i64
     var $t43: &0x42::valid_logic::S2
     var $t44: &i64
     var $t45: &0x42::valid_logic::S1
     var $t46: &i64
     var $t47: &0x42::valid_logic::S2
  0: $t11 := borrow_local($t0)
  1: $t12 := borrow_field<0x42::valid_logic::S1>.y($t11)
  2: $t10 := read_ref($t12)
  3: $t14 := borrow_local($t1)
  4: $t15 := borrow_field<0x42::valid_logic::S2>.y($t14)
  5: $t13 := read_ref($t15)
  6: $t9 := ==($t10, $t13)
  7: if ($t9) goto 8 else goto 17
  8: label L0
  9: $t17 := borrow_local($t0)
 10: $t18 := borrow_field<0x42::valid_logic::S1>.y($t17)
 11: $t16 := read_ref($t18)
 12: $t20 := borrow_local($t2)
 13: $t21 := borrow_field<0x42::valid_logic::S3<i64>>.x($t20)
 14: $t19 := read_ref($t21)
 15: $t8 := <=($t16, $t19)
 16: goto 19
 17: label L1
 18: $t8 := false
 19: label L2
 20: if ($t8) goto 21 else goto 30
 21: label L3
 22: $t23 := borrow_local($t1)
 23: $t24 := borrow_field<0x42::valid_logic::S2>.y($t23)
 24: $t22 := read_ref($t24)
 25: $t26 := borrow_local($t2)
 26: $t27 := borrow_field<0x42::valid_logic::S3<i64>>.x($t26)
 27: $t25 := read_ref($t27)
 28: $t7 := >=($t22, $t25)
 29: goto 32
 30: label L4
 31: $t7 := false
 32: label L5
 33: if ($t7) goto 34 else goto 43
 34: label L6
 35: $t29 := borrow_local($t2)
 36: $t30 := borrow_field<0x42::valid_logic::S3<i64>>.x($t29)
 37: $t28 := read_ref($t30)
 38: $t32 := borrow_local($t0)
 39: $t33 := borrow_field<0x42::valid_logic::S1>.y($t32)
 40: $t31 := read_ref($t33)
 41: $t6 := >($t28, $t31)
 42: goto 45
 43: label L7
 44: $t6 := false
 45: label L8
 46: if ($t6) goto 47 else goto 56
 47: label L9
 48: $t35 := borrow_local($t2)
 49: $t36 := borrow_field<0x42::valid_logic::S3<i64>>.x($t35)
 50: $t34 := read_ref($t36)
 51: $t38 := borrow_local($t1)
 52: $t39 := borrow_field<0x42::valid_logic::S2>.y($t38)
 53: $t37 := read_ref($t39)
 54: $t5 := <($t34, $t37)
 55: goto 58
 56: label L10
 57: $t5 := false
 58: label L11
 59: if ($t5) goto 60 else goto 67
 60: label L12
 61: $t41 := borrow_local($t0)
 62: $t40 := borrow_field<0x42::valid_logic::S1>.y($t41)
 63: $t43 := borrow_local($t1)
 64: $t42 := borrow_field<0x42::valid_logic::S2>.y($t43)
 65: $t4 := ==($t40, $t42)
 66: goto 69
 67: label L13
 68: $t4 := false
 69: label L14
 70: if ($t4) goto 71 else goto 78
 71: label L15
 72: $t45 := borrow_local($t0)
 73: $t44 := borrow_field<0x42::valid_logic::S1>.y($t45)
 74: $t47 := borrow_local($t1)
 75: $t46 := borrow_field<0x42::valid_logic::S2>.y($t47)
 76: $t3 := ==($t44, $t46)
 77: goto 80
 78: label L16
 79: $t3 := false
 80: label L17
 81: return $t3
}


[variant baseline]
fun valid_logic::test_cmp4($t0: 0x42::valid_logic::S1, $t1: 0x42::valid_logic::S2, $t2: 0x42::valid_logic::S3<i128>): bool {
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: bool
     var $t8: bool
     var $t9: bool
     var $t10: i128
     var $t11: &0x42::valid_logic::S1
     var $t12: &i128
     var $t13: i128
     var $t14: &0x42::valid_logic::S2
     var $t15: &i128
     var $t16: i128
     var $t17: &0x42::valid_logic::S1
     var $t18: &i128
     var $t19: i128
     var $t20: &0x42::valid_logic::S3<i128>
     var $t21: &i128
     var $t22: i128
     var $t23: &0x42::valid_logic::S2
     var $t24: &i128
     var $t25: i128
     var $t26: &0x42::valid_logic::S3<i128>
     var $t27: &i128
     var $t28: i128
     var $t29: &0x42::valid_logic::S3<i128>
     var $t30: &i128
     var $t31: i128
     var $t32: &0x42::valid_logic::S1
     var $t33: &i128
     var $t34: i128
     var $t35: &0x42::valid_logic::S3<i128>
     var $t36: &i128
     var $t37: i128
     var $t38: &0x42::valid_logic::S2
     var $t39: &i128
     var $t40: &i128
     var $t41: &0x42::valid_logic::S1
     var $t42: &i128
     var $t43: &0x42::valid_logic::S2
     var $t44: &i128
     var $t45: &0x42::valid_logic::S1
     var $t46: &i128
     var $t47: &0x42::valid_logic::S2
  0: $t11 := borrow_local($t0)
  1: $t12 := borrow_field<0x42::valid_logic::S1>.z($t11)
  2: $t10 := read_ref($t12)
  3: $t14 := borrow_local($t1)
  4: $t15 := borrow_field<0x42::valid_logic::S2>.z($t14)
  5: $t13 := read_ref($t15)
  6: $t9 := ==($t10, $t13)
  7: if ($t9) goto 8 else goto 17
  8: label L0
  9: $t17 := borrow_local($t0)
 10: $t18 := borrow_field<0x42::valid_logic::S1>.z($t17)
 11: $t16 := read_ref($t18)
 12: $t20 := borrow_local($t2)
 13: $t21 := borrow_field<0x42::valid_logic::S3<i128>>.x($t20)
 14: $t19 := read_ref($t21)
 15: $t8 := <=($t16, $t19)
 16: goto 19
 17: label L1
 18: $t8 := false
 19: label L2
 20: if ($t8) goto 21 else goto 30
 21: label L3
 22: $t23 := borrow_local($t1)
 23: $t24 := borrow_field<0x42::valid_logic::S2>.z($t23)
 24: $t22 := read_ref($t24)
 25: $t26 := borrow_local($t2)
 26: $t27 := borrow_field<0x42::valid_logic::S3<i128>>.x($t26)
 27: $t25 := read_ref($t27)
 28: $t7 := >=($t22, $t25)
 29: goto 32
 30: label L4
 31: $t7 := false
 32: label L5
 33: if ($t7) goto 34 else goto 43
 34: label L6
 35: $t29 := borrow_local($t2)
 36: $t30 := borrow_field<0x42::valid_logic::S3<i128>>.x($t29)
 37: $t28 := read_ref($t30)
 38: $t32 := borrow_local($t0)
 39: $t33 := borrow_field<0x42::valid_logic::S1>.z($t32)
 40: $t31 := read_ref($t33)
 41: $t6 := >($t28, $t31)
 42: goto 45
 43: label L7
 44: $t6 := false
 45: label L8
 46: if ($t6) goto 47 else goto 56
 47: label L9
 48: $t35 := borrow_local($t2)
 49: $t36 := borrow_field<0x42::valid_logic::S3<i128>>.x($t35)
 50: $t34 := read_ref($t36)
 51: $t38 := borrow_local($t1)
 52: $t39 := borrow_field<0x42::valid_logic::S2>.z($t38)
 53: $t37 := read_ref($t39)
 54: $t5 := <($t34, $t37)
 55: goto 58
 56: label L10
 57: $t5 := false
 58: label L11
 59: if ($t5) goto 60 else goto 67
 60: label L12
 61: $t41 := borrow_local($t0)
 62: $t40 := borrow_field<0x42::valid_logic::S1>.z($t41)
 63: $t43 := borrow_local($t1)
 64: $t42 := borrow_field<0x42::valid_logic::S2>.z($t43)
 65: $t4 := ==($t40, $t42)
 66: goto 69
 67: label L13
 68: $t4 := false
 69: label L14
 70: if ($t4) goto 71 else goto 78
 71: label L15
 72: $t45 := borrow_local($t0)
 73: $t44 := borrow_field<0x42::valid_logic::S1>.z($t45)
 74: $t47 := borrow_local($t1)
 75: $t46 := borrow_field<0x42::valid_logic::S2>.z($t47)
 76: $t3 := ==($t44, $t46)
 77: goto 80
 78: label L16
 79: $t3 := false
 80: label L17
 81: return $t3
}


[variant baseline]
fun valid_logic::test_mix1($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
  0: $t4 := infer($t0)
  1: $t3 := +($t4, $t1)
  2: $t6 := infer($t1)
  3: $t5 := +($t6, $t0)
  4: $t2 := ==($t3, $t5)
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix10($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
  0: $t5 := infer($t0)
  1: $t6 := 2
  2: $t4 := %($t5, $t6)
  3: $t3 := *($t4, $t1)
  4: $t9 := infer($t0)
  5: $t10 := 3
  6: $t8 := %($t9, $t10)
  7: $t7 := *($t8, $t1)
  8: $t2 := >($t3, $t7)
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix2($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
  0: $t4 := infer($t0)
  1: $t6 := 2
  2: $t5 := *($t6, $t1)
  3: $t3 := +($t4, $t5)
  4: $t8 := infer($t0)
  5: $t10 := 3
  6: $t9 := *($t10, $t1)
  7: $t7 := +($t8, $t9)
  8: $t2 := <=($t3, $t7)
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix3($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
  0: $t4 := infer($t0)
  1: $t3 := -($t4, $t1)
  2: $t6 := infer($t1)
  3: $t5 := -($t6, $t0)
  4: $t2 := ==($t3, $t5)
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix4($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
  0: $t4 := infer($t0)
  1: $t6 := 2
  2: $t5 := *($t6, $t1)
  3: $t3 := -($t4, $t5)
  4: $t8 := infer($t0)
  5: $t10 := 3
  6: $t9 := *($t10, $t1)
  7: $t7 := -($t8, $t9)
  8: $t2 := >($t3, $t7)
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix5($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
  0: $t4 := infer($t0)
  1: $t3 := *($t4, $t1)
  2: $t6 := infer($t1)
  3: $t5 := *($t6, $t0)
  4: $t2 := ==($t3, $t5)
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix6($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
  0: $t5 := infer($t0)
  1: $t6 := 2
  2: $t4 := *($t5, $t6)
  3: $t3 := *($t4, $t1)
  4: $t9 := infer($t0)
  5: $t10 := 3
  6: $t8 := *($t9, $t10)
  7: $t7 := *($t8, $t1)
  8: $t2 := >($t3, $t7)
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix7($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
  0: $t4 := infer($t0)
  1: $t3 := /($t4, $t1)
  2: $t6 := infer($t1)
  3: $t5 := /($t6, $t0)
  4: $t2 := ==($t3, $t5)
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix8($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128
     var $t4: i128
     var $t5: i128
     var $t6: i128
     var $t7: i128
     var $t8: i128
     var $t9: i128
     var $t10: i128
  0: $t5 := infer($t0)
  1: $t6 := 2
  2: $t4 := /($t5, $t6)
  3: $t3 := *($t4, $t1)
  4: $t9 := infer($t0)
  5: $t10 := 3
  6: $t8 := /($t9, $t10)
  7: $t7 := *($t8, $t1)
  8: $t2 := >($t3, $t7)
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix9($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64
     var $t4: i64
     var $t5: i64
     var $t6: i64
  0: $t4 := infer($t0)
  1: $t3 := %($t4, $t1)
  2: $t6 := infer($t1)
  3: $t5 := %($t6, $t0)
  4: $t2 := ==($t3, $t5)
  5: return $t2
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
fun valid_logic::test_cmp1($t0: i64): bool {
     var $t1: bool
     var $t2: bool
     var $t3: bool
     var $t4: bool
     var $t5: bool [unused]
     var $t6: bool
     var $t7: i64
     var $t8: i64 [unused]
     var $t9: i64 [unused]
     var $t10: i64 [unused]
     var $t11: i64 [unused]
     var $t12: &i64
     var $t13: &i64
     # live vars: $t0
  0: $t7 := copy($t0)
     # live vars: $t0, $t7
  1: $t6 := ==($t7, $t0)
     # live vars: $t0, $t6
  2: if ($t6) goto 3 else goto 40
     # live vars: $t0
  3: label L0
     # live vars: $t0
  4: $t7 := copy($t0)
     # live vars: $t0, $t7
  5: $t6 := >=($t7, $t0)
     # live vars: $t0, $t6
  6: label L2
     # live vars: $t0, $t6
  7: if ($t6) goto 8 else goto 37
     # live vars: $t0
  8: label L3
     # live vars: $t0
  9: $t7 := copy($t0)
     # live vars: $t0, $t7
 10: $t4 := <=($t7, $t0)
     # live vars: $t0, $t4
 11: label L5
     # live vars: $t0, $t4
 12: if ($t4) goto 13 else goto 34
     # live vars: $t0
 13: label L6
     # live vars: $t0
 14: $t7 := copy($t0)
     # live vars: $t0, $t7
 15: $t3 := >($t7, $t0)
     # live vars: $t0, $t3
 16: label L8
     # live vars: $t0, $t3
 17: if ($t3) goto 18 else goto 31
     # live vars: $t0
 18: label L9
     # live vars: $t0
 19: $t7 := copy($t0)
     # live vars: $t0, $t7
 20: $t2 := <($t7, $t0)
     # live vars: $t0, $t2
 21: label L11
     # live vars: $t0, $t2
 22: if ($t2) goto 23 else goto 28
     # live vars: $t0
 23: label L12
     # live vars: $t0
 24: $t12 := borrow_local($t0)
     # live vars: $t0, $t12
 25: $t13 := borrow_local($t0)
     # live vars: $t12, $t13
 26: $t1 := ==($t12, $t13)
     # live vars: $t1
 27: return $t1
     # live vars: $t0
 28: label L13
     # live vars:
 29: $t1 := false
     # live vars: $t1
 30: return $t1
     # live vars: $t0
 31: label L10
     # live vars: $t0
 32: $t2 := false
     # live vars: $t0, $t2
 33: goto 21
     # live vars: $t0
 34: label L7
     # live vars: $t0
 35: $t3 := false
     # live vars: $t0, $t3
 36: goto 16
     # live vars: $t0
 37: label L4
     # live vars: $t0
 38: $t4 := false
     # live vars: $t0, $t4
 39: goto 11
     # live vars: $t0
 40: label L1
     # live vars: $t0
 41: $t6 := false
     # live vars: $t0, $t6
 42: goto 6
}


[variant baseline]
fun valid_logic::test_cmp2($t0: i128): bool {
     var $t1: bool
     var $t2: bool
     var $t3: bool
     var $t4: bool
     var $t5: bool [unused]
     var $t6: bool
     var $t7: i128
     var $t8: i128 [unused]
     var $t9: i128 [unused]
     var $t10: i128 [unused]
     var $t11: i128 [unused]
     var $t12: &i128
     var $t13: &i128
     # live vars: $t0
  0: $t7 := copy($t0)
     # live vars: $t0, $t7
  1: $t6 := ==($t7, $t0)
     # live vars: $t0, $t6
  2: if ($t6) goto 3 else goto 40
     # live vars: $t0
  3: label L0
     # live vars: $t0
  4: $t7 := copy($t0)
     # live vars: $t0, $t7
  5: $t6 := >=($t7, $t0)
     # live vars: $t0, $t6
  6: label L2
     # live vars: $t0, $t6
  7: if ($t6) goto 8 else goto 37
     # live vars: $t0
  8: label L3
     # live vars: $t0
  9: $t7 := copy($t0)
     # live vars: $t0, $t7
 10: $t4 := <=($t7, $t0)
     # live vars: $t0, $t4
 11: label L5
     # live vars: $t0, $t4
 12: if ($t4) goto 13 else goto 34
     # live vars: $t0
 13: label L6
     # live vars: $t0
 14: $t7 := copy($t0)
     # live vars: $t0, $t7
 15: $t3 := >($t7, $t0)
     # live vars: $t0, $t3
 16: label L8
     # live vars: $t0, $t3
 17: if ($t3) goto 18 else goto 31
     # live vars: $t0
 18: label L9
     # live vars: $t0
 19: $t7 := copy($t0)
     # live vars: $t0, $t7
 20: $t2 := <($t7, $t0)
     # live vars: $t0, $t2
 21: label L11
     # live vars: $t0, $t2
 22: if ($t2) goto 23 else goto 28
     # live vars: $t0
 23: label L12
     # live vars: $t0
 24: $t12 := borrow_local($t0)
     # live vars: $t0, $t12
 25: $t13 := borrow_local($t0)
     # live vars: $t12, $t13
 26: $t1 := ==($t12, $t13)
     # live vars: $t1
 27: return $t1
     # live vars: $t0
 28: label L13
     # live vars:
 29: $t1 := false
     # live vars: $t1
 30: return $t1
     # live vars: $t0
 31: label L10
     # live vars: $t0
 32: $t2 := false
     # live vars: $t0, $t2
 33: goto 21
     # live vars: $t0
 34: label L7
     # live vars: $t0
 35: $t3 := false
     # live vars: $t0, $t3
 36: goto 16
     # live vars: $t0
 37: label L4
     # live vars: $t0
 38: $t4 := false
     # live vars: $t0, $t4
 39: goto 11
     # live vars: $t0
 40: label L1
     # live vars: $t0
 41: $t6 := false
     # live vars: $t0, $t6
 42: goto 6
}


[variant baseline]
fun valid_logic::test_cmp3($t0: 0x42::valid_logic::S1, $t1: 0x42::valid_logic::S2, $t2: 0x42::valid_logic::S3<i64>): bool {
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: bool
     var $t8: bool [unused]
     var $t9: bool
     var $t10: i64
     var $t11: &0x42::valid_logic::S1
     var $t12: &i64
     var $t13: i64
     var $t14: &0x42::valid_logic::S2
     var $t15: &i64 [unused]
     var $t16: i64 [unused]
     var $t17: &0x42::valid_logic::S1 [unused]
     var $t18: &i64 [unused]
     var $t19: i64 [unused]
     var $t20: &0x42::valid_logic::S3<i64>
     var $t21: &i64 [unused]
     var $t22: i64 [unused]
     var $t23: &0x42::valid_logic::S2 [unused]
     var $t24: &i64 [unused]
     var $t25: i64 [unused]
     var $t26: &0x42::valid_logic::S3<i64> [unused]
     var $t27: &i64 [unused]
     var $t28: i64 [unused]
     var $t29: &0x42::valid_logic::S3<i64> [unused]
     var $t30: &i64 [unused]
     var $t31: i64 [unused]
     var $t32: &0x42::valid_logic::S1 [unused]
     var $t33: &i64 [unused]
     var $t34: i64 [unused]
     var $t35: &0x42::valid_logic::S3<i64> [unused]
     var $t36: &i64 [unused]
     var $t37: i64 [unused]
     var $t38: &0x42::valid_logic::S2 [unused]
     var $t39: &i64 [unused]
     var $t40: &i64 [unused]
     var $t41: &0x42::valid_logic::S1 [unused]
     var $t42: &i64
     var $t43: &0x42::valid_logic::S2 [unused]
     var $t44: &i64 [unused]
     var $t45: &0x42::valid_logic::S1 [unused]
     var $t46: &i64 [unused]
     var $t47: &0x42::valid_logic::S2 [unused]
     # live vars: $t0, $t1, $t2
  0: $t11 := borrow_local($t0)
     # live vars: $t0, $t1, $t2, $t11
  1: $t12 := borrow_field<0x42::valid_logic::S1>.y($t11)
     # live vars: $t0, $t1, $t2, $t12
  2: $t10 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10
  3: $t14 := borrow_local($t1)
     # live vars: $t0, $t1, $t2, $t10, $t14
  4: $t12 := borrow_field<0x42::valid_logic::S2>.y($t14)
     # live vars: $t0, $t1, $t2, $t10, $t12
  5: $t13 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10, $t13
  6: $t9 := ==($t10, $t13)
     # live vars: $t0, $t1, $t2, $t9
  7: if ($t9) goto 8 else goto 78
     # live vars: $t0, $t1, $t2
  8: label L0
     # live vars: $t0, $t1, $t2
  9: $t11 := borrow_local($t0)
     # live vars: $t0, $t1, $t2, $t11
 10: $t12 := borrow_field<0x42::valid_logic::S1>.y($t11)
     # live vars: $t0, $t1, $t2, $t12
 11: $t10 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10
 12: $t20 := borrow_local($t2)
     # live vars: $t0, $t1, $t2, $t10, $t20
 13: $t12 := borrow_field<0x42::valid_logic::S3<i64>>.x($t20)
     # live vars: $t0, $t1, $t2, $t10, $t12
 14: $t13 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10, $t13
 15: $t9 := <=($t10, $t13)
     # live vars: $t0, $t1, $t2, $t9
 16: label L2
     # live vars: $t0, $t1, $t2, $t9
 17: if ($t9) goto 18 else goto 75
     # live vars: $t0, $t1, $t2
 18: label L3
     # live vars: $t0, $t1, $t2
 19: $t14 := borrow_local($t1)
     # live vars: $t0, $t1, $t2, $t14
 20: $t12 := borrow_field<0x42::valid_logic::S2>.y($t14)
     # live vars: $t0, $t1, $t2, $t12
 21: $t10 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10
 22: $t20 := borrow_local($t2)
     # live vars: $t0, $t1, $t2, $t10, $t20
 23: $t12 := borrow_field<0x42::valid_logic::S3<i64>>.x($t20)
     # live vars: $t0, $t1, $t2, $t10, $t12
 24: $t13 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10, $t13
 25: $t7 := >=($t10, $t13)
     # live vars: $t0, $t1, $t2, $t7
 26: label L5
     # live vars: $t0, $t1, $t2, $t7
 27: if ($t7) goto 28 else goto 72
     # live vars: $t0, $t1, $t2
 28: label L6
     # live vars: $t0, $t1, $t2
 29: $t20 := borrow_local($t2)
     # live vars: $t0, $t1, $t2, $t20
 30: $t12 := borrow_field<0x42::valid_logic::S3<i64>>.x($t20)
     # live vars: $t0, $t1, $t2, $t12
 31: $t10 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10
 32: $t11 := borrow_local($t0)
     # live vars: $t0, $t1, $t2, $t10, $t11
 33: $t12 := borrow_field<0x42::valid_logic::S1>.y($t11)
     # live vars: $t0, $t1, $t2, $t10, $t12
 34: $t13 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10, $t13
 35: $t6 := >($t10, $t13)
     # live vars: $t0, $t1, $t2, $t6
 36: label L8
     # live vars: $t0, $t1, $t2, $t6
 37: if ($t6) goto 38 else goto 69
     # live vars: $t0, $t1, $t2
 38: label L9
     # live vars: $t0, $t1, $t2
 39: $t20 := borrow_local($t2)
     # live vars: $t0, $t1, $t20
 40: $t12 := borrow_field<0x42::valid_logic::S3<i64>>.x($t20)
     # live vars: $t0, $t1, $t12
 41: $t10 := read_ref($t12)
     # live vars: $t0, $t1, $t10
 42: $t14 := borrow_local($t1)
     # live vars: $t0, $t1, $t10, $t14
 43: $t12 := borrow_field<0x42::valid_logic::S2>.y($t14)
     # live vars: $t0, $t1, $t10, $t12
 44: $t13 := read_ref($t12)
     # live vars: $t0, $t1, $t10, $t13
 45: $t5 := <($t10, $t13)
     # live vars: $t0, $t1, $t5
 46: label L11
     # live vars: $t0, $t1, $t5
 47: if ($t5) goto 48 else goto 66
     # live vars: $t0, $t1
 48: label L12
     # live vars: $t0, $t1
 49: $t11 := borrow_local($t0)
     # live vars: $t0, $t1, $t11
 50: $t12 := borrow_field<0x42::valid_logic::S1>.y($t11)
     # live vars: $t0, $t1, $t12
 51: $t14 := borrow_local($t1)
     # live vars: $t0, $t1, $t12, $t14
 52: $t42 := borrow_field<0x42::valid_logic::S2>.y($t14)
     # live vars: $t0, $t1, $t12, $t42
 53: $t4 := ==($t12, $t42)
     # live vars: $t0, $t1, $t4
 54: label L14
     # live vars: $t0, $t1, $t4
 55: if ($t4) goto 56 else goto 63
     # live vars: $t0, $t1
 56: label L15
     # live vars: $t0, $t1
 57: $t11 := borrow_local($t0)
     # live vars: $t1, $t11
 58: $t12 := borrow_field<0x42::valid_logic::S1>.y($t11)
     # live vars: $t1, $t12
 59: $t14 := borrow_local($t1)
     # live vars: $t12, $t14
 60: $t42 := borrow_field<0x42::valid_logic::S2>.y($t14)
     # live vars: $t12, $t42
 61: $t3 := ==($t12, $t42)
     # live vars: $t3
 62: return $t3
     # live vars: $t0, $t1
 63: label L16
     # live vars:
 64: $t3 := false
     # live vars: $t3
 65: return $t3
     # live vars: $t0, $t1
 66: label L13
     # live vars: $t0, $t1
 67: $t4 := false
     # live vars: $t0, $t1, $t4
 68: goto 54
     # live vars: $t0, $t1, $t2
 69: label L10
     # live vars: $t0, $t1
 70: $t5 := false
     # live vars: $t0, $t1, $t5
 71: goto 46
     # live vars: $t0, $t1, $t2
 72: label L7
     # live vars: $t0, $t1, $t2
 73: $t6 := false
     # live vars: $t0, $t1, $t2, $t6
 74: goto 36
     # live vars: $t0, $t1, $t2
 75: label L4
     # live vars: $t0, $t1, $t2
 76: $t7 := false
     # live vars: $t0, $t1, $t2, $t7
 77: goto 26
     # live vars: $t0, $t1, $t2
 78: label L1
     # live vars: $t0, $t1, $t2
 79: $t9 := false
     # live vars: $t0, $t1, $t2, $t9
 80: goto 16
}


[variant baseline]
fun valid_logic::test_cmp4($t0: 0x42::valid_logic::S1, $t1: 0x42::valid_logic::S2, $t2: 0x42::valid_logic::S3<i128>): bool {
     var $t3: bool
     var $t4: bool
     var $t5: bool
     var $t6: bool
     var $t7: bool
     var $t8: bool [unused]
     var $t9: bool
     var $t10: i128
     var $t11: &0x42::valid_logic::S1
     var $t12: &i128
     var $t13: i128
     var $t14: &0x42::valid_logic::S2
     var $t15: &i128 [unused]
     var $t16: i128 [unused]
     var $t17: &0x42::valid_logic::S1 [unused]
     var $t18: &i128 [unused]
     var $t19: i128 [unused]
     var $t20: &0x42::valid_logic::S3<i128>
     var $t21: &i128 [unused]
     var $t22: i128 [unused]
     var $t23: &0x42::valid_logic::S2 [unused]
     var $t24: &i128 [unused]
     var $t25: i128 [unused]
     var $t26: &0x42::valid_logic::S3<i128> [unused]
     var $t27: &i128 [unused]
     var $t28: i128 [unused]
     var $t29: &0x42::valid_logic::S3<i128> [unused]
     var $t30: &i128 [unused]
     var $t31: i128 [unused]
     var $t32: &0x42::valid_logic::S1 [unused]
     var $t33: &i128 [unused]
     var $t34: i128 [unused]
     var $t35: &0x42::valid_logic::S3<i128> [unused]
     var $t36: &i128 [unused]
     var $t37: i128 [unused]
     var $t38: &0x42::valid_logic::S2 [unused]
     var $t39: &i128 [unused]
     var $t40: &i128 [unused]
     var $t41: &0x42::valid_logic::S1 [unused]
     var $t42: &i128
     var $t43: &0x42::valid_logic::S2 [unused]
     var $t44: &i128 [unused]
     var $t45: &0x42::valid_logic::S1 [unused]
     var $t46: &i128 [unused]
     var $t47: &0x42::valid_logic::S2 [unused]
     # live vars: $t0, $t1, $t2
  0: $t11 := borrow_local($t0)
     # live vars: $t0, $t1, $t2, $t11
  1: $t12 := borrow_field<0x42::valid_logic::S1>.z($t11)
     # live vars: $t0, $t1, $t2, $t12
  2: $t10 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10
  3: $t14 := borrow_local($t1)
     # live vars: $t0, $t1, $t2, $t10, $t14
  4: $t12 := borrow_field<0x42::valid_logic::S2>.z($t14)
     # live vars: $t0, $t1, $t2, $t10, $t12
  5: $t13 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10, $t13
  6: $t9 := ==($t10, $t13)
     # live vars: $t0, $t1, $t2, $t9
  7: if ($t9) goto 8 else goto 78
     # live vars: $t0, $t1, $t2
  8: label L0
     # live vars: $t0, $t1, $t2
  9: $t11 := borrow_local($t0)
     # live vars: $t0, $t1, $t2, $t11
 10: $t12 := borrow_field<0x42::valid_logic::S1>.z($t11)
     # live vars: $t0, $t1, $t2, $t12
 11: $t10 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10
 12: $t20 := borrow_local($t2)
     # live vars: $t0, $t1, $t2, $t10, $t20
 13: $t12 := borrow_field<0x42::valid_logic::S3<i128>>.x($t20)
     # live vars: $t0, $t1, $t2, $t10, $t12
 14: $t13 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10, $t13
 15: $t9 := <=($t10, $t13)
     # live vars: $t0, $t1, $t2, $t9
 16: label L2
     # live vars: $t0, $t1, $t2, $t9
 17: if ($t9) goto 18 else goto 75
     # live vars: $t0, $t1, $t2
 18: label L3
     # live vars: $t0, $t1, $t2
 19: $t14 := borrow_local($t1)
     # live vars: $t0, $t1, $t2, $t14
 20: $t12 := borrow_field<0x42::valid_logic::S2>.z($t14)
     # live vars: $t0, $t1, $t2, $t12
 21: $t10 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10
 22: $t20 := borrow_local($t2)
     # live vars: $t0, $t1, $t2, $t10, $t20
 23: $t12 := borrow_field<0x42::valid_logic::S3<i128>>.x($t20)
     # live vars: $t0, $t1, $t2, $t10, $t12
 24: $t13 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10, $t13
 25: $t7 := >=($t10, $t13)
     # live vars: $t0, $t1, $t2, $t7
 26: label L5
     # live vars: $t0, $t1, $t2, $t7
 27: if ($t7) goto 28 else goto 72
     # live vars: $t0, $t1, $t2
 28: label L6
     # live vars: $t0, $t1, $t2
 29: $t20 := borrow_local($t2)
     # live vars: $t0, $t1, $t2, $t20
 30: $t12 := borrow_field<0x42::valid_logic::S3<i128>>.x($t20)
     # live vars: $t0, $t1, $t2, $t12
 31: $t10 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10
 32: $t11 := borrow_local($t0)
     # live vars: $t0, $t1, $t2, $t10, $t11
 33: $t12 := borrow_field<0x42::valid_logic::S1>.z($t11)
     # live vars: $t0, $t1, $t2, $t10, $t12
 34: $t13 := read_ref($t12)
     # live vars: $t0, $t1, $t2, $t10, $t13
 35: $t6 := >($t10, $t13)
     # live vars: $t0, $t1, $t2, $t6
 36: label L8
     # live vars: $t0, $t1, $t2, $t6
 37: if ($t6) goto 38 else goto 69
     # live vars: $t0, $t1, $t2
 38: label L9
     # live vars: $t0, $t1, $t2
 39: $t20 := borrow_local($t2)
     # live vars: $t0, $t1, $t20
 40: $t12 := borrow_field<0x42::valid_logic::S3<i128>>.x($t20)
     # live vars: $t0, $t1, $t12
 41: $t10 := read_ref($t12)
     # live vars: $t0, $t1, $t10
 42: $t14 := borrow_local($t1)
     # live vars: $t0, $t1, $t10, $t14
 43: $t12 := borrow_field<0x42::valid_logic::S2>.z($t14)
     # live vars: $t0, $t1, $t10, $t12
 44: $t13 := read_ref($t12)
     # live vars: $t0, $t1, $t10, $t13
 45: $t5 := <($t10, $t13)
     # live vars: $t0, $t1, $t5
 46: label L11
     # live vars: $t0, $t1, $t5
 47: if ($t5) goto 48 else goto 66
     # live vars: $t0, $t1
 48: label L12
     # live vars: $t0, $t1
 49: $t11 := borrow_local($t0)
     # live vars: $t0, $t1, $t11
 50: $t12 := borrow_field<0x42::valid_logic::S1>.z($t11)
     # live vars: $t0, $t1, $t12
 51: $t14 := borrow_local($t1)
     # live vars: $t0, $t1, $t12, $t14
 52: $t42 := borrow_field<0x42::valid_logic::S2>.z($t14)
     # live vars: $t0, $t1, $t12, $t42
 53: $t4 := ==($t12, $t42)
     # live vars: $t0, $t1, $t4
 54: label L14
     # live vars: $t0, $t1, $t4
 55: if ($t4) goto 56 else goto 63
     # live vars: $t0, $t1
 56: label L15
     # live vars: $t0, $t1
 57: $t11 := borrow_local($t0)
     # live vars: $t1, $t11
 58: $t12 := borrow_field<0x42::valid_logic::S1>.z($t11)
     # live vars: $t1, $t12
 59: $t14 := borrow_local($t1)
     # live vars: $t12, $t14
 60: $t42 := borrow_field<0x42::valid_logic::S2>.z($t14)
     # live vars: $t12, $t42
 61: $t3 := ==($t12, $t42)
     # live vars: $t3
 62: return $t3
     # live vars: $t0, $t1
 63: label L16
     # live vars:
 64: $t3 := false
     # live vars: $t3
 65: return $t3
     # live vars: $t0, $t1
 66: label L13
     # live vars: $t0, $t1
 67: $t4 := false
     # live vars: $t0, $t1, $t4
 68: goto 54
     # live vars: $t0, $t1, $t2
 69: label L10
     # live vars: $t0, $t1
 70: $t5 := false
     # live vars: $t0, $t1, $t5
 71: goto 46
     # live vars: $t0, $t1, $t2
 72: label L7
     # live vars: $t0, $t1, $t2
 73: $t6 := false
     # live vars: $t0, $t1, $t2, $t6
 74: goto 36
     # live vars: $t0, $t1, $t2
 75: label L4
     # live vars: $t0, $t1, $t2
 76: $t7 := false
     # live vars: $t0, $t1, $t2, $t7
 77: goto 26
     # live vars: $t0, $t1, $t2
 78: label L1
     # live vars: $t0, $t1, $t2
 79: $t9 := false
     # live vars: $t0, $t1, $t2, $t9
 80: goto 16
}


[variant baseline]
fun valid_logic::test_mix1($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64 [unused]
     var $t4: i64
     var $t5: i64 [unused]
     var $t6: i64 [unused]
     # live vars: $t0, $t1
  0: $t4 := copy($t0)
     # live vars: $t0, $t1, $t4
  1: $t4 := +($t4, $t1)
     # live vars: $t0, $t1, $t4
  2: $t1 := move($t1)
     # live vars: $t0, $t1, $t4
  3: $t0 := +($t1, $t0)
     # live vars: $t0, $t4
  4: $t2 := ==($t4, $t0)
     # live vars: $t2
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix10($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128 [unused]
     var $t4: i128 [unused]
     var $t5: i128
     var $t6: i128
     var $t7: i128 [unused]
     var $t8: i128 [unused]
     var $t9: i128 [unused]
     var $t10: i128 [unused]
     # live vars: $t0, $t1
  0: $t5 := copy($t0)
     # live vars: $t0, $t1, $t5
  1: $t6 := 2
     # live vars: $t0, $t1, $t5, $t6
  2: $t5 := %($t5, $t6)
     # live vars: $t0, $t1, $t5
  3: $t5 := *($t5, $t1)
     # live vars: $t0, $t1, $t5
  4: $t0 := move($t0)
     # live vars: $t0, $t1, $t5
  5: $t6 := 3
     # live vars: $t0, $t1, $t5, $t6
  6: $t0 := %($t0, $t6)
     # live vars: $t0, $t1, $t5
  7: $t0 := *($t0, $t1)
     # live vars: $t0, $t5
  8: $t2 := >($t5, $t0)
     # live vars: $t2
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix2($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128 [unused]
     var $t4: i128
     var $t5: i128 [unused]
     var $t6: i128
     var $t7: i128 [unused]
     var $t8: i128 [unused]
     var $t9: i128 [unused]
     var $t10: i128 [unused]
     # live vars: $t0, $t1
  0: $t4 := copy($t0)
     # live vars: $t0, $t1, $t4
  1: $t6 := 2
     # live vars: $t0, $t1, $t4, $t6
  2: $t6 := *($t6, $t1)
     # live vars: $t0, $t1, $t4, $t6
  3: $t4 := +($t4, $t6)
     # live vars: $t0, $t1, $t4
  4: $t0 := move($t0)
     # live vars: $t0, $t1, $t4
  5: $t6 := 3
     # live vars: $t0, $t1, $t4, $t6
  6: $t1 := *($t6, $t1)
     # live vars: $t0, $t1, $t4
  7: $t0 := +($t0, $t1)
     # live vars: $t0, $t4
  8: $t2 := <=($t4, $t0)
     # live vars: $t2
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix3($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64 [unused]
     var $t4: i64
     var $t5: i64 [unused]
     var $t6: i64 [unused]
     # live vars: $t0, $t1
  0: $t4 := copy($t0)
     # live vars: $t0, $t1, $t4
  1: $t4 := -($t4, $t1)
     # live vars: $t0, $t1, $t4
  2: $t1 := move($t1)
     # live vars: $t0, $t1, $t4
  3: $t0 := -($t1, $t0)
     # live vars: $t0, $t4
  4: $t2 := ==($t4, $t0)
     # live vars: $t2
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix4($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128 [unused]
     var $t4: i128
     var $t5: i128 [unused]
     var $t6: i128
     var $t7: i128 [unused]
     var $t8: i128 [unused]
     var $t9: i128 [unused]
     var $t10: i128 [unused]
     # live vars: $t0, $t1
  0: $t4 := copy($t0)
     # live vars: $t0, $t1, $t4
  1: $t6 := 2
     # live vars: $t0, $t1, $t4, $t6
  2: $t6 := *($t6, $t1)
     # live vars: $t0, $t1, $t4, $t6
  3: $t4 := -($t4, $t6)
     # live vars: $t0, $t1, $t4
  4: $t0 := move($t0)
     # live vars: $t0, $t1, $t4
  5: $t6 := 3
     # live vars: $t0, $t1, $t4, $t6
  6: $t1 := *($t6, $t1)
     # live vars: $t0, $t1, $t4
  7: $t0 := -($t0, $t1)
     # live vars: $t0, $t4
  8: $t2 := >($t4, $t0)
     # live vars: $t2
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix5($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64 [unused]
     var $t4: i64
     var $t5: i64 [unused]
     var $t6: i64 [unused]
     # live vars: $t0, $t1
  0: $t4 := copy($t0)
     # live vars: $t0, $t1, $t4
  1: $t4 := *($t4, $t1)
     # live vars: $t0, $t1, $t4
  2: $t1 := move($t1)
     # live vars: $t0, $t1, $t4
  3: $t0 := *($t1, $t0)
     # live vars: $t0, $t4
  4: $t2 := ==($t4, $t0)
     # live vars: $t2
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix6($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128 [unused]
     var $t4: i128 [unused]
     var $t5: i128
     var $t6: i128
     var $t7: i128 [unused]
     var $t8: i128 [unused]
     var $t9: i128 [unused]
     var $t10: i128 [unused]
     # live vars: $t0, $t1
  0: $t5 := copy($t0)
     # live vars: $t0, $t1, $t5
  1: $t6 := 2
     # live vars: $t0, $t1, $t5, $t6
  2: $t5 := *($t5, $t6)
     # live vars: $t0, $t1, $t5
  3: $t5 := *($t5, $t1)
     # live vars: $t0, $t1, $t5
  4: $t0 := move($t0)
     # live vars: $t0, $t1, $t5
  5: $t6 := 3
     # live vars: $t0, $t1, $t5, $t6
  6: $t0 := *($t0, $t6)
     # live vars: $t0, $t1, $t5
  7: $t0 := *($t0, $t1)
     # live vars: $t0, $t5
  8: $t2 := >($t5, $t0)
     # live vars: $t2
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix7($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64 [unused]
     var $t4: i64
     var $t5: i64 [unused]
     var $t6: i64 [unused]
     # live vars: $t0, $t1
  0: $t4 := copy($t0)
     # live vars: $t0, $t1, $t4
  1: $t4 := /($t4, $t1)
     # live vars: $t0, $t1, $t4
  2: $t1 := move($t1)
     # live vars: $t0, $t1, $t4
  3: $t0 := /($t1, $t0)
     # live vars: $t0, $t4
  4: $t2 := ==($t4, $t0)
     # live vars: $t2
  5: return $t2
}


[variant baseline]
fun valid_logic::test_mix8($t0: i128, $t1: i128): bool {
     var $t2: bool
     var $t3: i128 [unused]
     var $t4: i128 [unused]
     var $t5: i128
     var $t6: i128
     var $t7: i128 [unused]
     var $t8: i128 [unused]
     var $t9: i128 [unused]
     var $t10: i128 [unused]
     # live vars: $t0, $t1
  0: $t5 := copy($t0)
     # live vars: $t0, $t1, $t5
  1: $t6 := 2
     # live vars: $t0, $t1, $t5, $t6
  2: $t5 := /($t5, $t6)
     # live vars: $t0, $t1, $t5
  3: $t5 := *($t5, $t1)
     # live vars: $t0, $t1, $t5
  4: $t0 := move($t0)
     # live vars: $t0, $t1, $t5
  5: $t6 := 3
     # live vars: $t0, $t1, $t5, $t6
  6: $t0 := /($t0, $t6)
     # live vars: $t0, $t1, $t5
  7: $t0 := *($t0, $t1)
     # live vars: $t0, $t5
  8: $t2 := >($t5, $t0)
     # live vars: $t2
  9: return $t2
}


[variant baseline]
fun valid_logic::test_mix9($t0: i64, $t1: i64): bool {
     var $t2: bool
     var $t3: i64 [unused]
     var $t4: i64
     var $t5: i64 [unused]
     var $t6: i64 [unused]
     # live vars: $t0, $t1
  0: $t4 := copy($t0)
     # live vars: $t0, $t1, $t4
  1: $t4 := %($t4, $t1)
     # live vars: $t0, $t1, $t4
  2: $t1 := move($t1)
     # live vars: $t0, $t1, $t4
  3: $t0 := %($t1, $t0)
     # live vars: $t0, $t4
  4: $t2 := ==($t4, $t0)
     # live vars: $t2
  5: return $t2
}


============ disassembled file-format ==================
// Bytecode version v9
module 0x42::valid_logic
enum E1 has copy + drop
  V1
    s: S1
  V2
    s: S2
  V3
    s: S3<i64>

enum E2 has copy + drop
  V1
    s: S1
  V2
    s: S2
  V3
    s: S3<i128>

enum E3<T0> has copy + drop
  V1
    s: S1
  V2
    s: S2
  V3
    s: S3<T0>

struct S1 has copy + drop
  x: u64
  y: i64
  z: i128

struct S2 has copy + drop
  x: S1
  y: i64
  z: i128

struct S3<T0> has copy + drop
  x: T0
  y: S1
  z: S2

// Function definition at index 0
fun test_cmp1(l0: i64): bool
    local l1: bool
    local l2: bool
    local l3: bool
    local l4: bool
    copy_loc l0
    copy_loc l0
    eq
    br_false l0
    copy_loc l0
    // @5
    copy_loc l0
    ge
    st_loc l1
l8: move_loc l1
    br_false l1
    // @10
    copy_loc l0
    copy_loc l0
    le
    st_loc l2
l7: move_loc l2
    // @15
    br_false l2
    copy_loc l0
    copy_loc l0
    gt
    st_loc l3
    // @20
l6: move_loc l3
    br_false l3
    copy_loc l0
    copy_loc l0
    lt
    // @25
    st_loc l4
l5: move_loc l4
    br_false l4
    borrow_loc l0
    borrow_loc l0
    // @30
    eq
    ret
l4: ld_false
    ret
l3: ld_false
    // @35
    st_loc l4
    branch l5
l2: ld_false
    st_loc l3
    branch l6
    // @40
l1: ld_false
    st_loc l2
    branch l7
l0: ld_false
    st_loc l1
    // @45
    branch l8

// Function definition at index 1
fun test_cmp2(l0: i128): bool
    local l1: bool
    local l2: bool
    local l3: bool
    local l4: bool
    copy_loc l0
    copy_loc l0
    eq
    br_false l0
    copy_loc l0
    // @5
    copy_loc l0
    ge
    st_loc l1
l8: move_loc l1
    br_false l1
    // @10
    copy_loc l0
    copy_loc l0
    le
    st_loc l2
l7: move_loc l2
    // @15
    br_false l2
    copy_loc l0
    copy_loc l0
    gt
    st_loc l3
    // @20
l6: move_loc l3
    br_false l3
    copy_loc l0
    copy_loc l0
    lt
    // @25
    st_loc l4
l5: move_loc l4
    br_false l4
    borrow_loc l0
    borrow_loc l0
    // @30
    eq
    ret
l4: ld_false
    ret
l3: ld_false
    // @35
    st_loc l4
    branch l5
l2: ld_false
    st_loc l3
    branch l6
    // @40
l1: ld_false
    st_loc l2
    branch l7
l0: ld_false
    st_loc l1
    // @45
    branch l8

// Function definition at index 2
fun test_cmp3(l0: S1, l1: S2, l2: S3<i64>): bool
    local l3: bool
    local l4: bool
    local l5: bool
    local l6: bool
    local l7: bool
    borrow_loc l0
    borrow_field S1, y
    read_ref
    borrow_loc l1
    borrow_field S2, y
    // @5
    read_ref
    eq
    br_false l0
    borrow_loc l0
    borrow_field S1, y
    // @10
    read_ref
    borrow_loc l2
    borrow_field S3<i64>, x
    read_ref
    le
    // @15
    st_loc l3
l10: move_loc l3
    br_false l1
    borrow_loc l1
    borrow_field S2, y
    // @20
    read_ref
    borrow_loc l2
    borrow_field S3<i64>, x
    read_ref
    ge
    // @25
    st_loc l4
l9: move_loc l4
    br_false l2
    borrow_loc l2
    borrow_field S3<i64>, x
    // @30
    read_ref
    borrow_loc l0
    borrow_field S1, y
    read_ref
    gt
    // @35
    st_loc l5
l8: move_loc l5
    br_false l3
    borrow_loc l2
    borrow_field S3<i64>, x
    // @40
    read_ref
    borrow_loc l1
    borrow_field S2, y
    read_ref
    lt
    // @45
    st_loc l6
l7: move_loc l6
    br_false l4
    borrow_loc l0
    borrow_field S1, y
    // @50
    borrow_loc l1
    borrow_field S2, y
    eq
    st_loc l7
l6: move_loc l7
    // @55
    br_false l5
    borrow_loc l0
    borrow_field S1, y
    borrow_loc l1
    borrow_field S2, y
    // @60
    eq
    ret
l5: ld_false
    ret
l4: ld_false
    // @65
    st_loc l7
    branch l6
l3: ld_false
    st_loc l6
    branch l7
    // @70
l2: ld_false
    st_loc l5
    branch l8
l1: ld_false
    st_loc l4
    // @75
    branch l9
l0: ld_false
    st_loc l3
    branch l10

// Function definition at index 3
fun test_cmp4(l0: S1, l1: S2, l2: S3<i128>): bool
    local l3: bool
    local l4: bool
    local l5: bool
    local l6: bool
    local l7: bool
    borrow_loc l0
    borrow_field S1, z
    read_ref
    borrow_loc l1
    borrow_field S2, z
    // @5
    read_ref
    eq
    br_false l0
    borrow_loc l0
    borrow_field S1, z
    // @10
    read_ref
    borrow_loc l2
    borrow_field S3<i128>, x
    read_ref
    le
    // @15
    st_loc l3
l10: move_loc l3
    br_false l1
    borrow_loc l1
    borrow_field S2, z
    // @20
    read_ref
    borrow_loc l2
    borrow_field S3<i128>, x
    read_ref
    ge
    // @25
    st_loc l4
l9: move_loc l4
    br_false l2
    borrow_loc l2
    borrow_field S3<i128>, x
    // @30
    read_ref
    borrow_loc l0
    borrow_field S1, z
    read_ref
    gt
    // @35
    st_loc l5
l8: move_loc l5
    br_false l3
    borrow_loc l2
    borrow_field S3<i128>, x
    // @40
    read_ref
    borrow_loc l1
    borrow_field S2, z
    read_ref
    lt
    // @45
    st_loc l6
l7: move_loc l6
    br_false l4
    borrow_loc l0
    borrow_field S1, z
    // @50
    borrow_loc l1
    borrow_field S2, z
    eq
    st_loc l7
l6: move_loc l7
    // @55
    br_false l5
    borrow_loc l0
    borrow_field S1, z
    borrow_loc l1
    borrow_field S2, z
    // @60
    eq
    ret
l5: ld_false
    ret
l4: ld_false
    // @65
    st_loc l7
    branch l6
l3: ld_false
    st_loc l6
    branch l7
    // @70
l2: ld_false
    st_loc l5
    branch l8
l1: ld_false
    st_loc l4
    // @75
    branch l9
l0: ld_false
    st_loc l3
    branch l10

// Function definition at index 4
fun test_mix1(l0: i64, l1: i64): bool
    copy_loc l0
    copy_loc l1
    add
    move_loc l1
    move_loc l0
    // @5
    add
    eq
    ret

// Function definition at index 5
fun test_mix10(l0: i128, l1: i128): bool
    copy_loc l0
    ld_i128 2
    mod
    copy_loc l1
    mul
    // @5
    move_loc l0
    ld_i128 3
    mod
    move_loc l1
    mul
    // @10
    gt
    ret

// Function definition at index 6
fun test_mix2(l0: i128, l1: i128): bool
    copy_loc l0
    ld_i128 2
    copy_loc l1
    mul
    add
    // @5
    move_loc l0
    ld_i128 3
    move_loc l1
    mul
    add
    // @10
    le
    ret

// Function definition at index 7
fun test_mix3(l0: i64, l1: i64): bool
    copy_loc l0
    copy_loc l1
    sub
    move_loc l1
    move_loc l0
    // @5
    sub
    eq
    ret

// Function definition at index 8
fun test_mix4(l0: i128, l1: i128): bool
    copy_loc l0
    ld_i128 2
    copy_loc l1
    mul
    sub
    // @5
    move_loc l0
    ld_i128 3
    move_loc l1
    mul
    sub
    // @10
    gt
    ret

// Function definition at index 9
fun test_mix5(l0: i64, l1: i64): bool
    copy_loc l0
    copy_loc l1
    mul
    move_loc l1
    move_loc l0
    // @5
    mul
    eq
    ret

// Function definition at index 10
fun test_mix6(l0: i128, l1: i128): bool
    copy_loc l0
    ld_i128 2
    mul
    copy_loc l1
    mul
    // @5
    move_loc l0
    ld_i128 3
    mul
    move_loc l1
    mul
    // @10
    gt
    ret

// Function definition at index 11
fun test_mix7(l0: i64, l1: i64): bool
    copy_loc l0
    copy_loc l1
    div
    move_loc l1
    move_loc l0
    // @5
    div
    eq
    ret

// Function definition at index 12
fun test_mix8(l0: i128, l1: i128): bool
    copy_loc l0
    ld_i128 2
    div
    copy_loc l1
    mul
    // @5
    move_loc l0
    ld_i128 3
    div
    move_loc l1
    mul
    // @10
    gt
    ret

// Function definition at index 13
fun test_mix9(l0: i64, l1: i64): bool
    copy_loc l0
    copy_loc l1
    mod
    move_loc l1
    move_loc l0
    // @5
    mod
    eq
    ret


============ bytecode verification succeeded ========
