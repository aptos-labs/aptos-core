// -- Model dump before first bytecode pipeline
module 0xc0ffee::m {
    struct Lazy {
        0: || has drop,
    }
    public fun make_lazy(): Lazy {
        pack m::Lazy(closure#0m::__lambda__1__make_lazy())
    }
    private fun __lambda__1__make_lazy() {
        Tuple()
    }
} // end 0xc0ffee::m
module 0xc0ffee::m_friend {
    struct Lazy {
        0: || has drop,
    }
    public fun make_lazy(): Lazy {
        pack m_friend::Lazy(closure#0m_friend::__lambda__1__make_lazy())
    }
    private fun __lambda__1__make_lazy() {
        Tuple()
    }
} // end 0xc0ffee::m_friend
module 0xc0ffee::n {
    public fun test() {
        {
          let l: m::Lazy = m::make_lazy();
          (l)();
          Tuple()
        }
    }
    public fun test_friend() {
        {
          let l: m_friend::Lazy = m_friend::make_lazy();
          (l)();
          Tuple()
        }
    }
} // end 0xc0ffee::n

// -- Sourcified model before first bytecode pipeline
module 0xc0ffee::m {
    friend 0xc0ffee::n;
    struct Lazy has drop {
        0: || has drop,
    }
    public fun make_lazy(): Lazy {
        Lazy(|| lambda__1__make_lazy())
    }
    fun lambda__1__make_lazy() {
    }
}
module 0xc0ffee::m_friend {
    friend 0xc0ffee::n;
    struct Lazy has drop {
        0: || has drop,
    }
    public fun make_lazy(): Lazy {
        Lazy(|| lambda__1__make_lazy())
    }
    fun lambda__1__make_lazy() {
    }
}
module 0xc0ffee::n {
    public fun test() {
        let l = 0xc0ffee::m::make_lazy();
        l();
    }
    public fun test_friend() {
        let l = 0xc0ffee::m_friend::make_lazy();
        l();
    }
}

============ bytecode before first stackless bytecode pipeline ================

[variant baseline]
public fun m::make_lazy(): 0xc0ffee::m::Lazy {
     var $t0: 0xc0ffee::m::Lazy
     var $t1: || has drop
  0: $t1 := closure#0 m::__lambda__1__make_lazy()
  1: $t0 := pack 0xc0ffee::m::Lazy($t1)
  2: return $t0
}


[variant baseline]
fun m::__lambda__1__make_lazy() {
  0: return ()
}


[variant baseline]
public fun m_friend::make_lazy(): 0xc0ffee::m_friend::Lazy {
     var $t0: 0xc0ffee::m_friend::Lazy
     var $t1: || has drop
  0: $t1 := closure#0 m_friend::__lambda__1__make_lazy()
  1: $t0 := pack 0xc0ffee::m_friend::Lazy($t1)
  2: return $t0
}


[variant baseline]
fun m_friend::__lambda__1__make_lazy() {
  0: return ()
}


[variant baseline]
public fun n::test() {
     var $t0: 0xc0ffee::m::Lazy
     var $t1: || has drop
  0: $t0 := m::make_lazy()
  1: $t1 := unpack 0xc0ffee::m::Lazy($t0)
  2: invoke($t1)
  3: return ()
}


[variant baseline]
public fun n::test_friend() {
     var $t0: 0xc0ffee::m_friend::Lazy
     var $t1: || has drop
  0: $t0 := m_friend::make_lazy()
  1: $t1 := unpack 0xc0ffee::m_friend::Lazy($t0)
  2: invoke($t1)
  3: return ()
}

// -- Model dump before second bytecode pipeline
module 0xc0ffee::m {
    struct Lazy {
        0: || has drop,
    }
    public fun make_lazy(): Lazy {
        pack m::Lazy(closure#0m::__lambda__1__make_lazy())
    }
    private fun __lambda__1__make_lazy() {
        Tuple()
    }
} // end 0xc0ffee::m
module 0xc0ffee::m_friend {
    struct Lazy {
        0: || has drop,
    }
    public fun make_lazy(): Lazy {
        pack m_friend::Lazy(closure#0m_friend::__lambda__1__make_lazy())
    }
    private fun __lambda__1__make_lazy() {
        Tuple()
    }
} // end 0xc0ffee::m_friend
module 0xc0ffee::n {
    public fun test() {
        {
          let l: m::Lazy = m::make_lazy();
          (l)();
          Tuple()
        }
    }
    public fun test_friend() {
        {
          let l: m_friend::Lazy = m_friend::make_lazy();
          (l)();
          Tuple()
        }
    }
} // end 0xc0ffee::n

============ bytecode before second stackless bytecode pipeline ================

[variant baseline]
public fun m::make_lazy(): 0xc0ffee::m::Lazy {
     var $t0: 0xc0ffee::m::Lazy
     var $t1: || has drop
  0: $t1 := closure#0 m::__lambda__1__make_lazy()
  1: $t0 := pack 0xc0ffee::m::Lazy($t1)
  2: return $t0
}


[variant baseline]
fun m::__lambda__1__make_lazy() {
  0: return ()
}


[variant baseline]
public fun m_friend::make_lazy(): 0xc0ffee::m_friend::Lazy {
     var $t0: 0xc0ffee::m_friend::Lazy
     var $t1: || has drop
  0: $t1 := closure#0 m_friend::__lambda__1__make_lazy()
  1: $t0 := pack 0xc0ffee::m_friend::Lazy($t1)
  2: return $t0
}


[variant baseline]
fun m_friend::__lambda__1__make_lazy() {
  0: return ()
}


[variant baseline]
public fun n::test() {
     var $t0: 0xc0ffee::m::Lazy
     var $t1: || has drop
  0: $t0 := m::make_lazy()
  1: $t1 := unpack 0xc0ffee::m::Lazy($t0)
  2: invoke($t1)
  3: return ()
}


[variant baseline]
public fun n::test_friend() {
     var $t0: 0xc0ffee::m_friend::Lazy
     var $t1: || has drop
  0: $t0 := m_friend::make_lazy()
  1: $t1 := unpack 0xc0ffee::m_friend::Lazy($t0)
  2: invoke($t1)
  3: return ()
}


Diagnostics:
bug: compiler internal error: struct not defined
   ┌─ tests/bytecode-generator/bug_16222_fv_wrapper_unpack.move:20:16
   │
20 │     public fun test() {
   │                ^^^^
   │
   = please consider reporting this issue (see https://aptos.dev/en/build/smart-contracts/compiler_v2#reporting-an-issue)

bug: compiler internal error: struct not defined
   ┌─ tests/bytecode-generator/bug_16222_fv_wrapper_unpack.move:25:16
   │
25 │     public fun test_friend() {
   │                ^^^^^^^^^^^
   │
   = please consider reporting this issue (see https://aptos.dev/en/build/smart-contracts/compiler_v2#reporting-an-issue)
