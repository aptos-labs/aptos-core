// -- Model dump before first bytecode pipeline
module 0x66::fv_enum_basic {
    use std::signer;
    enum FunVec<T> {
        V1 {
            v1: vector<|&mut T|T has copy + store>,
        }
        V2 {
            v0: u64,
            v1: vector<|&mut T|T has copy + store>,
        }
    }
    private fun add_k_persistent_ref(x: &mut u64,k: u64): u64 {
        x = Add<u64>(Deref(x), 1);
        Add<u64>(Deref(x), k)
    }
    private fun test_fun_vec(s: &signer) {
        {
          let k: u64 = 3;
          {
            let add_k: |&mut u64|u64 has copy + drop + store = closure#10fv_enum_basic::add_k_persistent_ref(k);
            {
              let v1: FunVec<u64> = pack fv_enum_basic::FunVec::V1<u64>(Vector<|&mut u64|u64 has copy + store>(add_k, add_k));
              MoveTo<FunVec<u64>>(s, v1);
              {
                let m: FunVec<u64> = MoveFrom<FunVec<u64>>(signer::address_of(s));
                match (m) {
                  fv_enum_basic::FunVec::V1<u64>{ v1 } => {
                    vector::pop_back<|&mut u64|u64 has copy + store>(Borrow(Mutable)(v1));
                    vector::pop_back<|&mut u64|u64 has copy + store>(Borrow(Mutable)(v1));
                    vector::destroy_empty<|&mut u64|u64 has copy + store>(v1);
                    Tuple()
                  }
                  fv_enum_basic::FunVec::V2<u64>{ v0: _, v1 } => {
                    vector::destroy_empty<|&mut u64|u64 has copy + store>(v1);
                    if false {
                      Tuple()
                    } else {
                      Abort(99)
                    };
                    Tuple()
                  }
                }
                ;
                Tuple()
              }
            }
          }
        }
    }
} // end 0x66::fv_enum_basic

// -- Sourcified model before first bytecode pipeline
module 0x66::fv_enum_basic {
    enum FunVec<T> has key {
        V1 {
            v1: vector<|&mut T|T has copy + store>,
        }
        V2 {
            v0: u64,
            v1: vector<|&mut T|T has copy + store>,
        }
    }
    fun add_k_persistent_ref(x: &mut u64, k: u64): u64 {
        *x = *x + 1;
        *x + k
    }
    fun test_fun_vec(s: &signer) {
        let k = 3;
        let add_k = |arg0| add_k_persistent_ref(arg0, k);
        let v1 = FunVec::V1<u64>{v1: vector[add_k, add_k]};
        move_to<FunVec<u64>>(s, v1);
        let m = move_from<FunVec<u64>>(0x1::signer::address_of(s));
        match (m) {
            FunVec::V1<u64>{v1: v1} => {
                0x1::vector::pop_back<|&mut u64|u64 has copy + store>(&mut v1);
                0x1::vector::pop_back<|&mut u64|u64 has copy + store>(&mut v1);
                0x1::vector::destroy_empty<|&mut u64|u64 has copy + store>(v1);
            },
            FunVec::V2<u64>{v0: _,v1: v1} => {
                0x1::vector::destroy_empty<|&mut u64|u64 has copy + store>(v1);
                if (false) () else abort 99;
            },
        };
    }
}

============ bytecode before first stackless bytecode pipeline ================

[variant baseline]
fun fv_enum_basic::add_k_persistent_ref($t0: &mut u64, $t1: u64): u64 {
     var $t2: u64
     var $t3: u64
     var $t4: u64
     var $t5: u64
     var $t6: u64
  0: $t4 := read_ref($t0)
  1: $t5 := 1
  2: $t3 := +($t4, $t5)
  3: write_ref($t0, $t3)
  4: $t6 := read_ref($t0)
  5: $t2 := +($t6, $t1)
  6: return $t2
}


[variant baseline]
fun fv_enum_basic::test_fun_vec($t0: &signer) {
     var $t1: u64
     var $t2: |&mut u64|u64 has copy + drop + store
     var $t3: 0x66::fv_enum_basic::FunVec<u64>
     var $t4: vector<|&mut u64|u64 has copy + store>
     var $t5: |&mut u64|u64 has copy + drop + store
     var $t6: &signer
     var $t7: 0x66::fv_enum_basic::FunVec<u64>
     var $t8: address
     var $t9: &0x66::fv_enum_basic::FunVec<u64>
     var $t10: bool
     var $t11: vector<|&mut u64|u64 has copy + store>
     var $t12: |&mut u64|u64 has copy + store
     var $t13: &mut vector<|&mut u64|u64 has copy + store>
     var $t14: |&mut u64|u64 has copy + store
     var $t15: &mut vector<|&mut u64|u64 has copy + store>
     var $t16: vector<|&mut u64|u64 has copy + store>
     var $t17: u64
     var $t18: bool
     var $t19: u64
     var $t20: u64
  0: $t1 := 3
  1: $t2 := closure#10 fv_enum_basic::add_k_persistent_ref($t1)
  2: $t5 := infer($t2)
  3: $t4 := vector($t5, $t2)
  4: $t3 := pack_variant 0x66::fv_enum_basic::FunVec<u64>::V1($t4)
  5: $t6 := infer($t0)
  6: move_to<0x66::fv_enum_basic::FunVec<u64>>($t6, $t3)
  7: $t8 := signer::address_of($t0)
  8: $t7 := move_from<0x66::fv_enum_basic::FunVec<u64>>($t8)
  9: $t9 := borrow_local($t7)
 10: $t10 := test_variant 0x66::fv_enum_basic::FunVec<u64>::V1($t9)
 11: if ($t10) goto 12 else goto 20
 12: label L2
 13: $t11 := unpack_variant 0x66::fv_enum_basic::FunVec<u64>::V1($t7)
 14: $t13 := borrow_local($t11)
 15: $t12 := vector::pop_back<|&mut u64|u64 has copy + store>($t13)
 16: $t15 := borrow_local($t11)
 17: $t14 := vector::pop_back<|&mut u64|u64 has copy + store>($t15)
 18: vector::destroy_empty<|&mut u64|u64 has copy + store>($t11)
 19: goto 38
 20: label L1
 21: $t10 := test_variant 0x66::fv_enum_basic::FunVec<u64>::V2($t9)
 22: if ($t10) goto 23 else goto 35
 23: label L4
 24: ($t17, $t16) := unpack_variant 0x66::fv_enum_basic::FunVec<u64>::V2($t7)
 25: vector::destroy_empty<|&mut u64|u64 has copy + store>($t16)
 26: $t18 := false
 27: if ($t18) goto 28 else goto 30
 28: label L5
 29: goto 33
 30: label L6
 31: $t19 := 99
 32: abort($t19)
 33: label L7
 34: goto 38
 35: label L3
 36: $t20 := 14566554180833181697
 37: abort($t20)
 38: label L0
 39: return ()
}


Diagnostics:
error: value of type `|&mut u64|u64 has copy + store` does not have the `drop` ability
   ┌─ tests/bytecode-generator/fv_enum_err.move:21:17
   │
21 │                 vector::pop_back(&mut v1);
   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^ implicitly dropped here since it is no longer used

error: value of type `|&mut u64|u64 has copy + store` does not have the `drop` ability
   ┌─ tests/bytecode-generator/fv_enum_err.move:22:17
   │
22 │                 vector::pop_back(&mut v1);
   │                 ^^^^^^^^^^^^^^^^^^^^^^^^^ implicitly dropped here since it is no longer used
