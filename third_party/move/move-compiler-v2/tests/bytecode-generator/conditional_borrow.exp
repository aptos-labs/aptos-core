// -- Model dump before first bytecode pipeline
module 0x8675::M {
    struct S {
        f: u64,
    }
    public fun test(): u64 {
        Add<u64>(M::test1(7), M::test1(2))
    }
    private fun test1(r: u64): u64 {
        {
          let x: u64 = 3;
          {
            let tref: &mut u64 = Borrow(Mutable)(if Lt<u64>(r, 4) {
              r
            } else {
              x
            });
            tref = 10;
            {
              let y: u64 = r;
              {
                let tref2: &mut u64 = Borrow(Mutable)(y);
                tref2 = Add<u64>(Deref(tref2), 1);
                {
                  let z: u64 = y;
                  {
                    let tref3: &mut u64 = Borrow(Mutable)(Add<u64>(z, 0));
                    tref3 = Add<u64>(Deref(tref3), 2);
                    {
                      let a: u64 = z;
                      {
                        let tref4: &mut u64 = Borrow(Mutable)({
                          let _q: u64 = 1;
                          a
                        });
                        tref4 = Add<u64>(Deref(tref4), 4);
                        {
                          let tref5: &mut u64 = Borrow(Mutable)(a);
                          tref5 = Add<u64>(Deref(tref5), 8);
                          {
                            let tref6: &mut u64 = Borrow(Mutable)(3;
                            a);
                            tref6 = Add<u64>(Deref(tref6), 16);
                            a
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun test1b(r: S): u64 {
        {
          let x: S = pack M::S(3);
          {
            let tref: &mut S = Borrow(Mutable)(if Lt<u64>(select M::S.f<S>(r), 4) {
              r
            } else {
              x
            });
            select M::S.f<S>(Deref(tref)) = 10;
            {
              let y: S = r;
              {
                let tref2: &mut S = Borrow(Mutable)(y);
                select M::S.f<S>(Deref(tref2)) = Add<u64>(select M::S.f<S>(Deref(tref2)), 1);
                {
                  let z: S = y;
                  {
                    let tref3: &mut u64 = Borrow(Mutable)(select M::S.f<S>(z));
                    tref3 = Add<u64>(Deref(tref3), 1);
                    {
                      let a: S = z;
                      {
                        let tref4: &mut u64 = Borrow(Mutable)({
                          let _q: u64 = 1;
                          select M::S.f<S>(a)
                        });
                        tref4 = Add<u64>(Deref(tref4), 1);
                        {
                          let tref5: &mut u64 = Borrow(Mutable)(select M::S.f<S>(a));
                          tref5 = Add<u64>(Deref(tref5), 8);
                          {
                            let tref6: &mut u64 = Borrow(Mutable)(3;
                            select M::S.f<S>(a));
                            tref6 = Add<u64>(Deref(tref6), 16);
                            select M::S.f<S>(a)
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    public fun testb(): u64 {
        Add<u64>(M::test1b(pack M::S(7)), M::test1b(pack M::S(2)))
    }
} // end 0x8675::M

// -- Sourcified model before first bytecode pipeline
module 0x8675::M {
    struct S has copy, drop {
        f: u64,
    }
    public fun test(): u64 {
        test1(7) + test1(2)
    }
    fun test1(r: u64): u64 {
        let x = 3;
        let tref = &mut (if (r < 4) r else x);
        *tref = 10;
        let y = r;
        let tref2 = &mut y;
        *tref2 = *tref2 + 1;
        let z = y;
        let tref3 = &mut (z + 0);
        *tref3 = *tref3 + 2;
        let a = z;
        let tref4 = &mut {
            let _q = 1;
            a
        };
        *tref4 = *tref4 + 4;
        let tref5 = &mut a;
        *tref5 = *tref5 + 8;
        let tref6 = &mut {
            3;
            a
        };
        *tref6 = *tref6 + 16;
        a
    }
    fun test1b(r: S): u64 {
        let x = S{f: 3};
        let tref = &mut (if (r.f < 4) r else x);
        (*tref).f = 10;
        let y = r;
        let tref2 = &mut y;
        (*tref2).f = (*tref2).f + 1;
        let z = y;
        let tref3 = &mut z.f;
        *tref3 = *tref3 + 1;
        let a = z;
        let tref4 = &mut {
            let _q = 1;
            a.f
        };
        *tref4 = *tref4 + 1;
        let tref5 = &mut a.f;
        *tref5 = *tref5 + 8;
        let tref6 = &mut {
            3;
            a.f
        };
        *tref6 = *tref6 + 16;
        a.f
    }
    public fun testb(): u64 {
        test1b(S{f: 7}) + test1b(S{f: 2})
    }
}

============ bytecode before first stackless bytecode pipeline ================

[variant baseline]
public fun M::test(): u64 {
     var $t0: u64
     var $t1: u64
     var $t2: u64
     var $t3: u64
     var $t4: u64
  0: $t2 := 7
  1: $t1 := M::test1($t2)
  2: $t4 := 2
  3: $t3 := M::test1($t4)
  4: $t0 := +($t1, $t3)
  5: return $t0
}


[variant baseline]
fun M::test1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: &mut u64
     var $t4: u64
     var $t5: bool
     var $t6: u64
     var $t7: u64
     var $t8: u64
     var $t9: u64
     var $t10: &mut u64
     var $t11: u64
     var $t12: u64
     var $t13: u64
     var $t14: u64
     var $t15: &mut u64
     var $t16: u64
     var $t17: u64
     var $t18: u64
     var $t19: u64
     var $t20: u64
     var $t21: u64
     var $t22: u64
     var $t23: &mut u64
     var $t24: u64
     var $t25: u64
     var $t26: u64
     var $t27: u64
     var $t28: u64
     var $t29: &mut u64
     var $t30: u64
     var $t31: u64
     var $t32: u64
     var $t33: u64
     var $t34: &mut u64
     var $t35: u64
     var $t36: u64
     var $t37: u64
     var $t38: u64
     var $t39: u64
  0: $t2 := 3
  1: $t6 := infer($t0)
  2: $t7 := 4
  3: $t5 := <($t6, $t7)
  4: if ($t5) goto 5 else goto 8
  5: label L0
  6: $t4 := infer($t0)
  7: goto 10
  8: label L1
  9: $t4 := infer($t2)
 10: label L2
 11: $t3 := borrow_local($t4)
 12: $t8 := 10
 13: write_ref($t3, $t8)
 14: $t9 := infer($t0)
 15: $t10 := borrow_local($t9)
 16: $t12 := read_ref($t10)
 17: $t13 := 1
 18: $t11 := +($t12, $t13)
 19: write_ref($t10, $t11)
 20: $t14 := infer($t9)
 21: $t17 := infer($t14)
 22: $t18 := 0
 23: $t16 := +($t17, $t18)
 24: $t15 := borrow_local($t16)
 25: $t20 := read_ref($t15)
 26: $t21 := 2
 27: $t19 := +($t20, $t21)
 28: write_ref($t15, $t19)
 29: $t22 := infer($t14)
 30: $t25 := 1
 31: $t24 := infer($t22)
 32: $t23 := borrow_local($t24)
 33: $t27 := read_ref($t23)
 34: $t28 := 4
 35: $t26 := +($t27, $t28)
 36: write_ref($t23, $t26)
 37: $t30 := infer($t22)
 38: $t29 := borrow_local($t30)
 39: $t32 := read_ref($t29)
 40: $t33 := 8
 41: $t31 := +($t32, $t33)
 42: write_ref($t29, $t31)
 43: $t36 := 3
 44: $t35 := infer($t22)
 45: $t34 := borrow_local($t35)
 46: $t38 := read_ref($t34)
 47: $t39 := 16
 48: $t37 := +($t38, $t39)
 49: write_ref($t34, $t37)
 50: $t1 := infer($t22)
 51: return $t1
}


[variant baseline]
fun M::test1b($t0: 0x8675::M::S): u64 {
     var $t1: u64
     var $t2: 0x8675::M::S
     var $t3: u64
     var $t4: &mut 0x8675::M::S
     var $t5: 0x8675::M::S
     var $t6: bool
     var $t7: u64
     var $t8: &0x8675::M::S
     var $t9: &u64
     var $t10: u64
     var $t11: u64
     var $t12: &mut u64
     var $t13: 0x8675::M::S
     var $t14: &mut 0x8675::M::S
     var $t15: 0x8675::M::S
     var $t16: &mut 0x8675::M::S
     var $t17: u64
     var $t18: u64
     var $t19: 0x8675::M::S
     var $t20: &0x8675::M::S
     var $t21: &u64
     var $t22: u64
     var $t23: &mut u64
     var $t24: 0x8675::M::S
     var $t25: &mut 0x8675::M::S
     var $t26: 0x8675::M::S
     var $t27: &mut u64
     var $t28: &mut 0x8675::M::S
     var $t29: u64
     var $t30: u64
     var $t31: u64
     var $t32: 0x8675::M::S
     var $t33: &mut u64
     var $t34: u64
     var $t35: u64
     var $t36: &0x8675::M::S
     var $t37: &u64
     var $t38: u64
     var $t39: u64
     var $t40: u64
     var $t41: &mut u64
     var $t42: u64
     var $t43: &0x8675::M::S
     var $t44: &u64
     var $t45: u64
     var $t46: u64
     var $t47: u64
     var $t48: &mut u64
     var $t49: u64
     var $t50: u64
     var $t51: &0x8675::M::S
     var $t52: &u64
     var $t53: u64
     var $t54: u64
     var $t55: u64
     var $t56: &0x8675::M::S
     var $t57: &u64
  0: $t3 := 3
  1: $t2 := pack 0x8675::M::S($t3)
  2: $t8 := borrow_local($t0)
  3: $t9 := borrow_field<0x8675::M::S>.f($t8)
  4: $t7 := read_ref($t9)
  5: $t10 := 4
  6: $t6 := <($t7, $t10)
  7: if ($t6) goto 8 else goto 11
  8: label L0
  9: $t5 := infer($t0)
 10: goto 13
 11: label L1
 12: $t5 := infer($t2)
 13: label L2
 14: $t4 := borrow_local($t5)
 15: $t11 := 10
 16: $t13 := read_ref($t4)
 17: $t14 := borrow_local($t13)
 18: $t12 := borrow_field<0x8675::M::S>.f($t14)
 19: write_ref($t12, $t11)
 20: $t15 := infer($t0)
 21: $t16 := borrow_local($t15)
 22: $t19 := read_ref($t16)
 23: $t20 := borrow_local($t19)
 24: $t21 := borrow_field<0x8675::M::S>.f($t20)
 25: $t18 := read_ref($t21)
 26: $t22 := 1
 27: $t17 := +($t18, $t22)
 28: $t24 := read_ref($t16)
 29: $t25 := borrow_local($t24)
 30: $t23 := borrow_field<0x8675::M::S>.f($t25)
 31: write_ref($t23, $t17)
 32: $t26 := infer($t15)
 33: $t28 := borrow_local($t26)
 34: $t27 := borrow_field<0x8675::M::S>.f($t28)
 35: $t30 := read_ref($t27)
 36: $t31 := 1
 37: $t29 := +($t30, $t31)
 38: write_ref($t27, $t29)
 39: $t32 := infer($t26)
 40: $t35 := 1
 41: $t36 := borrow_local($t32)
 42: $t37 := borrow_field<0x8675::M::S>.f($t36)
 43: $t34 := read_ref($t37)
 44: $t33 := borrow_local($t34)
 45: $t39 := read_ref($t33)
 46: $t40 := 1
 47: $t38 := +($t39, $t40)
 48: write_ref($t33, $t38)
 49: $t43 := borrow_local($t32)
 50: $t44 := borrow_field<0x8675::M::S>.f($t43)
 51: $t42 := read_ref($t44)
 52: $t41 := borrow_local($t42)
 53: $t46 := read_ref($t41)
 54: $t47 := 8
 55: $t45 := +($t46, $t47)
 56: write_ref($t41, $t45)
 57: $t50 := 3
 58: $t51 := borrow_local($t32)
 59: $t52 := borrow_field<0x8675::M::S>.f($t51)
 60: $t49 := read_ref($t52)
 61: $t48 := borrow_local($t49)
 62: $t54 := read_ref($t48)
 63: $t55 := 16
 64: $t53 := +($t54, $t55)
 65: write_ref($t48, $t53)
 66: $t56 := borrow_local($t32)
 67: $t57 := borrow_field<0x8675::M::S>.f($t56)
 68: $t1 := read_ref($t57)
 69: return $t1
}


[variant baseline]
public fun M::testb(): u64 {
     var $t0: u64
     var $t1: u64
     var $t2: 0x8675::M::S
     var $t3: u64
     var $t4: u64
     var $t5: 0x8675::M::S
     var $t6: u64
  0: $t3 := 7
  1: $t2 := pack 0x8675::M::S($t3)
  2: $t1 := M::test1b($t2)
  3: $t6 := 2
  4: $t5 := pack 0x8675::M::S($t6)
  5: $t4 := M::test1b($t5)
  6: $t0 := +($t1, $t4)
  7: return $t0
}

// -- Model dump before second bytecode pipeline
module 0x8675::M {
    struct S {
        f: u64,
    }
    public fun test(): u64 {
        Add<u64>(M::test1(7), M::test1(2))
    }
    private fun test1(r: u64): u64 {
        {
          let tref: &mut u64 = Borrow(Mutable)(if Lt<u64>(r, 4) {
            r
          } else {
            3
          });
          tref = 10;
          {
            let y: u64 = r;
            {
              let tref2: &mut u64 = Borrow(Mutable)(y);
              tref2 = Add<u64>(Deref(tref2), 1);
              {
                let z: u64 = y;
                {
                  let tref3: &mut u64 = Borrow(Mutable)(Add<u64>(z, 0));
                  tref3 = Add<u64>(Deref(tref3), 2);
                  {
                    let a: u64 = z;
                    {
                      let tref4: &mut u64 = Borrow(Mutable)(a);
                      tref4 = Add<u64>(Deref(tref4), 4);
                      {
                        let tref5: &mut u64 = Borrow(Mutable)(a);
                        tref5 = Add<u64>(Deref(tref5), 8);
                        {
                          let tref6: &mut u64 = Borrow(Mutable)(3;
                          a);
                          tref6 = Add<u64>(Deref(tref6), 16);
                          a
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun test1b(r: S): u64 {
        {
          let x: S = pack M::S(3);
          {
            let tref: &mut S = Borrow(Mutable)(if Lt<u64>(select M::S.f<S>(r), 4) {
              r
            } else {
              x
            });
            select M::S.f<S>(Deref(tref)) = 10;
            {
              let y: S = r;
              {
                let tref2: &mut S = Borrow(Mutable)(y);
                select M::S.f<S>(Deref(tref2)) = Add<u64>(select M::S.f<S>(Deref(tref2)), 1);
                {
                  let z: S = y;
                  {
                    let tref3: &mut u64 = Borrow(Mutable)(select M::S.f<S>(z));
                    tref3 = Add<u64>(Deref(tref3), 1);
                    {
                      let a: S = z;
                      {
                        let tref4: &mut u64 = Borrow(Mutable)(select M::S.f<S>(a));
                        tref4 = Add<u64>(Deref(tref4), 1);
                        {
                          let tref5: &mut u64 = Borrow(Mutable)(select M::S.f<S>(a));
                          tref5 = Add<u64>(Deref(tref5), 8);
                          {
                            let tref6: &mut u64 = Borrow(Mutable)(3;
                            select M::S.f<S>(a));
                            tref6 = Add<u64>(Deref(tref6), 16);
                            select M::S.f<S>(a)
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    public fun testb(): u64 {
        Add<u64>(M::test1b(pack M::S(7)), M::test1b(pack M::S(2)))
    }
} // end 0x8675::M

============ bytecode before second stackless bytecode pipeline ================

[variant baseline]
public fun M::test(): u64 {
     var $t0: u64
     var $t1: u64
     var $t2: u64
     var $t3: u64
     var $t4: u64
  0: $t2 := 7
  1: $t1 := M::test1($t2)
  2: $t4 := 2
  3: $t3 := M::test1($t4)
  4: $t0 := +($t1, $t3)
  5: return $t0
}


[variant baseline]
fun M::test1($t0: u64): u64 {
     var $t1: u64
     var $t2: &mut u64
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: u64
     var $t8: u64
     var $t9: &mut u64
     var $t10: u64
     var $t11: u64
     var $t12: u64
     var $t13: u64
     var $t14: &mut u64
     var $t15: u64
     var $t16: u64
     var $t17: u64
     var $t18: u64
     var $t19: u64
     var $t20: u64
     var $t21: u64
     var $t22: &mut u64
     var $t23: u64
     var $t24: u64
     var $t25: u64
     var $t26: u64
     var $t27: &mut u64
     var $t28: u64
     var $t29: u64
     var $t30: u64
     var $t31: u64
     var $t32: &mut u64
     var $t33: u64
     var $t34: u64
     var $t35: u64
     var $t36: u64
     var $t37: u64
  0: $t5 := infer($t0)
  1: $t6 := 4
  2: $t4 := <($t5, $t6)
  3: if ($t4) goto 4 else goto 7
  4: label L0
  5: $t3 := infer($t0)
  6: goto 9
  7: label L1
  8: $t3 := 3
  9: label L2
 10: $t2 := borrow_local($t3)
 11: $t7 := 10
 12: write_ref($t2, $t7)
 13: $t8 := infer($t0)
 14: $t9 := borrow_local($t8)
 15: $t11 := read_ref($t9)
 16: $t12 := 1
 17: $t10 := +($t11, $t12)
 18: write_ref($t9, $t10)
 19: $t13 := infer($t8)
 20: $t16 := infer($t13)
 21: $t17 := 0
 22: $t15 := +($t16, $t17)
 23: $t14 := borrow_local($t15)
 24: $t19 := read_ref($t14)
 25: $t20 := 2
 26: $t18 := +($t19, $t20)
 27: write_ref($t14, $t18)
 28: $t21 := infer($t13)
 29: $t23 := infer($t21)
 30: $t22 := borrow_local($t23)
 31: $t25 := read_ref($t22)
 32: $t26 := 4
 33: $t24 := +($t25, $t26)
 34: write_ref($t22, $t24)
 35: $t28 := infer($t21)
 36: $t27 := borrow_local($t28)
 37: $t30 := read_ref($t27)
 38: $t31 := 8
 39: $t29 := +($t30, $t31)
 40: write_ref($t27, $t29)
 41: $t34 := 3
 42: $t33 := infer($t21)
 43: $t32 := borrow_local($t33)
 44: $t36 := read_ref($t32)
 45: $t37 := 16
 46: $t35 := +($t36, $t37)
 47: write_ref($t32, $t35)
 48: $t1 := infer($t21)
 49: return $t1
}


[variant baseline]
fun M::test1b($t0: 0x8675::M::S): u64 {
     var $t1: u64
     var $t2: 0x8675::M::S
     var $t3: u64
     var $t4: &mut 0x8675::M::S
     var $t5: 0x8675::M::S
     var $t6: bool
     var $t7: u64
     var $t8: &0x8675::M::S
     var $t9: &u64
     var $t10: u64
     var $t11: u64
     var $t12: &mut u64
     var $t13: 0x8675::M::S
     var $t14: &mut 0x8675::M::S
     var $t15: 0x8675::M::S
     var $t16: &mut 0x8675::M::S
     var $t17: u64
     var $t18: u64
     var $t19: 0x8675::M::S
     var $t20: &0x8675::M::S
     var $t21: &u64
     var $t22: u64
     var $t23: &mut u64
     var $t24: 0x8675::M::S
     var $t25: &mut 0x8675::M::S
     var $t26: 0x8675::M::S
     var $t27: &mut u64
     var $t28: &mut 0x8675::M::S
     var $t29: u64
     var $t30: u64
     var $t31: u64
     var $t32: 0x8675::M::S
     var $t33: &mut u64
     var $t34: u64
     var $t35: &0x8675::M::S
     var $t36: &u64
     var $t37: u64
     var $t38: u64
     var $t39: u64
     var $t40: &mut u64
     var $t41: u64
     var $t42: &0x8675::M::S
     var $t43: &u64
     var $t44: u64
     var $t45: u64
     var $t46: u64
     var $t47: &mut u64
     var $t48: u64
     var $t49: u64
     var $t50: &0x8675::M::S
     var $t51: &u64
     var $t52: u64
     var $t53: u64
     var $t54: u64
     var $t55: &0x8675::M::S
     var $t56: &u64
  0: $t3 := 3
  1: $t2 := pack 0x8675::M::S($t3)
  2: $t8 := borrow_local($t0)
  3: $t9 := borrow_field<0x8675::M::S>.f($t8)
  4: $t7 := read_ref($t9)
  5: $t10 := 4
  6: $t6 := <($t7, $t10)
  7: if ($t6) goto 8 else goto 11
  8: label L0
  9: $t5 := infer($t0)
 10: goto 13
 11: label L1
 12: $t5 := infer($t2)
 13: label L2
 14: $t4 := borrow_local($t5)
 15: $t11 := 10
 16: $t13 := read_ref($t4)
 17: $t14 := borrow_local($t13)
 18: $t12 := borrow_field<0x8675::M::S>.f($t14)
 19: write_ref($t12, $t11)
 20: $t15 := infer($t0)
 21: $t16 := borrow_local($t15)
 22: $t19 := read_ref($t16)
 23: $t20 := borrow_local($t19)
 24: $t21 := borrow_field<0x8675::M::S>.f($t20)
 25: $t18 := read_ref($t21)
 26: $t22 := 1
 27: $t17 := +($t18, $t22)
 28: $t24 := read_ref($t16)
 29: $t25 := borrow_local($t24)
 30: $t23 := borrow_field<0x8675::M::S>.f($t25)
 31: write_ref($t23, $t17)
 32: $t26 := infer($t15)
 33: $t28 := borrow_local($t26)
 34: $t27 := borrow_field<0x8675::M::S>.f($t28)
 35: $t30 := read_ref($t27)
 36: $t31 := 1
 37: $t29 := +($t30, $t31)
 38: write_ref($t27, $t29)
 39: $t32 := infer($t26)
 40: $t35 := borrow_local($t32)
 41: $t36 := borrow_field<0x8675::M::S>.f($t35)
 42: $t34 := read_ref($t36)
 43: $t33 := borrow_local($t34)
 44: $t38 := read_ref($t33)
 45: $t39 := 1
 46: $t37 := +($t38, $t39)
 47: write_ref($t33, $t37)
 48: $t42 := borrow_local($t32)
 49: $t43 := borrow_field<0x8675::M::S>.f($t42)
 50: $t41 := read_ref($t43)
 51: $t40 := borrow_local($t41)
 52: $t45 := read_ref($t40)
 53: $t46 := 8
 54: $t44 := +($t45, $t46)
 55: write_ref($t40, $t44)
 56: $t49 := 3
 57: $t50 := borrow_local($t32)
 58: $t51 := borrow_field<0x8675::M::S>.f($t50)
 59: $t48 := read_ref($t51)
 60: $t47 := borrow_local($t48)
 61: $t53 := read_ref($t47)
 62: $t54 := 16
 63: $t52 := +($t53, $t54)
 64: write_ref($t47, $t52)
 65: $t55 := borrow_local($t32)
 66: $t56 := borrow_field<0x8675::M::S>.f($t55)
 67: $t1 := read_ref($t56)
 68: return $t1
}


[variant baseline]
public fun M::testb(): u64 {
     var $t0: u64
     var $t1: u64
     var $t2: 0x8675::M::S
     var $t3: u64
     var $t4: u64
     var $t5: 0x8675::M::S
     var $t6: u64
  0: $t3 := 7
  1: $t2 := pack 0x8675::M::S($t3)
  2: $t1 := M::test1b($t2)
  3: $t6 := 2
  4: $t5 := pack 0x8675::M::S($t6)
  5: $t4 := M::test1b($t5)
  6: $t0 := +($t1, $t4)
  7: return $t0
}


============ disassembled file-format ==================
// Bytecode version v9
module 0x8675::M
struct S has copy + drop
  f: u64

// Function definition at index 0
#[persistent] public fun test(): u64
    ld_u64 7
    call test1
    ld_u64 2
    call test1
    add
    // @5
    ret

// Function definition at index 1
fun test1(l0: u64): u64
    local l1: u64
    local l2: u64
    local l3: &mut u64
    local l4: u64
    local l5: u64
    local l6: u64
    local l7: u64
    local l8: u64
    copy_loc l0
    ld_u64 4
    lt
    br_false l0
    copy_loc l0
    // @5
    st_loc l1
l1: mut_borrow_loc l1
    st_loc l3
    ld_u64 10
    move_loc l3
    // @10
    write_ref
    move_loc l0
    st_loc l4
    mut_borrow_loc l4
    st_loc l3
    // @15
    copy_loc l3
    read_ref
    ld_u64 1
    add
    move_loc l3
    // @20
    write_ref
    move_loc l4
    st_loc l2
    copy_loc l2
    ld_u64 0
    // @25
    add
    st_loc l5
    mut_borrow_loc l5
    st_loc l3
    copy_loc l3
    // @30
    read_ref
    ld_u64 2
    add
    move_loc l3
    write_ref
    // @35
    copy_loc l2
    st_loc l6
    mut_borrow_loc l6
    st_loc l3
    copy_loc l3
    // @40
    read_ref
    ld_u64 4
    add
    move_loc l3
    write_ref
    // @45
    copy_loc l2
    st_loc l7
    mut_borrow_loc l7
    st_loc l3
    copy_loc l3
    // @50
    read_ref
    ld_u64 8
    add
    move_loc l3
    write_ref
    // @55
    copy_loc l2
    st_loc l8
    mut_borrow_loc l8
    st_loc l3
    copy_loc l3
    // @60
    read_ref
    ld_u64 16
    add
    move_loc l3
    write_ref
    // @65
    move_loc l2
    ret
l0: ld_u64 3
    st_loc l1
    branch l1

// Function definition at index 2
fun test1b(l0: S): u64
    local l1: S
    local l2: S
    local l3: &mut S
    local l4: S
    local l5: S
    local l6: S
    local l7: S
    local l8: S
    local l9: &mut u64
    local l10: S
    local l11: u64
    local l12: u64
    local l13: u64
    ld_u64 3
    pack S
    st_loc l1
    borrow_loc l0
    borrow_field S, f
    // @5
    read_ref
    ld_u64 4
    lt
    br_false l0
    copy_loc l0
    // @10
    st_loc l2
l1: mut_borrow_loc l2
    st_loc l3
    ld_u64 10
    move_loc l3
    // @15
    read_ref
    st_loc l4
    mut_borrow_loc l4
    mut_borrow_field S, f
    write_ref
    // @20
    move_loc l0
    st_loc l5
    mut_borrow_loc l5
    st_loc l3
    copy_loc l3
    // @25
    read_ref
    st_loc l6
    borrow_loc l6
    borrow_field S, f
    read_ref
    // @30
    ld_u64 1
    add
    move_loc l3
    read_ref
    st_loc l7
    // @35
    mut_borrow_loc l7
    mut_borrow_field S, f
    write_ref
    move_loc l5
    st_loc l8
    // @40
    mut_borrow_loc l8
    mut_borrow_field S, f
    st_loc l9
    copy_loc l9
    read_ref
    // @45
    ld_u64 1
    add
    move_loc l9
    write_ref
    move_loc l8
    // @50
    st_loc l10
    borrow_loc l10
    borrow_field S, f
    read_ref
    st_loc l11
    // @55
    mut_borrow_loc l11
    st_loc l9
    copy_loc l9
    read_ref
    ld_u64 1
    // @60
    add
    move_loc l9
    write_ref
    borrow_loc l10
    borrow_field S, f
    // @65
    read_ref
    st_loc l12
    mut_borrow_loc l12
    st_loc l9
    copy_loc l9
    // @70
    read_ref
    ld_u64 8
    add
    move_loc l9
    write_ref
    // @75
    borrow_loc l10
    borrow_field S, f
    read_ref
    st_loc l13
    mut_borrow_loc l13
    // @80
    st_loc l9
    copy_loc l9
    read_ref
    ld_u64 16
    add
    // @85
    move_loc l9
    write_ref
    borrow_loc l10
    borrow_field S, f
    read_ref
    // @90
    ret
l0: move_loc l1
    st_loc l2
    branch l1

// Function definition at index 3
#[persistent] public fun testb(): u64
    ld_u64 7
    pack S
    call test1b
    ld_u64 2
    pack S
    // @5
    call test1b
    add
    ret


============ bytecode verification succeeded ========
