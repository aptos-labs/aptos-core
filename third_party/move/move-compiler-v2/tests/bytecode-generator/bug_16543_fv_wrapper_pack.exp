// -- Model dump before first bytecode pipeline
module 0xc0ffee::m {
    struct Lazy {
        0: || has drop,
    }
} // end 0xc0ffee::m
module 0xc0ffee::m_friend {
    struct Lazy {
        0: || has drop,
    }
} // end 0xc0ffee::m_friend
module 0xc0ffee::n {
    public fun test(): m::Lazy {
        closure#0n::__lambda__1__test()
    }
    public fun test_friend(): m_friend::Lazy {
        closure#0n::__lambda__1__test_friend()
    }
    private fun __lambda__1__test() {
        Tuple()
    }
    private fun __lambda__1__test_friend() {
        Tuple()
    }
} // end 0xc0ffee::n

// -- Sourcified model before first bytecode pipeline
module 0xc0ffee::m {
    friend 0xc0ffee::n;
    struct Lazy has drop {
        0: || has drop,
    }
}
module 0xc0ffee::m_friend {
    friend 0xc0ffee::n;
    struct Lazy has drop {
        0: || has drop,
    }
}
module 0xc0ffee::n {
    public fun test(): m::Lazy {
        <<wrongly typed closure expression>>
    }
    public fun test_friend(): m_friend::Lazy {
        <<wrongly typed closure expression>>
    }
    fun lambda__1__test() {
    }
    fun lambda__1__test_friend() {
    }
}

============ bytecode before first stackless bytecode pipeline ================

[variant baseline]
public fun n::test(): 0xc0ffee::m::Lazy {
     var $t0: 0xc0ffee::m::Lazy
     var $t1: || has drop
  0: $t1 := closure#0 n::__lambda__1__test()
  1: $t0 := pack 0xc0ffee::m::Lazy($t1)
  2: return $t0
}


[variant baseline]
public fun n::test_friend(): 0xc0ffee::m_friend::Lazy {
     var $t0: 0xc0ffee::m_friend::Lazy
     var $t1: || has drop
  0: $t1 := closure#0 n::__lambda__1__test_friend()
  1: $t0 := pack 0xc0ffee::m_friend::Lazy($t1)
  2: return $t0
}


[variant baseline]
fun n::__lambda__1__test() {
  0: return ()
}


[variant baseline]
fun n::__lambda__1__test_friend() {
  0: return ()
}

// -- Model dump before second bytecode pipeline
module 0xc0ffee::m {
    struct Lazy {
        0: || has drop,
    }
} // end 0xc0ffee::m
module 0xc0ffee::m_friend {
    struct Lazy {
        0: || has drop,
    }
} // end 0xc0ffee::m_friend
module 0xc0ffee::n {
    public fun test(): m::Lazy {
        closure#0n::__lambda__1__test()
    }
    public fun test_friend(): m_friend::Lazy {
        closure#0n::__lambda__1__test_friend()
    }
    private fun __lambda__1__test() {
        Tuple()
    }
    private fun __lambda__1__test_friend() {
        Tuple()
    }
} // end 0xc0ffee::n

============ bytecode before second stackless bytecode pipeline ================

[variant baseline]
public fun n::test(): 0xc0ffee::m::Lazy {
     var $t0: 0xc0ffee::m::Lazy
     var $t1: || has drop
  0: $t1 := closure#0 n::__lambda__1__test()
  1: $t0 := pack 0xc0ffee::m::Lazy($t1)
  2: return $t0
}


[variant baseline]
public fun n::test_friend(): 0xc0ffee::m_friend::Lazy {
     var $t0: 0xc0ffee::m_friend::Lazy
     var $t1: || has drop
  0: $t1 := closure#0 n::__lambda__1__test_friend()
  1: $t0 := pack 0xc0ffee::m_friend::Lazy($t1)
  2: return $t0
}


[variant baseline]
fun n::__lambda__1__test() {
  0: return ()
}


[variant baseline]
fun n::__lambda__1__test_friend() {
  0: return ()
}


============ disassembled file-format ==================
// Bytecode version v10
module 0xc0ffee::m
friend 0xc0ffee::n
struct Lazy has drop
  _0: || has drop

// Function definition at index 0
#[pack] friend fun pack$Lazy(l0: || has drop): Lazy
    local l1: || has drop
    move_loc l0
    pack Lazy
    ret

// Function definition at index 1
#[unpack] friend fun unpack$Lazy(l0: Lazy): || has drop
    local l1: Lazy
    move_loc l0
    unpack Lazy
    ret

// Function definition at index 2
#[borrow=0] friend fun borrow$Lazy$0(l0: &Lazy): &|| has drop
    local l1: &Lazy
    move_loc l0
    borrow_field Lazy, _0
    ret

// Function definition at index 3
#[borrow_mut=0] friend fun borrow_mut$Lazy$0(l0: &mut Lazy): &mut || has drop
    local l1: &mut Lazy
    move_loc l0
    mut_borrow_field Lazy, _0
    ret

// Bytecode version v10
module 0xc0ffee::m_friend
friend 0xc0ffee::n
struct Lazy has drop
  _0: || has drop

// Function definition at index 0
#[pack] friend fun pack$Lazy(l0: || has drop): Lazy
    local l1: || has drop
    move_loc l0
    pack Lazy
    ret

// Function definition at index 1
#[unpack] friend fun unpack$Lazy(l0: Lazy): || has drop
    local l1: Lazy
    move_loc l0
    unpack Lazy
    ret

// Function definition at index 2
#[borrow=0] friend fun borrow$Lazy$0(l0: &Lazy): &|| has drop
    local l1: &Lazy
    move_loc l0
    borrow_field Lazy, _0
    ret

// Function definition at index 3
#[borrow_mut=0] friend fun borrow_mut$Lazy$0(l0: &mut Lazy): &mut || has drop
    local l1: &mut Lazy
    move_loc l0
    mut_borrow_field Lazy, _0
    ret

// Bytecode version v10
module 0xc0ffee::n
use 0xc0ffee::m
use 0xc0ffee::m_friend
// Function definition at index 0
#[persistent] public fun test(): m::Lazy
    pack_closure __lambda__1__test, 0
    call m::pack$Lazy
    ret

// Function definition at index 1
#[persistent] public fun test_friend(): m_friend::Lazy
    pack_closure __lambda__1__test_friend, 0
    call m_friend::pack$Lazy
    ret

// Function definition at index 2
fun __lambda__1__test()
    ret

// Function definition at index 3
fun __lambda__1__test_friend()
    ret


============ bytecode verification succeeded ========
