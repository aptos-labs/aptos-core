// -- Model dump before first bytecode pipeline
module 0xc0ffee::m {
    struct Lazy {
        0: || has drop,
    }
    friend fun _pack_0xc0ffee_1_m_4_Lazy(_0: || has drop): Lazy {
        pack m::Lazy(_0)
    }
    friend fun _unpack_0xc0ffee_1_m_4_Lazy(_s: Lazy): (|| has drop) {
        {
          let m::Lazy{ 0 } = _s;
          Tuple(0)
        }
    }
    friend fun _unpackmutref_0xc0ffee_1_m_4_Lazy(_s: &mut Lazy): (&mut || has drop) {
        Tuple(Borrow(Mutable)(select_variants m::Lazy.0(_s)))
    }
    friend fun _borrow_0xc0ffee_1_m_4_Lazy_0_0(_s: &Lazy): &|| has drop {
        Borrow(Immutable)(select m::Lazy.0(_s))
    }
    friend fun _borrowmut_0xc0ffee_1_m_4_Lazy_0_0(_s: &mut Lazy): &mut || has drop {
        Borrow(Mutable)(select m::Lazy.0(_s))
    }
} // end 0xc0ffee::m
module 0xc0ffee::m_friend {
    struct Lazy {
        0: || has drop,
    }
    friend fun _pack_0xc0ffee_8_m_friend_4_Lazy(_0: || has drop): Lazy {
        pack m_friend::Lazy(_0)
    }
    friend fun _unpack_0xc0ffee_8_m_friend_4_Lazy(_s: Lazy): (|| has drop) {
        {
          let m_friend::Lazy{ 0 } = _s;
          Tuple(0)
        }
    }
    friend fun _unpackmutref_0xc0ffee_8_m_friend_4_Lazy(_s: &mut Lazy): (&mut || has drop) {
        Tuple(Borrow(Mutable)(select_variants m_friend::Lazy.0(_s)))
    }
    friend fun _borrow_0xc0ffee_8_m_friend_4_Lazy_0_0(_s: &Lazy): &|| has drop {
        Borrow(Immutable)(select m_friend::Lazy.0(_s))
    }
    friend fun _borrowmut_0xc0ffee_8_m_friend_4_Lazy_0_0(_s: &mut Lazy): &mut || has drop {
        Borrow(Mutable)(select m_friend::Lazy.0(_s))
    }
} // end 0xc0ffee::m_friend
module 0xc0ffee::n {
    public fun test(): m::Lazy {
        closure#0n::__lambda__1__test()
    }
    public fun test_friend(): m_friend::Lazy {
        closure#0n::__lambda__1__test_friend()
    }
    private fun __lambda__1__test() {
        Tuple()
    }
    private fun __lambda__1__test_friend() {
        Tuple()
    }
} // end 0xc0ffee::n

// -- Sourcified model before first bytecode pipeline
module 0xc0ffee::m {
    friend 0xc0ffee::n;
    struct Lazy has drop {
        0: || has drop,
    }
    friend fun _pack_0xc0ffee_1_m_4_Lazy(_0: || has drop): Lazy {
        Lazy(_0)
    }
    friend fun _unpack_0xc0ffee_1_m_4_Lazy(_s: Lazy): (|| has drop) {
        let Lazy(0) = _s;
        (0)
    }
    friend fun _unpackmutref_0xc0ffee_1_m_4_Lazy(_s: &mut Lazy): (&mut || has drop) {
        (&mut _s.0)
    }
    friend fun _borrow_0xc0ffee_1_m_4_Lazy_0_0(_s: &Lazy): &|| has drop {
        &_s.0
    }
    friend fun _borrowmut_0xc0ffee_1_m_4_Lazy_0_0(_s: &mut Lazy): &mut || has drop {
        &mut _s.0
    }
}
module 0xc0ffee::m_friend {
    friend 0xc0ffee::n;
    struct Lazy has drop {
        0: || has drop,
    }
    friend fun _pack_0xc0ffee_8_m_friend_4_Lazy(_0: || has drop): Lazy {
        Lazy(_0)
    }
    friend fun _unpack_0xc0ffee_8_m_friend_4_Lazy(_s: Lazy): (|| has drop) {
        let Lazy(0) = _s;
        (0)
    }
    friend fun _unpackmutref_0xc0ffee_8_m_friend_4_Lazy(_s: &mut Lazy): (&mut || has drop) {
        (&mut _s.0)
    }
    friend fun _borrow_0xc0ffee_8_m_friend_4_Lazy_0_0(_s: &Lazy): &|| has drop {
        &_s.0
    }
    friend fun _borrowmut_0xc0ffee_8_m_friend_4_Lazy_0_0(_s: &mut Lazy): &mut || has drop {
        &mut _s.0
    }
}
module 0xc0ffee::n {
    public fun test(): m::Lazy {
        <<wrongly typed closure expression>>
    }
    public fun test_friend(): m_friend::Lazy {
        <<wrongly typed closure expression>>
    }
    fun lambda__1__test() {
    }
    fun lambda__1__test_friend() {
    }
}

============ bytecode before first stackless bytecode pipeline ================

[variant baseline]
public(friend) fun m::_pack_0xc0ffee_1_m_4_Lazy($t0: || has drop): 0xc0ffee::m::Lazy {
     var $t1: 0xc0ffee::m::Lazy
  0: $t1 := pack 0xc0ffee::m::Lazy($t0)
  1: return $t1
}


[variant baseline]
public(friend) fun m::_unpack_0xc0ffee_1_m_4_Lazy($t0: 0xc0ffee::m::Lazy): || has drop {
     var $t1: || has drop
     var $t2: || has drop
  0: $t2 := unpack 0xc0ffee::m::Lazy($t0)
  1: $t1 := infer($t2)
  2: return $t1
}


[variant baseline]
public(friend) fun m::_unpackmutref_0xc0ffee_1_m_4_Lazy($t0: &mut 0xc0ffee::m::Lazy): &mut || has drop {
     var $t1: &mut || has drop
  0: $t1 := borrow_field<0xc0ffee::m::Lazy>.0($t0)
  1: return $t1
}


[variant baseline]
public(friend) fun m::_borrow_0xc0ffee_1_m_4_Lazy_0_0($t0: &0xc0ffee::m::Lazy): &|| has drop {
     var $t1: &|| has drop
  0: $t1 := borrow_field<0xc0ffee::m::Lazy>.0($t0)
  1: return $t1
}


[variant baseline]
public(friend) fun m::_borrowmut_0xc0ffee_1_m_4_Lazy_0_0($t0: &mut 0xc0ffee::m::Lazy): &mut || has drop {
     var $t1: &mut || has drop
  0: $t1 := borrow_field<0xc0ffee::m::Lazy>.0($t0)
  1: return $t1
}


[variant baseline]
public(friend) fun m_friend::_pack_0xc0ffee_8_m_friend_4_Lazy($t0: || has drop): 0xc0ffee::m_friend::Lazy {
     var $t1: 0xc0ffee::m_friend::Lazy
  0: $t1 := pack 0xc0ffee::m_friend::Lazy($t0)
  1: return $t1
}


[variant baseline]
public(friend) fun m_friend::_unpack_0xc0ffee_8_m_friend_4_Lazy($t0: 0xc0ffee::m_friend::Lazy): || has drop {
     var $t1: || has drop
     var $t2: || has drop
  0: $t2 := unpack 0xc0ffee::m_friend::Lazy($t0)
  1: $t1 := infer($t2)
  2: return $t1
}


[variant baseline]
public(friend) fun m_friend::_unpackmutref_0xc0ffee_8_m_friend_4_Lazy($t0: &mut 0xc0ffee::m_friend::Lazy): &mut || has drop {
     var $t1: &mut || has drop
  0: $t1 := borrow_field<0xc0ffee::m_friend::Lazy>.0($t0)
  1: return $t1
}


[variant baseline]
public(friend) fun m_friend::_borrow_0xc0ffee_8_m_friend_4_Lazy_0_0($t0: &0xc0ffee::m_friend::Lazy): &|| has drop {
     var $t1: &|| has drop
  0: $t1 := borrow_field<0xc0ffee::m_friend::Lazy>.0($t0)
  1: return $t1
}


[variant baseline]
public(friend) fun m_friend::_borrowmut_0xc0ffee_8_m_friend_4_Lazy_0_0($t0: &mut 0xc0ffee::m_friend::Lazy): &mut || has drop {
     var $t1: &mut || has drop
  0: $t1 := borrow_field<0xc0ffee::m_friend::Lazy>.0($t0)
  1: return $t1
}


[variant baseline]
public fun n::test(): 0xc0ffee::m::Lazy {
     var $t0: 0xc0ffee::m::Lazy
     var $t1: || has drop
  0: $t1 := closure#0 n::__lambda__1__test()
  1: $t0 := m::_pack_0xc0ffee_1_m_4_Lazy($t1)
  2: return $t0
}


[variant baseline]
public fun n::test_friend(): 0xc0ffee::m_friend::Lazy {
     var $t0: 0xc0ffee::m_friend::Lazy
     var $t1: || has drop
  0: $t1 := closure#0 n::__lambda__1__test_friend()
  1: $t0 := m_friend::_pack_0xc0ffee_8_m_friend_4_Lazy($t1)
  2: return $t0
}


[variant baseline]
fun n::__lambda__1__test() {
  0: return ()
}


[variant baseline]
fun n::__lambda__1__test_friend() {
  0: return ()
}

// -- Model dump before second bytecode pipeline
module 0xc0ffee::m {
    struct Lazy {
        0: || has drop,
    }
    friend fun _pack_0xc0ffee_1_m_4_Lazy(_0: || has drop): Lazy {
        pack m::Lazy(_0)
    }
    friend fun _unpack_0xc0ffee_1_m_4_Lazy(_s: Lazy): (|| has drop) {
        {
          let m::Lazy{ 0 } = _s;
          Tuple(0)
        }
    }
    friend fun _unpackmutref_0xc0ffee_1_m_4_Lazy(_s: &mut Lazy): (&mut || has drop) {
        Tuple(Borrow(Mutable)(select_variants m::Lazy.0(_s)))
    }
    friend fun _borrow_0xc0ffee_1_m_4_Lazy_0_0(_s: &Lazy): &|| has drop {
        Borrow(Immutable)(select m::Lazy.0(_s))
    }
    friend fun _borrowmut_0xc0ffee_1_m_4_Lazy_0_0(_s: &mut Lazy): &mut || has drop {
        Borrow(Mutable)(select m::Lazy.0(_s))
    }
} // end 0xc0ffee::m
module 0xc0ffee::m_friend {
    struct Lazy {
        0: || has drop,
    }
    friend fun _pack_0xc0ffee_8_m_friend_4_Lazy(_0: || has drop): Lazy {
        pack m_friend::Lazy(_0)
    }
    friend fun _unpack_0xc0ffee_8_m_friend_4_Lazy(_s: Lazy): (|| has drop) {
        {
          let m_friend::Lazy{ 0 } = _s;
          Tuple(0)
        }
    }
    friend fun _unpackmutref_0xc0ffee_8_m_friend_4_Lazy(_s: &mut Lazy): (&mut || has drop) {
        Tuple(Borrow(Mutable)(select_variants m_friend::Lazy.0(_s)))
    }
    friend fun _borrow_0xc0ffee_8_m_friend_4_Lazy_0_0(_s: &Lazy): &|| has drop {
        Borrow(Immutable)(select m_friend::Lazy.0(_s))
    }
    friend fun _borrowmut_0xc0ffee_8_m_friend_4_Lazy_0_0(_s: &mut Lazy): &mut || has drop {
        Borrow(Mutable)(select m_friend::Lazy.0(_s))
    }
} // end 0xc0ffee::m_friend
module 0xc0ffee::n {
    public fun test(): m::Lazy {
        closure#0n::__lambda__1__test()
    }
    public fun test_friend(): m_friend::Lazy {
        closure#0n::__lambda__1__test_friend()
    }
    private fun __lambda__1__test() {
        Tuple()
    }
    private fun __lambda__1__test_friend() {
        Tuple()
    }
} // end 0xc0ffee::n

============ bytecode before second stackless bytecode pipeline ================

[variant baseline]
public(friend) fun m::_pack_0xc0ffee_1_m_4_Lazy($t0: || has drop): 0xc0ffee::m::Lazy {
     var $t1: 0xc0ffee::m::Lazy
  0: $t1 := pack 0xc0ffee::m::Lazy($t0)
  1: return $t1
}


[variant baseline]
public(friend) fun m::_unpack_0xc0ffee_1_m_4_Lazy($t0: 0xc0ffee::m::Lazy): || has drop {
     var $t1: || has drop
     var $t2: || has drop
  0: $t2 := unpack 0xc0ffee::m::Lazy($t0)
  1: $t1 := infer($t2)
  2: return $t1
}


[variant baseline]
public(friend) fun m::_unpackmutref_0xc0ffee_1_m_4_Lazy($t0: &mut 0xc0ffee::m::Lazy): &mut || has drop {
     var $t1: &mut || has drop
  0: $t1 := borrow_field<0xc0ffee::m::Lazy>.0($t0)
  1: return $t1
}


[variant baseline]
public(friend) fun m::_borrow_0xc0ffee_1_m_4_Lazy_0_0($t0: &0xc0ffee::m::Lazy): &|| has drop {
     var $t1: &|| has drop
  0: $t1 := borrow_field<0xc0ffee::m::Lazy>.0($t0)
  1: return $t1
}


[variant baseline]
public(friend) fun m::_borrowmut_0xc0ffee_1_m_4_Lazy_0_0($t0: &mut 0xc0ffee::m::Lazy): &mut || has drop {
     var $t1: &mut || has drop
  0: $t1 := borrow_field<0xc0ffee::m::Lazy>.0($t0)
  1: return $t1
}


[variant baseline]
public(friend) fun m_friend::_pack_0xc0ffee_8_m_friend_4_Lazy($t0: || has drop): 0xc0ffee::m_friend::Lazy {
     var $t1: 0xc0ffee::m_friend::Lazy
  0: $t1 := pack 0xc0ffee::m_friend::Lazy($t0)
  1: return $t1
}


[variant baseline]
public(friend) fun m_friend::_unpack_0xc0ffee_8_m_friend_4_Lazy($t0: 0xc0ffee::m_friend::Lazy): || has drop {
     var $t1: || has drop
     var $t2: || has drop
  0: $t2 := unpack 0xc0ffee::m_friend::Lazy($t0)
  1: $t1 := infer($t2)
  2: return $t1
}


[variant baseline]
public(friend) fun m_friend::_unpackmutref_0xc0ffee_8_m_friend_4_Lazy($t0: &mut 0xc0ffee::m_friend::Lazy): &mut || has drop {
     var $t1: &mut || has drop
  0: $t1 := borrow_field<0xc0ffee::m_friend::Lazy>.0($t0)
  1: return $t1
}


[variant baseline]
public(friend) fun m_friend::_borrow_0xc0ffee_8_m_friend_4_Lazy_0_0($t0: &0xc0ffee::m_friend::Lazy): &|| has drop {
     var $t1: &|| has drop
  0: $t1 := borrow_field<0xc0ffee::m_friend::Lazy>.0($t0)
  1: return $t1
}


[variant baseline]
public(friend) fun m_friend::_borrowmut_0xc0ffee_8_m_friend_4_Lazy_0_0($t0: &mut 0xc0ffee::m_friend::Lazy): &mut || has drop {
     var $t1: &mut || has drop
  0: $t1 := borrow_field<0xc0ffee::m_friend::Lazy>.0($t0)
  1: return $t1
}


[variant baseline]
public fun n::test(): 0xc0ffee::m::Lazy {
     var $t0: 0xc0ffee::m::Lazy
     var $t1: || has drop
  0: $t1 := closure#0 n::__lambda__1__test()
  1: $t0 := m::_pack_0xc0ffee_1_m_4_Lazy($t1)
  2: return $t0
}


[variant baseline]
public fun n::test_friend(): 0xc0ffee::m_friend::Lazy {
     var $t0: 0xc0ffee::m_friend::Lazy
     var $t1: || has drop
  0: $t1 := closure#0 n::__lambda__1__test_friend()
  1: $t0 := m_friend::_pack_0xc0ffee_8_m_friend_4_Lazy($t1)
  2: return $t0
}


[variant baseline]
fun n::__lambda__1__test() {
  0: return ()
}


[variant baseline]
fun n::__lambda__1__test_friend() {
  0: return ()
}


============ disassembled file-format ==================
// Move bytecode v8
module c0ffee.m {
struct Lazy has drop {
	_0: || has drop
}

public(friend) _pack_0xc0ffee_1_m_4_Lazy(_0: || has drop): Lazy /* def_idx: 0 */ {
B0:
	0: MoveLoc[0](_0: || has drop)
	1: Pack[0](Lazy)
	2: Ret
}
public(friend) _unpack_0xc0ffee_1_m_4_Lazy(_s: Lazy): || has drop /* def_idx: 1 */ {
B0:
	0: MoveLoc[0](_s: Lazy)
	1: Unpack[0](Lazy)
	2: Ret
}
public(friend) _unpackmutref_0xc0ffee_1_m_4_Lazy(_s: &mut Lazy): &mut || has drop /* def_idx: 2 */ {
B0:
	0: MoveLoc[0](_s: &mut Lazy)
	1: MutBorrowField[0](Lazy._0: || has drop)
	2: Ret
}
public(friend) _borrow_0xc0ffee_1_m_4_Lazy_0_0(_s: &Lazy): &|| has drop /* def_idx: 3 */ {
B0:
	0: MoveLoc[0](_s: &Lazy)
	1: ImmBorrowField[0](Lazy._0: || has drop)
	2: Ret
}
public(friend) _borrowmut_0xc0ffee_1_m_4_Lazy_0_0(_s: &mut Lazy): &mut || has drop /* def_idx: 4 */ {
B0:
	0: MoveLoc[0](_s: &mut Lazy)
	1: MutBorrowField[0](Lazy._0: || has drop)
	2: Ret
}
}// Move bytecode v8
module c0ffee.m_friend {
struct Lazy has drop {
	_0: || has drop
}

public(friend) _pack_0xc0ffee_8_m_friend_4_Lazy(_0: || has drop): Lazy /* def_idx: 0 */ {
B0:
	0: MoveLoc[0](_0: || has drop)
	1: Pack[0](Lazy)
	2: Ret
}
public(friend) _unpack_0xc0ffee_8_m_friend_4_Lazy(_s: Lazy): || has drop /* def_idx: 1 */ {
B0:
	0: MoveLoc[0](_s: Lazy)
	1: Unpack[0](Lazy)
	2: Ret
}
public(friend) _unpackmutref_0xc0ffee_8_m_friend_4_Lazy(_s: &mut Lazy): &mut || has drop /* def_idx: 2 */ {
B0:
	0: MoveLoc[0](_s: &mut Lazy)
	1: MutBorrowField[0](Lazy._0: || has drop)
	2: Ret
}
public(friend) _borrow_0xc0ffee_8_m_friend_4_Lazy_0_0(_s: &Lazy): &|| has drop /* def_idx: 3 */ {
B0:
	0: MoveLoc[0](_s: &Lazy)
	1: ImmBorrowField[0](Lazy._0: || has drop)
	2: Ret
}
public(friend) _borrowmut_0xc0ffee_8_m_friend_4_Lazy_0_0(_s: &mut Lazy): &mut || has drop /* def_idx: 4 */ {
B0:
	0: MoveLoc[0](_s: &mut Lazy)
	1: MutBorrowField[0](Lazy._0: || has drop)
	2: Ret
}
}// Move bytecode v8
module c0ffee.n {
use 0000000000000000000000000000000000000000000000000000000000c0ffee::m;
use 0000000000000000000000000000000000000000000000000000000000c0ffee::m_friend;




public test(): Lazy /* def_idx: 0 */ {
B0:
	0: PackClosure#0 __lambda__1__test()
	1: Call m::_pack_0xc0ffee_1_m_4_Lazy(|| has drop): Lazy
	2: Ret
}
public test_friend(): Lazy /* def_idx: 1 */ {
B0:
	0: PackClosure#0 __lambda__1__test_friend()
	1: Call m_friend::_pack_0xc0ffee_8_m_friend_4_Lazy(|| has drop): Lazy
	2: Ret
}
__lambda__1__test() /* def_idx: 2 */ {
B0:
	0: Ret
}
__lambda__1__test_friend() /* def_idx: 3 */ {
B0:
	0: Ret
}
}
============ bytecode verification succeeded ========
