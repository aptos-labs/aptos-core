// -- Model dump before first bytecode pipeline
module 0x42::m {
    use std::vector;
    struct E {
        k: u8,
    }
    struct S {
        data: vector<E>,
    }
    public fun foo(v: &S): u8 {
        select m::E.k<&E>(vector::borrow<E>(Borrow(Immutable)(select m::S.data<&S>(v)), 0))
    }
} // end 0x42::m

// -- Sourcified model before first bytecode pipeline
module 0x42::m {
    use std::vector;
    struct E {
        k: u8,
    }
    struct S {
        data: vector<E>,
    }
    public fun foo(v: &S): u8 {
        0x1::vector::borrow<E>(&v.data, 0).k
    }
}

============ bytecode before first stackless bytecode pipeline ================

[variant baseline]
public fun m::foo($t0: &0x42::m::S): u8 {
     var $t1: u8
     var $t2: &0x42::m::E
     var $t3: &vector<0x42::m::E>
     var $t4: u64
     var $t5: &u8
  0: $t3 := borrow_field<0x42::m::S>.data($t0)
  1: $t4 := 0
  2: $t2 := vector::borrow<0x42::m::E>($t3, $t4)
  3: $t5 := borrow_field<0x42::m::E>.k($t2)
  4: $t1 := read_ref($t5)
  5: return $t1
}

// -- Model dump before second bytecode pipeline
module 0x42::m {
    use std::vector;
    struct E {
        k: u8,
    }
    struct S {
        data: vector<E>,
    }
    public fun foo(v: &S): u8 {
        select m::E.k<&E>(vector::borrow<E>(Borrow(Immutable)(select m::S.data<&S>(v)), 0))
    }
} // end 0x42::m

============ bytecode before second stackless bytecode pipeline ================

[variant baseline]
public fun m::foo($t0: &0x42::m::S): u8 {
     var $t1: u8
     var $t2: &0x42::m::E
     var $t3: &vector<0x42::m::E>
     var $t4: u64
     var $t5: &u8
  0: $t3 := borrow_field<0x42::m::S>.data($t0)
  1: $t4 := 0
  2: $t2 := vector::borrow<0x42::m::E>($t3, $t4)
  3: $t5 := borrow_field<0x42::m::E>.k($t2)
  4: $t1 := read_ref($t5)
  5: return $t1
}


============ disassembled file-format ==================
// Bytecode version v9
module 0x42::m
struct E
  k: u8

struct S
  data: vector<E>

// Function definition at index 0
#[persistent] public fun foo(l0: &S): u8
    move_loc l0
    borrow_field S, data
    ld_u64 0
    vec_borrow <E>
    borrow_field E, k
    // @5
    read_ref
    ret


============ bytecode verification succeeded ========
