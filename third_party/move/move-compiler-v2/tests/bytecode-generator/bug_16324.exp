// -- Model dump before first bytecode pipeline
module 0xc0ffee::m {
    use std::vector;
    struct TestOrder {
        price: u64,
        size: u64,
    }
    private fun price(self: &TestOrder): u64 {
        select m::TestOrder.price<&TestOrder>(self)
    }
    private fun size(self: &TestOrder): u64 {
        select m::TestOrder.size<&TestOrder>(self)
    }
    private fun test_self(orders: vector<TestOrder>) {
        {
          let (v: &vector<TestOrder>): (&vector<TestOrder>) = Tuple(Borrow(Immutable)(orders));
          {
            let i: u64 = 0;
            loop {
              if Lt<u64>(i, vector::length<TestOrder>(v)) {
                {
                  let (order: &TestOrder): (&TestOrder) = Tuple(vector::borrow<TestOrder>(v, i));
                  {
                    let _price: u64 = m::price(order);
                    {
                      let _size: u64 = m::size(order);
                      Tuple()
                    }
                  }
                };
                i: u64 = Add<u64>(i, 1)
              } else {
                break
              }
            }
          }
        };
        Tuple()
    }
} // end 0xc0ffee::m

// -- Sourcified model before first bytecode pipeline
module 0xc0ffee::m {
    use std::vector;
    struct TestOrder has copy, drop, store {
        price: u64,
        size: u64,
    }
    fun price(self: &TestOrder): u64 {
        self.price
    }
    fun size(self: &TestOrder): u64 {
        self.size
    }
    fun test_self(orders: vector<TestOrder>) {
        {
            let v = &orders;
            let i = 0;
            while (i < 0x1::vector::length<TestOrder>(v)) {
                {
                    let order = 0x1::vector::borrow<TestOrder>(v, i);
                    let _price = price(order);
                    let _size = size(order);
                };
                i = i + 1
            }
        };
    }
}

============ bytecode before first stackless bytecode pipeline ================

[variant baseline]
fun m::price($t0: &0xc0ffee::m::TestOrder): u64 {
     var $t1: u64
     var $t2: &u64
  0: $t2 := borrow_field<0xc0ffee::m::TestOrder>.price($t0)
  1: $t1 := read_ref($t2)
  2: return $t1
}


[variant baseline]
fun m::size($t0: &0xc0ffee::m::TestOrder): u64 {
     var $t1: u64
     var $t2: &u64
  0: $t2 := borrow_field<0xc0ffee::m::TestOrder>.size($t0)
  1: $t1 := read_ref($t2)
  2: return $t1
}


[variant baseline]
fun m::test_self($t0: vector<0xc0ffee::m::TestOrder>) {
     var $t1: &vector<0xc0ffee::m::TestOrder>
     var $t2: &vector<0xc0ffee::m::TestOrder>
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: &0xc0ffee::m::TestOrder
     var $t8: &0xc0ffee::m::TestOrder
     var $t9: &vector<0xc0ffee::m::TestOrder>
     var $t10: u64
     var $t11: u64
     var $t12: u64
     var $t13: u64
     var $t14: u64
  0: $t2 := borrow_local($t0)
  1: $t1 := infer($t2)
  2: $t3 := 0
  3: label L0
  4: $t5 := infer($t3)
  5: $t6 := vector::length<0xc0ffee::m::TestOrder>($t1)
  6: $t4 := <($t5, $t6)
  7: if ($t4) goto 8 else goto 19
  8: label L2
  9: $t9 := infer($t1)
 10: $t8 := vector::borrow<0xc0ffee::m::TestOrder>($t9, $t3)
 11: $t7 := infer($t8)
 12: $t10 := m::price($t7)
 13: $t11 := m::size($t7)
 14: $t13 := infer($t3)
 15: $t14 := 1
 16: $t12 := +($t13, $t14)
 17: $t3 := infer($t12)
 18: goto 21
 19: label L3
 20: goto 23
 21: label L4
 22: goto 3
 23: label L1
 24: return ()
}

// -- Model dump before second bytecode pipeline
module 0xc0ffee::m {
    use std::vector;
    struct TestOrder {
        price: u64,
        size: u64,
    }
    private fun price(self: &TestOrder): u64 {
        select m::TestOrder.price<&TestOrder>(self)
    }
    private fun size(self: &TestOrder): u64 {
        select m::TestOrder.size<&TestOrder>(self)
    }
    private fun test_self(orders: vector<TestOrder>) {
        {
          let (v: &vector<TestOrder>): (&vector<TestOrder>) = Tuple(Borrow(Immutable)(orders));
          {
            let i: u64 = 0;
            loop {
              if Lt<u64>(i, vector::length<TestOrder>(v)) {
                {
                  let (order: &TestOrder): (&TestOrder) = Tuple(vector::borrow<TestOrder>(v, i));
                  {
                    let _price: u64 = m::price(order);
                    {
                      let _size: u64 = m::size(order);
                      Tuple()
                    }
                  }
                };
                i: u64 = Add<u64>(i, 1)
              } else {
                break
              }
            }
          }
        };
        Tuple()
    }
} // end 0xc0ffee::m

============ bytecode before second stackless bytecode pipeline ================

[variant baseline]
fun m::price($t0: &0xc0ffee::m::TestOrder): u64 {
     var $t1: u64
     var $t2: &u64
  0: $t2 := borrow_field<0xc0ffee::m::TestOrder>.price($t0)
  1: $t1 := read_ref($t2)
  2: return $t1
}


[variant baseline]
fun m::size($t0: &0xc0ffee::m::TestOrder): u64 {
     var $t1: u64
     var $t2: &u64
  0: $t2 := borrow_field<0xc0ffee::m::TestOrder>.size($t0)
  1: $t1 := read_ref($t2)
  2: return $t1
}


[variant baseline]
fun m::test_self($t0: vector<0xc0ffee::m::TestOrder>) {
     var $t1: &vector<0xc0ffee::m::TestOrder>
     var $t2: &vector<0xc0ffee::m::TestOrder>
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: &0xc0ffee::m::TestOrder
     var $t8: &0xc0ffee::m::TestOrder
     var $t9: &vector<0xc0ffee::m::TestOrder>
     var $t10: u64
     var $t11: u64
     var $t12: u64
     var $t13: u64
     var $t14: u64
  0: $t2 := borrow_local($t0)
  1: $t1 := infer($t2)
  2: $t3 := 0
  3: label L0
  4: $t5 := infer($t3)
  5: $t6 := vector::length<0xc0ffee::m::TestOrder>($t1)
  6: $t4 := <($t5, $t6)
  7: if ($t4) goto 8 else goto 19
  8: label L2
  9: $t9 := infer($t1)
 10: $t8 := vector::borrow<0xc0ffee::m::TestOrder>($t9, $t3)
 11: $t7 := infer($t8)
 12: $t10 := m::price($t7)
 13: $t11 := m::size($t7)
 14: $t13 := infer($t3)
 15: $t14 := 1
 16: $t12 := +($t13, $t14)
 17: $t3 := infer($t12)
 18: goto 21
 19: label L3
 20: goto 23
 21: label L4
 22: goto 3
 23: label L1
 24: return ()
}


============ disassembled file-format ==================
// Bytecode version v10
module 0xc0ffee::m
struct TestOrder has copy + drop + store
  price: u64
  size: u64

// Function definition at index 0
fun price(l0: &TestOrder): u64
    move_loc l0
    borrow_field TestOrder, price
    read_ref
    ret

// Function definition at index 1
fun size(l0: &TestOrder): u64
    move_loc l0
    borrow_field TestOrder, size
    read_ref
    ret

// Function definition at index 2
fun test_self(l0: vector<TestOrder>)
    local l1: &vector<TestOrder>
    local l2: u64
    local l3: &TestOrder
    borrow_loc l0
    st_loc l1
    ld_u64 0
    st_loc l2
l1: copy_loc l2
    // @5
    copy_loc l1
    vec_len <TestOrder>
    lt
    br_false l0
    copy_loc l1
    // @10
    copy_loc l2
    vec_borrow <TestOrder>
    st_loc l3
    copy_loc l3
    call price
    // @15
    pop
    move_loc l3
    call size
    pop
    move_loc l2
    // @20
    ld_u64 1
    add
    st_loc l2
    branch l1
l0: move_loc l1
    // @25
    pop
    ret


============ bytecode verification succeeded ========
