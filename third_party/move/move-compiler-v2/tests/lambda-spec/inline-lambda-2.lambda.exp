// -- Model dump before first bytecode pipeline
module 0x42::m {
    use std::vector;
    struct T {
        issuer: vector<u8>,
        version: u64,
    }
    struct J {
        variant: u64,
    }
    struct S {
        entries: vector<T>,
    }
    private fun test(s: &mut S,issuer: vector<u8>) {
        {
          let x: u64 = vector::length<T>(Borrow(Immutable)(select m::S.entries<&mut S>(s)));
          {
            let (_found: bool, _index: u64): (bool, u64) = {
              let (v: &vector<T>): (&vector<T>) = Tuple(Borrow(Immutable)(select m::S.entries<&mut S>(s)));
              {
                let find: bool = false;
                {
                  let found_index: u64 = 0;
                  {
                    let i: u64 = 0;
                    {
                      let x': u64 = vector::length<T>(v);
                      {
                        let len: u64 = vector::length<T>(v);
                        loop {
                          if Lt<u64>(i, len) {
                            if m::__lambda__1_inline_1_956__test(issuer, x, vector::borrow<T>(v, i)) {
                              find: bool = true;
                              found_index: u64 = i;
                              break
                            } else {
                              Tuple()
                            };
                            i: u64 = Add<u64>(i, x');
                            Tuple()
                          } else {
                            break
                          }
                        };
                        spec {
                          assert Implies(find, m::$inline___lambda__1_inline_1_956__test($t1, x, Index(v, found_index)));
                        }
                        ;
                        Tuple(find, found_index)
                      }
                    }
                  }
                }
              }
            };
            Tuple()
          }
        }
    }
    private fun __lambda__1_inline_1_956__test(issuer: vector<u8>,x: u64,obj: &T): bool {
        spec {
          assume Gt(Len<u8>($t0), 0);
        }
        ;
        And(Eq<vector<u8>>(select m::T.issuer<&T>(obj), issuer), Gt<u64>(x, 0))
    }
    spec fun $inline___lambda__1_inline_1_956__test(issuer: vector<u8>,x: u64,obj: T): bool {
        And(Eq<vector<u8>>(select m::T.issuer<0x42::m::T>(obj), issuer), Gt<u64>(x, 0))
    }
} // end 0x42::m

// -- Sourcified model before first bytecode pipeline
module 0x42::m {
    use std::vector;
    struct T has copy, drop, store {
        issuer: vector<u8>,
        version: u64,
    }
    struct J has copy, drop, store {
        variant: u64,
    }
    struct S has copy, drop, store {
        entries: vector<T>,
    }
    fun test(s: &mut S, issuer: vector<u8>) {
        let x = 0x1::vector::length<T>(&s.entries);
        let (_found,_index) = {
            let v = &s.entries;
            let find = false;
            let found_index = 0;
            let i = 0;
            let x' = 0x1::vector::length<T>(v);
            let len = 0x1::vector::length<T>(v);
            while (i < len) {
                if (lambda__1_inline_1_956__test(issuer, x, 0x1::vector::borrow<T>(v, i))) {
                    find = true;
                    found_index = i;
                    break
                };
                i = i + x';
            };
            spec {
                assert find ==> inline___lambda__1_inline_1_956__test(issuer, x, v[found_index]);
            };
            (find, found_index)
        };
    }
    fun lambda__1_inline_1_956__test(issuer: vector<u8>, x: u64, obj: &T): bool {
        spec {
            assume len(issuer) > 0;
        };
        obj.issuer == issuer && x > 0
    }
}

============ bytecode before first stackless bytecode pipeline ================

[variant baseline]
fun m::test($t0: &mut 0x42::m::S, $t1: vector<u8>) {
     var $t2: u64
     var $t3: &vector<0x42::m::T>
     var $t4: bool
     var $t5: u64
     var $t6: &vector<0x42::m::T>
     var $t7: &vector<0x42::m::T>
     var $t8: bool
     var $t9: u64
     var $t10: u64
     var $t11: u64
     var $t12: u64
     var $t13: bool
     var $t14: u64
     var $t15: bool
     var $t16: vector<u8>
     var $t17: u64
     var $t18: &0x42::m::T
     var $t19: &vector<0x42::m::T>
     var $t20: bool
     var $t21: u64
     var $t22: u64
  0: $t3 := borrow_field<0x42::m::S>.entries($t0)
  1: $t2 := vector::length<0x42::m::T>($t3)
  2: $t7 := borrow_field<0x42::m::S>.entries($t0)
  3: $t6 := infer($t7)
  4: $t8 := false
  5: $t9 := 0
  6: $t10 := 0
  7: $t11 := vector::length<0x42::m::T>($t6)
  8: $t12 := vector::length<0x42::m::T>($t6)
  9: label L0
 10: $t14 := infer($t10)
 11: $t13 := <($t14, $t12)
 12: if ($t13) goto 13 else goto 32
 13: label L2
 14: $t16 := infer($t1)
 15: $t17 := infer($t2)
 16: $t19 := infer($t6)
 17: $t18 := vector::borrow<0x42::m::T>($t19, $t10)
 18: $t15 := m::__lambda__1_inline_1_956__test($t16, $t17, $t18)
 19: if ($t15) goto 20 else goto 26
 20: label L5
 21: $t20 := true
 22: $t8 := infer($t20)
 23: $t9 := infer($t10)
 24: goto 36
 25: goto 27
 26: label L6
 27: label L7
 28: $t22 := infer($t10)
 29: $t21 := +($t22, $t11)
 30: $t10 := infer($t21)
 31: goto 34
 32: label L3
 33: goto 36
 34: label L4
 35: goto 9
 36: label L1
 37: spec {
  assert Implies($t8, m::$inline___lambda__1_inline_1_956__test($t1, $t2, Index($t6, $t9)));
}

 38: $t4 := infer($t8)
 39: $t5 := infer($t9)
 40: return ()
}


[variant baseline]
fun m::__lambda__1_inline_1_956__test($t0: vector<u8>, $t1: u64, $t2: &0x42::m::T): bool {
     var $t3: bool
     var $t4: bool
     var $t5: vector<u8>
     var $t6: &vector<u8>
     var $t7: u64
     var $t8: u64
  0: spec {
  assume Gt(Len<u8>($t0), 0);
}

  1: $t6 := borrow_field<0x42::m::T>.issuer($t2)
  2: $t5 := read_ref($t6)
  3: $t4 := ==($t5, $t0)
  4: if ($t4) goto 5 else goto 10
  5: label L0
  6: $t7 := infer($t1)
  7: $t8 := 0
  8: $t3 := >($t7, $t8)
  9: goto 12
 10: label L1
 11: $t3 := false
 12: label L2
 13: return $t3
}

============ after AbortAnalysisProcessor: ================

[variant baseline]
fun m::test($t0: &mut 0x42::m::S, $t1: vector<u8>) {
     var $t2: u64
     var $t3: &vector<0x42::m::T>
     var $t4: bool
     var $t5: u64
     var $t6: &vector<0x42::m::T>
     var $t7: &vector<0x42::m::T>
     var $t8: bool
     var $t9: u64
     var $t10: u64
     var $t11: u64
     var $t12: u64
     var $t13: bool
     var $t14: u64
     var $t15: bool
     var $t16: vector<u8>
     var $t17: u64
     var $t18: &0x42::m::T
     var $t19: &vector<0x42::m::T>
     var $t20: bool
     var $t21: u64
     var $t22: u64
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  0: $t3 := borrow_field<0x42::m::S>.entries($t0)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t3
     # refs: [$t0 => #0, $t3 => #3]
     # #0
     #   => #3 via [field `entries`] at line 38
     # #3
     #   <no edges>
     # #root
     #   <no edges>
     #
  1: $t2 := vector::length<0x42::m::T>($t3)
     # abort state: {returns,aborts}
     # live vars: $t0, $t1, $t2
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  2: $t7 := borrow_field<0x42::m::S>.entries($t0)
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t7
     # refs: [$t7 => #7]
     # #7
     #   <no edges>
     # #root
     #   <no edges>
     #
  3: $t6 := infer($t7)
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
  4: $t8 := false
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6, $t8
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
  5: $t9 := 0
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6, $t8, $t9
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
  6: $t10 := 0
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
  7: $t11 := vector::length<0x42::m::T>($t6)
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
  8: $t12 := vector::length<0x42::m::T>($t6)
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
  9: label L0
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 10: $t14 := infer($t10)
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t14
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 11: $t13 := <($t14, $t12)
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t13
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 12: if ($t13) goto 13 else goto 32
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 13: label L2
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 14: $t16 := infer($t1)
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t16
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 15: $t17 := infer($t2)
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t16, $t17
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 16: $t19 := infer($t6)
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t16, $t17, $t19
     # refs: [$t6 => #6, $t19 => #19]
     # #6
     #   => #19 via [] at line 24
     # #19
     #   <no edges>
     # #root
     #   <no edges>
     #
 17: $t18 := vector::borrow<0x42::m::T>($t19, $t10)
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t16, $t17, $t18
     # refs: [$t6 => #6, $t18 => #18]
     # #6
     #   -> #18 via [] at line 24
     # #18
     #   <no edges>
     # #root
     #   <no edges>
     #
 18: $t15 := m::__lambda__1_inline_1_956__test($t16, $t17, $t18)
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t15
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 19: if ($t15) goto 20 else goto 26
     # abort state: {returns}
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 20: label L5
     # abort state: {returns}
     # live vars: $t1, $t2, $t6, $t10
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 21: $t20 := true
     # abort state: {returns}
     # live vars: $t1, $t2, $t6, $t10, $t20
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 22: $t8 := infer($t20)
     # abort state: {returns}
     # live vars: $t1, $t2, $t6, $t8, $t10
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 23: $t9 := infer($t10)
     # abort state: {returns}
     # live vars: $t1, $t2, $t6, $t8, $t9
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 24: goto 36
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
 25: goto 27
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 26: label L6
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 27: label L7
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 28: $t22 := infer($t10)
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6, $t8, $t9, $t11, $t12, $t22
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 29: $t21 := +($t22, $t11)
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6, $t8, $t9, $t11, $t12, $t21
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 30: $t10 := infer($t21)
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 31: goto 34
     # abort state: {returns}
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 32: label L3
     # abort state: {returns}
     # live vars: $t1, $t2, $t6, $t8, $t9
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 33: goto 36
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 34: label L4
     # abort state: {returns,aborts}
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 35: goto 9
     # abort state: {returns}
     # live vars: $t1, $t2, $t6, $t8, $t9
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 36: label L1
     # abort state: {returns}
     # live vars: $t1, $t2, $t6, $t8, $t9
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
 37: spec {
  assert Implies($t8, m::$inline___lambda__1_inline_1_956__test($t1, $t2, Index($t6, $t9)));
}

     # abort state: {returns}
     # live vars: $t8, $t9
     # refs: []
     #
 38: $t4 := infer($t8)
     # abort state: {returns}
     # live vars: $t9
     # refs: []
     #
 39: $t5 := infer($t9)
     # abort state: {returns}
     # live vars:
     # refs: []
     #
 40: return ()
}


[variant baseline]
fun m::__lambda__1_inline_1_956__test($t0: vector<u8>, $t1: u64, $t2: &0x42::m::T): bool {
     var $t3: bool
     var $t4: bool
     var $t5: vector<u8>
     var $t6: &vector<u8>
     var $t7: u64
     var $t8: u64
     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: [$t2 => #2]
     # #2
     #   <no edges>
     # #root
     #   <no edges>
     #
  0: spec {
  assume Gt(Len<u8>($t0), 0);
}

     # abort state: {returns}
     # live vars: $t0, $t1, $t2
     # refs: [$t2 => #2]
     # #2
     #   <no edges>
     # #root
     #   <no edges>
     #
  1: $t6 := borrow_field<0x42::m::T>.issuer($t2)
     # abort state: {returns}
     # live vars: $t0, $t1, $t6
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   <no edges>
     #
  2: $t5 := read_ref($t6)
     # abort state: {returns}
     # live vars: $t0, $t1, $t5
     # refs: []
     #
  3: $t4 := ==($t5, $t0)
     # abort state: {returns}
     # live vars: $t1, $t4
     # refs: []
     #
  4: if ($t4) goto 5 else goto 10
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  5: label L0
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  6: $t7 := infer($t1)
     # abort state: {returns}
     # live vars: $t7
     # refs: []
     #
  7: $t8 := 0
     # abort state: {returns}
     # live vars: $t7, $t8
     # refs: []
     #
  8: $t3 := >($t7, $t8)
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
  9: goto 12
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
 10: label L1
     # abort state: {returns}
     # live vars:
     # refs: []
     #
 11: $t3 := false
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 12: label L2
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 13: return $t3
}

// -- Model dump before second bytecode pipeline
module 0x42::m {
    use std::vector;
    struct T {
        issuer: vector<u8>,
        version: u64,
    }
    struct J {
        variant: u64,
    }
    struct S {
        entries: vector<T>,
    }
    private fun test(s: &mut S,issuer: vector<u8>) {
        {
          let x: u64 = vector::length<T>(Borrow(Immutable)(select m::S.entries<&mut S>(s)));
          {
            let (_found: bool, _index: u64): (bool, u64) = {
              let (v: &vector<T>): (&vector<T>) = Tuple(Borrow(Immutable)(select m::S.entries<&mut S>(s)));
              {
                let find: bool = false;
                {
                  let found_index: u64 = 0;
                  {
                    let i: u64 = 0;
                    {
                      let x': u64 = vector::length<T>(v);
                      {
                        let len: u64 = vector::length<T>(v);
                        loop {
                          if Lt<u64>(i, len) {
                            if m::__lambda__1_inline_1_956__test(issuer, x, vector::borrow<T>(v, i)) {
                              find: bool = true;
                              found_index: u64 = i;
                              break
                            } else {
                              Tuple()
                            };
                            i: u64 = Add<u64>(i, x');
                            Tuple()
                          } else {
                            break
                          }
                        };
                        spec {
                          assert Implies(find, m::$inline___lambda__1_inline_1_956__test($t1, x, Index(v, found_index)));
                        }
                        ;
                        Tuple(find, found_index)
                      }
                    }
                  }
                }
              }
            };
            Tuple()
          }
        }
    }
    private fun __lambda__1_inline_1_956__test(issuer: vector<u8>,x: u64,obj: &T): bool {
        spec {
          assume Gt(Len<u8>($t0), 0);
        }
        ;
        And(Eq<vector<u8>>(select m::T.issuer<&T>(obj), issuer), Gt<u64>(x, 0))
    }
    spec fun $inline___lambda__1_inline_1_956__test(issuer: vector<u8>,x: u64,obj: T): bool {
        And(Eq<vector<u8>>(select m::T.issuer<0x42::m::T>(obj), issuer), Gt<u64>(x, 0))
    }
} // end 0x42::m

============ bytecode before second stackless bytecode pipeline ================

[variant baseline]
fun m::test($t0: &mut 0x42::m::S, $t1: vector<u8>) {
     var $t2: u64
     var $t3: &vector<0x42::m::T>
     var $t4: bool
     var $t5: u64
     var $t6: &vector<0x42::m::T>
     var $t7: &vector<0x42::m::T>
     var $t8: bool
     var $t9: u64
     var $t10: u64
     var $t11: u64
     var $t12: u64
     var $t13: bool
     var $t14: u64
     var $t15: bool
     var $t16: vector<u8>
     var $t17: u64
     var $t18: &0x42::m::T
     var $t19: &vector<0x42::m::T>
     var $t20: bool
     var $t21: u64
     var $t22: u64
  0: $t3 := borrow_field<0x42::m::S>.entries($t0)
  1: $t2 := vector::length<0x42::m::T>($t3)
  2: $t7 := borrow_field<0x42::m::S>.entries($t0)
  3: $t6 := infer($t7)
  4: $t8 := false
  5: $t9 := 0
  6: $t10 := 0
  7: $t11 := vector::length<0x42::m::T>($t6)
  8: $t12 := vector::length<0x42::m::T>($t6)
  9: label L0
 10: $t14 := infer($t10)
 11: $t13 := <($t14, $t12)
 12: if ($t13) goto 13 else goto 32
 13: label L2
 14: $t16 := infer($t1)
 15: $t17 := infer($t2)
 16: $t19 := infer($t6)
 17: $t18 := vector::borrow<0x42::m::T>($t19, $t10)
 18: $t15 := m::__lambda__1_inline_1_956__test($t16, $t17, $t18)
 19: if ($t15) goto 20 else goto 26
 20: label L5
 21: $t20 := true
 22: $t8 := infer($t20)
 23: $t9 := infer($t10)
 24: goto 36
 25: goto 27
 26: label L6
 27: label L7
 28: $t22 := infer($t10)
 29: $t21 := +($t22, $t11)
 30: $t10 := infer($t21)
 31: goto 34
 32: label L3
 33: goto 36
 34: label L4
 35: goto 9
 36: label L1
 37: spec {
  assert Implies($t8, m::$inline___lambda__1_inline_1_956__test($t1, $t2, Index($t6, $t9)));
}

 38: $t4 := infer($t8)
 39: $t5 := infer($t9)
 40: return ()
}


[variant baseline]
fun m::__lambda__1_inline_1_956__test($t0: vector<u8>, $t1: u64, $t2: &0x42::m::T): bool {
     var $t3: bool
     var $t4: bool
     var $t5: vector<u8>
     var $t6: &vector<u8>
     var $t7: u64
     var $t8: u64
  0: spec {
  assume Gt(Len<u8>($t0), 0);
}

  1: $t6 := borrow_field<0x42::m::T>.issuer($t2)
  2: $t5 := read_ref($t6)
  3: $t4 := ==($t5, $t0)
  4: if ($t4) goto 5 else goto 10
  5: label L0
  6: $t7 := infer($t1)
  7: $t8 := 0
  8: $t3 := >($t7, $t8)
  9: goto 12
 10: label L1
 11: $t3 := false
 12: label L2
 13: return $t3
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
fun m::test($t0: &mut 0x42::m::S, $t1: vector<u8>) {
     var $t2: u64
     var $t3: &vector<0x42::m::T>
     var $t4: bool [unused]
     var $t5: u64 [unused]
     var $t6: &vector<0x42::m::T>
     var $t7: &vector<0x42::m::T> [unused]
     var $t8: bool
     var $t9: u64
     var $t10: u64
     var $t11: u64
     var $t12: u64
     var $t13: bool
     var $t14: u64
     var $t15: bool [unused]
     var $t16: vector<u8>
     var $t17: u64 [unused]
     var $t18: &0x42::m::T
     var $t19: &vector<0x42::m::T> [unused]
     var $t20: bool [unused]
     var $t21: u64 [unused]
     var $t22: u64 [unused]
     # live vars: $t0, $t1
  0: $t3 := borrow_field<0x42::m::S>.entries($t0)
     # live vars: $t0, $t1, $t3
  1: $t2 := vector::length<0x42::m::T>($t3)
     # live vars: $t0, $t1, $t2
  2: $t3 := borrow_field<0x42::m::S>.entries($t0)
     # live vars: $t1, $t2, $t3
  3: $t6 := move($t3)
     # live vars: $t1, $t2, $t6
  4: $t8 := false
     # live vars: $t1, $t2, $t6, $t8
  5: $t9 := 0
     # live vars: $t1, $t2, $t6, $t8, $t9
  6: $t10 := 0
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10
  7: $t11 := vector::length<0x42::m::T>($t6)
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11
  8: $t12 := vector::length<0x42::m::T>($t6)
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
  9: label L0
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
 10: $t14 := copy($t10)
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t14
 11: $t13 := <($t14, $t12)
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t13
 12: if ($t13) goto 15 else goto 13
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
 13: label L8
     # live vars: $t1, $t2, $t6, $t8, $t9
 14: goto 26
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
 15: label L2
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
 16: $t16 := copy($t1)
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t16
 17: $t14 := copy($t2)
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t14, $t16
 18: $t3 := copy($t6)
     # live vars: $t1, $t2, $t3, $t6, $t8, $t9, $t10, $t11, $t12, $t14, $t16
 19: $t18 := vector::borrow<0x42::m::T>($t3, $t10)
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t14, $t16, $t18
 20: $t13 := m::__lambda__1_inline_1_956__test($t16, $t14, $t18)
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12, $t13
 21: if ($t13) goto 22 else goto 30
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
 22: label L5
     # live vars: $t1, $t2, $t6, $t10
 23: $t13 := true
     # live vars: $t1, $t2, $t6, $t10, $t13
 24: $t8 := move($t13)
     # live vars: $t1, $t2, $t6, $t8, $t10
 25: $t9 := move($t10)
     # live vars: $t1, $t2, $t6, $t8, $t9
 26: label L1
     # live vars: $t1, $t2, $t6, $t8, $t9
 27: spec {
  assert Implies($t8, m::$inline___lambda__1_inline_1_956__test($t1, $t2, Index($t6, $t9)));
}

     # live vars: $t6
 28: drop($t6)
     # live vars:
 29: return ()
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
 30: label L7
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
 31: $t14 := move($t10)
     # live vars: $t1, $t2, $t6, $t8, $t9, $t11, $t12, $t14
 32: $t14 := +($t14, $t11)
     # live vars: $t1, $t2, $t6, $t8, $t9, $t11, $t12, $t14
 33: $t10 := move($t14)
     # live vars: $t1, $t2, $t6, $t8, $t9, $t10, $t11, $t12
 34: goto 9
}


[variant baseline]
fun m::__lambda__1_inline_1_956__test($t0: vector<u8>, $t1: u64, $t2: &0x42::m::T): bool {
     var $t3: bool [unused]
     var $t4: bool
     var $t5: vector<u8>
     var $t6: &vector<u8>
     var $t7: u64
     var $t8: u64
     # live vars: $t0, $t1, $t2
  0: spec {
  assume Gt(Len<u8>($t0), 0);
}

     # live vars: $t0, $t1, $t2
  1: $t6 := borrow_field<0x42::m::T>.issuer($t2)
     # live vars: $t0, $t1, $t6
  2: $t5 := read_ref($t6)
     # live vars: $t0, $t1, $t5
  3: $t4 := ==($t5, $t0)
     # live vars: $t1, $t4
  4: if ($t4) goto 5 else goto 10
     # live vars: $t1
  5: label L0
     # live vars: $t1
  6: $t7 := move($t1)
     # live vars: $t7
  7: $t8 := 0
     # live vars: $t7, $t8
  8: $t4 := >($t7, $t8)
     # live vars: $t4
  9: return $t4
     # live vars: $t1
 10: label L1
     # live vars:
 11: $t4 := false
     # live vars: $t4
 12: return $t4
}


============ disassembled file-format ==================
// Bytecode version v10
module 0x42::m
struct T has copy + drop + store
  issuer: vector<u8>
  version: u64

struct J has copy + drop + store
  variant: u64

struct S has copy + drop + store
  entries: vector<T>

// Function definition at index 0
fun test(l0: &mut S, l1: vector<u8>)
    local l2: u64
    local l3: &vector<T>
    local l4: bool
    local l5: u64
    local l6: u64
    local l7: u64
    local l8: u64
    copy_loc l0
    borrow_field S, entries
    vec_len <T>
    st_loc l2
    move_loc l0
    // @5
    borrow_field S, entries
    st_loc l3
    ld_false
    st_loc l4
    ld_u64 0
    // @10
    st_loc l5
    ld_u64 0
    st_loc l6
    copy_loc l3
    vec_len <T>
    // @15
    st_loc l7
    copy_loc l3
    vec_len <T>
    st_loc l8
l3: copy_loc l6
    // @20
    copy_loc l8
    lt
    br_true l0
    branch l1
l0: copy_loc l1
    // @25
    copy_loc l2
    copy_loc l3
    copy_loc l6
    vec_borrow <T>
    call __lambda__1_inline_1_956__test
    // @30
    br_false l2
    ld_true
    st_loc l4
    move_loc l6
    st_loc l5
    // @35
l1: nop
    move_loc l3
    pop
    ret
l2: move_loc l6
    // @40
    copy_loc l7
    add
    st_loc l6
    branch l3

// Function definition at index 1
fun __lambda__1_inline_1_956__test(l0: vector<u8>, l1: u64, l2: &T): bool
    nop
    move_loc l2
    borrow_field T, issuer
    read_ref
    move_loc l0
    // @5
    eq
    br_false l0
    move_loc l1
    ld_u64 0
    gt
    // @10
    ret
l0: ld_false
    ret


============ bytecode verification succeeded ========
