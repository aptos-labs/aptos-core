// -- Model dump before first bytecode pipeline
module 0x42::test {
    private fun contains(v: &vector<u64>,p: |u64|bool): bool {
        (p)(Deref(vector::borrow<u64>(v, 0)))
    }
    spec {
      ensures Eq<bool>(result0(), ($t1)(Index($t0, 0)));
    }

    private fun using(): bool {
        {
          let v: vector<u64> = Vector<u64>(1);
          test::contains(Borrow(Immutable)(v), closure#0test::__lambda__1__using())
        }
    }
    spec {
      ensures result0();
    }

    private fun __lambda__1__using(x: u64): bool {
        Eq<u64>(x, 1)
    }
    spec fun $__lambda__1__using(x: u64): bool {
        Eq<u64>(x, 1)
    }
} // end 0x42::test

// -- Sourcified model before first bytecode pipeline
module 0x42::test {
    fun contains(v: &vector<u64>, p: |u64|bool): bool {
        p(*0x1::vector::borrow<u64>(v, 0))
    }
    fun using(): bool {
        let v = vector[1];
        contains(&v, |arg0| lambda__1__using(arg0))
    }
    fun lambda__1__using(x: u64): bool {
        x == 1
    }
}

============ bytecode before first stackless bytecode pipeline ================

[variant baseline]
fun test::contains($t0: &vector<u64>, $t1: |u64|bool): bool {
     var $t2: bool
     var $t3: u64
     var $t4: &u64
     var $t5: &vector<u64>
     var $t6: u64
  0: $t5 := infer($t0)
  1: $t6 := 0
  2: $t4 := vector::borrow<u64>($t5, $t6)
  3: $t3 := read_ref($t4)
  4: $t2 := invoke($t3, $t1)
  5: return $t2
}


[variant baseline]
fun test::using(): bool {
     var $t0: bool
     var $t1: vector<u64>
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: |u64|bool
  0: $t2 := 1
  1: $t1 := vector($t2)
  2: $t3 := borrow_local($t1)
  3: $t4 := closure#0 test::__lambda__1__using()
  4: $t0 := test::contains($t3, $t4)
  5: return $t0
}


[variant baseline]
fun test::__lambda__1__using($t0: u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 1
  2: $t1 := ==($t2, $t3)
  3: return $t1
}

============ after AbortAnalysisProcessor: ================

[variant baseline]
fun test::contains($t0: &vector<u64>, $t1: |u64|bool): bool {
     var $t2: bool
     var $t3: u64
     var $t4: &u64
     var $t5: &vector<u64>
     var $t6: u64
     # abort state: {returns,aborts}
     # live vars: $t0, $t1
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  0: $t5 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t1, $t5
     # refs: [$t5 => #5]
     # #5
     #   <no edges>
     # #root
     #   <no edges>
     #
  1: $t6 := 0
     # abort state: {returns,aborts}
     # live vars: $t1, $t5, $t6
     # refs: [$t5 => #5]
     # #5
     #   <no edges>
     # #root
     #   <no edges>
     #
  2: $t4 := vector::borrow<u64>($t5, $t6)
     # abort state: {returns,aborts}
     # live vars: $t1, $t4
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   <no edges>
     #
  3: $t3 := read_ref($t4)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3
     # refs: []
     #
  4: $t2 := invoke($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  5: return $t2
}


[variant baseline]
fun test::using(): bool {
     var $t0: bool
     var $t1: vector<u64>
     var $t2: u64
     var $t3: &vector<u64>
     var $t4: |u64|bool
     # abort state: {returns,aborts}
     # live vars:
     # refs: []
     #
  0: $t2 := 1
     # abort state: {returns,aborts}
     # live vars: $t2
     # refs: []
     #
  1: $t1 := vector($t2)
     # abort state: {returns,aborts}
     # live vars: $t1
     # refs: []
     #
  2: $t3 := borrow_local($t1)
     # abort state: {returns,aborts}
     # live vars: $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [local `v`] at line 11
     #
  3: $t4 := closure#0 test::__lambda__1__using()
     # abort state: {returns,aborts}
     # live vars: $t3, $t4
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [local `v`] at line 11
     #
  4: $t0 := test::contains($t3, $t4)
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  5: return $t0
}


[variant baseline]
fun test::__lambda__1__using($t0: u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 1
     # abort state: {returns}
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := ==($t2, $t3)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}

// -- Model dump before second bytecode pipeline
module 0x42::test {
    private fun contains(v: &vector<u64>,p: |u64|bool): bool {
        (p)(Deref(vector::borrow<u64>(v, 0)))
    }
    spec {
      ensures Eq<bool>(result0(), ($t1)(Index($t0, 0)));
    }

    private fun using(): bool {
        test::contains(Borrow(Immutable)([Number(1)]), closure#0test::__lambda__1__using())
    }
    spec {
      ensures result0();
    }

    private fun __lambda__1__using(x: u64): bool {
        Eq<u64>(x, 1)
    }
    spec fun $__lambda__1__using(x: u64): bool {
        Eq<u64>(x, 1)
    }
} // end 0x42::test

============ bytecode before second stackless bytecode pipeline ================

[variant baseline]
fun test::contains($t0: &vector<u64>, $t1: |u64|bool): bool {
     var $t2: bool
     var $t3: u64
     var $t4: &u64
     var $t5: &vector<u64>
     var $t6: u64
  0: $t5 := infer($t0)
  1: $t6 := 0
  2: $t4 := vector::borrow<u64>($t5, $t6)
  3: $t3 := read_ref($t4)
  4: $t2 := invoke($t3, $t1)
  5: return $t2
}


[variant baseline]
fun test::using(): bool {
     var $t0: bool
     var $t1: &vector<u64>
     var $t2: vector<u64>
     var $t3: |u64|bool
  0: $t2 := ["1"]
  1: $t1 := borrow_local($t2)
  2: $t3 := closure#0 test::__lambda__1__using()
  3: $t0 := test::contains($t1, $t3)
  4: return $t0
}


[variant baseline]
fun test::__lambda__1__using($t0: u64): bool {
     var $t1: bool
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 1
  2: $t1 := ==($t2, $t3)
  3: return $t1
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
fun test::contains($t0: &vector<u64>, $t1: |u64|bool): bool {
     var $t2: bool
     var $t3: u64 [unused]
     var $t4: &u64
     var $t5: &vector<u64> [unused]
     var $t6: u64
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t6 := 0
     # live vars: $t0, $t1, $t6
  2: $t4 := vector::borrow<u64>($t0, $t6)
     # live vars: $t1, $t4
  3: $t6 := read_ref($t4)
     # live vars: $t1, $t6
  4: $t2 := invoke($t6, $t1)
     # live vars: $t2
  5: return $t2
}


[variant baseline]
fun test::using(): bool {
     var $t0: bool
     var $t1: &vector<u64>
     var $t2: vector<u64>
     var $t3: |u64|bool
     # live vars:
  0: $t2 := ["1"]
     # live vars: $t2
  1: $t1 := borrow_local($t2)
     # live vars: $t1
  2: $t3 := closure#0 test::__lambda__1__using()
     # live vars: $t1, $t3
  3: $t0 := test::contains($t1, $t3)
     # live vars: $t0
  4: return $t0
}


[variant baseline]
fun test::__lambda__1__using($t0: u64): bool {
     var $t1: bool
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 1
     # live vars: $t0, $t3
  2: $t1 := ==($t0, $t3)
     # live vars: $t1
  3: return $t1
}


============ disassembled file-format ==================
// Move bytecode v9
module 42.test {


contains(v: &vector<u64>, p: |u64|bool): bool /* def_idx: 0 */ {
B0:
	0: MoveLoc[0](v: &vector<u64>)
	1: LdU64(0)
	2: VecImmBorrow(2)
	3: ReadRef
	4: MoveLoc[1](p: |u64|bool)
	5: CallClosure(|u64|bool)
	6: Ret
}
using(): bool /* def_idx: 1 */ {
L0:	$t2: vector<u64>
B0:
	0: LdConst[0](Vector(U64): [1, 1, 0, 0, 0, 0, 0, 0, 0])
	1: StLoc[0]($t2: vector<u64>)
	2: ImmBorrowLoc[0]($t2: vector<u64>)
	3: PackClosure#0 __lambda__1__using(u64): bool
	4: Call contains(&vector<u64>, |u64|bool): bool
	5: Ret
}
__lambda__1__using(x: u64): bool /* def_idx: 2 */ {
B0:
	0: MoveLoc[0](x: u64)
	1: LdU64(1)
	2: Eq
	3: Ret
}
}
============ bytecode verification succeeded ========
