============ after ControlFlowGraphSimplifier: ================

[variant baseline]
public fun vectors::guess_flips($t0: vector<u8>) {
     var $t1: &vector<u8>
     var $t2: &vector<u8>
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: bool
     var $t8: u8
     var $t9: &u8
     var $t10: &vector<u8>
     var $t11: u8
     var $t12: u64
     var $t13: u64
     var $t14: u64
     var $t15: vector<u8>
     var $t16: vector<u8>
  0: $t2 := borrow_local($t0)
  1: $t1 := move($t2)
  2: $t3 := 0
  3: label L0
  4: $t5 := copy($t3)
  5: $t6 := vector::length<u8>($t1)
  6: $t4 := <($t5, $t6)
  7: if ($t4) goto 8 else goto 27
  8: label L2
  9: $t10 := copy($t1)
 10: $t9 := vector::borrow<u8>($t10, $t3)
 11: $t8 := read_ref($t9)
 12: $t11 := 0
 13: $t7 := !=($t8, $t11)
 14: if ($t7) goto 15 else goto 21
 15: label L5
 16: drop($t1)
 17: label L1
 18: $t15 := copy($t0)
 19: $t16 := move($t0)
 20: return ()
 21: label L7
 22: $t13 := move($t3)
 23: $t14 := 1
 24: $t12 := +($t13, $t14)
 25: $t3 := move($t12)
 26: goto 3
 27: label L3
 28: drop($t1)
 29: goto 17
}


[variant baseline]
public fun vectors::guess_flips_directly($t0: vector<u8>) {
     var $t1: u64
     var $t2: bool
     var $t3: u64
     var $t4: u64
     var $t5: &vector<u8>
     var $t6: bool
     var $t7: u8
     var $t8: &u8
     var $t9: &vector<u8>
     var $t10: u8
     var $t11: u64
     var $t12: u64
     var $t13: u64
     var $t14: vector<u8>
     var $t15: vector<u8>
  0: $t1 := 0
  1: label L0
  2: $t3 := copy($t1)
  3: $t5 := borrow_local($t0)
  4: $t4 := vector::length<u8>($t5)
  5: $t2 := <($t3, $t4)
  6: if ($t2) goto 7 else goto 14
  7: label L2
  8: $t9 := borrow_local($t0)
  9: $t8 := vector::borrow<u8>($t9, $t1)
 10: $t7 := read_ref($t8)
 11: $t10 := 0
 12: $t6 := !=($t7, $t10)
 13: if ($t6) goto 14 else goto 18
 14: label L1
 15: $t14 := copy($t0)
 16: $t15 := move($t0)
 17: return ()
 18: label L7
 19: $t12 := move($t1)
 20: $t13 := 1
 21: $t11 := +($t12, $t13)
 22: $t1 := move($t11)
 23: goto 1
}


[variant baseline]
public fun vectors::guess_with_break_without_inline($t0: vector<u8>) {
     var $t1: &vector<u8>
     var $t2: vector<u8>
     var $t3: vector<u8>
  0: $t1 := borrow_local($t0)
  1: vectors::loops_with_break_no_inline($t1)
  2: $t2 := copy($t0)
  3: $t3 := move($t0)
  4: return ()
}


[variant baseline]
public fun vectors::guess_without_break_with_inline($t0: vector<u8>) {
     var $t1: &vector<u8>
     var $t2: &vector<u8>
     var $t3: u64
     var $t4: bool
     var $t5: u64
     var $t6: u64
     var $t7: bool
     var $t8: u8
     var $t9: &u8
     var $t10: &vector<u8>
     var $t11: u8
     var $t12: u64
     var $t13: u64
     var $t14: u64
     var $t15: u64
     var $t16: vector<u8>
     var $t17: vector<u8>
  0: $t2 := borrow_local($t0)
  1: $t1 := move($t2)
  2: $t3 := 0
  3: label L0
  4: $t5 := copy($t3)
  5: $t6 := vector::length<u8>($t1)
  6: $t4 := <($t5, $t6)
  7: if ($t4) goto 8 else goto 25
  8: label L2
  9: $t10 := copy($t1)
 10: $t9 := vector::borrow<u8>($t10, $t3)
 11: $t8 := read_ref($t9)
 12: $t11 := 0
 13: $t7 := ==($t8, $t11)
 14: if ($t7) goto 15 else goto 21
 15: label L5
 16: $t14 := move($t3)
 17: $t15 := 1
 18: $t13 := +($t14, $t15)
 19: $t3 := move($t13)
 20: goto 3
 21: label L6
 22: drop($t1)
 23: $t12 := 3
 24: abort($t12)
 25: label L3
 26: drop($t1)
 27: $t16 := copy($t0)
 28: $t17 := copy($t0)
 29: return ()
}


[variant baseline]
fun vectors::loops_with_break_no_inline($t0: &vector<u8>) {
     var $t1: u64
     var $t2: bool
     var $t3: u64
     var $t4: u64
     var $t5: bool
     var $t6: u8
     var $t7: &u8
     var $t8: &vector<u8>
     var $t9: u8
     var $t10: u64
     var $t11: u64
     var $t12: u64
  0: $t1 := 0
  1: label L0
  2: $t3 := copy($t1)
  3: $t4 := vector::length<u8>($t0)
  4: $t2 := <($t3, $t4)
  5: if ($t2) goto 6 else goto 23
  6: label L2
  7: $t8 := copy($t0)
  8: $t7 := vector::borrow<u8>($t8, $t1)
  9: $t6 := read_ref($t7)
 10: $t9 := 0
 11: $t5 := !=($t6, $t9)
 12: if ($t5) goto 13 else goto 17
 13: label L5
 14: drop($t0)
 15: label L1
 16: return ()
 17: label L7
 18: $t11 := move($t1)
 19: $t12 := 1
 20: $t10 := +($t11, $t12)
 21: $t1 := move($t10)
 22: goto 1
 23: label L3
 24: drop($t0)
 25: goto 15
}


[variant baseline]
fun vectors::test_guess_directly() {
     var $t0: vector<u8>
  0: $t0 := ["0", "0", "0", "0"]
  1: vectors::guess_flips_directly($t0)
  2: return ()
}


[variant baseline]
fun vectors::test_guess_with_break_no_inline() {
     var $t0: vector<u8>
  0: $t0 := ["0", "0", "0", "0"]
  1: vectors::guess_with_break_without_inline($t0)
  2: return ()
}


[variant baseline]
fun vectors::test_guess_with_inline_break() {
     var $t0: vector<u8>
  0: $t0 := ["0", "0", "0", "0"]
  1: vectors::guess_flips($t0)
  2: return ()
}


[variant baseline]
fun vectors::test_guess_without_break() {
     var $t0: vector<u8>
  0: $t0 := ["0", "0", "0", "0"]
  1: vectors::guess_without_break_with_inline($t0)
  2: return ()
}


============ disassembled file-format ==================
// Bytecode version v9
module 0xcafe::vectors
// Function definition at index 0
#[persistent] entry public fun guess_flips(l0: vector<u8>)
    local l1: &vector<u8>
    local l2: u64
    borrow_loc l0
    st_loc l1
    ld_u64 0
    st_loc l2
l2: copy_loc l2
    // @5
    copy_loc l1
    vec_len <u8>
    lt
    br_false l0
    copy_loc l1
    // @10
    copy_loc l2
    vec_borrow <u8>
    read_ref
    ld_u8 0
    neq
    // @15
    br_false l1
    move_loc l1
    pop
l3: ret
l1: move_loc l2
    // @20
    ld_u64 1
    add
    st_loc l2
    branch l2
l0: move_loc l1
    // @25
    pop
    branch l3

// Function definition at index 1
#[persistent] entry public fun guess_flips_directly(l0: vector<u8>)
    local l1: u64
    ld_u64 0
    st_loc l1
l3: copy_loc l1
    borrow_loc l0
    vec_len <u8>
    // @5
    lt
    br_true l0
    branch l1
l0: borrow_loc l0
    copy_loc l1
    // @10
    vec_borrow <u8>
    read_ref
    ld_u8 0
    neq
    br_false l2
    // @15
    branch l1
l1: ret
l2: move_loc l1
    ld_u64 1
    add
    // @20
    st_loc l1
    branch l3

// Function definition at index 2
#[persistent] entry public fun guess_with_break_without_inline(l0: vector<u8>)
    borrow_loc l0
    call loops_with_break_no_inline
    ret

// Function definition at index 3
#[persistent] entry public fun guess_without_break_with_inline(l0: vector<u8>)
    local l1: &vector<u8>
    local l2: u64
    borrow_loc l0
    st_loc l1
    ld_u64 0
    st_loc l2
l2: copy_loc l2
    // @5
    copy_loc l1
    vec_len <u8>
    lt
    br_false l0
    copy_loc l1
    // @10
    copy_loc l2
    vec_borrow <u8>
    read_ref
    ld_u8 0
    eq
    // @15
    br_false l1
    move_loc l2
    ld_u64 1
    add
    st_loc l2
    // @20
    branch l2
l1: move_loc l1
    pop
    ld_u64 3
    abort
    // @25
l0: move_loc l1
    pop
    ret

// Function definition at index 4
fun loops_with_break_no_inline(l0: &vector<u8>)
    local l1: u64
    ld_u64 0
    st_loc l1
l2: copy_loc l1
    copy_loc l0
    vec_len <u8>
    // @5
    lt
    br_false l0
    copy_loc l0
    copy_loc l1
    vec_borrow <u8>
    // @10
    read_ref
    ld_u8 0
    neq
    br_false l1
    move_loc l0
    // @15
    pop
l3: ret
l1: move_loc l1
    ld_u64 1
    add
    // @20
    st_loc l1
    branch l2
l0: move_loc l0
    pop
    branch l3

// Function definition at index 5
fun test_guess_directly()
    ld_const<vector<u8>> [0, 0, 0, 0]
    call guess_flips_directly
    ret

// Function definition at index 6
fun test_guess_with_break_no_inline()
    ld_const<vector<u8>> [0, 0, 0, 0]
    call guess_with_break_without_inline
    ret

// Function definition at index 7
fun test_guess_with_inline_break()
    ld_const<vector<u8>> [0, 0, 0, 0]
    call guess_flips
    ret

// Function definition at index 8
fun test_guess_without_break()
    ld_const<vector<u8>> [0, 0, 0, 0]
    call guess_without_break_with_inline
    ret


============ bytecode verification succeeded ========
