
============ disassembled file-format ==================
// Bytecode version v9
module 0xcafe::vectors
// Function definition at index 0
#[persistent] entry public fun guess_flips(l0: vector<u8>)
    local l1: &vector<u8>
    local l2: u64
    borrow_loc l0
    st_loc l1
    ld_u64 0
    st_loc l2
l4: copy_loc l2
    // @5
    copy_loc l1
    vec_len <u8>
    lt
    br_false l0
    copy_loc l1
    // @10
    copy_loc l2
    vec_borrow <u8>
    read_ref
    ld_u8 0
    neq
    // @15
    br_false l1
    move_loc l1
    pop
    branch l2
l1: move_loc l2
    // @20
    ld_u64 1
    add
    st_loc l2
    branch l3
l0: move_loc l1
    // @25
    pop
    branch l2
l3: branch l4
l2: ret

// Function definition at index 1
#[persistent] entry public fun guess_flips_directly(l0: vector<u8>)
    local l1: u64
    ld_u64 0
    st_loc l1
l4: copy_loc l1
    borrow_loc l0
    vec_len <u8>
    // @5
    lt
    br_false l0
    borrow_loc l0
    copy_loc l1
    vec_borrow <u8>
    // @10
    read_ref
    ld_u8 0
    neq
    br_false l1
    branch l2
    // @15
l1: move_loc l1
    ld_u64 1
    add
    st_loc l1
    branch l3
    // @20
l0: branch l2
l3: branch l4
l2: ret

// Function definition at index 2
#[persistent] entry public fun guess_with_break_without_inline(l0: vector<u8>)
    borrow_loc l0
    call loops_with_break_no_inline
    ret

// Function definition at index 3
#[persistent] entry public fun guess_without_break_with_inline(l0: vector<u8>)
    local l1: &vector<u8>
    local l2: u64
    borrow_loc l0
    st_loc l1
    ld_u64 0
    st_loc l2
l5: copy_loc l2
    // @5
    copy_loc l1
    vec_len <u8>
    lt
    br_false l0
    copy_loc l1
    // @10
    copy_loc l2
    vec_borrow <u8>
    read_ref
    ld_u8 0
    eq
    // @15
    br_false l1
    branch l2
l1: move_loc l1
    pop
    ld_u64 3
    // @20
    abort
l2: move_loc l2
    ld_u64 1
    add
    st_loc l2
    // @25
    branch l3
l0: move_loc l1
    pop
    branch l4
l3: branch l5
    // @30
l4: ret

// Function definition at index 4
fun loops_with_break_no_inline(l0: &vector<u8>)
    local l1: u64
    ld_u64 0
    st_loc l1
l4: copy_loc l1
    copy_loc l0
    vec_len <u8>
    // @5
    lt
    br_false l0
    copy_loc l0
    copy_loc l1
    vec_borrow <u8>
    // @10
    read_ref
    ld_u8 0
    neq
    br_false l1
    move_loc l0
    // @15
    pop
    branch l2
l1: move_loc l1
    ld_u64 1
    add
    // @20
    st_loc l1
    branch l3
l0: move_loc l0
    pop
    branch l2
    // @25
l3: branch l4
l2: ret

// Function definition at index 5
fun test_guess_directly()
    ld_const<vector<u8>> [0, 0, 0, 0]
    call guess_flips_directly
    ret

// Function definition at index 6
fun test_guess_with_break_no_inline()
    ld_const<vector<u8>> [0, 0, 0, 0]
    call guess_with_break_without_inline
    ret

// Function definition at index 7
fun test_guess_with_inline_break()
    ld_const<vector<u8>> [0, 0, 0, 0]
    call guess_flips
    ret

// Function definition at index 8
fun test_guess_without_break()
    ld_const<vector<u8>> [0, 0, 0, 0]
    call guess_without_break_with_inline
    ret


============ bytecode verification succeeded ========
