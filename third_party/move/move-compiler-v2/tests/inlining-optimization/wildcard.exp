// -- Model dump before first bytecode pipeline
module 0x42::test {
    struct T<A,B> {
        x: A,
        y: B,
    }
    struct S<A,B,C> {
        0: A,
        1: B,
        2: C,
    }
    private fun proj_0<A,B,C>(self: S<A, B, C>): A {
        {
          let test::S<A, B, C>{ 0: x, 1: _, 2: _ } = self;
          x
        }
    }
    private fun test_proj_0(): u8 {
        {
          let x: S<u8, address, bool> = pack test::S<u8, address, bool>(42, 0x1, true);
          test::proj_0<u8, address, bool>(x)
        }
    }
} // end 0x42::test

// -- Sourcified model before first bytecode pipeline
module 0x42::test {
    struct T<A, B> has drop {
        x: A,
        y: B,
    }
    struct S<A, B, C> has drop {
        0: A,
        1: B,
        2: C,
    }
    fun proj_0<A, B: drop, C: drop>(self: S<A, B, C>): A {
        let S<A, B, C>(x, _, _) = self;
        x
    }
    fun test_proj_0(): u8 {
        let x = S<u8, address, bool>(42u8, @0x1, true);
        proj_0<u8, address, bool>(x)
    }
}

// -- Model dump before second bytecode pipeline
module 0x42::test {
    struct T<A,B> {
        x: A,
        y: B,
    }
    struct S<A,B,C> {
        0: A,
        1: B,
        2: C,
    }
    private fun proj_0<A,B,C>(self: S<A, B, C>): A {
        {
          let test::S<A, B, C>{ 0: x, 1: _, 2: _ } = self;
          x
        }
    }
    private fun test_proj_0(): u8 {
        {
          let x: S<u8, address, bool> = pack test::S<u8, address, bool>(42, 0x1, true);
          {
            let (self: S<u8, address, bool>): (S<u8, address, bool>) = Tuple(x);
            {
              let test::S<u8, address, bool>{ 0: x, 1: _, 2: _ } = self;
              x
            }
          }
        }
    }
} // end 0x42::test


============ disassembled file-format ==================
// Bytecode version v10
module 0x42::test
struct T<T0, T1> has drop
  x: T0
  y: T1

struct S<T0, T1, T2> has drop
  _0: T0
  _1: T1
  _2: T2

// Function definition at index 0
fun proj_0<T0, T1: drop, T2: drop>(l0: S<T0, T1, T2>): T0
    move_loc l0
    unpack S<T0, T1, T2>
    pop
    pop
    ret

// Function definition at index 1
fun test_proj_0(): u8
    ld_u8 42
    ld_const<address> 1
    ld_true
    pack S<u8, address, bool>
    unpack S<u8, address, bool>
    // @5
    pop
    pop
    ret


============ bytecode verification succeeded ========
