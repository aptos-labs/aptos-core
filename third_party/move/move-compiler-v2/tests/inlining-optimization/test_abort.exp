// -- Model dump before first bytecode pipeline
module 0xc0ffee::n {
    public fun not_inlined(x: &mut u64) {
        if Gt<u64>(Deref(x), 5) {
          if Gt<u64>(Deref(x), 5) {
            Tuple()
          } else {
            Abort(42)
          };
          x = 42;
          Tuple()
        } else {
          x = Add<u64>(Deref(x), 1);
          Tuple()
        }
    }
} // end 0xc0ffee::n
module 0xc0ffee::m {
    public fun compute(): u64 {
        {
          let x: u64 = 3;
          n::not_inlined(Borrow(Mutable)(x));
          m::one(Borrow(Mutable)(x));
          Add<u64>(x, m::two())
        }
    }
    private fun one(x: &mut u64) {
        if Gt<u64>(Deref(x), 5) {
          if Gt<u64>(Deref(x), 5) {
            Tuple()
          } else {
            Abort(42)
          };
          x = 42;
          Tuple()
        } else {
          x = Add<u64>(Deref(x), 43);
          Tuple()
        }
    }
    public fun two(): u64 {
        2
    }
} // end 0xc0ffee::m

// -- Sourcified model before first bytecode pipeline
module 0xc0ffee::n {
    public fun not_inlined(x: &mut u64) {
        if (*x > 5) {
            if (*x > 5) () else abort 42;
            *x = 42;
        } else {
            *x = *x + 1;
        }
    }
}
module 0xc0ffee::m {
    public fun compute(): u64 {
        let x = 3;
        0xc0ffee::n::not_inlined(&mut x);
        one(&mut x);
        x + two()
    }
    fun one(x: &mut u64) {
        if (*x > 5) {
            if (*x > 5) () else abort 42;
            *x = 42;
        } else {
            *x = *x + 43;
        }
    }
    public fun two(): u64 {
        2
    }
}

// -- Model dump before second bytecode pipeline
module 0xc0ffee::n {
    public fun not_inlined(x: &mut u64) {
        if Gt<u64>(Deref(x), 5) {
          if Gt<u64>(Deref(x), 5) {
            Tuple()
          } else {
            Abort(42)
          };
          x = 42;
          Tuple()
        } else {
          x = Add<u64>(Deref(x), 1);
          Tuple()
        }
    }
} // end 0xc0ffee::n
module 0xc0ffee::m {
    public fun compute(): u64 {
        {
          let x: u64 = 3;
          n::not_inlined(Borrow(Mutable)(x));
          {
            let (x: &mut u64): (&mut u64) = Tuple(Borrow(Mutable)(x));
            if Gt<u64>(Deref(x), 5) {
              if Gt<u64>(Deref(x), 5) {
                Tuple()
              } else {
                Abort(42)
              };
              x = 42;
              Tuple()
            } else {
              x = Add<u64>(Deref(x), 43);
              Tuple()
            }
          };
          Add<u64>(x, 2)
        }
    }
    private fun one(x: &mut u64) {
        if Gt<u64>(Deref(x), 5) {
          if Gt<u64>(Deref(x), 5) {
            Tuple()
          } else {
            Abort(42)
          };
          x = 42;
          Tuple()
        } else {
          x = Add<u64>(Deref(x), 43);
          Tuple()
        }
    }
    public fun two(): u64 {
        2
    }
} // end 0xc0ffee::m


============ disassembled file-format ==================
// Move bytecode v9
module c0ffee.n {


public not_inlined(x: &mut u64) /* def_idx: 0 */ {
B0:
	0: CopyLoc[0](x: &mut u64)
	1: ReadRef
	2: LdU64(5)
	3: Gt
	4: BrFalse(18)
B1:
	5: CopyLoc[0](x: &mut u64)
	6: ReadRef
	7: LdU64(5)
	8: Gt
	9: BrFalse(14)
B2:
	10: LdU64(42)
	11: MoveLoc[0](x: &mut u64)
	12: WriteRef
B3:
	13: Ret
B4:
	14: MoveLoc[0](x: &mut u64)
	15: Pop
	16: LdU64(42)
	17: Abort
B5:
	18: CopyLoc[0](x: &mut u64)
	19: ReadRef
	20: LdU64(1)
	21: Add
	22: MoveLoc[0](x: &mut u64)
	23: WriteRef
	24: Branch(13)
}
}// Move bytecode v9
module c0ffee.m {
use 0000000000000000000000000000000000000000000000000000000000c0ffee::n;




public compute(): u64 /* def_idx: 0 */ {
L0:	x: u64
L1:	$t2: &mut u64
B0:
	0: LdU64(3)
	1: StLoc[0](x: u64)
	2: MutBorrowLoc[0](x: u64)
	3: Call n::not_inlined(&mut u64)
	4: MutBorrowLoc[0](x: u64)
	5: StLoc[1]($t2: &mut u64)
	6: CopyLoc[1]($t2: &mut u64)
	7: ReadRef
	8: LdU64(5)
	9: Gt
	10: BrFalse(27)
B1:
	11: CopyLoc[1]($t2: &mut u64)
	12: ReadRef
	13: LdU64(5)
	14: Gt
	15: BrFalse(23)
B2:
	16: LdU64(42)
	17: MoveLoc[1]($t2: &mut u64)
	18: WriteRef
B3:
	19: MoveLoc[0](x: u64)
	20: LdU64(2)
	21: Add
	22: Ret
B4:
	23: MoveLoc[1]($t2: &mut u64)
	24: Pop
	25: LdU64(42)
	26: Abort
B5:
	27: CopyLoc[1]($t2: &mut u64)
	28: ReadRef
	29: LdU64(43)
	30: Add
	31: MoveLoc[1]($t2: &mut u64)
	32: WriteRef
	33: Branch(19)
}
one(x: &mut u64) /* def_idx: 1 */ {
B0:
	0: CopyLoc[0](x: &mut u64)
	1: ReadRef
	2: LdU64(5)
	3: Gt
	4: BrFalse(18)
B1:
	5: CopyLoc[0](x: &mut u64)
	6: ReadRef
	7: LdU64(5)
	8: Gt
	9: BrFalse(14)
B2:
	10: LdU64(42)
	11: MoveLoc[0](x: &mut u64)
	12: WriteRef
B3:
	13: Ret
B4:
	14: MoveLoc[0](x: &mut u64)
	15: Pop
	16: LdU64(42)
	17: Abort
B5:
	18: CopyLoc[0](x: &mut u64)
	19: ReadRef
	20: LdU64(43)
	21: Add
	22: MoveLoc[0](x: &mut u64)
	23: WriteRef
	24: Branch(13)
}
public two(): u64 /* def_idx: 2 */ {
B0:
	0: LdU64(2)
	1: Ret
}
}
============ bytecode verification succeeded ========
