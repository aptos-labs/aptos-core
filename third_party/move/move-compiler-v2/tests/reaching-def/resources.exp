============ bytecode before first stackless bytecode pipeline ================

[variant baseline]
fun resources::acquire_counter($t0: address): u64 {
     var $t1: u64
     var $t2: 0x42::resources::Counter
     var $t3: &0x42::resources::Counter
     var $t4: &u64
  0: $t2 := move_from<0x42::resources::Counter>($t0)
  1: $t3 := borrow_local($t2)
  2: $t4 := borrow_field<0x42::resources::Counter>.value($t3)
  3: $t1 := read_ref($t4)
  4: return $t1
}


[variant baseline]
fun resources::add_to_counter($t0: &mut 0x42::resources::Counter, $t1: u64) {
     var $t2: u64
     var $t3: u64
     var $t4: &u64
     var $t5: &mut u64
  0: $t4 := borrow_field<0x42::resources::Counter>.value($t0)
  1: $t3 := read_ref($t4)
  2: $t2 := +($t3, $t1)
  3: $t5 := borrow_field<0x42::resources::Counter>.value($t0)
  4: write_ref($t5, $t2)
  5: return ()
}


[variant baseline]
fun resources::call_nested($t0: address) {
     var $t1: &mut 0x42::resources::Counter
  0: $t1 := borrow_global<0x42::resources::Counter>($t0)
  1: resources::nested_helper($t1)
  2: return ()
}


[variant baseline]
fun resources::call_with_immut_ref($t0: address): u64 {
     var $t1: u64
     var $t2: &0x42::resources::Counter
  0: $t2 := borrow_global<0x42::resources::Counter>($t0)
  1: $t1 := resources::read_value($t2)
  2: return $t1
}


[variant baseline]
fun resources::call_with_mut_ref($t0: address) {
     var $t1: &mut 0x42::resources::Counter
     var $t2: &mut 0x42::resources::Counter
     var $t3: u64
  0: $t1 := borrow_global<0x42::resources::Counter>($t0)
  1: $t2 := infer($t1)
  2: $t3 := 1
  3: resources::add_to_counter($t2, $t3)
  4: return ()
}


[variant baseline]
fun resources::check_and_read($t0: address): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: bool
     var $t4: &0x42::resources::Counter
     var $t5: u64
     var $t6: &u64
     var $t7: u64
  0: $t3 := exists<0x42::resources::Counter>($t0)
  1: if ($t3) goto 2 else goto 8
  2: label L0
  3: $t4 := borrow_global<0x42::resources::Counter>($t0)
  4: $t6 := borrow_field<0x42::resources::Counter>.value($t4)
  5: $t5 := read_ref($t6)
  6: $t2 := infer($t5)
  7: goto 11
  8: label L1
  9: $t7 := 0
 10: $t2 := infer($t7)
 11: label L2
 12: $t1 := infer($t2)
 13: return $t1
}


[variant baseline]
fun resources::conditional_acquire($t0: address, $t1: bool): u64 {
     var $t2: u64
     var $t3: u64
     var $t4: 0x42::resources::Counter
     var $t5: u64
     var $t6: &0x42::resources::Counter
     var $t7: &u64
     var $t8: u64
  0: if ($t1) goto 1 else goto 8
  1: label L0
  2: $t4 := move_from<0x42::resources::Counter>($t0)
  3: $t6 := borrow_local($t4)
  4: $t7 := borrow_field<0x42::resources::Counter>.value($t6)
  5: $t5 := read_ref($t7)
  6: $t3 := infer($t5)
  7: goto 11
  8: label L1
  9: $t8 := 0
 10: $t3 := infer($t8)
 11: label L2
 12: $t2 := infer($t3)
 13: return $t2
}


[variant baseline]
fun resources::conditional_mut_call($t0: address, $t1: bool) {
     var $t2: &mut 0x42::resources::Counter
     var $t3: &mut 0x42::resources::Counter
     var $t4: u64
  0: $t2 := borrow_global<0x42::resources::Counter>($t0)
  1: if ($t1) goto 2 else goto 7
  2: label L0
  3: $t3 := infer($t2)
  4: $t4 := 1
  5: resources::add_to_counter($t3, $t4)
  6: goto 8
  7: label L1
  8: label L2
  9: return ()
}


[variant baseline]
fun resources::increment_counter($t0: address) {
     var $t1: &mut 0x42::resources::Counter
     var $t2: u64
     var $t3: u64
     var $t4: &u64
     var $t5: u64
     var $t6: &mut u64
  0: $t1 := borrow_global<0x42::resources::Counter>($t0)
  1: $t4 := borrow_field<0x42::resources::Counter>.value($t1)
  2: $t3 := read_ref($t4)
  3: $t5 := 1
  4: $t2 := +($t3, $t5)
  5: $t6 := borrow_field<0x42::resources::Counter>.value($t1)
  6: write_ref($t6, $t2)
  7: return ()
}


[variant baseline]
fun resources::invoke_local_modifier($t0: address) {
     var $t1: |address|
  0: $t1 := closure#0 resources::modifier_func()
  1: invoke($t0, $t1)
  2: return ()
}


[variant baseline]
fun resources::invoke_local_reader($t0: address): u64 {
     var $t1: u64
     var $t2: |address|u64
  0: $t2 := closure#0 resources::reader_func()
  1: $t1 := invoke($t0, $t2)
  2: return $t1
}


[variant baseline]
fun resources::invoke_passed_closure($t0: address, $t1: |address|) {
  0: invoke($t0, $t1)
  1: return ()
}


[variant baseline]
fun resources::invoke_passed_closure_mut_ref($t0: address, $t1: |&mut 0x42::resources::Counter|) {
     var $t2: &mut 0x42::resources::Counter
  0: $t2 := borrow_global<0x42::resources::Counter>($t0)
  1: invoke($t2, $t1)
  2: return ()
}


[variant baseline]
fun resources::loop_mut_call($t0: address, $t1: u64) {
     var $t2: u64
     var $t3: bool
     var $t4: u64
     var $t5: &mut 0x42::resources::Counter
     var $t6: &mut 0x42::resources::Counter
     var $t7: u64
     var $t8: u64
     var $t9: u64
     var $t10: u64
  0: $t2 := 0
  1: label L0
  2: $t4 := infer($t2)
  3: $t3 := <($t4, $t1)
  4: if ($t3) goto 5 else goto 15
  5: label L2
  6: $t5 := borrow_global<0x42::resources::Counter>($t0)
  7: $t6 := infer($t5)
  8: $t7 := 1
  9: resources::add_to_counter($t6, $t7)
 10: $t9 := infer($t2)
 11: $t10 := 1
 12: $t8 := +($t9, $t10)
 13: $t2 := infer($t8)
 14: goto 17
 15: label L3
 16: goto 19
 17: label L4
 18: goto 1
 19: label L1
 20: return ()
}


[variant baseline]
fun resources::modifier_func($t0: address) {
     var $t1: &mut 0x42::resources::Counter
     var $t2: u64
     var $t3: u64
     var $t4: &u64
     var $t5: u64
     var $t6: &mut u64
  0: $t1 := borrow_global<0x42::resources::Counter>($t0)
  1: $t4 := borrow_field<0x42::resources::Counter>.value($t1)
  2: $t3 := read_ref($t4)
  3: $t5 := 1
  4: $t2 := +($t3, $t5)
  5: $t6 := borrow_field<0x42::resources::Counter>.value($t1)
  6: write_ref($t6, $t2)
  7: return ()
}


[variant baseline]
fun resources::nested_helper($t0: &mut 0x42::resources::Counter) {
     var $t1: &mut 0x42::resources::Counter
     var $t2: u64
  0: $t1 := infer($t0)
  1: $t2 := 10
  2: resources::add_to_counter($t1, $t2)
  3: return ()
}


[variant baseline]
fun resources::publish_counter($t0: &signer, $t1: u64) {
     var $t2: 0x42::resources::Counter
     var $t3: &signer
  0: $t2 := pack 0x42::resources::Counter($t1)
  1: $t3 := infer($t0)
  2: move_to<0x42::resources::Counter>($t3, $t2)
  3: return ()
}


[variant baseline]
fun resources::read_counter($t0: address): u64 {
     var $t1: u64
     var $t2: &0x42::resources::Counter
     var $t3: &u64
  0: $t2 := borrow_global<0x42::resources::Counter>($t0)
  1: $t3 := borrow_field<0x42::resources::Counter>.value($t2)
  2: $t1 := read_ref($t3)
  3: return $t1
}


[variant baseline]
fun resources::read_multiple($t0: address): u64 {
     var $t1: u64
     var $t2: &0x42::resources::Counter
     var $t3: &0x42::resources::Wallet
     var $t4: u64
     var $t5: &u64
     var $t6: u64
     var $t7: &u64
  0: $t2 := borrow_global<0x42::resources::Counter>($t0)
  1: $t3 := borrow_global<0x42::resources::Wallet>($t0)
  2: $t5 := borrow_field<0x42::resources::Counter>.value($t2)
  3: $t4 := read_ref($t5)
  4: $t7 := borrow_field<0x42::resources::Wallet>.balance($t3)
  5: $t6 := read_ref($t7)
  6: $t1 := +($t4, $t6)
  7: return $t1
}


[variant baseline]
fun resources::read_value($t0: &0x42::resources::Counter): u64 {
     var $t1: u64
     var $t2: &u64
  0: $t2 := borrow_field<0x42::resources::Counter>.value($t0)
  1: $t1 := read_ref($t2)
  2: return $t1
}


[variant baseline]
fun resources::reader_func($t0: address): u64 {
     var $t1: u64
     var $t2: &0x42::resources::Counter
     var $t3: &u64
  0: $t2 := borrow_global<0x42::resources::Counter>($t0)
  1: $t3 := borrow_field<0x42::resources::Counter>.value($t2)
  2: $t1 := read_ref($t3)
  3: return $t1
}


[variant baseline]
fun resources::test_pass_modifier_closure($t0: address) {
     var $t1: address
     var $t2: |address|
  0: $t1 := infer($t0)
  1: $t2 := closure#0 resources::modifier_func()
  2: resources::invoke_passed_closure($t1, $t2)
  3: return ()
}

============ after ReachingDefProcessor: ================

[variant baseline]
fun resources::acquire_counter($t0: address): u64 {
     var $t1: u64
     var $t2: 0x42::resources::Counter
     var $t3: &0x42::resources::Counter
     var $t4: &u64
     # live vars: $t0
     # reaching instruction #0:
     # refs: []
     #
  0: $t2 := move_from<0x42::resources::Counter>($t0)
     # live vars: $t2
     # reaching instruction #1: `t2` @ {0}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {0}
     # refs: []
     #
  1: $t3 := borrow_local($t2)
     # live vars: $t3
     # reaching instruction #2: `t2` @ {0}, `t3` @ {1}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {0}
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [local `c`] at line 21
     #
  2: $t4 := borrow_field<0x42::resources::Counter>.value($t3)
     # live vars: $t4
     # reaching instruction #3: `t2` @ {0}, `t3` @ {1}, `t4` @ {2}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {0}
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   => #4 via [local `c`, field `value`] at line 21
     #
  3: $t1 := read_ref($t4)
     # live vars: $t1
     # reaching instruction #4: `t1` @ {3}, `t2` @ {0}, `t3` @ {1}, `t4` @ {2}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {0}
     # refs: []
     #
  4: return $t1
}


[variant baseline]
fun resources::add_to_counter($t0: &mut 0x42::resources::Counter, $t1: u64) {
     var $t2: u64
     var $t3: u64
     var $t4: &u64
     var $t5: &mut u64
     # live vars: $t0, $t1
     # reaching instruction #0:
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  0: $t4 := borrow_field<0x42::resources::Counter>.value($t0)
     # live vars: $t0, $t1, $t4
     # reaching instruction #1: `t4` @ {0}
     # refs: [$t0 => #0, $t4 => #4]
     # #0
     #   => #4 via [field `value`] at line 76
     # #4
     #   <no edges>
     # #root
     #   <no edges>
     #
  1: $t3 := read_ref($t4)
     # live vars: $t0, $t1, $t3
     # reaching instruction #2: `t3` @ {1}, `t4` @ {0}
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  2: $t2 := +($t3, $t1)
     # live vars: $t0, $t2
     # reaching instruction #3: `t2` @ {2}, `t3` @ {1}, `t4` @ {0}
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  3: $t5 := borrow_field<0x42::resources::Counter>.value($t0)
     # live vars: $t2, $t5
     # reaching instruction #4: `t2` @ {2}, `t3` @ {1}, `t4` @ {0}, `t5` @ {3}
     # refs: [$t5 => #5]
     # #5
     #   <no edges>
     # #root
     #   <no edges>
     #
  4: write_ref($t5, $t2)
     # live vars:
     # reaching instruction #5: `t2` @ {2}, `t3` @ {1}, `t4` @ {0}, `t5` @ {3}
     # refs: []
     #
  5: return ()
}


[variant baseline]
fun resources::call_nested($t0: address) {
     var $t1: &mut 0x42::resources::Counter
     # live vars: $t0
     # reaching instruction #0:
     # refs: []
     #
  0: $t1 := borrow_global<0x42::resources::Counter>($t0)
     # live vars: $t1
     # reaching instruction #1: `t1` @ {0}
     # refs: [$t1 => #1]
     # #1
     #   <no edges>
     # #root
     #   -> (mut) #1 via [struct `resources::Counter`] at line 115
     #
  1: resources::nested_helper($t1)
     # live vars:
     # reaching instruction #2: `t1` @ {0}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {1}
     # refs: []
     #
  2: return ()
}


[variant baseline]
fun resources::call_with_immut_ref($t0: address): u64 {
     var $t1: u64
     var $t2: &0x42::resources::Counter
     # live vars: $t0
     # reaching instruction #0:
     # refs: []
     #
  0: $t2 := borrow_global<0x42::resources::Counter>($t0)
     # live vars: $t2
     # reaching instruction #1: `t2` @ {0}
     # refs: [$t2 => #2]
     # #2
     #   <no edges>
     # #root
     #   -> #2 via [struct `resources::Counter`] at line 87
     #
  1: $t1 := resources::read_value($t2)
     # live vars: $t1
     # reaching instruction #2: `t1` @ {1}, `t2` @ {0}
     # refs: []
     #
  2: return $t1
}


[variant baseline]
fun resources::call_with_mut_ref($t0: address) {
     var $t1: &mut 0x42::resources::Counter
     var $t2: &mut 0x42::resources::Counter
     var $t3: u64
     # live vars: $t0
     # reaching instruction #0:
     # refs: []
     #
  0: $t1 := borrow_global<0x42::resources::Counter>($t0)
     # live vars: $t1
     # reaching instruction #1: `t1` @ {0}
     # refs: [$t1 => #1]
     # #1
     #   <no edges>
     # #root
     #   -> (mut) #1 via [struct `resources::Counter`] at line 81
     #
  1: $t2 := infer($t1)
     # live vars: $t2
     # reaching instruction #2: `t2` @ {1}
     # refs: [$t2 => #2]
     # #2
     #   <no edges>
     # #root
     #   -> (mut) #2 via [struct `resources::Counter`] at line 81
     #
  2: $t3 := 1
     # live vars: $t2, $t3
     # reaching instruction #3: `t2` @ {1}, `t3` @ {2}
     # refs: [$t2 => #2]
     # #2
     #   <no edges>
     # #root
     #   -> (mut) #2 via [struct `resources::Counter`] at line 81
     #
  3: resources::add_to_counter($t2, $t3)
     # live vars:
     # reaching instruction #4: `t2` @ {1}, `t3` @ {2}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {3}
     # refs: []
     #
  4: return ()
}


[variant baseline]
fun resources::check_and_read($t0: address): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: bool
     var $t4: &0x42::resources::Counter
     var $t5: u64
     var $t6: &u64
     var $t7: u64
     # live vars: $t0
     # reaching instruction #0:
     # refs: []
     #
  0: $t3 := exists<0x42::resources::Counter>($t0)
     # live vars: $t0, $t3
     # reaching instruction #1: `t3` @ {0}
     # refs: []
     #
  1: if ($t3) goto 2 else goto 8
     # live vars: $t0
     # reaching instruction #2: `t3` @ {0}
     # refs: []
     #
  2: label L0
     # live vars: $t0
     # reaching instruction #3: `t3` @ {0}
     # refs: []
     #
  3: $t4 := borrow_global<0x42::resources::Counter>($t0)
     # live vars: $t4
     # reaching instruction #4: `t3` @ {0}, `t4` @ {3}
     # refs: [$t4 => #4]
     # #4
     #   <no edges>
     # #root
     #   -> #4 via [struct `resources::Counter`] at line 40
     #
  4: $t6 := borrow_field<0x42::resources::Counter>.value($t4)
     # live vars: $t6
     # reaching instruction #5: `t3` @ {0}, `t4` @ {3}, `t6` @ {4}
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   -> #6 via [struct `resources::Counter`] at line 41
     #
  5: $t5 := read_ref($t6)
     # live vars: $t5
     # reaching instruction #6: `t3` @ {0}, `t4` @ {3}, `t5` @ {5}, `t6` @ {4}
     # refs: []
     #
  6: $t2 := infer($t5)
     # live vars: $t2
     # reaching instruction #7: `t2` @ {6}, `t3` @ {0}, `t4` @ {3}, `t6` @ {4}
     # refs: []
     #
  7: goto 11
     # live vars: $t0
     # reaching instruction #8: `t3` @ {0}
     # refs: []
     #
  8: label L1
     # live vars:
     # reaching instruction #9: `t3` @ {0}
     # refs: []
     #
  9: $t7 := 0
     # live vars: $t7
     # reaching instruction #10: `t3` @ {0}, `t7` @ {9}
     # refs: []
     #
 10: $t2 := infer($t7)
     # live vars: $t2
     # reaching instruction #11: `t2` @ {6, 10}, `t3` @ {0}, `t4` @ {3}, `t6` @ {4}
     # refs: []
     #
 11: label L2
     # live vars: $t2
     # reaching instruction #12: `t2` @ {6, 10}, `t3` @ {0}, `t4` @ {3}, `t6` @ {4}
     # refs: []
     #
 12: $t1 := infer($t2)
     # live vars: $t1
     # reaching instruction #13: `t1` @ {12}, `t3` @ {0}, `t4` @ {3}, `t6` @ {4}
     # refs: []
     #
 13: return $t1
}


[variant baseline]
fun resources::conditional_acquire($t0: address, $t1: bool): u64 {
     var $t2: u64
     var $t3: u64
     var $t4: 0x42::resources::Counter
     var $t5: u64
     var $t6: &0x42::resources::Counter
     var $t7: &u64
     var $t8: u64
     # live vars: $t0, $t1
     # reaching instruction #0:
     # refs: []
     #
  0: if ($t1) goto 1 else goto 8
     # live vars: $t0
     # reaching instruction #1:
     # refs: []
     #
  1: label L0
     # live vars: $t0
     # reaching instruction #2:
     # refs: []
     #
  2: $t4 := move_from<0x42::resources::Counter>($t0)
     # live vars: $t4
     # reaching instruction #3: `t4` @ {2}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {2}
     # refs: []
     #
  3: $t6 := borrow_local($t4)
     # live vars: $t6
     # reaching instruction #4: `t4` @ {2}, `t6` @ {3}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {2}
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   => #6 via [local `c`] at line 53
     #
  4: $t7 := borrow_field<0x42::resources::Counter>.value($t6)
     # live vars: $t7
     # reaching instruction #5: `t4` @ {2}, `t6` @ {3}, `t7` @ {4}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {2}
     # refs: [$t7 => #7]
     # #7
     #   <no edges>
     # #root
     #   => #7 via [local `c`, field `value`] at line 53
     #
  5: $t5 := read_ref($t7)
     # live vars: $t5
     # reaching instruction #6: `t4` @ {2}, `t5` @ {5}, `t6` @ {3}, `t7` @ {4}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {2}
     # refs: []
     #
  6: $t3 := infer($t5)
     # live vars: $t3
     # reaching instruction #7: `t3` @ {6}, `t4` @ {2}, `t6` @ {3}, `t7` @ {4}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {2}
     # refs: []
     #
  7: goto 11
     # live vars: $t0
     # reaching instruction #8:
     # refs: []
     #
  8: label L1
     # live vars:
     # reaching instruction #9:
     # refs: []
     #
  9: $t8 := 0
     # live vars: $t8
     # reaching instruction #10: `t8` @ {9}
     # refs: []
     #
 10: $t3 := infer($t8)
     # live vars: $t3
     # reaching instruction #11: `t3` @ {6, 10}, `t4` @ {2}, `t6` @ {3}, `t7` @ {4}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {2}
     # refs: []
     #
 11: label L2
     # live vars: $t3
     # reaching instruction #12: `t3` @ {6, 10}, `t4` @ {2}, `t6` @ {3}, `t7` @ {4}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {2}
     # refs: []
     #
 12: $t2 := infer($t3)
     # live vars: $t2
     # reaching instruction #13: `t2` @ {12}, `t4` @ {2}, `t6` @ {3}, `t7` @ {4}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {2}
     # refs: []
     #
 13: return $t2
}


[variant baseline]
fun resources::conditional_mut_call($t0: address, $t1: bool) {
     var $t2: &mut 0x42::resources::Counter
     var $t3: &mut 0x42::resources::Counter
     var $t4: u64
     # live vars: $t0, $t1
     # reaching instruction #0:
     # refs: []
     #
  0: $t2 := borrow_global<0x42::resources::Counter>($t0)
     # live vars: $t1, $t2
     # reaching instruction #1: `t2` @ {0}
     # refs: [$t2 => #2]
     # #2
     #   <no edges>
     # #root
     #   -> (mut) #2 via [struct `resources::Counter`] at line 93
     #
  1: if ($t1) goto 2 else goto 7
     # live vars: $t2
     # reaching instruction #2: `t2` @ {0}
     # refs: [$t2 => #2]
     # #2
     #   <no edges>
     # #root
     #   -> (mut) #2 via [struct `resources::Counter`] at line 93
     #
  2: label L0
     # live vars: $t2
     # reaching instruction #3: `t2` @ {0}
     # refs: [$t2 => #2]
     # #2
     #   <no edges>
     # #root
     #   -> (mut) #2 via [struct `resources::Counter`] at line 93
     #
  3: $t3 := infer($t2)
     # live vars: $t3
     # reaching instruction #4: `t3` @ {3}
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   -> (mut) #3 via [struct `resources::Counter`] at line 93
     #
  4: $t4 := 1
     # live vars: $t3, $t4
     # reaching instruction #5: `t3` @ {3}, `t4` @ {4}
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   -> (mut) #3 via [struct `resources::Counter`] at line 93
     #
  5: resources::add_to_counter($t3, $t4)
     # live vars:
     # reaching instruction #6: `t3` @ {3}, `t4` @ {4}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {5}
     # refs: []
     #
  6: goto 8
     # live vars: $t2
     # reaching instruction #7: `t2` @ {0}
     # refs: [$t2 => #2]
     # #2
     #   <no edges>
     # #root
     #   -> (mut) #2 via [struct `resources::Counter`] at line 93
     #
  7: label L1
     # live vars:
     # reaching instruction #8: `t2` @ {0}, `t3` @ {3}, `t4` @ {4}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {5}
     # refs: []
     #
  8: label L2
     # live vars:
     # reaching instruction #9: `t2` @ {0}, `t3` @ {3}, `t4` @ {4}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {5}
     # refs: []
     #
  9: return ()
}


[variant baseline]
fun resources::increment_counter($t0: address) {
     var $t1: &mut 0x42::resources::Counter
     var $t2: u64
     var $t3: u64
     var $t4: &u64
     var $t5: u64
     var $t6: &mut u64
     # live vars: $t0
     # reaching instruction #0:
     # refs: []
     #
  0: $t1 := borrow_global<0x42::resources::Counter>($t0)
     # live vars: $t1
     # reaching instruction #1: `t1` @ {0}
     # refs: [$t1 => #1]
     # #1
     #   <no edges>
     # #root
     #   -> (mut) #1 via [struct `resources::Counter`] at line 32
     #
  1: $t4 := borrow_field<0x42::resources::Counter>.value($t1)
     # live vars: $t1, $t4
     # reaching instruction #2: `t1` @ {0}, `t4` @ {1}
     # refs: [$t1 => #1, $t4 => #4]
     # #1
     #   => #4 via [field `value`] at line 33
     # #4
     #   <no edges>
     # #root
     #   -> (mut) #1 via [struct `resources::Counter`] at line 32
     #
  2: $t3 := read_ref($t4)
     # live vars: $t1, $t3
     # reaching instruction #3: `t1` @ {0}, `t3` @ {2}, `t4` @ {1}
     # refs: [$t1 => #1]
     # #1
     #   <no edges>
     # #root
     #   -> (mut) #1 via [struct `resources::Counter`] at line 32
     #
  3: $t5 := 1
     # live vars: $t1, $t3, $t5
     # reaching instruction #4: `t1` @ {0}, `t3` @ {2}, `t4` @ {1}, `t5` @ {3}
     # refs: [$t1 => #1]
     # #1
     #   <no edges>
     # #root
     #   -> (mut) #1 via [struct `resources::Counter`] at line 32
     #
  4: $t2 := +($t3, $t5)
     # live vars: $t1, $t2
     # reaching instruction #5: `t1` @ {0}, `t2` @ {4}, `t3` @ {2}, `t4` @ {1}, `t5` @ {3}
     # refs: [$t1 => #1]
     # #1
     #   <no edges>
     # #root
     #   -> (mut) #1 via [struct `resources::Counter`] at line 32
     #
  5: $t6 := borrow_field<0x42::resources::Counter>.value($t1)
     # live vars: $t2, $t6
     # reaching instruction #6: `t1` @ {0}, `t2` @ {4}, `t3` @ {2}, `t4` @ {1}, `t5` @ {3}, `t6` @ {5}
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   -> (mut) #6 via [struct `resources::Counter`] at line 33
     #
  6: write_ref($t6, $t2)
     # live vars:
     # reaching instruction #7: `t1` @ {0}, `t2` @ {4}, `t3` @ {2}, `t4` @ {1}, `t5` @ {3}, `t6` @ {5}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {6}
     # refs: []
     #
  7: return ()
}


[variant baseline]
fun resources::invoke_local_modifier($t0: address) {
     var $t1: |address|
     # live vars: $t0
     # reaching instruction #0:
     # refs: []
     #
  0: $t1 := closure#0 resources::modifier_func()
     # live vars: $t0, $t1
     # reaching instruction #1: `t1` @ {0}
     # refs: []
     #
  1: invoke($t0, $t1)
     # live vars:
     # reaching instruction #2: `t1` @ {0}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {1}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(134)) }` @ {1}
     # refs: []
     #
  2: return ()
}


[variant baseline]
fun resources::invoke_local_reader($t0: address): u64 {
     var $t1: u64
     var $t2: |address|u64
     # live vars: $t0
     # reaching instruction #0:
     # refs: []
     #
  0: $t2 := closure#0 resources::reader_func()
     # live vars: $t0, $t2
     # reaching instruction #1: `t2` @ {0}
     # refs: []
     #
  1: $t1 := invoke($t0, $t2)
     # live vars: $t1
     # reaching instruction #2: `t1` @ {1}, `t2` @ {0}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {1}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(134)) }` @ {1}
     # refs: []
     #
  2: return $t1
}


[variant baseline]
fun resources::invoke_passed_closure($t0: address, $t1: |address|) {
     # live vars: $t0, $t1
     # reaching instruction #0:
     # refs: []
     #
  0: invoke($t0, $t1)
     # live vars:
     # reaching instruction #1: `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {0}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(134)) }` @ {0}
     # refs: []
     #
  1: return ()
}


[variant baseline]
fun resources::invoke_passed_closure_mut_ref($t0: address, $t1: |&mut 0x42::resources::Counter|) {
     var $t2: &mut 0x42::resources::Counter
     # live vars: $t0, $t1
     # reaching instruction #0:
     # refs: []
     #
  0: $t2 := borrow_global<0x42::resources::Counter>($t0)
     # live vars: $t1, $t2
     # reaching instruction #1: `t2` @ {0}
     # refs: [$t2 => #2]
     # #2
     #   <no edges>
     # #root
     #   -> (mut) #2 via [struct `resources::Counter`] at line 153
     #
  1: invoke($t2, $t1)
     # live vars:
     # reaching instruction #2: `t2` @ {0}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {1}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(134)) }` @ {1}
     # refs: []
     #
  2: return ()
}


[variant baseline]
fun resources::loop_mut_call($t0: address, $t1: u64) {
     var $t2: u64
     var $t3: bool
     var $t4: u64
     var $t5: &mut 0x42::resources::Counter
     var $t6: &mut 0x42::resources::Counter
     var $t7: u64
     var $t8: u64
     var $t9: u64
     var $t10: u64
     # live vars: $t0, $t1
     # reaching instruction #0:
     # refs: []
     #
  0: $t2 := 0
     # live vars: $t0, $t1, $t2
     # reaching instruction #1: `t2` @ {0, 13}, `t3` @ {3}, `t4` @ {2}, `t6` @ {7}, `t7` @ {8}, `t9` @ {10}, `t10` @ {11}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {9}
     # refs: []
     #
  1: label L0
     # live vars: $t0, $t1, $t2
     # reaching instruction #2: `t2` @ {0, 13}, `t3` @ {3}, `t4` @ {2}, `t6` @ {7}, `t7` @ {8}, `t9` @ {10}, `t10` @ {11}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {9}
     # refs: []
     #
  2: $t4 := infer($t2)
     # live vars: $t0, $t1, $t2, $t4
     # reaching instruction #3: `t2` @ {0, 13}, `t3` @ {3}, `t4` @ {2}, `t6` @ {7}, `t7` @ {8}, `t9` @ {10}, `t10` @ {11}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {9}
     # refs: []
     #
  3: $t3 := <($t4, $t1)
     # live vars: $t0, $t1, $t2, $t3
     # reaching instruction #4: `t2` @ {0, 13}, `t3` @ {3}, `t4` @ {2}, `t6` @ {7}, `t7` @ {8}, `t9` @ {10}, `t10` @ {11}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {9}
     # refs: []
     #
  4: if ($t3) goto 5 else goto 15
     # live vars: $t0, $t1, $t2
     # reaching instruction #5: `t2` @ {0, 13}, `t3` @ {3}, `t4` @ {2}, `t6` @ {7}, `t7` @ {8}, `t9` @ {10}, `t10` @ {11}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {9}
     # refs: []
     #
  5: label L2
     # live vars: $t0, $t1, $t2
     # reaching instruction #6: `t2` @ {0, 13}, `t3` @ {3}, `t4` @ {2}, `t6` @ {7}, `t7` @ {8}, `t9` @ {10}, `t10` @ {11}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {9}
     # refs: []
     #
  6: $t5 := borrow_global<0x42::resources::Counter>($t0)
     # live vars: $t0, $t1, $t2, $t5
     # reaching instruction #7: `t2` @ {0, 13}, `t3` @ {3}, `t4` @ {2}, `t5` @ {6}, `t6` @ {7}, `t7` @ {8}, `t9` @ {10}, `t10` @ {11}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {9}
     # refs: [$t5 => #5]
     # #5
     #   <no edges>
     # #root
     #   -> (mut) #5 via [struct `resources::Counter`] at line 103
     #
  7: $t6 := infer($t5)
     # live vars: $t0, $t1, $t2, $t6
     # reaching instruction #8: `t2` @ {0, 13}, `t3` @ {3}, `t4` @ {2}, `t6` @ {7}, `t7` @ {8}, `t9` @ {10}, `t10` @ {11}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {9}
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   -> (mut) #6 via [struct `resources::Counter`] at line 103
     #
  8: $t7 := 1
     # live vars: $t0, $t1, $t2, $t6, $t7
     # reaching instruction #9: `t2` @ {0, 13}, `t3` @ {3}, `t4` @ {2}, `t6` @ {7}, `t7` @ {8}, `t9` @ {10}, `t10` @ {11}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {9}
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   -> (mut) #6 via [struct `resources::Counter`] at line 103
     #
  9: resources::add_to_counter($t6, $t7)
     # live vars: $t0, $t1, $t2
     # reaching instruction #10: `t2` @ {0, 13}, `t3` @ {3}, `t4` @ {2}, `t6` @ {7}, `t7` @ {8}, `t9` @ {10}, `t10` @ {11}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {9}
     # refs: []
     #
 10: $t9 := infer($t2)
     # live vars: $t0, $t1, $t9
     # reaching instruction #11: `t3` @ {3}, `t4` @ {2}, `t6` @ {7}, `t7` @ {8}, `t9` @ {10}, `t10` @ {11}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {9}
     # refs: []
     #
 11: $t10 := 1
     # live vars: $t0, $t1, $t9, $t10
     # reaching instruction #12: `t3` @ {3}, `t4` @ {2}, `t6` @ {7}, `t7` @ {8}, `t9` @ {10}, `t10` @ {11}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {9}
     # refs: []
     #
 12: $t8 := +($t9, $t10)
     # live vars: $t0, $t1, $t8
     # reaching instruction #13: `t3` @ {3}, `t4` @ {2}, `t6` @ {7}, `t7` @ {8}, `t8` @ {12}, `t9` @ {10}, `t10` @ {11}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {9}
     # refs: []
     #
 13: $t2 := infer($t8)
     # live vars: $t0, $t1, $t2
     # reaching instruction #14: `t2` @ {13}, `t3` @ {3}, `t4` @ {2}, `t6` @ {7}, `t7` @ {8}, `t9` @ {10}, `t10` @ {11}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {9}
     # refs: []
     #
 14: goto 17
     # live vars: $t0, $t1, $t2
     # reaching instruction #15: `t2` @ {0, 13}, `t3` @ {3}, `t4` @ {2}, `t6` @ {7}, `t7` @ {8}, `t9` @ {10}, `t10` @ {11}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {9}
     # refs: []
     #
 15: label L3
     # live vars:
     # reaching instruction #16: `t2` @ {0, 13}, `t3` @ {3}, `t4` @ {2}, `t6` @ {7}, `t7` @ {8}, `t9` @ {10}, `t10` @ {11}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {9}
     # refs: []
     #
 16: goto 19
     # live vars: $t0, $t1, $t2
     # reaching instruction #17: `t2` @ {13}, `t3` @ {3}, `t4` @ {2}, `t6` @ {7}, `t7` @ {8}, `t9` @ {10}, `t10` @ {11}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {9}
     # refs: []
     #
 17: label L4
     # live vars: $t0, $t1, $t2
     # reaching instruction #18: `t2` @ {13}, `t3` @ {3}, `t4` @ {2}, `t6` @ {7}, `t7` @ {8}, `t9` @ {10}, `t10` @ {11}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {9}
     # refs: []
     #
 18: goto 1
     # live vars:
     # reaching instruction #19: `t2` @ {0, 13}, `t3` @ {3}, `t4` @ {2}, `t6` @ {7}, `t7` @ {8}, `t9` @ {10}, `t10` @ {11}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {9}
     # refs: []
     #
 19: label L1
     # live vars:
     # reaching instruction #20: `t2` @ {0, 13}, `t3` @ {3}, `t4` @ {2}, `t6` @ {7}, `t7` @ {8}, `t9` @ {10}, `t10` @ {11}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {9}
     # refs: []
     #
 20: return ()
}


[variant baseline]
fun resources::modifier_func($t0: address) {
     var $t1: &mut 0x42::resources::Counter
     var $t2: u64
     var $t3: u64
     var $t4: &u64
     var $t5: u64
     var $t6: &mut u64
     # live vars: $t0
     # reaching instruction #0:
     # refs: []
     #
  0: $t1 := borrow_global<0x42::resources::Counter>($t0)
     # live vars: $t1
     # reaching instruction #1: `t1` @ {0}
     # refs: [$t1 => #1]
     # #1
     #   <no edges>
     # #root
     #   -> (mut) #1 via [struct `resources::Counter`] at line 123
     #
  1: $t4 := borrow_field<0x42::resources::Counter>.value($t1)
     # live vars: $t1, $t4
     # reaching instruction #2: `t1` @ {0}, `t4` @ {1}
     # refs: [$t1 => #1, $t4 => #4]
     # #1
     #   => #4 via [field `value`] at line 124
     # #4
     #   <no edges>
     # #root
     #   -> (mut) #1 via [struct `resources::Counter`] at line 123
     #
  2: $t3 := read_ref($t4)
     # live vars: $t1, $t3
     # reaching instruction #3: `t1` @ {0}, `t3` @ {2}, `t4` @ {1}
     # refs: [$t1 => #1]
     # #1
     #   <no edges>
     # #root
     #   -> (mut) #1 via [struct `resources::Counter`] at line 123
     #
  3: $t5 := 1
     # live vars: $t1, $t3, $t5
     # reaching instruction #4: `t1` @ {0}, `t3` @ {2}, `t4` @ {1}, `t5` @ {3}
     # refs: [$t1 => #1]
     # #1
     #   <no edges>
     # #root
     #   -> (mut) #1 via [struct `resources::Counter`] at line 123
     #
  4: $t2 := +($t3, $t5)
     # live vars: $t1, $t2
     # reaching instruction #5: `t1` @ {0}, `t2` @ {4}, `t3` @ {2}, `t4` @ {1}, `t5` @ {3}
     # refs: [$t1 => #1]
     # #1
     #   <no edges>
     # #root
     #   -> (mut) #1 via [struct `resources::Counter`] at line 123
     #
  5: $t6 := borrow_field<0x42::resources::Counter>.value($t1)
     # live vars: $t2, $t6
     # reaching instruction #6: `t1` @ {0}, `t2` @ {4}, `t3` @ {2}, `t4` @ {1}, `t5` @ {3}, `t6` @ {5}
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   -> (mut) #6 via [struct `resources::Counter`] at line 124
     #
  6: write_ref($t6, $t2)
     # live vars:
     # reaching instruction #7: `t1` @ {0}, `t2` @ {4}, `t3` @ {2}, `t4` @ {1}, `t5` @ {3}, `t6` @ {5}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {6}
     # refs: []
     #
  7: return ()
}


[variant baseline]
fun resources::nested_helper($t0: &mut 0x42::resources::Counter) {
     var $t1: &mut 0x42::resources::Counter
     var $t2: u64
     # live vars: $t0
     # reaching instruction #0:
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  0: $t1 := infer($t0)
     # live vars: $t1
     # reaching instruction #1: `t1` @ {0}
     # refs: [$t1 => #1]
     # #1
     #   <no edges>
     # #root
     #   <no edges>
     #
  1: $t2 := 10
     # live vars: $t1, $t2
     # reaching instruction #2: `t1` @ {0}, `t2` @ {1}
     # refs: [$t1 => #1]
     # #1
     #   <no edges>
     # #root
     #   <no edges>
     #
  2: resources::add_to_counter($t1, $t2)
     # live vars:
     # reaching instruction #3: `t1` @ {0}, `t2` @ {1}
     # refs: []
     #
  3: return ()
}


[variant baseline]
fun resources::publish_counter($t0: &signer, $t1: u64) {
     var $t2: 0x42::resources::Counter
     var $t3: &signer
     # live vars: $t0, $t1
     # reaching instruction #0:
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  0: $t2 := pack 0x42::resources::Counter($t1)
     # live vars: $t0, $t2
     # reaching instruction #1: `t2` @ {0}
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  1: $t3 := infer($t0)
     # live vars: $t2, $t3
     # reaching instruction #2: `t2` @ {0}, `t3` @ {1}
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   <no edges>
     #
  2: move_to<0x42::resources::Counter>($t3, $t2)
     # live vars:
     # reaching instruction #3: `t2` @ {0}, `t3` @ {1}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {2}
     # refs: []
     #
  3: return ()
}


[variant baseline]
fun resources::read_counter($t0: address): u64 {
     var $t1: u64
     var $t2: &0x42::resources::Counter
     var $t3: &u64
     # live vars: $t0
     # reaching instruction #0:
     # refs: []
     #
  0: $t2 := borrow_global<0x42::resources::Counter>($t0)
     # live vars: $t2
     # reaching instruction #1: `t2` @ {0}
     # refs: [$t2 => #2]
     # #2
     #   <no edges>
     # #root
     #   -> #2 via [struct `resources::Counter`] at line 26
     #
  1: $t3 := borrow_field<0x42::resources::Counter>.value($t2)
     # live vars: $t3
     # reaching instruction #2: `t2` @ {0}, `t3` @ {1}
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   -> #3 via [struct `resources::Counter`] at line 27
     #
  2: $t1 := read_ref($t3)
     # live vars: $t1
     # reaching instruction #3: `t1` @ {2}, `t2` @ {0}, `t3` @ {1}
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun resources::read_multiple($t0: address): u64 {
     var $t1: u64
     var $t2: &0x42::resources::Counter
     var $t3: &0x42::resources::Wallet
     var $t4: u64
     var $t5: &u64
     var $t6: u64
     var $t7: &u64
     # live vars: $t0
     # reaching instruction #0:
     # refs: []
     #
  0: $t2 := borrow_global<0x42::resources::Counter>($t0)
     # live vars: $t0, $t2
     # reaching instruction #1: `t2` @ {0}
     # refs: [$t2 => #2]
     # #2
     #   <no edges>
     # #root
     #   -> #2 via [struct `resources::Counter`] at line 62
     #
  1: $t3 := borrow_global<0x42::resources::Wallet>($t0)
     # live vars: $t2, $t3
     # reaching instruction #2: `t2` @ {0}, `t3` @ {1}
     # refs: [$t2 => #2, $t3 => #3]
     # #2
     #   <no edges>
     # #3
     #   <no edges>
     # #root
     #   -> #2 via [struct `resources::Counter`] at line 62
     #   -> #3 via [struct `resources::Wallet`] at line 63
     #
  2: $t5 := borrow_field<0x42::resources::Counter>.value($t2)
     # live vars: $t3, $t5
     # reaching instruction #3: `t2` @ {0}, `t3` @ {1}, `t5` @ {2}
     # refs: [$t3 => #3, $t5 => #5]
     # #3
     #   <no edges>
     # #5
     #   <no edges>
     # #root
     #   -> #3 via [struct `resources::Wallet`] at line 63
     #   -> #5 via [struct `resources::Counter`] at line 64
     #
  3: $t4 := read_ref($t5)
     # live vars: $t3, $t4
     # reaching instruction #4: `t2` @ {0}, `t3` @ {1}, `t4` @ {3}, `t5` @ {2}
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   -> #3 via [struct `resources::Wallet`] at line 63
     #
  4: $t7 := borrow_field<0x42::resources::Wallet>.balance($t3)
     # live vars: $t4, $t7
     # reaching instruction #5: `t2` @ {0}, `t3` @ {1}, `t4` @ {3}, `t5` @ {2}, `t7` @ {4}
     # refs: [$t7 => #7]
     # #7
     #   <no edges>
     # #root
     #   -> #7 via [struct `resources::Wallet`] at line 64
     #
  5: $t6 := read_ref($t7)
     # live vars: $t4, $t6
     # reaching instruction #6: `t2` @ {0}, `t3` @ {1}, `t4` @ {3}, `t5` @ {2}, `t6` @ {5}, `t7` @ {4}
     # refs: []
     #
  6: $t1 := +($t4, $t6)
     # live vars: $t1
     # reaching instruction #7: `t1` @ {6}, `t2` @ {0}, `t3` @ {1}, `t4` @ {3}, `t5` @ {2}, `t6` @ {5}, `t7` @ {4}
     # refs: []
     #
  7: return $t1
}


[variant baseline]
fun resources::read_value($t0: &0x42::resources::Counter): u64 {
     var $t1: u64
     var $t2: &u64
     # live vars: $t0
     # reaching instruction #0:
     # refs: [$t0 => #0]
     # #0
     #   <no edges>
     # #root
     #   <no edges>
     #
  0: $t2 := borrow_field<0x42::resources::Counter>.value($t0)
     # live vars: $t2
     # reaching instruction #1: `t2` @ {0}
     # refs: [$t2 => #2]
     # #2
     #   <no edges>
     # #root
     #   <no edges>
     #
  1: $t1 := read_ref($t2)
     # live vars: $t1
     # reaching instruction #2: `t1` @ {1}, `t2` @ {0}
     # refs: []
     #
  2: return $t1
}


[variant baseline]
fun resources::reader_func($t0: address): u64 {
     var $t1: u64
     var $t2: &0x42::resources::Counter
     var $t3: &u64
     # live vars: $t0
     # reaching instruction #0:
     # refs: []
     #
  0: $t2 := borrow_global<0x42::resources::Counter>($t0)
     # live vars: $t2
     # reaching instruction #1: `t2` @ {0}
     # refs: [$t2 => #2]
     # #2
     #   <no edges>
     # #root
     #   -> #2 via [struct `resources::Counter`] at line 129
     #
  1: $t3 := borrow_field<0x42::resources::Counter>.value($t2)
     # live vars: $t3
     # reaching instruction #2: `t2` @ {0}, `t3` @ {1}
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   -> #3 via [struct `resources::Counter`] at line 130
     #
  2: $t1 := read_ref($t3)
     # live vars: $t1
     # reaching instruction #3: `t1` @ {2}, `t2` @ {0}, `t3` @ {1}
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun resources::test_pass_modifier_closure($t0: address) {
     var $t1: address
     var $t2: |address|
     # live vars: $t0
     # reaching instruction #0:
     # refs: []
     #
  0: $t1 := infer($t0)
     # live vars: $t1
     # reaching instruction #1: `t1` @ {0}
     # refs: []
     #
  1: $t2 := closure#0 resources::modifier_func()
     # live vars: $t1, $t2
     # reaching instruction #2: `t1` @ {0}, `t2` @ {1}
     # refs: []
     #
  2: resources::invoke_passed_closure($t1, $t2)
     # live vars:
     # reaching instruction #3: `t1` @ {0}, `t2` @ {1}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(133)) }` @ {2}, `Struct QualifiedId { module_id: ModuleId(1), id: StructId(Symbol(134)) }` @ {2}
     # refs: []
     #
  3: return ()
}
