<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Binary Canonical Serialization (BCS)"><meta name="keywords" content="rust, rustlang, rust-lang, bcs"><title>bcs - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="../crates.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../bcs/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../bcs/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Crate bcs</a></h2><div class="sidebar-elems"><div class="block"><ul><li class="version">Version 0.1.3</li><li><a id="all-types" href="all.html">All Items</a></li></ul></div><section><div class="block"><ul><li><a href="#modules">Modules</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div></section></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../bcs/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><div id="settings-menu" tabindex="-1">
                                <a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div>
                        </div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">bcs</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/bcs/lib.rs.html#4-322">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="binary-canonical-serialization-bcs"><a href="#binary-canonical-serialization-bcs">Binary Canonical Serialization (BCS)</a></h2>
<p>BCS (formerly “Libra Canonical Serialization” or LCS) is a serialization format developed
in the context of the <a href="https://diem.com">Diem</a> blockchain.</p>
<p>BCS was designed with the following main goals in mind:</p>
<ul>
<li>provide good performance and concise (binary) representations;</li>
<li>support a rich set of data types commonly used in Rust;</li>
<li>enforce canonical serialization, meaning that every value of a given type should have
a single valid representation.</li>
</ul>
<p>BCS also aims to mitigate the consequence of malicious inputs by enforcing well-defined limits
on large or nested containers during (de)serialization.</p>
<h3 id="rust-implementation"><a href="#rust-implementation">Rust Implementation</a></h3>
<p>This crate provides a Rust implementation of BCS as an encoding format for the <a href="https://serde.rs">Serde library</a>.
As such, this implementation covers most data types supported by Serde – including user-defined structs,
tagged variants (Rust enums), tuples, and maps – excluding floats, single unicode characters (char), and sets.</p>
<p>BCS is also available in other programming languages, thanks to the separate project <a href="https://github.com/novifinancial/serde-reflection">serde-reflection</a>.</p>
<h3 id="application-to-cryptography"><a href="#application-to-cryptography">Application to Cryptography</a></h3>
<p>The BCS format guarantees canonical serialization, meaning that for any given data type, there
is a one-to-one correspondance between in-memory values and valid byte representations.</p>
<p>In the context of a cryptographic application, canonical serialization has several benefits:</p>
<ul>
<li>It provides a natural and reliable way to associate in-memory values to cryptographic hashes.</li>
<li>It allows the signature of a message to be defined equivalently as the signature of the serialized bytes or as the signature of the in-memory value.</li>
</ul>
<p>Note that BCS ensures canonical serialization for each data type separately. The data type of a serialized value
must be enforced by the application itself. This requirement is typically fulfilled
using unique hash seeds for each data type. (See <a href="https://github.com/diem/diem/blob/master/crypto/crypto/src/hash.rs">Diem’s cryptographic library</a> for an example.)</p>
<h3 id="backwards-compatibility"><a href="#backwards-compatibility">Backwards Compatibility</a></h3>
<p>By design, BCS does not provide implicit versioning or backwards/forwards compatibility, therefore
applications must carefully plan in advance for adhoc extension points:</p>
<ul>
<li>Enums may be used for explicit versioning and backward compatibility (e.g. extensible query interfaces).</li>
<li>In some cases, data fields of type <code>Vec&lt;u8&gt;</code> may also be added to allow (future) unknown payloads
in serialized form.</li>
</ul>
<h3 id="detailed-specifications"><a href="#detailed-specifications">Detailed Specifications</a></h3>
<p>BCS supports the following data types:</p>
<ul>
<li>Booleans</li>
<li>Signed 8-bit, 16-bit, 32-bit, 64-bit, and 128-bit integers</li>
<li>Unsigned 8-bit, 16-bit, 32-bit, 64-bit, and 128-bit integers</li>
<li>Option</li>
<li>Unit (an empty value)</li>
<li>Fixed and variable length sequences</li>
<li>UTF-8 Encoded Strings</li>
<li>Tuples</li>
<li>Structures (aka “structs”)</li>
<li>Externally tagged enumerations (aka “enums”)</li>
<li>Maps</li>
</ul>
<p>BCS is not a self-describing format. As such, in order to deserialize a message, one must
know the message type and layout ahead of time.</p>
<p>Unless specified, all numbers are stored in little endian, two’s complement format.</p>
<h4 id="recursion-and-depth-of-bcs-data"><a href="#recursion-and-depth-of-bcs-data">Recursion and Depth of BCS Data</a></h4>
<p>Recursive data-structures (e.g. trees) are allowed. However, because of the possibility of stack
overflow during (de)serialization, the <em>container depth</em> of any valid BCS data cannot exceed the constant
<code>MAX_CONTAINER_DEPTH</code>. Formally, we define <em>container depth</em> as the number of structs and enums traversed
during (de)serialization.</p>
<p>This definition aims to minimize the number of operations while ensuring that
(de)serialization of a known BCS format cannot cause arbitrarily large stack allocations.</p>
<p>As an example, if <code>v1</code> and <code>v2</code> are values of depth <code>n1</code> and <code>n2</code>,</p>
<ul>
<li>a struct value <code>Foo { v1, v2 }</code> has depth <code>1 + max(n1, n2)</code>;</li>
<li>an enum value <code>E::Foo { v1, v2 }</code> has depth <code>1 + max(n1, n2)</code>;</li>
<li>a pair <code>(v1, v2)</code> has depth <code>max(n1, n2)</code>;</li>
<li>the value <code>Some(v1)</code> has depth <code>n1</code>.</li>
</ul>
<p>All string and integer values have depths <code>0</code>.</p>
<h4 id="booleans-and-integers"><a href="#booleans-and-integers">Booleans and Integers</a></h4><div><table><thead><tr><th>Type</th><th>Original data</th><th>Hex representation</th><th>Serialized bytes</th></tr></thead><tbody>
<tr><td>Boolean</td><td>True / False</td><td>0x01 / 0x00</td><td>01 / 00</td></tr>
<tr><td>8-bit signed integer</td><td>-1</td><td>0xFF</td><td>FF</td></tr>
<tr><td>8-bit unsigned integer</td><td>1</td><td>0x01</td><td>01</td></tr>
<tr><td>16-bit signed integer</td><td>-4660</td><td>0xEDCC</td><td>CC ED</td></tr>
<tr><td>16-bit unsigned integer</td><td>4660</td><td>0x1234</td><td>34 12</td></tr>
<tr><td>32-bit signed integer</td><td>-305419896</td><td>0xEDCBA988</td><td>88 A9 CB ED</td></tr>
<tr><td>32-bit unsigned integer</td><td>305419896</td><td>0x12345678</td><td>78 56 34 12</td></tr>
<tr><td>64-bit signed integer</td><td>-1311768467750121216</td><td>0xEDCBA98754321100</td><td>00 11 32 54 87 A9 CB ED</td></tr>
<tr><td>64-bit unsigned integer</td><td>1311768467750121216</td><td>0x12345678ABCDEF00</td><td>00 EF CD AB 78 56 34 12</td></tr>
</tbody></table>
</div><h4 id="uleb128-encoded-integers"><a href="#uleb128-encoded-integers">ULEB128-Encoded Integers</a></h4>
<p>The BCS format also uses the <a href="https://en.wikipedia.org/wiki/LEB128">ULEB128 encoding</a> internally
to represent unsigned 32-bit integers in two cases where small values are usually expected:
(1) lengths of variable-length sequences and (2) tags of enum values (see the corresponding
sections below).</p>
<div><table><thead><tr><th>Type</th><th>Original data</th><th>Hex representation</th><th>Serialized bytes</th></tr></thead><tbody>
<tr><td>ULEB128-encoded u32-integer</td><td>2^0 = 1</td><td>0x00000001</td><td>01</td></tr>
<tr><td></td><td>2^7 = 128</td><td>0x00000080</td><td>80 01</td></tr>
<tr><td></td><td>2^14 = 16384</td><td>0x00004000</td><td>80 80 01</td></tr>
<tr><td></td><td>2^21 = 2097152</td><td>0x00200000</td><td>80 80 80 01</td></tr>
<tr><td></td><td>2^28 = 268435456</td><td>0x10000000</td><td>80 80 80 80 01</td></tr>
<tr><td></td><td>9487</td><td>0x0000250f</td><td>8f 4a</td></tr>
</tbody></table>
</div>
<p>In general, a ULEB128 encoding consists of a little-endian sequence of base-128 (7-bit)
digits. Each digit is completed into a byte by setting the highest bit to 1, except for the
last (highest-significance) digit whose highest bit is set to 0.</p>
<p>In BCS, the result of decoding ULEB128 bytes is required to fit into a 32-bit unsigned
integer and be in canonical form. For instance, the following values are rejected:</p>
<ul>
<li>80 80 80 80 80 01 (2^36) is too large.</li>
<li>80 80 80 80 10 (2^33) is too large.</li>
<li>80 00 is not a minimal encoding of 0.</li>
</ul>
<h4 id="optional-data"><a href="#optional-data">Optional Data</a></h4>
<p>Optional or nullable data either exists in its full representation or does not. BCS represents
this as a single byte representing the presence <code>0x01</code> or absence <code>0x00</code> of data. If the data
is present then the serialized form of that data follows. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">some_data</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="ident">to_bytes</span>(<span class="kw-2">&amp;</span><span class="ident">some_data</span>)<span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">8</span>]);

<span class="kw">let</span> <span class="ident">no_data</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">None</span>;
<span class="macro">assert_eq!</span>(<span class="ident">to_bytes</span>(<span class="kw-2">&amp;</span><span class="ident">no_data</span>)<span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="number">0</span>]);</code></pre></div>
<h4 id="fixed-and-variable-length-sequences"><a href="#fixed-and-variable-length-sequences">Fixed and Variable Length Sequences</a></h4>
<p>Sequences can be made of up of any BCS supported types (even complex structures) but all
elements in the sequence must be of the same type. If the length of a sequence is fixed and
well known then BCS represents this as just the concatenation of the serialized form of each
individual element in the sequence. If the length of the sequence can be variable, then the
serialized sequence is length prefixed with a ULEB128-encoded unsigned integer indicating
the number of elements in the sequence. All variable length sequences must be
<code>MAX_SEQUENCE_LENGTH</code> elements long or less.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">fixed</span>: [<span class="ident">u16</span>; <span class="number">3</span>] <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="macro">assert_eq!</span>(<span class="ident">to_bytes</span>(<span class="kw-2">&amp;</span><span class="ident">fixed</span>)<span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>]);

<span class="kw">let</span> <span class="ident">variable</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>];
<span class="macro">assert_eq!</span>(<span class="ident">to_bytes</span>(<span class="kw-2">&amp;</span><span class="ident">variable</span>)<span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>]);

<span class="kw">let</span> <span class="ident">large_variable_length</span>: <span class="ident">Vec</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">=</span> <span class="macro">vec!</span>[(); <span class="number">9_487</span>];
<span class="macro">assert_eq!</span>(<span class="ident">to_bytes</span>(<span class="kw-2">&amp;</span><span class="ident">large_variable_length</span>)<span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="number">0x8f</span>, <span class="number">0x4a</span>]);</code></pre></div>
<h4 id="strings"><a href="#strings">Strings</a></h4>
<p>Only valid UTF-8 Strings are supported. BCS serializes such strings as a variable length byte
sequence, i.e. length prefixed with a ULEB128-encoded unsigned integer followed by the byte
representation of the string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Note that this string has 10 characters but has a byte length of 24</span>
<span class="kw">let</span> <span class="ident">utf8_str</span> <span class="op">=</span> <span class="string">&quot;çå∞≠¢õß∂ƒ∫&quot;</span>;
<span class="kw">let</span> <span class="ident">expecting</span> <span class="op">=</span> <span class="macro">vec!</span>[
    <span class="number">24</span>, <span class="number">0xc3</span>, <span class="number">0xa7</span>, <span class="number">0xc3</span>, <span class="number">0xa5</span>, <span class="number">0xe2</span>, <span class="number">0x88</span>, <span class="number">0x9e</span>, <span class="number">0xe2</span>, <span class="number">0x89</span>, <span class="number">0xa0</span>, <span class="number">0xc2</span>,
    <span class="number">0xa2</span>, <span class="number">0xc3</span>, <span class="number">0xb5</span>, <span class="number">0xc3</span>, <span class="number">0x9f</span>, <span class="number">0xe2</span>, <span class="number">0x88</span>, <span class="number">0x82</span>, <span class="number">0xc6</span>, <span class="number">0x92</span>, <span class="number">0xe2</span>, <span class="number">0x88</span>, <span class="number">0xab</span>,
];
<span class="macro">assert_eq!</span>(<span class="ident">to_bytes</span>(<span class="kw-2">&amp;</span><span class="ident">utf8_str</span>)<span class="question-mark">?</span>, <span class="ident">expecting</span>);</code></pre></div>
<h4 id="tuples"><a href="#tuples">Tuples</a></h4>
<p>Tuples are typed composition of objects: <code>(Type0, Type1)</code></p>
<p>Tuples are considered a fixed length sequence where each element in the sequence can be a
different type supported by BCS. Each element of a tuple is serialized in the order it is
defined within the tuple, i.e. [tuple.0, tuple.2].</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">tuple</span> <span class="op">=</span> (<span class="op">-</span><span class="number">1i8</span>, <span class="string">&quot;diem&quot;</span>);
<span class="kw">let</span> <span class="ident">expecting</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">0xFF</span>, <span class="number">4</span>, <span class="string">b&#39;d&#39;</span>, <span class="string">b&#39;i&#39;</span>, <span class="string">b&#39;e&#39;</span>, <span class="string">b&#39;m&#39;</span>];
<span class="macro">assert_eq!</span>(<span class="ident">to_bytes</span>(<span class="kw-2">&amp;</span><span class="ident">tuple</span>)<span class="question-mark">?</span>, <span class="ident">expecting</span>);</code></pre></div>
<h4 id="structures"><a href="#structures">Structures</a></h4>
<p>Structures are fixed length sequences consisting of fields with potentially different types.
Each field within a struct is serialized in the order specified by the canonical structure
definition. Structs can exist within other structs and as such, BCS recurses into each struct
and serializes them in order. There are no labels in the serialized format, the struct ordering
defines the organization within the serialization stream.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Serialize</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyStruct</span> {
    <span class="ident">boolean</span>: <span class="ident">bool</span>,
    <span class="ident">bytes</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>,
    <span class="ident">label</span>: <span class="ident">String</span>,
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Serialize</span>)]</span>
<span class="kw">struct</span> <span class="ident">Wrapper</span> {
    <span class="ident">inner</span>: <span class="ident">MyStruct</span>,
    <span class="ident">name</span>: <span class="ident">String</span>,
}

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">MyStruct</span> {
    <span class="ident">boolean</span>: <span class="bool-val">true</span>,
    <span class="ident">bytes</span>: <span class="macro">vec!</span>[<span class="number">0xC0</span>, <span class="number">0xDE</span>],
    <span class="ident">label</span>: <span class="string">&quot;a&quot;</span>.<span class="ident">to_owned</span>(),
};
<span class="kw">let</span> <span class="ident">s_bytes</span> <span class="op">=</span> <span class="ident">to_bytes</span>(<span class="kw-2">&amp;</span><span class="ident">s</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">expecting</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0xC0</span>, <span class="number">0xDE</span>, <span class="number">1</span>, <span class="string">b&#39;a&#39;</span>];
<span class="macro">assert_eq!</span>(<span class="ident">s_bytes</span>, <span class="ident">expecting</span>);

<span class="kw">let</span> <span class="ident">w</span> <span class="op">=</span> <span class="ident">Wrapper</span> {
    <span class="ident">inner</span>: <span class="ident">s</span>,
    <span class="ident">name</span>: <span class="string">&quot;b&quot;</span>.<span class="ident">to_owned</span>(),
};
<span class="kw">let</span> <span class="ident">w_bytes</span> <span class="op">=</span> <span class="ident">to_bytes</span>(<span class="kw-2">&amp;</span><span class="ident">w</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(<span class="ident">w_bytes</span>.<span class="ident">starts_with</span>(<span class="kw-2">&amp;</span><span class="ident">s_bytes</span>));

<span class="ident">expecting</span>.<span class="ident">append</span>(<span class="kw-2">&amp;mut</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="string">b&#39;b&#39;</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">w_bytes</span>, <span class="ident">expecting</span>);</code></pre></div>
<h4 id="externally-tagged-enumerations"><a href="#externally-tagged-enumerations">Externally Tagged Enumerations</a></h4>
<p>An enumeration is typically represented as a type that can take one of potentially many
different variants. In BCS, each variant is mapped to a variant index, a ULEB128-encoded 32-bit unsigned
integer, followed by serialized data if the type has an associated value. An
associated type can be any BCS supported type. The variant index is determined based on the
ordering of the variants in the canonical enum definition, where the first variant has an index
of <code>0</code>, the second an index of <code>1</code>, etc.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Serialize</span>)]</span>
<span class="kw">enum</span> <span class="ident">E</span> {
    <span class="ident">Variant0</span>(<span class="ident">u16</span>),
    <span class="ident">Variant1</span>(<span class="ident">u8</span>),
    <span class="ident">Variant2</span>(<span class="ident">String</span>),
}

<span class="kw">let</span> <span class="ident">v0</span> <span class="op">=</span> <span class="ident">E::Variant0</span>(<span class="number">8000</span>);
<span class="kw">let</span> <span class="ident">v1</span> <span class="op">=</span> <span class="ident">E::Variant1</span>(<span class="number">255</span>);
<span class="kw">let</span> <span class="ident">v2</span> <span class="op">=</span> <span class="ident">E::Variant2</span>(<span class="string">&quot;e&quot;</span>.<span class="ident">to_owned</span>());

<span class="macro">assert_eq!</span>(<span class="ident">to_bytes</span>(<span class="kw-2">&amp;</span><span class="ident">v0</span>)<span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">0x40</span>, <span class="number">0x1F</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">to_bytes</span>(<span class="kw-2">&amp;</span><span class="ident">v1</span>)<span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">0xFF</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">to_bytes</span>(<span class="kw-2">&amp;</span><span class="ident">v2</span>)<span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="number">2</span>, <span class="number">1</span>, <span class="string">b&#39;e&#39;</span>]);</code></pre></div>
<p>If you need to serialize a C-style enum, you should use a primitive integer type.</p>
<h4 id="maps-key--value-stores"><a href="#maps-key--value-stores">Maps (Key / Value Stores)</a></h4>
<p>Maps are represented as a variable-length, sorted sequence of (Key, Value) tuples. Keys must be
unique and the tuples sorted by increasing lexicographical order on the BCS bytes of each key.
The representation is otherwise similar to that of a variable-length sequence. In particular,
it is preceded by the number of tuples, encoded in ULEB128.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">map</span> <span class="op">=</span> <span class="ident">HashMap::new</span>();
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="string">b&#39;e&#39;</span>, <span class="string">b&#39;f&#39;</span>);
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="string">b&#39;a&#39;</span>, <span class="string">b&#39;b&#39;</span>);
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="string">b&#39;c&#39;</span>, <span class="string">b&#39;d&#39;</span>);

<span class="kw">let</span> <span class="ident">expecting</span> <span class="op">=</span> <span class="macro">vec!</span>[(<span class="string">b&#39;a&#39;</span>, <span class="string">b&#39;b&#39;</span>), (<span class="string">b&#39;c&#39;</span>, <span class="string">b&#39;d&#39;</span>), (<span class="string">b&#39;e&#39;</span>, <span class="string">b&#39;f&#39;</span>)];

<span class="macro">assert_eq!</span>(<span class="ident">to_bytes</span>(<span class="kw-2">&amp;</span><span class="ident">map</span>)<span class="question-mark">?</span>, <span class="ident">to_bytes</span>(<span class="kw-2">&amp;</span><span class="ident">expecting</span>)<span class="question-mark">?</span>);</code></pre></div>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="test_helpers/index.html" title="bcs::test_helpers mod">test_helpers</a></div><div class="item-right docblock-short"></div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Error.html" title="bcs::Error enum">Error</a></div><div class="item-right docblock-short"></div></div></div><h2 id="constants" class="small-section-header"><a href="#constants">Constants</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant.MAX_CONTAINER_DEPTH.html" title="bcs::MAX_CONTAINER_DEPTH constant">MAX_CONTAINER_DEPTH</a></div><div class="item-right docblock-short"><p>Maximal allowed depth of BCS data, counting only structs and enums.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant.MAX_SEQUENCE_LENGTH.html" title="bcs::MAX_SEQUENCE_LENGTH constant">MAX_SEQUENCE_LENGTH</a></div><div class="item-right docblock-short"><p>Variable length sequences in BCS are limited to max length of 2^31 - 1.</p>
</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.from_bytes.html" title="bcs::from_bytes fn">from_bytes</a></div><div class="item-right docblock-short"><p>Deserializes a <code>&amp;[u8]</code> into a type.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.from_bytes_seed.html" title="bcs::from_bytes_seed fn">from_bytes_seed</a></div><div class="item-right docblock-short"><p>Perform a stateful deserialization from a <code>&amp;[u8]</code> using the provided <code>seed</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.from_bytes_seed_with_limit.html" title="bcs::from_bytes_seed_with_limit fn">from_bytes_seed_with_limit</a></div><div class="item-right docblock-short"><p>Same as <code>from_bytes_seed</code> but use <code>limit</code> as max container depth instead of MAX_CONTAINER_DEPTH`</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.from_bytes_with_limit.html" title="bcs::from_bytes_with_limit fn">from_bytes_with_limit</a></div><div class="item-right docblock-short"><p>Same as <code>from_bytes</code> but use <code>limit</code> as max container depth instead of MAX_CONTAINER_DEPTH`</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.is_human_readable.html" title="bcs::is_human_readable fn">is_human_readable</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.serialize_into.html" title="bcs::serialize_into fn">serialize_into</a></div><div class="item-right docblock-short"><p>Same as <code>to_bytes</code> but write directly into an <code>std::io::Write</code> object.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.serialize_into_with_limit.html" title="bcs::serialize_into_with_limit fn">serialize_into_with_limit</a></div><div class="item-right docblock-short"><p>Same as <code>serialize_into</code> but use <code>limit</code> as max container depth instead of MAX_CONTAINER_DEPTH</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.serialized_size.html" title="bcs::serialized_size fn">serialized_size</a></div><div class="item-right docblock-short"><p>Same as <code>to_bytes</code> but only return the size of the serialized bytes.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.serialized_size_with_limit.html" title="bcs::serialized_size_with_limit fn">serialized_size_with_limit</a></div><div class="item-right docblock-short"><p>Same as <code>serialized_size</code> but use <code>limit</code> as max container depth instead of MAX_CONTAINER_DEPTH</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.to_bytes.html" title="bcs::to_bytes fn">to_bytes</a></div><div class="item-right docblock-short"><p>Serialize the given data structure as a <code>Vec&lt;u8&gt;</code> of BCS.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.to_bytes_with_limit.html" title="bcs::to_bytes_with_limit fn">to_bytes_with_limit</a></div><div class="item-right docblock-short"><p>Same as <code>to_bytes</code> but use <code>limit</code> as max container depth instead of MAX_CONTAINER_DEPTH</p>
</div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Result.html" title="bcs::Result type">Result</a></div><div class="item-right docblock-short"></div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="bcs" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.63.0 (4b91a6ea7 2022-08-08)" ></div>
</body></html>