<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A already configured CSV reader."><meta name="keywords" content="rust, rustlang, rust-lang, Reader"><title>Reader in prettytable::csv - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../prettytable/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../prettytable/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Reader</a></h2><div class="sidebar-elems"><section><div class="block"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><ul><li><a href="#method.byte_headers">byte_headers</a></li><li><a href="#method.byte_records">byte_records</a></li><li><a href="#method.deserialize">deserialize</a></li><li><a href="#method.from_path">from_path</a></li><li><a href="#method.from_reader">from_reader</a></li><li><a href="#method.get_mut">get_mut</a></li><li><a href="#method.get_ref">get_ref</a></li><li><a href="#method.has_headers">has_headers</a></li><li><a href="#method.headers">headers</a></li><li><a href="#method.into_byte_records">into_byte_records</a></li><li><a href="#method.into_deserialize">into_deserialize</a></li><li><a href="#method.into_inner">into_inner</a></li><li><a href="#method.into_records">into_records</a></li><li><a href="#method.is_done">is_done</a></li><li><a href="#method.position">position</a></li><li><a href="#method.read_byte_record">read_byte_record</a></li><li><a href="#method.read_record">read_record</a></li><li><a href="#method.records">records</a></li><li><a href="#method.seek">seek</a></li><li><a href="#method.seek_raw">seek_raw</a></li><li><a href="#method.set_byte_headers">set_byte_headers</a></li><li><a href="#method.set_headers">set_headers</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><ul><li><a href="#impl-Debug">Debug</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul><li><a href="#impl-RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send">Send</a></li><li><a href="#impl-Sync">Sync</a></li><li><a href="#impl-Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe">UnwindSafe</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><ul><li><a href="#impl-Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a></li><li><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></li></ul></div></section><h2 class="location"><a href="index.html">In prettytable::csv</a></h2></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../prettytable/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><div id="settings-menu" tabindex="-1">
                                <a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div>
                        </div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Struct <a href="../index.html">prettytable</a>::<wbr><a href="index.html">csv</a>::<wbr><a class="struct" href="#">Reader</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../src/csv/reader.rs.html#707-720">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust struct"><code>pub struct Reader&lt;R&gt; { /* private fields */ }</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A already configured CSV reader.</p>
<p>A CSV reader takes as input CSV data and transforms that into standard Rust
values. The most flexible way to read CSV data is as a sequence of records,
where a record is a sequence of fields and each field is a string. However,
a reader can also deserialize CSV data into Rust types like <code>i64</code> or
<code>(String, f64, f64, f64)</code> or even a custom struct automatically using
Serde.</p>
<h2 id="configuration"><a href="#configuration">Configuration</a></h2>
<p>A CSV reader has a couple convenient constructor methods like <code>from_path</code>
and <code>from_reader</code>. However, if you want to configure the CSV reader to use
a different delimiter or quote character (among many other things), then
you should use a <a href="struct.ReaderBuilder.html"><code>ReaderBuilder</code></a> to construct
a <code>Reader</code>. For example, to change the field delimiter:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::error::Error</span>;
<span class="kw">use</span> <span class="ident">csv::ReaderBuilder</span>;

<span class="kw">fn</span> <span class="ident">example</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city;country;pop
Boston;United States;4628910
&quot;</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">ReaderBuilder::new</span>()
        .<span class="ident">delimiter</span>(<span class="string">b&#39;;&#39;</span>)
        .<span class="ident">from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());

    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">records</span>().<span class="ident">next</span>() {
        <span class="kw">let</span> <span class="ident">record</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
        <span class="macro">assert_eq!</span>(<span class="ident">record</span>, <span class="macro">vec!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else</span> {
        <span class="prelude-val">Err</span>(<span class="ident">From::from</span>(<span class="string">&quot;expected at least one record but got none&quot;</span>))
    }
}</code></pre></div>
<h2 id="error-handling"><a href="#error-handling">Error handling</a></h2>
<p>In general, CSV <em>parsing</em> does not ever return an error. That is, there is
no such thing as malformed CSV data. Instead, this reader will prioritize
finding a parse over rejecting CSV data that it does not understand. This
choice was inspired by other popular CSV parsers, but also because it is
pragmatic. CSV data varies wildly, so even if the CSV data is malformed,
it might still be possible to work with the data. In the land of CSV, there
is no “right” or “wrong,” only “right” and “less right.”</p>
<p>With that said, a number of errors can occur while reading CSV data:</p>
<ul>
<li>By default, all records in CSV data must have the same number of fields.
If a record is found with a different number of fields than a prior
record, then an error is returned. This behavior can be disabled by
enabling flexible parsing via the <code>flexible</code> method on
<a href="struct.ReaderBuilder.html"><code>ReaderBuilder</code></a>.</li>
<li>When reading CSV data from a resource (like a file), it is possible for
reading from the underlying resource to fail. This will return an error.
For subsequent calls to the <code>Reader</code> after encountering a such error
(unless <code>seek</code> is used), it will behave as if end of file had been
reached, in order to avoid running into infinite loops when still
attempting to read the next record when one has errored.</li>
<li>When reading CSV data into <code>String</code> or <code>&amp;str</code> fields (e.g., via a
<a href="struct.StringRecord.html"><code>StringRecord</code></a>), UTF-8 is strictly
enforced. If CSV data is invalid UTF-8, then an error is returned. If
you want to read invalid UTF-8, then you should use the byte oriented
APIs such as <a href="struct.ByteRecord.html"><code>ByteRecord</code></a>. If you need explicit
support for another encoding entirely, then you’ll need to use another
crate to transcode your CSV data to UTF-8 before parsing it.</li>
<li>When using Serde to deserialize CSV data into Rust types, it is possible
for a number of additional errors to occur. For example, deserializing
a field <code>xyz</code> into an <code>i32</code> field will result in an error.</li>
</ul>
<p>For more details on the precise semantics of errors, see the
<a href="enum.Error.html"><code>Error</code></a> type.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><div id="implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#789-814">source</a></span><a href="#impl" class="anchor"></a><h3 class="code-header in-band">impl <a class="struct" href="struct.Reader.html" title="struct prettytable::csv::Reader">Reader</a>&lt;<a class="struct" href="struct.Reader.html" title="struct prettytable::csv::Reader">Reader</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.63.0/std/fs/struct.File.html" title="struct std::fs::File">File</a>&gt;&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_path" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#811">source</a></span><a href="#method.from_path" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.from_path" class="fnname">from_path</a>&lt;P&gt;(path: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Reader.html" title="struct prettytable::csv::Reader">Reader</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.63.0/std/fs/struct.File.html" title="struct std::fs::File">File</a>&gt;, <a class="struct" href="../../csv/error/struct.Error.html" title="struct csv::error::Error">Error</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.63.0/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>Create a new CSV parser with a default configuration for the given
file path.</p>
<p>To customize CSV parsing, use a <code>ReaderBuilder</code>.</p>
<h5 id="example"><a href="#example">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::error::Error</span>;
<span class="kw">use</span> <span class="ident">csv::Reader</span>;

<span class="kw">fn</span> <span class="ident">example</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader::from_path</span>(<span class="string">&quot;foo.csv&quot;</span>)<span class="question-mark">?</span>;
    <span class="kw">for</span> <span class="ident">result</span> <span class="kw">in</span> <span class="ident">rdr</span>.<span class="ident">records</span>() {
        <span class="kw">let</span> <span class="ident">record</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
        <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">record</span>);
    }
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#816-1780">source</a></span><a href="#impl-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;R&gt; <a class="struct" href="struct.Reader.html" title="struct prettytable::csv::Reader">Reader</a>&lt;R&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_reader" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#863">source</a></span><a href="#method.from_reader" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.from_reader" class="fnname">from_reader</a>(rdr: R) -&gt; <a class="struct" href="struct.Reader.html" title="struct prettytable::csv::Reader">Reader</a>&lt;R&gt;</h4></section></summary><div class="docblock"><p>Create a new CSV parser with a default configuration for the given
reader.</p>
<p>To customize CSV parsing, use a <code>ReaderBuilder</code>.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::error::Error</span>;
<span class="kw">use</span> <span class="ident">csv::Reader</span>;

<span class="kw">fn</span> <span class="ident">example</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
Concord,United States,42695
&quot;</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader::from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());
    <span class="kw">for</span> <span class="ident">result</span> <span class="kw">in</span> <span class="ident">rdr</span>.<span class="ident">records</span>() {
        <span class="kw">let</span> <span class="ident">record</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
        <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">record</span>);
    }
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.deserialize" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#1051-1053">source</a></span><a href="#method.deserialize" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.deserialize" class="fnname">deserialize</a>&lt;D&gt;(&amp;mut self) -&gt; <a class="struct" href="../../csv/reader/struct.DeserializeRecordsIter.html" title="struct csv::reader::DeserializeRecordsIter">DeserializeRecordsIter</a>&lt;'_, R, D&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../../serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns a borrowed iterator over deserialized records.</p>
<p>Each item yielded by this iterator is a <code>Result&lt;D, Error&gt;</code>.
Therefore, in order to access the record, callers must handle the
possibility of error (typically with <code>try!</code> or <code>?</code>).</p>
<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
default), then this does not include the first record. Additionally,
if <code>has_headers</code> is enabled, then deserializing into a struct will
automatically align the values in each row to the fields of a struct
based on the header row.</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<p>This shows how to deserialize CSV data into normal Rust structs. The
fields of the header row are used to match up the values in each row
to the fields of the struct.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::error::Error</span>;

<span class="kw">use</span> <span class="ident">csv::Reader</span>;
<span class="kw">use</span> <span class="ident">serde::Deserialize</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Deserialize</span>, <span class="ident">Eq</span>, <span class="ident">PartialEq</span>)]</span>
<span class="kw">struct</span> <span class="ident">Row</span> {
    <span class="ident">city</span>: <span class="ident">String</span>,
    <span class="ident">country</span>: <span class="ident">String</span>,
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;popcount&quot;</span>)]</span>
    <span class="ident">population</span>: <span class="ident">u64</span>,
}

<span class="kw">fn</span> <span class="ident">example</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,popcount
Boston,United States,4628910
&quot;</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader::from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">deserialize</span>();

    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>() {
        <span class="kw">let</span> <span class="ident">record</span>: <span class="ident">Row</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
        <span class="macro">assert_eq!</span>(<span class="ident">record</span>, <span class="ident">Row</span> {
            <span class="ident">city</span>: <span class="string">&quot;Boston&quot;</span>.<span class="ident">to_string</span>(),
            <span class="ident">country</span>: <span class="string">&quot;United States&quot;</span>.<span class="ident">to_string</span>(),
            <span class="ident">population</span>: <span class="number">4628910</span>,
        });
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else</span> {
        <span class="prelude-val">Err</span>(<span class="ident">From::from</span>(<span class="string">&quot;expected at least one record but got none&quot;</span>))
    }
}</code></pre></div>
<h5 id="rules"><a href="#rules">Rules</a></h5>
<p>For the most part, any Rust type that maps straight-forwardly to a CSV
record is supported. This includes maps, structs, tuples and tuple
structs. Other Rust types, such as <code>Vec</code>s, arrays, and enums have
a more complicated story. In general, when working with CSV data, one
should avoid <em>nested sequences</em> as much as possible.</p>
<p>Maps, structs, tuples and tuple structs map to CSV records in a simple
way. Tuples and tuple structs decode their fields in the order that
they are defined. Structs will do the same only if <code>has_headers</code> has
been disabled using <a href="struct.ReaderBuilder.html"><code>ReaderBuilder</code></a>,
otherwise, structs and maps are deserialized based on the fields
defined in the header row. (If there is no header row, then
deserializing into a map will result in an error.)</p>
<p>Nested sequences are supported in a limited capacity. Namely, they
are flattened. As a result, it’s often useful to use a <code>Vec</code> to capture
a “tail” of fields in a record:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::error::Error</span>;

<span class="kw">use</span> <span class="ident">csv::ReaderBuilder</span>;
<span class="kw">use</span> <span class="ident">serde::Deserialize</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Deserialize</span>, <span class="ident">Eq</span>, <span class="ident">PartialEq</span>)]</span>
<span class="kw">struct</span> <span class="ident">Row</span> {
    <span class="ident">label</span>: <span class="ident">String</span>,
    <span class="ident">values</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
}

<span class="kw">fn</span> <span class="ident">example</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;foo,1,2,3&quot;</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">ReaderBuilder::new</span>()
        .<span class="ident">has_headers</span>(<span class="bool-val">false</span>)
        .<span class="ident">from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">deserialize</span>();

    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>() {
        <span class="kw">let</span> <span class="ident">record</span>: <span class="ident">Row</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
        <span class="macro">assert_eq!</span>(<span class="ident">record</span>, <span class="ident">Row</span> {
            <span class="ident">label</span>: <span class="string">&quot;foo&quot;</span>.<span class="ident">to_string</span>(),
            <span class="ident">values</span>: <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],
        });
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else</span> {
        <span class="prelude-val">Err</span>(<span class="ident">From::from</span>(<span class="string">&quot;expected at least one record but got none&quot;</span>))
    }
}</code></pre></div>
<p>In the above example, adding another field to the <code>Row</code> struct after
the <code>values</code> field will result in a deserialization error. This is
because the deserializer doesn’t know when to stop reading fields
into the <code>values</code> vector, so it will consume the rest of the fields in
the record leaving none left over for the additional field.</p>
<p>Finally, simple enums in Rust can be deserialized as well. Namely,
enums must either be variants with no arguments or variants with a
single argument. Variants with no arguments are deserialized based on
which variant name the field matches. Variants with a single argument
are deserialized based on which variant can store the data. The latter
is only supported when using “untagged” enum deserialization. The
following example shows both forms in action:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::error::Error</span>;

<span class="kw">use</span> <span class="ident">csv::Reader</span>;
<span class="kw">use</span> <span class="ident">serde::Deserialize</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Deserialize</span>, <span class="ident">PartialEq</span>)]</span>
<span class="kw">struct</span> <span class="ident">Row</span> {
    <span class="ident">label</span>: <span class="ident">Label</span>,
    <span class="ident">value</span>: <span class="ident">Number</span>,
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Deserialize</span>, <span class="ident">PartialEq</span>)]</span>
<span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename_all</span> <span class="op">=</span> <span class="string">&quot;lowercase&quot;</span>)]</span>
<span class="kw">enum</span> <span class="ident">Label</span> {
    <span class="ident">Celsius</span>,
    <span class="ident">Fahrenheit</span>,
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Deserialize</span>, <span class="ident">PartialEq</span>)]</span>
<span class="attribute">#[<span class="ident">serde</span>(<span class="ident">untagged</span>)]</span>
<span class="kw">enum</span> <span class="ident">Number</span> {
    <span class="ident">Integer</span>(<span class="ident">i64</span>),
    <span class="ident">Float</span>(<span class="ident">f64</span>),
}

<span class="kw">fn</span> <span class="ident">example</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
label,value
celsius,22.2222
fahrenheit,72
&quot;</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader::from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">deserialize</span>();

    <span class="comment">// Read the first record.</span>
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>() {
        <span class="kw">let</span> <span class="ident">record</span>: <span class="ident">Row</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
        <span class="macro">assert_eq!</span>(<span class="ident">record</span>, <span class="ident">Row</span> {
            <span class="ident">label</span>: <span class="ident">Label::Celsius</span>,
            <span class="ident">value</span>: <span class="ident">Number::Float</span>(<span class="number">22.2222</span>),
        });
    } <span class="kw">else</span> {
        <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">From::from</span>(
            <span class="string">&quot;expected at least two records but got none&quot;</span>));
    }

    <span class="comment">// Read the second record.</span>
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>() {
        <span class="kw">let</span> <span class="ident">record</span>: <span class="ident">Row</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
        <span class="macro">assert_eq!</span>(<span class="ident">record</span>, <span class="ident">Row</span> {
            <span class="ident">label</span>: <span class="ident">Label::Fahrenheit</span>,
            <span class="ident">value</span>: <span class="ident">Number::Integer</span>(<span class="number">72</span>),
        });
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else</span> {
        <span class="prelude-val">Err</span>(<span class="ident">From::from</span>(
            <span class="string">&quot;expected at least two records but got only one&quot;</span>))
    }
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_deserialize" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#1114-1116">source</a></span><a href="#method.into_deserialize" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.into_deserialize" class="fnname">into_deserialize</a>&lt;D&gt;(self) -&gt; <a class="struct" href="../../csv/reader/struct.DeserializeRecordsIntoIter.html" title="struct csv::reader::DeserializeRecordsIntoIter">DeserializeRecordsIntoIter</a>&lt;R, D&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../../serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns an owned iterator over deserialized records.</p>
<p>Each item yielded by this iterator is a <code>Result&lt;D, Error&gt;</code>.
Therefore, in order to access the record, callers must handle the
possibility of error (typically with <code>try!</code> or <code>?</code>).</p>
<p>This is mostly useful when you want to return a CSV iterator or store
it somewhere.</p>
<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
default), then this does not include the first record. Additionally,
if <code>has_headers</code> is enabled, then deserializing into a struct will
automatically align the values in each row to the fields of a struct
based on the header row.</p>
<p>For more detailed deserialization rules, see the documentation on the
<code>deserialize</code> method.</p>
<h5 id="example-3"><a href="#example-3">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::error::Error</span>;

<span class="kw">use</span> <span class="ident">csv::Reader</span>;
<span class="kw">use</span> <span class="ident">serde::Deserialize</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Deserialize</span>, <span class="ident">Eq</span>, <span class="ident">PartialEq</span>)]</span>
<span class="kw">struct</span> <span class="ident">Row</span> {
    <span class="ident">city</span>: <span class="ident">String</span>,
    <span class="ident">country</span>: <span class="ident">String</span>,
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;popcount&quot;</span>)]</span>
    <span class="ident">population</span>: <span class="ident">u64</span>,
}

<span class="kw">fn</span> <span class="ident">example</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,popcount
Boston,United States,4628910
&quot;</span>;
    <span class="kw">let</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader::from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">into_deserialize</span>();

    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>() {
        <span class="kw">let</span> <span class="ident">record</span>: <span class="ident">Row</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
        <span class="macro">assert_eq!</span>(<span class="ident">record</span>, <span class="ident">Row</span> {
            <span class="ident">city</span>: <span class="string">&quot;Boston&quot;</span>.<span class="ident">to_string</span>(),
            <span class="ident">country</span>: <span class="string">&quot;United States&quot;</span>.<span class="ident">to_string</span>(),
            <span class="ident">population</span>: <span class="number">4628910</span>,
        });
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else</span> {
        <span class="prelude-val">Err</span>(<span class="ident">From::from</span>(<span class="string">&quot;expected at least one record but got none&quot;</span>))
    }
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.records" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#1154">source</a></span><a href="#method.records" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.records" class="fnname">records</a>(&amp;mut self) -&gt; <a class="struct" href="../../csv/reader/struct.StringRecordsIter.html" title="struct csv::reader::StringRecordsIter">StringRecordsIter</a>&lt;'_, R&gt;</h4></section></summary><div class="docblock"><p>Returns a borrowed iterator over all records as strings.</p>
<p>Each item yielded by this iterator is a <code>Result&lt;StringRecord, Error&gt;</code>.
Therefore, in order to access the record, callers must handle the
possibility of error (typically with <code>try!</code> or <code>?</code>).</p>
<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
default), then this does not include the first record.</p>
<h5 id="example-4"><a href="#example-4">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::error::Error</span>;
<span class="kw">use</span> <span class="ident">csv::Reader</span>;

<span class="kw">fn</span> <span class="ident">example</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader::from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">records</span>();

    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>() {
        <span class="kw">let</span> <span class="ident">record</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
        <span class="macro">assert_eq!</span>(<span class="ident">record</span>, <span class="macro">vec!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else</span> {
        <span class="prelude-val">Err</span>(<span class="ident">From::from</span>(<span class="string">&quot;expected at least one record but got none&quot;</span>))
    }
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_records" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#1194">source</a></span><a href="#method.into_records" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.into_records" class="fnname">into_records</a>(self) -&gt; <a class="struct" href="../../csv/reader/struct.StringRecordsIntoIter.html" title="struct csv::reader::StringRecordsIntoIter">StringRecordsIntoIter</a>&lt;R&gt;</h4></section></summary><div class="docblock"><p>Returns an owned iterator over all records as strings.</p>
<p>Each item yielded by this iterator is a <code>Result&lt;StringRecord, Error&gt;</code>.
Therefore, in order to access the record, callers must handle the
possibility of error (typically with <code>try!</code> or <code>?</code>).</p>
<p>This is mostly useful when you want to return a CSV iterator or store
it somewhere.</p>
<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
default), then this does not include the first record.</p>
<h5 id="example-5"><a href="#example-5">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::error::Error</span>;
<span class="kw">use</span> <span class="ident">csv::Reader</span>;

<span class="kw">fn</span> <span class="ident">example</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
    <span class="kw">let</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader::from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">into_records</span>();

    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>() {
        <span class="kw">let</span> <span class="ident">record</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
        <span class="macro">assert_eq!</span>(<span class="ident">record</span>, <span class="macro">vec!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else</span> {
        <span class="prelude-val">Err</span>(<span class="ident">From::from</span>(<span class="string">&quot;expected at least one record but got none&quot;</span>))
    }
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.byte_records" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#1231">source</a></span><a href="#method.byte_records" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.byte_records" class="fnname">byte_records</a>(&amp;mut self) -&gt; <a class="struct" href="../../csv/reader/struct.ByteRecordsIter.html" title="struct csv::reader::ByteRecordsIter">ByteRecordsIter</a>&lt;'_, R&gt;</h4></section></summary><div class="docblock"><p>Returns a borrowed iterator over all records as raw bytes.</p>
<p>Each item yielded by this iterator is a <code>Result&lt;ByteRecord, Error&gt;</code>.
Therefore, in order to access the record, callers must handle the
possibility of error (typically with <code>try!</code> or <code>?</code>).</p>
<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
default), then this does not include the first record.</p>
<h5 id="example-6"><a href="#example-6">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::error::Error</span>;
<span class="kw">use</span> <span class="ident">csv::Reader</span>;

<span class="kw">fn</span> <span class="ident">example</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader::from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">byte_records</span>();

    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>() {
        <span class="kw">let</span> <span class="ident">record</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
        <span class="macro">assert_eq!</span>(<span class="ident">record</span>, <span class="macro">vec!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else</span> {
        <span class="prelude-val">Err</span>(<span class="ident">From::from</span>(<span class="string">&quot;expected at least one record but got none&quot;</span>))
    }
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_byte_records" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#1271">source</a></span><a href="#method.into_byte_records" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.into_byte_records" class="fnname">into_byte_records</a>(self) -&gt; <a class="struct" href="../../csv/reader/struct.ByteRecordsIntoIter.html" title="struct csv::reader::ByteRecordsIntoIter">ByteRecordsIntoIter</a>&lt;R&gt;</h4></section></summary><div class="docblock"><p>Returns an owned iterator over all records as raw bytes.</p>
<p>Each item yielded by this iterator is a <code>Result&lt;ByteRecord, Error&gt;</code>.
Therefore, in order to access the record, callers must handle the
possibility of error (typically with <code>try!</code> or <code>?</code>).</p>
<p>This is mostly useful when you want to return a CSV iterator or store
it somewhere.</p>
<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
default), then this does not include the first record.</p>
<h5 id="example-7"><a href="#example-7">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::error::Error</span>;
<span class="kw">use</span> <span class="ident">csv::Reader</span>;

<span class="kw">fn</span> <span class="ident">example</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
    <span class="kw">let</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader::from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">into_byte_records</span>();

    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>() {
        <span class="kw">let</span> <span class="ident">record</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
        <span class="macro">assert_eq!</span>(<span class="ident">record</span>, <span class="macro">vec!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else</span> {
        <span class="prelude-val">Err</span>(<span class="ident">From::from</span>(<span class="string">&quot;expected at least one record but got none&quot;</span>))
    }
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.headers" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#1329">source</a></span><a href="#method.headers" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.headers" class="fnname">headers</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;<a class="struct" href="../../csv/string_record/struct.StringRecord.html" title="struct csv::string_record::StringRecord">StringRecord</a>, <a class="struct" href="../../csv/error/struct.Error.html" title="struct csv::error::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a reference to the first row read by this parser.</p>
<p>If no row has been read yet, then this will force parsing of the first
row.</p>
<p>If there was a problem parsing the row or if it wasn’t valid UTF-8,
then this returns an error.</p>
<p>If the underlying reader emits EOF before any data, then this returns
an empty record.</p>
<p>Note that this method may be used regardless of whether <code>has_headers</code>
was enabled (but it is enabled by default).</p>
<h5 id="example-8"><a href="#example-8">Example</a></h5>
<p>This example shows how to get the header row of CSV data. Notice that
the header row does not appear as a record in the iterator!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::error::Error</span>;
<span class="kw">use</span> <span class="ident">csv::Reader</span>;

<span class="kw">fn</span> <span class="ident">example</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader::from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());

    <span class="comment">// We can read the headers before iterating.</span>
    {
        <span class="comment">// `headers` borrows from the reader, so we put this in its</span>
        <span class="comment">// own scope. That way, the borrow ends before we try iterating</span>
        <span class="comment">// below. Alternatively, we could clone the headers.</span>
        <span class="kw">let</span> <span class="ident">headers</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">headers</span>()<span class="question-mark">?</span>;
        <span class="macro">assert_eq!</span>(<span class="ident">headers</span>, <span class="macro">vec!</span>[<span class="string">&quot;city&quot;</span>, <span class="string">&quot;country&quot;</span>, <span class="string">&quot;pop&quot;</span>]);
    }

    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">records</span>().<span class="ident">next</span>() {
        <span class="kw">let</span> <span class="ident">record</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
        <span class="macro">assert_eq!</span>(<span class="ident">record</span>, <span class="macro">vec!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
    } <span class="kw">else</span> {
        <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">From::from</span>(
            <span class="string">&quot;expected at least one record but got none&quot;</span>))
    }

    <span class="comment">// We can also read the headers after iterating.</span>
    <span class="kw">let</span> <span class="ident">headers</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">headers</span>()<span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(<span class="ident">headers</span>, <span class="macro">vec!</span>[<span class="string">&quot;city&quot;</span>, <span class="string">&quot;country&quot;</span>, <span class="string">&quot;pop&quot;</span>]);
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.byte_headers" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#1398">source</a></span><a href="#method.byte_headers" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.byte_headers" class="fnname">byte_headers</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;<a class="struct" href="../../csv/byte_record/struct.ByteRecord.html" title="struct csv::byte_record::ByteRecord">ByteRecord</a>, <a class="struct" href="../../csv/error/struct.Error.html" title="struct csv::error::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a reference to the first row read by this parser as raw bytes.</p>
<p>If no row has been read yet, then this will force parsing of the first
row.</p>
<p>If there was a problem parsing the row then this returns an error.</p>
<p>If the underlying reader emits EOF before any data, then this returns
an empty record.</p>
<p>Note that this method may be used regardless of whether <code>has_headers</code>
was enabled (but it is enabled by default).</p>
<h5 id="example-9"><a href="#example-9">Example</a></h5>
<p>This example shows how to get the header row of CSV data. Notice that
the header row does not appear as a record in the iterator!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::error::Error</span>;
<span class="kw">use</span> <span class="ident">csv::Reader</span>;

<span class="kw">fn</span> <span class="ident">example</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader::from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());

    <span class="comment">// We can read the headers before iterating.</span>
    {
        <span class="comment">// `headers` borrows from the reader, so we put this in its</span>
        <span class="comment">// own scope. That way, the borrow ends before we try iterating</span>
        <span class="comment">// below. Alternatively, we could clone the headers.</span>
        <span class="kw">let</span> <span class="ident">headers</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">byte_headers</span>()<span class="question-mark">?</span>;
        <span class="macro">assert_eq!</span>(<span class="ident">headers</span>, <span class="macro">vec!</span>[<span class="string">&quot;city&quot;</span>, <span class="string">&quot;country&quot;</span>, <span class="string">&quot;pop&quot;</span>]);
    }

    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">byte_records</span>().<span class="ident">next</span>() {
        <span class="kw">let</span> <span class="ident">record</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
        <span class="macro">assert_eq!</span>(<span class="ident">record</span>, <span class="macro">vec!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
    } <span class="kw">else</span> {
        <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">From::from</span>(
            <span class="string">&quot;expected at least one record but got none&quot;</span>))
    }

    <span class="comment">// We can also read the headers after iterating.</span>
    <span class="kw">let</span> <span class="ident">headers</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">byte_headers</span>()<span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(<span class="ident">headers</span>, <span class="macro">vec!</span>[<span class="string">&quot;city&quot;</span>, <span class="string">&quot;country&quot;</span>, <span class="string">&quot;pop&quot;</span>]);
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_headers" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#1434">source</a></span><a href="#method.set_headers" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.set_headers" class="fnname">set_headers</a>(&amp;mut self, headers: <a class="struct" href="../../csv/string_record/struct.StringRecord.html" title="struct csv::string_record::StringRecord">StringRecord</a>)</h4></section></summary><div class="docblock"><p>Set the headers of this CSV parser manually.</p>
<p>This overrides any other setting (including <code>set_byte_headers</code>). Any
automatic detection of headers is disabled. This may be called at any
time.</p>
<h5 id="example-10"><a href="#example-10">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::error::Error</span>;
<span class="kw">use</span> <span class="ident">csv</span>::{<span class="ident">Reader</span>, <span class="ident">StringRecord</span>};

<span class="kw">fn</span> <span class="ident">example</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader::from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());

    <span class="macro">assert_eq!</span>(<span class="ident">rdr</span>.<span class="ident">headers</span>()<span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="string">&quot;city&quot;</span>, <span class="string">&quot;country&quot;</span>, <span class="string">&quot;pop&quot;</span>]);
    <span class="ident">rdr</span>.<span class="ident">set_headers</span>(<span class="ident">StringRecord::from</span>(<span class="macro">vec!</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]));
    <span class="macro">assert_eq!</span>(<span class="ident">rdr</span>.<span class="ident">headers</span>()<span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_byte_headers" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#1465">source</a></span><a href="#method.set_byte_headers" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.set_byte_headers" class="fnname">set_byte_headers</a>(&amp;mut self, headers: <a class="struct" href="../../csv/byte_record/struct.ByteRecord.html" title="struct csv::byte_record::ByteRecord">ByteRecord</a>)</h4></section></summary><div class="docblock"><p>Set the headers of this CSV parser manually as raw bytes.</p>
<p>This overrides any other setting (including <code>set_headers</code>). Any
automatic detection of headers is disabled. This may be called at any
time.</p>
<h5 id="example-11"><a href="#example-11">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::error::Error</span>;
<span class="kw">use</span> <span class="ident">csv</span>::{<span class="ident">Reader</span>, <span class="ident">ByteRecord</span>};

<span class="kw">fn</span> <span class="ident">example</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader::from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());

    <span class="macro">assert_eq!</span>(<span class="ident">rdr</span>.<span class="ident">byte_headers</span>()<span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="string">&quot;city&quot;</span>, <span class="string">&quot;country&quot;</span>, <span class="string">&quot;pop&quot;</span>]);
    <span class="ident">rdr</span>.<span class="ident">set_byte_headers</span>(<span class="ident">ByteRecord::from</span>(<span class="macro">vec!</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]));
    <span class="macro">assert_eq!</span>(<span class="ident">rdr</span>.<span class="ident">byte_headers</span>()<span class="question-mark">?</span>, <span class="macro">vec!</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.read_record" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#1536">source</a></span><a href="#method.read_record" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.read_record" class="fnname">read_record</a>(&amp;mut self, record: &amp;mut <a class="struct" href="../../csv/string_record/struct.StringRecord.html" title="struct csv::string_record::StringRecord">StringRecord</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>, <a class="struct" href="../../csv/error/struct.Error.html" title="struct csv::error::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Read a single row into the given record. Returns false when no more
records could be read.</p>
<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
default), then this will never read the first record.</p>
<p>This method is useful when you want to read records as fast as
as possible. It’s less ergonomic than an iterator, but it permits the
caller to reuse the <code>StringRecord</code> allocation, which usually results
in higher throughput.</p>
<p>Records read via this method are guaranteed to have a position set
on them, even if the reader is at EOF or if an error is returned.</p>
<h5 id="example-12"><a href="#example-12">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::error::Error</span>;
<span class="kw">use</span> <span class="ident">csv</span>::{<span class="ident">Reader</span>, <span class="ident">StringRecord</span>};

<span class="kw">fn</span> <span class="ident">example</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader::from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">record</span> <span class="op">=</span> <span class="ident">StringRecord::new</span>();

    <span class="kw">if</span> <span class="ident">rdr</span>.<span class="ident">read_record</span>(<span class="kw-2">&amp;mut</span> <span class="ident">record</span>)<span class="question-mark">?</span> {
        <span class="macro">assert_eq!</span>(<span class="ident">record</span>, <span class="macro">vec!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else</span> {
        <span class="prelude-val">Err</span>(<span class="ident">From::from</span>(<span class="string">&quot;expected at least one record but got none&quot;</span>))
    }
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.read_byte_record" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#1584-1587">source</a></span><a href="#method.read_byte_record" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.read_byte_record" class="fnname">read_byte_record</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;record: &amp;mut <a class="struct" href="../../csv/byte_record/struct.ByteRecord.html" title="struct csv::byte_record::ByteRecord">ByteRecord</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>, <a class="struct" href="../../csv/error/struct.Error.html" title="struct csv::error::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Read a single row into the given byte record. Returns false when no
more records could be read.</p>
<p>If <code>has_headers</code> was enabled via a <code>ReaderBuilder</code> (which is the
default), then this will never read the first record.</p>
<p>This method is useful when you want to read records as fast as
as possible. It’s less ergonomic than an iterator, but it permits the
caller to reuse the <code>ByteRecord</code> allocation, which usually results
in higher throughput.</p>
<p>Records read via this method are guaranteed to have a position set
on them, even if the reader is at EOF or if an error is returned.</p>
<h5 id="example-13"><a href="#example-13">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::error::Error</span>;
<span class="kw">use</span> <span class="ident">csv</span>::{<span class="ident">ByteRecord</span>, <span class="ident">Reader</span>};

<span class="kw">fn</span> <span class="ident">example</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,pop
Boston,United States,4628910
&quot;</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader::from_reader</span>(<span class="ident">data</span>.<span class="ident">as_bytes</span>());
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">record</span> <span class="op">=</span> <span class="ident">ByteRecord::new</span>();

    <span class="kw">if</span> <span class="ident">rdr</span>.<span class="ident">read_byte_record</span>(<span class="kw-2">&amp;mut</span> <span class="ident">record</span>)<span class="question-mark">?</span> {
        <span class="macro">assert_eq!</span>(<span class="ident">record</span>, <span class="macro">vec!</span>[<span class="string">&quot;Boston&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;4628910&quot;</span>]);
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else</span> {
        <span class="prelude-val">Err</span>(<span class="ident">From::from</span>(<span class="string">&quot;expected at least one record but got none&quot;</span>))
    }
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.position" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#1721">source</a></span><a href="#method.position" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.position" class="fnname">position</a>(&amp;self) -&gt; &amp;<a class="struct" href="../../csv/byte_record/struct.Position.html" title="struct csv::byte_record::Position">Position</a></h4></section></summary><div class="docblock"><p>Return the current position of this CSV reader.</p>
<p>The byte offset in the position returned can be used to <code>seek</code> this
reader. In particular, seeking to a position returned here on the same
data will result in parsing the same subsequent record.</p>
<h5 id="example-reading-the-position"><a href="#example-reading-the-position">Example: reading the position</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::error::Error</span>;
<span class="kw">use</span> <span class="ident">std::io</span>;
<span class="kw">use</span> <span class="ident">csv</span>::{<span class="ident">Reader</span>, <span class="ident">Position</span>};

<span class="kw">fn</span> <span class="ident">example</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,popcount
Boston,United States,4628910
Concord,United States,42695
&quot;</span>;
    <span class="kw">let</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader::from_reader</span>(<span class="ident">io::Cursor::new</span>(<span class="ident">data</span>));
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">into_records</span>();
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">pos</span> <span class="op">=</span> <span class="ident">Position::new</span>();
    <span class="kw">loop</span> {
        <span class="comment">// Read the position immediately before each record.</span>
        <span class="kw">let</span> <span class="ident">next_pos</span> <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">reader</span>().<span class="ident">position</span>().<span class="ident">clone</span>();
        <span class="kw">if</span> <span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>() {
            <span class="kw">break</span>;
        }
        <span class="ident">pos</span> <span class="op">=</span> <span class="ident">next_pos</span>;
    }

    <span class="comment">// `pos` should now be the position immediately before the last</span>
    <span class="comment">// record.</span>
    <span class="macro">assert_eq!</span>(<span class="ident">pos</span>.<span class="ident">byte</span>(), <span class="number">51</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">pos</span>.<span class="ident">line</span>(), <span class="number">3</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">pos</span>.<span class="ident">record</span>(), <span class="number">2</span>);
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_done" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#1753">source</a></span><a href="#method.is_done" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.is_done" class="fnname">is_done</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this reader has been exhausted.</p>
<p>When this returns true, no more records can be read from this reader
(unless it has been seeked to another position).</p>
<h5 id="example-14"><a href="#example-14">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::error::Error</span>;
<span class="kw">use</span> <span class="ident">std::io</span>;
<span class="kw">use</span> <span class="ident">csv</span>::{<span class="ident">Reader</span>, <span class="ident">Position</span>};

<span class="kw">fn</span> <span class="ident">example</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,popcount
Boston,United States,4628910
Concord,United States,42695
&quot;</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader::from_reader</span>(<span class="ident">io::Cursor::new</span>(<span class="ident">data</span>));
    <span class="macro">assert!</span>(<span class="op">!</span><span class="ident">rdr</span>.<span class="ident">is_done</span>());
    <span class="kw">for</span> <span class="ident">result</span> <span class="kw">in</span> <span class="ident">rdr</span>.<span class="ident">records</span>() {
        <span class="kw">let</span> <span class="kw">_</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
    }
    <span class="macro">assert!</span>(<span class="ident">rdr</span>.<span class="ident">is_done</span>());
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.has_headers" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#1759">source</a></span><a href="#method.has_headers" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.has_headers" class="fnname">has_headers</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this reader has been configured to
interpret the first record as a header record.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_ref" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#1764">source</a></span><a href="#method.get_ref" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_ref" class="fnname">get_ref</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>R</h4></section></summary><div class="docblock"><p>Returns a reference to the underlying reader.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#1769">source</a></span><a href="#method.get_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_mut" class="fnname">get_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>R</h4></section></summary><div class="docblock"><p>Returns a mutable reference to the underlying reader.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_inner" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#1777">source</a></span><a href="#method.into_inner" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.into_inner" class="fnname">into_inner</a>(self) -&gt; R</h4></section></summary><div class="docblock"><p>Unwraps this CSV reader, returning the underlying reader.</p>
<p>Note that any leftover data inside this reader’s internal buffer is
lost.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-2" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#1782-1886">source</a></span><a href="#impl-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;R&gt; <a class="struct" href="struct.Reader.html" title="struct prettytable::csv::Reader">Reader</a>&lt;R&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> + <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Seek.html" title="trait std::io::Seek">Seek</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.seek" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#1845">source</a></span><a href="#method.seek" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.seek" class="fnname">seek</a>(&amp;mut self, pos: <a class="struct" href="../../csv/byte_record/struct.Position.html" title="struct csv::byte_record::Position">Position</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.unit.html">()</a>, <a class="struct" href="../../csv/error/struct.Error.html" title="struct csv::error::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Seeks the underlying reader to the position given.</p>
<p>This comes with a few caveats:</p>
<ul>
<li>Any internal buffer associated with this reader is cleared.</li>
<li>If the given position does not correspond to a position immediately
before the start of a record, then the behavior of this reader is
unspecified.</li>
<li>Any special logic that skips the first record in the CSV reader
when reading or iterating over records is disabled.</li>
</ul>
<p>If the given position has a byte offset equivalent to the current
position, then no seeking is performed.</p>
<p>If the header row has not already been read, then this will attempt
to read the header row before seeking. Therefore, it is possible that
this returns an error associated with reading CSV data.</p>
<p>Note that seeking is performed based only on the byte offset in the
given position. Namely, the record or line numbers in the position may
be incorrect, but this will cause any future position generated by
this CSV reader to be similarly incorrect.</p>
<h5 id="example-seek-to-parse-a-record-twice"><a href="#example-seek-to-parse-a-record-twice">Example: seek to parse a record twice</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::error::Error</span>;
<span class="kw">use</span> <span class="ident">std::io</span>;
<span class="kw">use</span> <span class="ident">csv</span>::{<span class="ident">Reader</span>, <span class="ident">Position</span>};

<span class="kw">fn</span> <span class="ident">example</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;\
city,country,popcount
Boston,United States,4628910
Concord,United States,42695
&quot;</span>;
    <span class="kw">let</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">Reader::from_reader</span>(<span class="ident">io::Cursor::new</span>(<span class="ident">data</span>));
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">into_records</span>();
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">pos</span> <span class="op">=</span> <span class="ident">Position::new</span>();
    <span class="kw">loop</span> {
        <span class="comment">// Read the position immediately before each record.</span>
        <span class="kw">let</span> <span class="ident">next_pos</span> <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">reader</span>().<span class="ident">position</span>().<span class="ident">clone</span>();
        <span class="kw">if</span> <span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>() {
            <span class="kw">break</span>;
        }
        <span class="ident">pos</span> <span class="op">=</span> <span class="ident">next_pos</span>;
    }

    <span class="comment">// Now seek the reader back to `pos`. This will let us read the</span>
    <span class="comment">// last record again.</span>
    <span class="ident">iter</span>.<span class="ident">reader_mut</span>().<span class="ident">seek</span>(<span class="ident">pos</span>)<span class="question-mark">?</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">into_reader</span>().<span class="ident">into_records</span>();
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">result</span>) <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>() {
        <span class="kw">let</span> <span class="ident">record</span> <span class="op">=</span> <span class="ident">result</span><span class="question-mark">?</span>;
        <span class="macro">assert_eq!</span>(<span class="ident">record</span>, <span class="macro">vec!</span>[<span class="string">&quot;Concord&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;42695&quot;</span>]);
        <span class="prelude-val">Ok</span>(())
    } <span class="kw">else</span> {
        <span class="prelude-val">Err</span>(<span class="ident">From::from</span>(<span class="string">&quot;expected at least one record but got none&quot;</span>))
    }
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.seek_raw" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#1872-1876">source</a></span><a href="#method.seek_raw" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.seek_raw" class="fnname">seek_raw</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;seek_from: <a class="enum" href="https://doc.rust-lang.org/1.63.0/std/io/enum.SeekFrom.html" title="enum std::io::SeekFrom">SeekFrom</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;pos: <a class="struct" href="../../csv/byte_record/struct.Position.html" title="struct csv::byte_record::Position">Position</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.unit.html">()</a>, <a class="struct" href="../../csv/error/struct.Error.html" title="struct csv::error::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>This is like <code>seek</code>, but provides direct control over how the seeking
operation is performed via <code>io::SeekFrom</code>.</p>
<p>The <code>pos</code> position given <em>should</em> correspond the position indicated
by <code>seek_from</code>, but there is no requirement. If the <code>pos</code> position
given is incorrect, then the position information returned by this
reader will be similarly incorrect.</p>
<p>If the header row has not already been read, then this will attempt
to read the header row before seeking. Therefore, it is possible that
this returns an error associated with reading CSV data.</p>
<p>Unlike <code>seek</code>, this will always cause an actual seek to be performed.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Debug" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#706">source</a></span><a href="#impl-Debug" class="anchor"></a><h3 class="code-header in-band">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Reader.html" title="struct prettytable::csv::Reader">Reader</a>&lt;R&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/csv/reader.rs.html#706">source</a></span><a href="#method.fmt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.63.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.63.0/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></details></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe" class="impl has-srclink"><a href="#impl-RefUnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Reader.html" title="struct prettytable::csv::Reader">Reader</a>&lt;R&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,&nbsp;</span></h3></section><section id="impl-Send" class="impl has-srclink"><a href="#impl-Send" class="anchor"></a><h3 class="code-header in-band">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Reader.html" title="struct prettytable::csv::Reader">Reader</a>&lt;R&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,&nbsp;</span></h3></section><section id="impl-Sync" class="impl has-srclink"><a href="#impl-Sync" class="anchor"></a><h3 class="code-header in-band">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Reader.html" title="struct prettytable::csv::Reader">Reader</a>&lt;R&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,&nbsp;</span></h3></section><section id="impl-Unpin" class="impl has-srclink"><a href="#impl-Unpin" class="anchor"></a><h3 class="code-header in-band">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Reader.html" title="struct prettytable::csv::Reader">Reader</a>&lt;R&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,&nbsp;</span></h3></section><section id="impl-UnwindSafe" class="impl has-srclink"><a href="#impl-UnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Reader.html" title="struct prettytable::csv::Reader">Reader</a>&lt;R&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,&nbsp;</span></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Any" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/any.rs.html#203-207">source</a></span><a href="#impl-Any" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/any.rs.html#204">source</a></span><a href="#method.type_id" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.63.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.63.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/borrow.rs.html#209-214">source</a></span><a href="#impl-Borrow%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/borrow.rs.html#211">source</a></span><a href="#method.borrow" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>T</h4></section></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/borrow.rs.html#218-222">source</a></span><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/borrow.rs.html#219">source</a></span><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-From%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/convert/mod.rs.html#557-562">source</a></span><a href="#impl-From%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/convert/mod.rs.html#559">source</a></span><a href="#method.from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/convert/mod.rs.html#541-552">source</a></span><a href="#impl-Into%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/convert/mod.rs.html#549">source</a></span><a href="#method.into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html" title="From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/convert/mod.rs.html#598-607">source</a></span><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/convert/mod.rs.html#604">source</a></span><a href="#method.try_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/convert/mod.rs.html#583-592">source</a></span><a href="#impl-TryInto%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/convert/mod.rs.html#589">source</a></span><a href="#method.try_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details></div></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="prettytable" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.63.0 (4b91a6ea7 2022-08-08)" ></div>
</body></html>