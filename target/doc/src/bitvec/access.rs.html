<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/Users/claymurphy/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.19.6/src/access.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>access.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../bitvec/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><div id="settings-menu" tabindex="-1">
                                <a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div>
                        </div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
</pre><pre class="rust"><code><span class="doccomment">/*! Memory access control.

`bitvec` allows a program to produce handles over memory that do not logically
alias, but may alias in hardware. This module provides a unified interface for
memory accesses that can be specialized to handle aliased and unaliased access
events.

The `BitAccess` trait provides capabilities to access bits in memory elements
through shared references, and its implementations are responsible for
coördinating synchronization and contention as needed.
!*/</span>

<span class="kw">use</span> <span class="kw">crate</span>::{
	<span class="ident">index</span>::{
		<span class="ident">BitIdx</span>,
		<span class="ident">BitMask</span>,
		<span class="ident">BitRegister</span>,
	},
	<span class="ident">order::BitOrder</span>,
};

<span class="kw">use</span> <span class="ident">core</span>::{
	<span class="ident">fmt::Debug</span>,
	<span class="ident">sync::atomic::Ordering</span>,
};

<span class="kw">use</span> <span class="ident">radium::Radium</span>;

<span class="doccomment">/** Access interface to memory locations.

This trait abstracts over the specific instructions used to perform accesses to
memory locations, so that use sites elsewhere in the crate can select their
required behavior without changing the interface.

This is automatically implemented for all types that permit shared/mutable
memory access to register types through the `radium` crate. Its use is
constrained in the `store` module.
**/</span>
<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">BitAccess</span>: <span class="ident">Debug</span> <span class="op">+</span> <span class="ident">Radium</span> <span class="op">+</span> <span class="ident">Sized</span>
<span class="kw">where</span> <span class="op">&lt;</span><span class="self">Self</span> <span class="kw">as</span> <span class="ident">Radium</span><span class="op">&gt;</span><span class="ident">::Item</span>: <span class="ident">BitRegister</span>
{
	<span class="doccomment">/// Sets one bit in a memory element to `0`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Type Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `O`: A bit ordering.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">/// - `index`: The semantic index of the bit in `*self` to be erased.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Effects</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The memory element at `*self` has the bit corresponding to `index` set</span>
	<span class="doccomment">/// to `0`, and all other bits are unchanged.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">fn</span> <span class="ident">clear_bit</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">index</span>: <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="self">Self</span> <span class="kw">as</span> <span class="ident">Radium</span><span class="op">&gt;</span><span class="ident">::Item</span><span class="op">&gt;</span>)
	<span class="kw">where</span> <span class="ident">O</span>: <span class="ident">BitOrder</span> {
		<span class="self">self</span>.<span class="ident">fetch_and</span>(<span class="op">!</span><span class="ident">index</span>.<span class="ident">select</span>::<span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>().<span class="ident">value</span>(), <span class="ident">Ordering::Relaxed</span>);
	}

	<span class="doccomment">/// Set any number of bits in a memory element to `0`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The mask provided to this method must be constructed from indices that</span>
	<span class="doccomment">/// are valid in the caller’s context. As the mask is already computed by</span>
	<span class="doccomment">/// the caller, this does not take an ordering type parameter.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">/// - `mask`: A mask of any number of bits. This is a selection mask of bits</span>
	<span class="doccomment">///   to modify.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Effects</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// All bits in `*self` that are selected (set to `1`) in `mask` will be set</span>
	<span class="doccomment">/// to `0`, and all bits in `*self` that are not selected (set to `0`) in</span>
	<span class="doccomment">/// `mask` will be unchanged.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Do not invert the mask prior to calling this function in order to save</span>
	<span class="doccomment">/// the unselected bits and erase the selected bits. `BitMask` is a</span>
	<span class="doccomment">/// selection type, not a bitwise-operation argument.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">fn</span> <span class="ident">clear_bits</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">mask</span>: <span class="ident">BitMask</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="self">Self</span> <span class="kw">as</span> <span class="ident">Radium</span><span class="op">&gt;</span><span class="ident">::Item</span><span class="op">&gt;</span>) {
		<span class="self">self</span>.<span class="ident">fetch_and</span>(<span class="op">!</span><span class="ident">mask</span>.<span class="ident">value</span>(), <span class="ident">Ordering::Relaxed</span>);
	}

	<span class="doccomment">/// Sets one bit in a memory element to `1`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Type Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `O`: A bit ordering.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">/// - `index`: The semantic index of the bit in `*self` to be written.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Effects</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The memory element at `*self` has the bit corresponding to `index` set</span>
	<span class="doccomment">/// to `1`, and all other bits are unchanged.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">fn</span> <span class="ident">set_bit</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">index</span>: <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="self">Self</span> <span class="kw">as</span> <span class="ident">Radium</span><span class="op">&gt;</span><span class="ident">::Item</span><span class="op">&gt;</span>)
	<span class="kw">where</span> <span class="ident">O</span>: <span class="ident">BitOrder</span> {
		<span class="self">self</span>.<span class="ident">fetch_or</span>(<span class="ident">index</span>.<span class="ident">select</span>::<span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>().<span class="ident">value</span>(), <span class="ident">Ordering::Relaxed</span>);
	}

	<span class="doccomment">/// Sets any number of bits in a memory element to `1`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The mask provided to this method must be constructed from indices that</span>
	<span class="doccomment">/// are valid in the caller’s context. As the mask is already computed by</span>
	<span class="doccomment">/// the caller, this does not need to take an ordering type parameter.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">/// - `mask`: A mask of any number of bits. This is a selection mask of bits</span>
	<span class="doccomment">///   to modify.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Effects</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// All bits in `*self` that are selected (set to `1`) in `mask` will be set</span>
	<span class="doccomment">/// to `1`, and all bits in `*self` that are not selected (set to `0`) in</span>
	<span class="doccomment">/// `mask` will be unchanged.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">fn</span> <span class="ident">set_bits</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">mask</span>: <span class="ident">BitMask</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="self">Self</span> <span class="kw">as</span> <span class="ident">Radium</span><span class="op">&gt;</span><span class="ident">::Item</span><span class="op">&gt;</span>) {
		<span class="self">self</span>.<span class="ident">fetch_or</span>(<span class="ident">mask</span>.<span class="ident">value</span>(), <span class="ident">Ordering::Relaxed</span>);
	}

	<span class="doccomment">/// Inverts the value of one bit in a memory element.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Type Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `O`: A bit ordering.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">/// - `index`: The semantic index of the bit in `*self` to be inverted.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Effects</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The memory element at `*self` has the bit corresponding to `index` set</span>
	<span class="doccomment">/// to the opposite of its current value. All other bits are unchanged.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">fn</span> <span class="ident">invert_bit</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">index</span>: <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="self">Self</span> <span class="kw">as</span> <span class="ident">Radium</span><span class="op">&gt;</span><span class="ident">::Item</span><span class="op">&gt;</span>)
	<span class="kw">where</span> <span class="ident">O</span>: <span class="ident">BitOrder</span> {
		<span class="self">self</span>.<span class="ident">fetch_xor</span>(<span class="ident">index</span>.<span class="ident">select</span>::<span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>().<span class="ident">value</span>(), <span class="ident">Ordering::Relaxed</span>);
	}

	<span class="doccomment">/// Invert any number of bits in a memory element.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The mask provided to this method must be constructed from indices that</span>
	<span class="doccomment">/// are valid in the caller’s context. As the mask is already computed by</span>
	<span class="doccomment">/// the caller, this does not take an ordering type parameter.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">/// - `mask`: A mask of any number of bits. This is a selection mask of bits</span>
	<span class="doccomment">///   to modify.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Effects</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// All bits in `*self` that are selected (set to `1`) in `mask` will be set</span>
	<span class="doccomment">/// to the opposite of their current value, and all bits in `*self` that are</span>
	<span class="doccomment">/// not selected (set to `0`) in `mask` will be unchanged.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">fn</span> <span class="ident">invert_bits</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">mask</span>: <span class="ident">BitMask</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="self">Self</span> <span class="kw">as</span> <span class="ident">Radium</span><span class="op">&gt;</span><span class="ident">::Item</span><span class="op">&gt;</span>) {
		<span class="self">self</span>.<span class="ident">fetch_xor</span>(<span class="ident">mask</span>.<span class="ident">value</span>(), <span class="ident">Ordering::Relaxed</span>);
	}

	<span class="doccomment">/// Writes a bit to an index within the `self` element.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Type Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `O`: A bit ordering.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">/// - `index`: The semantic index of the bit in `*self` to be written.</span>
	<span class="doccomment">/// - `value`: The bit value to write into `*self` at `index`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Effects</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The bit in `*self` at `index` is set to the `value` bit.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">fn</span> <span class="ident">write_bit</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">index</span>: <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="self">Self</span> <span class="kw">as</span> <span class="ident">Radium</span><span class="op">&gt;</span><span class="ident">::Item</span><span class="op">&gt;</span>, <span class="ident">value</span>: <span class="ident">bool</span>)
	<span class="kw">where</span> <span class="ident">O</span>: <span class="ident">BitOrder</span> {
		<span class="kw">if</span> <span class="ident">value</span> {
			<span class="self">self</span>.<span class="ident">set_bit</span>::<span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>(<span class="ident">index</span>);
		}
		<span class="kw">else</span> {
			<span class="self">self</span>.<span class="ident">clear_bit</span>::<span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>(<span class="ident">index</span>);
		}
	}

	<span class="doccomment">/// Writes a bit value to any number of bits within the `self` element.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The mask provided to this method must be constructed from indices that</span>
	<span class="doccomment">/// are valid in the caller’s context. As the mask is already computed by</span>
	<span class="doccomment">/// the caller, this does not need to take an ordering type parameter.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">/// - `mask`: A mask of any number of bits. This is a selection mask of bits</span>
	<span class="doccomment">///   to modify.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Effects</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// All bits in `*self` that are selected (set to `1`) in `mask` will be set</span>
	<span class="doccomment">/// to `value`, and all bits in `*self` that are not selected (set to `0`)</span>
	<span class="doccomment">/// in `mask` will be unchanged.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">fn</span> <span class="ident">write_bits</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">mask</span>: <span class="ident">BitMask</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="self">Self</span> <span class="kw">as</span> <span class="ident">Radium</span><span class="op">&gt;</span><span class="ident">::Item</span><span class="op">&gt;</span>, <span class="ident">value</span>: <span class="ident">bool</span>) {
		<span class="kw">if</span> <span class="ident">value</span> {
			<span class="self">self</span>.<span class="ident">set_bits</span>(<span class="ident">mask</span>);
		}
		<span class="kw">else</span> {
			<span class="self">self</span>.<span class="ident">clear_bits</span>(<span class="ident">mask</span>);
		}
	}

	<span class="doccomment">/// Gets the function that writes `value` to an index.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Type Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `O`: A bit ordering.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `value`: The bit that will be directly written by the returned</span>
	<span class="doccomment">///   function.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// A function which, when applied to a reference and an index, will write</span>
	<span class="doccomment">/// `value` into memory. If `value` is `false`, then this produces</span>
	<span class="doccomment">/// [`clear_bit`]; if it is `true`, then this produces [`set_bit`].</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`clear_bit`]: #method.clear_bit</span>
	<span class="doccomment">/// [`set_bit`]: #method.set_bit</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">fn</span> <span class="ident">get_writer</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>(
		<span class="ident">value</span>: <span class="ident">bool</span>,
	) -&gt; <span class="kw">for</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">fn</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="self">Self</span>, <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="self">Self</span> <span class="kw">as</span> <span class="ident">Radium</span><span class="op">&gt;</span><span class="ident">::Item</span><span class="op">&gt;</span>)
	<span class="kw">where</span> <span class="ident">O</span>: <span class="ident">BitOrder</span> {
		[<span class="ident"><span class="self">Self</span>::clear_bit</span>::<span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>, <span class="ident"><span class="self">Self</span>::set_bit</span>::<span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>][<span class="ident">value</span> <span class="kw">as</span> <span class="ident">usize</span>]
	}

	<span class="doccomment">/// Gets the function that writes `value` into all bits under a mask.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `value`: The bit that will be directly written by the returned</span>
	<span class="doccomment">///   function.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// A function which, when applied to a reference and a mask, will write</span>
	<span class="doccomment">/// `value` into memory. If `value` is `false`, then this produces</span>
	<span class="doccomment">/// [`clear_bits`]; if it is `true`, then this produces [`set_bits`].</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`clear_bits`]: #method.clear_bits</span>
	<span class="doccomment">/// [`set_bits`]: #method.set_bits</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">fn</span> <span class="ident">get_writers</span>(
		<span class="ident">value</span>: <span class="ident">bool</span>,
	) -&gt; <span class="kw">for</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">fn</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="self">Self</span>, <span class="ident">BitMask</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="self">Self</span> <span class="kw">as</span> <span class="ident">Radium</span><span class="op">&gt;</span><span class="ident">::Item</span><span class="op">&gt;</span>) {
		[<span class="ident"><span class="self">Self</span>::clear_bits</span>, <span class="ident"><span class="self">Self</span>::set_bits</span>][<span class="ident">value</span> <span class="kw">as</span> <span class="ident">usize</span>]
	}

	<span class="doccomment">/// Unconditionally writes a value into a memory location.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">/// - `value`: The new value to write into `*self`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Effects</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The current value at `*self` is replaced with `value`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Safety</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The calling context must either have write permissions to the entire</span>
	<span class="doccomment">/// memory element at `*self`, or construct a `value` that does not modify</span>
	<span class="doccomment">/// the bits of `*self` that the caller does not currently own.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// As this directly permits the modification of memory outside the logical</span>
	<span class="doccomment">/// ownership of the caller, this method risks behavior that violates the</span>
	<span class="doccomment">/// Rust memory model, even if it may not be technically undefined.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">store_value</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">value</span>: <span class="op">&lt;</span><span class="self">Self</span> <span class="kw">as</span> <span class="ident">Radium</span><span class="op">&gt;</span><span class="ident">::Item</span>) {
		<span class="self">self</span>.<span class="ident">store</span>(<span class="ident">value</span>, <span class="ident">Ordering::Relaxed</span>)
	}
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">A</span><span class="op">&gt;</span> <span class="ident">BitAccess</span> <span class="kw">for</span> <span class="ident">A</span>
<span class="kw">where</span>
	<span class="ident">A</span>: <span class="ident">Debug</span> <span class="op">+</span> <span class="ident">Radium</span>,
	<span class="op">&lt;</span><span class="self">Self</span> <span class="kw">as</span> <span class="ident">Radium</span><span class="op">&gt;</span><span class="ident">::Item</span>: <span class="ident">BitRegister</span>,
{
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">test</span>)]</span>
<span class="kw">mod</span> <span class="ident">tests</span> {
	<span class="kw">use</span> <span class="kw">super</span>::<span class="kw-2">*</span>;
	<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::prelude</span>::<span class="kw-2">*</span>;

	<span class="attribute">#[<span class="ident">test</span>]</span>
	<span class="kw">fn</span> <span class="ident">touch_memory</span>() {
		<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
		<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span><span class="op">&gt;</span>();
		<span class="kw">let</span> <span class="ident">accessor</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="kw-2">&amp;</span><span class="kw-2">*</span>(<span class="ident">bits</span>.<span class="ident">bitptr</span>().<span class="ident">pointer</span>().<span class="ident">to_access</span>()) };

		<span class="ident">BitAccess::set_bit</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>(<span class="ident">accessor</span>, <span class="ident">BitIdx::ZERO</span>);
		<span class="macro">assert_eq!</span>(<span class="ident">accessor</span>.<span class="ident">get</span>(), <span class="number">1</span>);

		<span class="ident">BitAccess::set_bits</span>(<span class="ident">accessor</span>, <span class="ident">BitMask::ALL</span>);
		<span class="macro">assert_eq!</span>(<span class="ident">accessor</span>.<span class="ident">get</span>(), <span class="op">!</span><span class="number">0</span>);

		<span class="ident">BitAccess::clear_bit</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>(<span class="ident">accessor</span>, <span class="ident">BitIdx::ZERO</span>);
		<span class="macro">assert_eq!</span>(<span class="ident">accessor</span>.<span class="ident">get</span>(), <span class="op">!</span><span class="number">1</span>);

		<span class="ident">BitAccess::clear_bits</span>(<span class="ident">accessor</span>, <span class="ident">BitMask::ALL</span>);
		<span class="macro">assert_eq!</span>(<span class="ident">accessor</span>.<span class="ident">get</span>(), <span class="number">0</span>);

		<span class="ident">BitAccess::invert_bit</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>(<span class="ident">accessor</span>, <span class="ident">BitIdx::ZERO</span>);
		<span class="macro">assert_eq!</span>(<span class="ident">accessor</span>.<span class="ident">get</span>(), <span class="number">1</span>);
		<span class="ident">BitAccess::invert_bits</span>(<span class="ident">accessor</span>, <span class="ident">BitMask::ALL</span>);
		<span class="macro">assert_eq!</span>(<span class="ident">accessor</span>.<span class="ident">get</span>(), <span class="op">!</span><span class="number">1</span>);

		<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">BitStore::get_bit</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>(<span class="ident">accessor</span>, <span class="ident">BitIdx::ZERO</span>));
		<span class="macro">assert_eq!</span>(<span class="ident">accessor</span>.<span class="ident">get</span>(), <span class="op">!</span><span class="number">1</span>);

		<span class="ident">BitAccess::write_bit</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>(<span class="ident">accessor</span>, <span class="ident">BitIdx::new</span>(<span class="number">1</span>).<span class="ident">unwrap</span>(), <span class="bool-val">false</span>);
		<span class="macro">assert_eq!</span>(<span class="ident">accessor</span>.<span class="ident">get</span>(), <span class="op">!</span><span class="number">3</span>);

		<span class="ident">BitAccess::write_bits</span>(<span class="ident">accessor</span>, <span class="ident">BitMask::ALL</span>, <span class="bool-val">true</span>);
		<span class="macro">assert_eq!</span>(<span class="ident">accessor</span>.<span class="ident">get</span>(), <span class="op">!</span><span class="number">0</span>);
		<span class="ident">BitAccess::write_bits</span>(<span class="ident">accessor</span>, <span class="ident">Lsb0::mask</span>(<span class="ident">BitIdx::new</span>(<span class="number">2</span>), <span class="prelude-val">None</span>), <span class="bool-val">false</span>);
		<span class="macro">assert_eq!</span>(
			<span class="ident">BitStore::get_bits</span>(<span class="ident">accessor</span>, <span class="ident">Lsb0::mask</span>(<span class="ident">BitIdx::new</span>(<span class="number">2</span>), <span class="prelude-val">None</span>)),
			<span class="number">0</span>
		);
		<span class="macro">assert_eq!</span>(<span class="ident">accessor</span>.<span class="ident">get</span>(), <span class="number">3</span>);

		<span class="ident">BitAccess::get_writer</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>(<span class="bool-val">false</span>)(<span class="ident">accessor</span>, <span class="ident">BitIdx::ZERO</span>);
		<span class="macro">assert_eq!</span>(<span class="ident">accessor</span>.<span class="ident">get</span>(), <span class="number">2</span>);

		<span class="kw">unsafe</span> {
			<span class="ident">BitAccess::store_value</span>(<span class="ident">accessor</span>, <span class="op">!</span><span class="number">1</span>);
		}
		<span class="macro">assert_eq!</span>(<span class="ident">accessor</span>.<span class="ident">get</span>(), <span class="op">!</span><span class="number">1</span>);
	}

	<span class="attribute">#[<span class="ident">test</span>]</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">miri</span>))]</span>
	<span class="kw">fn</span> <span class="ident">sanity_check_prefetch</span>() {
		<span class="kw">use</span> <span class="ident">core::cell::Cell</span>;

		<span class="macro">assert_eq!</span>(
			<span class="op">&lt;</span><span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="ident">BitAccess</span><span class="op">&gt;</span><span class="ident">::get_writer</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>(<span class="bool-val">false</span>) <span class="kw">as</span> <span class="kw-2">*const</span> (),
			<span class="op">&lt;</span><span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="ident">BitAccess</span><span class="op">&gt;</span><span class="ident">::clear_bit</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="kw-2">*const</span> ()
		);

		<span class="macro">assert_eq!</span>(
			<span class="op">&lt;</span><span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="ident">BitAccess</span><span class="op">&gt;</span><span class="ident">::get_writer</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>(<span class="bool-val">true</span>) <span class="kw">as</span> <span class="kw-2">*const</span> (),
			<span class="op">&lt;</span><span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="ident">BitAccess</span><span class="op">&gt;</span><span class="ident">::set_bit</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="kw-2">*const</span> ()
		);

		<span class="macro">assert_eq!</span>(
			<span class="op">&lt;</span><span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="ident">BitAccess</span><span class="op">&gt;</span><span class="ident">::get_writers</span>(<span class="bool-val">false</span>) <span class="kw">as</span> <span class="kw-2">*const</span> (),
			<span class="op">&lt;</span><span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="ident">BitAccess</span><span class="op">&gt;</span><span class="ident">::clear_bits</span> <span class="kw">as</span> <span class="kw-2">*const</span> ()
		);

		<span class="macro">assert_eq!</span>(
			<span class="op">&lt;</span><span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="ident">BitAccess</span><span class="op">&gt;</span><span class="ident">::get_writers</span>(<span class="bool-val">true</span>) <span class="kw">as</span> <span class="kw-2">*const</span> (),
			<span class="op">&lt;</span><span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="ident">BitAccess</span><span class="op">&gt;</span><span class="ident">::set_bits</span> <span class="kw">as</span> <span class="kw-2">*const</span> ()
		);
	}
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="bitvec" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.63.0 (4b91a6ea7 2022-08-08)" ></div>
</body></html>