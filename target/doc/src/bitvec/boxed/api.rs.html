<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/Users/claymurphy/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.19.6/src/boxed/api.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>api.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script defer src="../../../source-script.js"></script><script defer src="../../../source-files.js"></script><script defer src="../../../main.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div>
        </a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../bitvec/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><div id="settings-menu" tabindex="-1">
                                <a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div>
                        </div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
</pre><pre class="rust"><code><span class="doccomment">//! Port of the `Box&lt;[T]&gt;` function API.</span>

<span class="kw">use</span> <span class="kw">crate</span>::{
	<span class="ident">boxed::BitBox</span>,
	<span class="ident">order::BitOrder</span>,
	<span class="ident">pointer::BitPtr</span>,
	<span class="ident">slice::BitSlice</span>,
	<span class="ident">store::BitStore</span>,
	<span class="ident">vec::BitVec</span>,
};

<span class="kw">use</span> <span class="ident">core</span>::{
	<span class="ident">marker::Unpin</span>,
	<span class="ident">mem::ManuallyDrop</span>,
	<span class="ident">pin::Pin</span>,
};

<span class="kw">use</span> <span class="ident">tap::pipe::Pipe</span>;

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span> <span class="ident">BitBox</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
	<span class="ident">O</span>: <span class="ident">BitOrder</span>,
	<span class="ident">T</span>: <span class="ident">BitStore</span>,
{
	<span class="doccomment">/// Allocates memory on the heap and copies `x` into it.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This doesn’t actually allocate if `x` is zero-length.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Original</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`Box::new`](https://doc.rust-lang.org/alloc/boxed/struct.Box.html#method.new)</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # API Differences</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// `Box::&lt;[T]&gt;::new` does not exist, because `new` cannot take unsized</span>
	<span class="doccomment">/// types by value. Instead, this takes a slice reference, and boxes the</span>
	<span class="doccomment">/// referent slice.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let boxed = BitBox::new(bits![0; 5]);</span>
	<span class="doccomment">/// ```</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
	<span class="attribute">#[<span class="ident">deprecated</span>(<span class="ident">since</span> <span class="op">=</span> <span class="string">&quot;0.18.0&quot;</span>, <span class="ident">note</span> <span class="op">=</span> <span class="string">&quot;Prefer `::from_bitslice`&quot;</span>)]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>) -&gt; <span class="self">Self</span> {
		<span class="ident"><span class="self">Self</span>::from_bitslice</span>(<span class="ident">x</span>)
	}

	<span class="doccomment">/// Constructs a new `Pin&lt;BitBox&lt;O, T&gt;&gt;`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// `BitSlice` is always `Unpin`, so this has no actual immobility effect.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Original</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`Box::pin`](https://doc.rust-lang.org/alloc/boxed/struct.Box.html#method.pin)</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # API Differences</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// As with `::new`, this only exists on `Box` when `T` is not unsized. This</span>
	<span class="doccomment">/// takes a slice reference, and pins the referent slice.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">pin</span>(<span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>) -&gt; <span class="ident">Pin</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span>
	<span class="kw">where</span>
		<span class="ident">O</span>: <span class="ident">Unpin</span>,
		<span class="ident">T</span>: <span class="ident">Unpin</span>,
	{
		<span class="ident">x</span>.<span class="ident">pipe</span>(<span class="ident"><span class="self">Self</span>::from_bitslice</span>).<span class="ident">pipe</span>(<span class="ident">Pin::new</span>)
	}

	<span class="doccomment">/// Constructs a box from a raw pointer.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// After calling this function, the raw pointer is owned by the</span>
	<span class="doccomment">/// resulting `BitBox`. Specifically, the `Box` destructor will free the</span>
	<span class="doccomment">/// allocated memory. For this to be safe, the memory must have been</span>
	<span class="doccomment">/// allocated in accordance with the [memory layout] used by `BitBox`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Original</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`Box::from_raw`](https://doc.rust-lang.org/alloc/boxed/struct.Box.html#method.from_raw)</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Safety</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This function is unsafe because improper use may lead to</span>
	<span class="doccomment">/// memory problems. For example, a double-free may occur if the</span>
	<span class="doccomment">/// function is called twice on the same raw pointer.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Recreate a `BitBox` which was previously converted to a raw pointer</span>
	<span class="doccomment">/// using [`BitBox::into_raw`]:</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let x = bitbox![0; 10];</span>
	<span class="doccomment">/// let ptr = BitBox::into_raw(x);</span>
	<span class="doccomment">/// let x = unsafe { BitBox::from_raw(ptr) };</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [memory layout]: https://doc.rust-lang.org/alloc/boxed/index.html#memory-layout</span>
	<span class="doccomment">/// [`Layout`]: https://doc.rust-lang.org/alloc/struct.Layout.html</span>
	<span class="doccomment">/// [`BitBox::into_raw`]: #method.into_raw</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">from_raw</span>(<span class="ident">raw</span>: <span class="kw-2">*mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>) -&gt; <span class="self">Self</span> {
		<span class="ident">raw</span>.<span class="ident">pipe</span>(<span class="ident">BitPtr::from_bitslice_ptr_mut</span>)
			.<span class="ident">to_nonnull</span>()
			.<span class="ident">pipe</span>(<span class="op">|</span><span class="ident">pointer</span><span class="op">|</span> <span class="self">Self</span> { <span class="ident">pointer</span> })
	}

	<span class="doccomment">/// Consumes the `BitBox`, returning a wrapped raw pointer.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The pointer will be properly aligned and non-null.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// After calling this function, the caller is responsible for the memory</span>
	<span class="doccomment">/// previously managed by the `BitBox`. In particular, the caller should</span>
	<span class="doccomment">/// properly release the memory by converting the pointer back into a</span>
	<span class="doccomment">/// `BitBox` with the [`BitBox::from_raw`] function, allowing the `BitBox`</span>
	<span class="doccomment">/// destructor to perform the cleanup.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Note: this is an associated function, which means that you have to call</span>
	<span class="doccomment">/// it as `BitBox::into_raw(b)` instead of `b.into_raw()`. This is to match</span>
	<span class="doccomment">/// layout with the standard library’s `Box` API; there will never be a name</span>
	<span class="doccomment">/// conflict with `BitSlice`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Original</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`Box::into_raw`](https://doc.rust-lang.org/alloc/boxed/struct.Box.html#method.into_raw)</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Converting the raw pointer back into a `BitBox` with</span>
	<span class="doccomment">/// [`BitBox::from_raw`] for automatic cleanup:</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let b = BitBox::new(bits![Msb0, u32; 0; 32]);</span>
	<span class="doccomment">/// let ptr = BitBox::into_raw(b);</span>
	<span class="doccomment">/// let b = unsafe { BitBox::from_raw(ptr) };</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`BitBox::from_raw`]: #method.from_raw</span>
	<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">not</span>(<span class="ident">tarpaulin</span>), <span class="ident">inline</span>(<span class="ident">always</span>))]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">into_raw</span>(<span class="ident">b</span>: <span class="self">Self</span>) -&gt; <span class="kw-2">*mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span> {
		<span class="ident"><span class="self">Self</span>::leak</span>(<span class="ident">b</span>)
	}

	<span class="doccomment">/// Consumes and leaks the `BitBox`, returning a mutable reference,</span>
	<span class="doccomment">/// `&amp;&#39;a mut BitSlice&lt;O, T&gt;`. Note that the memory region `[T]` must outlive</span>
	<span class="doccomment">/// the chosen lifetime `&#39;a`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This function is mainly useful for bit regions that live for the</span>
	<span class="doccomment">/// remainder of the program’s life. Dropping the returned reference will</span>
	<span class="doccomment">/// cause a memory leak. If this is not acceptable, the reference should</span>
	<span class="doccomment">/// first be wrapped with the [`BitBox::from_raw`] function, producing a</span>
	<span class="doccomment">/// `BitBox`. This `BitBox` can then be dropped which will properly</span>
	<span class="doccomment">/// deallocate the memory.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Note: this is an associated function, which means that you have to call</span>
	<span class="doccomment">/// it as `BitBox::leak(b)` instead of `b.leak()`. This is to match layout</span>
	<span class="doccomment">/// with the standard library’s `Box` API; there will never be a name</span>
	<span class="doccomment">/// conflict with `BitSlice`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Original</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`Box::leak`](https://doc.rust-lang.org/alloc/boxed/struct.Box.html#method.leak)</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Simple usage:</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let b = bitbox![LocalBits, u32; 0; 32];</span>
	<span class="doccomment">/// let static_ref: &amp;&#39;static mut BitSlice&lt;LocalBits, u32&gt; = BitBox::leak(b);</span>
	<span class="doccomment">/// static_ref.set(0, true);</span>
	<span class="doccomment">/// assert_eq!(static_ref.count_ones(), 1);</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`BitBox::from_raw`]: #method.from_raw</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">leak</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>(<span class="ident">b</span>: <span class="self">Self</span>) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="kw-2">mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>
	<span class="kw">where</span> <span class="ident">T</span>: <span class="lifetime">&#39;a</span> {
		<span class="ident">b</span>.<span class="ident">pipe</span>(<span class="ident">ManuallyDrop::new</span>).<span class="ident">bitptr</span>().<span class="ident">to_bitslice_mut</span>()
	}

	<span class="doccomment">/// Converts `self` into a vector without clones or allocation.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The resulting vector can be converted back into a box via `BitVec&lt;O,</span>
	<span class="doccomment">/// T&gt;`’s `into_boxed_bitslice` method.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Original</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`slice::into_vec`](https://doc.rust-lang.org/std/primitive.slice.html#method.into_vec)</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # API Differences</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Despite taking a `Box&lt;[T]&gt;` receiver, this function is written in an</span>
	<span class="doccomment">/// `impl&lt;T&gt; [T]` block.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Rust does not allow the text</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust,ignore</span>
	<span class="doccomment">/// impl&lt;O, T&gt; BitSlice&lt;O, T&gt; {</span>
	<span class="doccomment">///   fn into_bitvec(self: BitBox&lt;O, T&gt;);</span>
	<span class="doccomment">/// }</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// to be written, and `BitBox` exists specifically because</span>
	<span class="doccomment">/// `Box&lt;BitSlice&lt;&gt;&gt;` cannot be written either, so this function must be</span>
	<span class="doccomment">/// implemented directly on `BitBox` rather than on `BitSlice` with a boxed</span>
	<span class="doccomment">/// receiver.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let bb = bitbox![0, 1, 0, 1];</span>
	<span class="doccomment">/// let bv = bb.into_bitvec();</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// assert_eq!(bv, bitvec![0, 1, 0, 1]);</span>
	<span class="doccomment">/// ```</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">into_bitvec</span>(<span class="self">self</span>) -&gt; <span class="ident">BitVec</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span> {
		<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bitptr</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">bitptr</span>();
		<span class="kw">let</span> <span class="ident">raw</span> <span class="op">=</span> <span class="self">self</span>
			<span class="comment">//  Disarm the `self` destructor</span>
			.<span class="ident">pipe</span>(<span class="ident">ManuallyDrop::new</span>)
			<span class="comment">//  Extract the `Box&lt;[T]&gt;` handle, invalidating `self`</span>
			.<span class="ident">with_box</span>(<span class="op">|</span><span class="ident">b</span><span class="op">|</span> <span class="kw">unsafe</span> { <span class="ident">ManuallyDrop::take</span>(<span class="ident">b</span>) })
			<span class="comment">//  The distribution guarantees this to be correct and in-place.</span>
			.<span class="ident">into_vec</span>()
			<span class="comment">//  Disarm the `Vec&lt;T&gt;` destructor *also*.</span>
			.<span class="ident">pipe</span>(<span class="ident">ManuallyDrop::new</span>);
		<span class="comment">/* The distribution claims that `[T]::into_vec(Box&lt;[T]&gt;) -&gt; Vec&lt;T&gt;` does
		not alter the address of the heap allocation, and only modifies the
		buffer handle. Nevertheless, update the bit-pointer with the address of
		the vector as returned by this transformation Just In Case.

		Inspection of the distribution’s implementation shows that the
		conversion from `(buf, len)` to `(buf, cap, len)` is done by using the
		slice length as the buffer capacity. However, this is *not* a behavior
		guaranteed by the distribution, and so the pipeline above must remain in
		place in the event that this behavior ever changes. It should compile
		away to nothing, as it is almost entirely typesystem manipulation.
		*/</span>
		<span class="kw">unsafe</span> {
			<span class="ident">bitptr</span>.<span class="ident">set_pointer</span>(<span class="ident">raw</span>.<span class="ident">as_ptr</span>() <span class="kw">as</span> <span class="kw-2">*const</span> <span class="ident">T</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">T</span>);
			<span class="ident">BitVec::from_raw_parts</span>(<span class="ident">bitptr</span>.<span class="ident">to_bitslice_ptr_mut</span>(), <span class="ident">raw</span>.<span class="ident">capacity</span>())
		}
	}
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="bitvec" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.63.0 (4b91a6ea7 2022-08-08)" ></div>
</body></html>