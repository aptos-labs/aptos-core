<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/Users/claymurphy/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.19.6/src/pointer.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>pointer.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../bitvec/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><div id="settings-menu" tabindex="-1">
                                <a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div>
                        </div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
<span id="558">558</span>
<span id="559">559</span>
<span id="560">560</span>
<span id="561">561</span>
<span id="562">562</span>
<span id="563">563</span>
<span id="564">564</span>
<span id="565">565</span>
<span id="566">566</span>
<span id="567">567</span>
<span id="568">568</span>
<span id="569">569</span>
<span id="570">570</span>
<span id="571">571</span>
<span id="572">572</span>
<span id="573">573</span>
<span id="574">574</span>
<span id="575">575</span>
<span id="576">576</span>
<span id="577">577</span>
<span id="578">578</span>
<span id="579">579</span>
<span id="580">580</span>
<span id="581">581</span>
<span id="582">582</span>
<span id="583">583</span>
<span id="584">584</span>
<span id="585">585</span>
<span id="586">586</span>
<span id="587">587</span>
<span id="588">588</span>
<span id="589">589</span>
<span id="590">590</span>
<span id="591">591</span>
<span id="592">592</span>
<span id="593">593</span>
<span id="594">594</span>
<span id="595">595</span>
<span id="596">596</span>
<span id="597">597</span>
<span id="598">598</span>
<span id="599">599</span>
<span id="600">600</span>
<span id="601">601</span>
<span id="602">602</span>
<span id="603">603</span>
<span id="604">604</span>
<span id="605">605</span>
<span id="606">606</span>
<span id="607">607</span>
<span id="608">608</span>
<span id="609">609</span>
<span id="610">610</span>
<span id="611">611</span>
<span id="612">612</span>
<span id="613">613</span>
<span id="614">614</span>
<span id="615">615</span>
<span id="616">616</span>
<span id="617">617</span>
<span id="618">618</span>
<span id="619">619</span>
<span id="620">620</span>
<span id="621">621</span>
<span id="622">622</span>
<span id="623">623</span>
<span id="624">624</span>
<span id="625">625</span>
<span id="626">626</span>
<span id="627">627</span>
<span id="628">628</span>
<span id="629">629</span>
<span id="630">630</span>
<span id="631">631</span>
<span id="632">632</span>
<span id="633">633</span>
<span id="634">634</span>
<span id="635">635</span>
<span id="636">636</span>
<span id="637">637</span>
<span id="638">638</span>
<span id="639">639</span>
<span id="640">640</span>
<span id="641">641</span>
<span id="642">642</span>
<span id="643">643</span>
<span id="644">644</span>
<span id="645">645</span>
<span id="646">646</span>
<span id="647">647</span>
<span id="648">648</span>
<span id="649">649</span>
<span id="650">650</span>
<span id="651">651</span>
<span id="652">652</span>
<span id="653">653</span>
<span id="654">654</span>
<span id="655">655</span>
<span id="656">656</span>
<span id="657">657</span>
<span id="658">658</span>
<span id="659">659</span>
<span id="660">660</span>
<span id="661">661</span>
<span id="662">662</span>
<span id="663">663</span>
<span id="664">664</span>
<span id="665">665</span>
<span id="666">666</span>
<span id="667">667</span>
<span id="668">668</span>
<span id="669">669</span>
<span id="670">670</span>
<span id="671">671</span>
<span id="672">672</span>
<span id="673">673</span>
<span id="674">674</span>
<span id="675">675</span>
<span id="676">676</span>
<span id="677">677</span>
<span id="678">678</span>
<span id="679">679</span>
<span id="680">680</span>
<span id="681">681</span>
<span id="682">682</span>
<span id="683">683</span>
<span id="684">684</span>
<span id="685">685</span>
<span id="686">686</span>
<span id="687">687</span>
<span id="688">688</span>
<span id="689">689</span>
<span id="690">690</span>
<span id="691">691</span>
<span id="692">692</span>
<span id="693">693</span>
<span id="694">694</span>
<span id="695">695</span>
<span id="696">696</span>
<span id="697">697</span>
<span id="698">698</span>
<span id="699">699</span>
<span id="700">700</span>
<span id="701">701</span>
<span id="702">702</span>
<span id="703">703</span>
<span id="704">704</span>
<span id="705">705</span>
<span id="706">706</span>
<span id="707">707</span>
<span id="708">708</span>
<span id="709">709</span>
<span id="710">710</span>
<span id="711">711</span>
<span id="712">712</span>
<span id="713">713</span>
<span id="714">714</span>
<span id="715">715</span>
<span id="716">716</span>
<span id="717">717</span>
<span id="718">718</span>
<span id="719">719</span>
<span id="720">720</span>
<span id="721">721</span>
<span id="722">722</span>
<span id="723">723</span>
<span id="724">724</span>
<span id="725">725</span>
<span id="726">726</span>
<span id="727">727</span>
<span id="728">728</span>
<span id="729">729</span>
<span id="730">730</span>
<span id="731">731</span>
<span id="732">732</span>
<span id="733">733</span>
<span id="734">734</span>
<span id="735">735</span>
<span id="736">736</span>
<span id="737">737</span>
<span id="738">738</span>
<span id="739">739</span>
<span id="740">740</span>
<span id="741">741</span>
<span id="742">742</span>
<span id="743">743</span>
<span id="744">744</span>
<span id="745">745</span>
<span id="746">746</span>
<span id="747">747</span>
<span id="748">748</span>
<span id="749">749</span>
<span id="750">750</span>
<span id="751">751</span>
<span id="752">752</span>
<span id="753">753</span>
<span id="754">754</span>
<span id="755">755</span>
<span id="756">756</span>
<span id="757">757</span>
<span id="758">758</span>
<span id="759">759</span>
<span id="760">760</span>
<span id="761">761</span>
<span id="762">762</span>
<span id="763">763</span>
<span id="764">764</span>
<span id="765">765</span>
<span id="766">766</span>
<span id="767">767</span>
<span id="768">768</span>
<span id="769">769</span>
<span id="770">770</span>
<span id="771">771</span>
<span id="772">772</span>
<span id="773">773</span>
<span id="774">774</span>
<span id="775">775</span>
<span id="776">776</span>
<span id="777">777</span>
<span id="778">778</span>
<span id="779">779</span>
<span id="780">780</span>
<span id="781">781</span>
<span id="782">782</span>
<span id="783">783</span>
<span id="784">784</span>
<span id="785">785</span>
<span id="786">786</span>
<span id="787">787</span>
<span id="788">788</span>
<span id="789">789</span>
<span id="790">790</span>
<span id="791">791</span>
<span id="792">792</span>
<span id="793">793</span>
<span id="794">794</span>
<span id="795">795</span>
<span id="796">796</span>
<span id="797">797</span>
<span id="798">798</span>
<span id="799">799</span>
<span id="800">800</span>
<span id="801">801</span>
<span id="802">802</span>
<span id="803">803</span>
<span id="804">804</span>
<span id="805">805</span>
<span id="806">806</span>
<span id="807">807</span>
<span id="808">808</span>
<span id="809">809</span>
<span id="810">810</span>
<span id="811">811</span>
<span id="812">812</span>
<span id="813">813</span>
<span id="814">814</span>
<span id="815">815</span>
<span id="816">816</span>
<span id="817">817</span>
<span id="818">818</span>
<span id="819">819</span>
<span id="820">820</span>
<span id="821">821</span>
<span id="822">822</span>
<span id="823">823</span>
<span id="824">824</span>
<span id="825">825</span>
<span id="826">826</span>
<span id="827">827</span>
<span id="828">828</span>
<span id="829">829</span>
<span id="830">830</span>
<span id="831">831</span>
<span id="832">832</span>
<span id="833">833</span>
<span id="834">834</span>
<span id="835">835</span>
<span id="836">836</span>
<span id="837">837</span>
<span id="838">838</span>
<span id="839">839</span>
<span id="840">840</span>
<span id="841">841</span>
<span id="842">842</span>
<span id="843">843</span>
<span id="844">844</span>
<span id="845">845</span>
<span id="846">846</span>
<span id="847">847</span>
<span id="848">848</span>
<span id="849">849</span>
<span id="850">850</span>
<span id="851">851</span>
<span id="852">852</span>
<span id="853">853</span>
<span id="854">854</span>
<span id="855">855</span>
<span id="856">856</span>
<span id="857">857</span>
<span id="858">858</span>
<span id="859">859</span>
<span id="860">860</span>
<span id="861">861</span>
<span id="862">862</span>
<span id="863">863</span>
<span id="864">864</span>
<span id="865">865</span>
<span id="866">866</span>
<span id="867">867</span>
<span id="868">868</span>
<span id="869">869</span>
<span id="870">870</span>
<span id="871">871</span>
<span id="872">872</span>
<span id="873">873</span>
<span id="874">874</span>
<span id="875">875</span>
<span id="876">876</span>
<span id="877">877</span>
<span id="878">878</span>
<span id="879">879</span>
<span id="880">880</span>
<span id="881">881</span>
<span id="882">882</span>
<span id="883">883</span>
<span id="884">884</span>
<span id="885">885</span>
<span id="886">886</span>
<span id="887">887</span>
<span id="888">888</span>
<span id="889">889</span>
<span id="890">890</span>
<span id="891">891</span>
<span id="892">892</span>
<span id="893">893</span>
<span id="894">894</span>
<span id="895">895</span>
<span id="896">896</span>
<span id="897">897</span>
<span id="898">898</span>
<span id="899">899</span>
<span id="900">900</span>
<span id="901">901</span>
<span id="902">902</span>
<span id="903">903</span>
<span id="904">904</span>
<span id="905">905</span>
<span id="906">906</span>
<span id="907">907</span>
<span id="908">908</span>
<span id="909">909</span>
<span id="910">910</span>
<span id="911">911</span>
<span id="912">912</span>
<span id="913">913</span>
<span id="914">914</span>
<span id="915">915</span>
<span id="916">916</span>
<span id="917">917</span>
<span id="918">918</span>
<span id="919">919</span>
<span id="920">920</span>
<span id="921">921</span>
<span id="922">922</span>
<span id="923">923</span>
<span id="924">924</span>
<span id="925">925</span>
<span id="926">926</span>
<span id="927">927</span>
<span id="928">928</span>
<span id="929">929</span>
<span id="930">930</span>
<span id="931">931</span>
<span id="932">932</span>
<span id="933">933</span>
<span id="934">934</span>
<span id="935">935</span>
<span id="936">936</span>
<span id="937">937</span>
<span id="938">938</span>
<span id="939">939</span>
<span id="940">940</span>
<span id="941">941</span>
<span id="942">942</span>
<span id="943">943</span>
<span id="944">944</span>
<span id="945">945</span>
<span id="946">946</span>
<span id="947">947</span>
<span id="948">948</span>
<span id="949">949</span>
<span id="950">950</span>
<span id="951">951</span>
<span id="952">952</span>
<span id="953">953</span>
<span id="954">954</span>
<span id="955">955</span>
<span id="956">956</span>
<span id="957">957</span>
<span id="958">958</span>
<span id="959">959</span>
<span id="960">960</span>
<span id="961">961</span>
<span id="962">962</span>
<span id="963">963</span>
<span id="964">964</span>
<span id="965">965</span>
<span id="966">966</span>
<span id="967">967</span>
<span id="968">968</span>
<span id="969">969</span>
<span id="970">970</span>
<span id="971">971</span>
<span id="972">972</span>
<span id="973">973</span>
<span id="974">974</span>
<span id="975">975</span>
<span id="976">976</span>
<span id="977">977</span>
<span id="978">978</span>
<span id="979">979</span>
<span id="980">980</span>
<span id="981">981</span>
<span id="982">982</span>
<span id="983">983</span>
<span id="984">984</span>
<span id="985">985</span>
<span id="986">986</span>
<span id="987">987</span>
<span id="988">988</span>
<span id="989">989</span>
<span id="990">990</span>
<span id="991">991</span>
<span id="992">992</span>
<span id="993">993</span>
<span id="994">994</span>
<span id="995">995</span>
<span id="996">996</span>
<span id="997">997</span>
<span id="998">998</span>
<span id="999">999</span>
<span id="1000">1000</span>
<span id="1001">1001</span>
<span id="1002">1002</span>
<span id="1003">1003</span>
<span id="1004">1004</span>
<span id="1005">1005</span>
<span id="1006">1006</span>
<span id="1007">1007</span>
<span id="1008">1008</span>
<span id="1009">1009</span>
<span id="1010">1010</span>
<span id="1011">1011</span>
<span id="1012">1012</span>
<span id="1013">1013</span>
<span id="1014">1014</span>
<span id="1015">1015</span>
<span id="1016">1016</span>
<span id="1017">1017</span>
<span id="1018">1018</span>
<span id="1019">1019</span>
<span id="1020">1020</span>
<span id="1021">1021</span>
<span id="1022">1022</span>
<span id="1023">1023</span>
<span id="1024">1024</span>
<span id="1025">1025</span>
<span id="1026">1026</span>
<span id="1027">1027</span>
<span id="1028">1028</span>
<span id="1029">1029</span>
<span id="1030">1030</span>
<span id="1031">1031</span>
<span id="1032">1032</span>
<span id="1033">1033</span>
<span id="1034">1034</span>
<span id="1035">1035</span>
<span id="1036">1036</span>
<span id="1037">1037</span>
<span id="1038">1038</span>
<span id="1039">1039</span>
<span id="1040">1040</span>
<span id="1041">1041</span>
<span id="1042">1042</span>
<span id="1043">1043</span>
<span id="1044">1044</span>
<span id="1045">1045</span>
<span id="1046">1046</span>
<span id="1047">1047</span>
<span id="1048">1048</span>
<span id="1049">1049</span>
<span id="1050">1050</span>
<span id="1051">1051</span>
<span id="1052">1052</span>
<span id="1053">1053</span>
<span id="1054">1054</span>
<span id="1055">1055</span>
<span id="1056">1056</span>
<span id="1057">1057</span>
<span id="1058">1058</span>
<span id="1059">1059</span>
<span id="1060">1060</span>
<span id="1061">1061</span>
<span id="1062">1062</span>
<span id="1063">1063</span>
<span id="1064">1064</span>
<span id="1065">1065</span>
<span id="1066">1066</span>
<span id="1067">1067</span>
<span id="1068">1068</span>
<span id="1069">1069</span>
<span id="1070">1070</span>
<span id="1071">1071</span>
<span id="1072">1072</span>
<span id="1073">1073</span>
<span id="1074">1074</span>
<span id="1075">1075</span>
<span id="1076">1076</span>
<span id="1077">1077</span>
<span id="1078">1078</span>
<span id="1079">1079</span>
<span id="1080">1080</span>
<span id="1081">1081</span>
<span id="1082">1082</span>
<span id="1083">1083</span>
<span id="1084">1084</span>
<span id="1085">1085</span>
<span id="1086">1086</span>
<span id="1087">1087</span>
<span id="1088">1088</span>
<span id="1089">1089</span>
<span id="1090">1090</span>
<span id="1091">1091</span>
<span id="1092">1092</span>
<span id="1093">1093</span>
<span id="1094">1094</span>
<span id="1095">1095</span>
<span id="1096">1096</span>
<span id="1097">1097</span>
<span id="1098">1098</span>
<span id="1099">1099</span>
<span id="1100">1100</span>
<span id="1101">1101</span>
<span id="1102">1102</span>
<span id="1103">1103</span>
<span id="1104">1104</span>
<span id="1105">1105</span>
<span id="1106">1106</span>
<span id="1107">1107</span>
<span id="1108">1108</span>
<span id="1109">1109</span>
<span id="1110">1110</span>
<span id="1111">1111</span>
<span id="1112">1112</span>
<span id="1113">1113</span>
<span id="1114">1114</span>
<span id="1115">1115</span>
<span id="1116">1116</span>
<span id="1117">1117</span>
<span id="1118">1118</span>
</pre><pre class="rust"><code><span class="doccomment">/*! Bitslice pointer encoding

This module defines the in-memory representation of the handle to a `BitSlice`
region. This structure is crate-internal, and defines the methods required to
store a `BitSlice` pointer in memory and retrieve values from it suitable for
work.

Currently, this module is absolutely forbidden for export outside the crate, and
its implementation cannot be relied upon. Future work *may* choose to stabilize
the encoding, and make it available, but this work is not a priority for the
project.
!*/</span>

<span class="kw">use</span> <span class="kw">crate</span>::{
	<span class="ident">access::BitAccess</span>,
	<span class="ident">devel</span> <span class="kw">as</span> <span class="ident">dvl</span>,
	<span class="ident">index</span>::{
		<span class="ident">BitIdx</span>,
		<span class="ident">BitTail</span>,
	},
	<span class="ident">mem::BitMemory</span>,
	<span class="ident">order::BitOrder</span>,
	<span class="ident">slice::BitSlice</span>,
	<span class="ident">store::BitStore</span>,
};

<span class="kw">use</span> <span class="ident">core</span>::{
	<span class="ident">any</span>,
	<span class="ident">fmt</span>::{
		<span class="self">self</span>,
		<span class="ident">Debug</span>,
		<span class="ident">Formatter</span>,
		<span class="ident">Pointer</span>,
	},
	<span class="ident">marker::PhantomData</span>,
	<span class="ident">ptr</span>::{
		<span class="self">self</span>,
		<span class="ident">NonNull</span>,
	},
	<span class="ident">slice</span>,
};

<span class="kw">use</span> <span class="ident">wyz::fmt::FmtForward</span>;

<span class="doccomment">/** Pointer to memory with limited typecasting support.

# Type Parameters

- `T`: The referent data type.
**/</span>
<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Eq</span>, <span class="ident">Hash</span>, <span class="ident">Ord</span>, <span class="ident">PartialEq</span>, <span class="ident">PartialOrd</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Address</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span>
{
	<span class="doccomment">/// The numeric value of the address.</span>
	<span class="ident">addr</span>: <span class="ident">usize</span>,
	<span class="doccomment">/// The referent type of data at the address.</span>
	<span class="ident">_ty</span>: <span class="ident">PhantomData</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">Address</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span>
{
	<span class="doccomment">/// Views a numeric address as a typed data address.</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">addr</span>: <span class="ident">usize</span>) -&gt; <span class="self">Self</span> {
		<span class="self">Self</span> {
			<span class="ident">addr</span>,
			<span class="ident">_ty</span>: <span class="ident">PhantomData</span>,
		}
	}

	<span class="doccomment">/// Views the memory address as an access pointer.</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">to_access</span>(<span class="self">self</span>) -&gt; <span class="kw-2">*const</span> <span class="ident">T::Access</span> {
		<span class="self">self</span>.<span class="ident">addr</span> <span class="kw">as</span> <span class="kw-2">*const</span> <span class="ident">T::Access</span>
	}

	<span class="doccomment">/// Views the memory address as an alias pointer.</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">to_alias</span>(<span class="self">self</span>) -&gt; <span class="kw-2">*const</span> <span class="ident">T::Alias</span> {
		<span class="self">self</span>.<span class="ident">addr</span> <span class="kw">as</span> <span class="kw-2">*const</span> <span class="ident">T::Alias</span>
	}

	<span class="doccomment">/// Views the memory address as an immutable pointer.</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">to_const</span>(<span class="self">self</span>) -&gt; <span class="kw-2">*const</span> <span class="ident">T</span> {
		<span class="self">self</span>.<span class="ident">addr</span> <span class="kw">as</span> <span class="kw-2">*const</span> <span class="ident">T</span>
	}

	<span class="doccomment">/// Views the memory address as a mutable pointer.</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="attribute">#[<span class="ident">allow</span>(<span class="ident">clippy::wrong_self_convention</span>)]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">to_mut</span>(<span class="self">self</span>) -&gt; <span class="kw-2">*mut</span> <span class="ident">T</span> {
		<span class="self">self</span>.<span class="ident">addr</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">T</span>
	}

	<span class="doccomment">/// Gets the numeric value of the address.</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">value</span>(<span class="self">self</span>) -&gt; <span class="ident">usize</span> {
		<span class="self">self</span>.<span class="ident">addr</span>
	}
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">Clone</span> <span class="kw">for</span> <span class="ident">Address</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span>
{
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">fn</span> <span class="ident">clone</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="self">Self</span> {
		<span class="self">Self</span> { ..<span class="kw-2">*</span><span class="self">self</span> }
	}
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">From</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Address</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span>
{
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">fn</span> <span class="ident">from</span>(<span class="ident">addr</span>: <span class="kw-2">&amp;</span><span class="ident">T</span>) -&gt; <span class="self">Self</span> {
		(<span class="ident">addr</span> <span class="kw">as</span> <span class="kw-2">*const</span> <span class="ident">T</span>).<span class="ident">into</span>()
	}
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">From</span><span class="op">&lt;</span><span class="kw-2">*const</span> <span class="ident">T</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Address</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span>
{
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">fn</span> <span class="ident">from</span>(<span class="ident">addr</span>: <span class="kw-2">*const</span> <span class="ident">T</span>) -&gt; <span class="self">Self</span> {
		<span class="ident"><span class="self">Self</span>::new</span>((<span class="ident">addr</span>) <span class="kw">as</span> <span class="ident">usize</span>)
	}
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">From</span><span class="op">&lt;</span><span class="kw-2">&amp;mut</span> <span class="ident">T</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Address</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span>
{
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">fn</span> <span class="ident">from</span>(<span class="ident">addr</span>: <span class="kw-2">&amp;mut</span> <span class="ident">T</span>) -&gt; <span class="self">Self</span> {
		(<span class="ident">addr</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">T</span>).<span class="ident">into</span>()
	}
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">From</span><span class="op">&lt;</span><span class="kw-2">*mut</span> <span class="ident">T</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Address</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span>
{
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">fn</span> <span class="ident">from</span>(<span class="ident">addr</span>: <span class="kw-2">*mut</span> <span class="ident">T</span>) -&gt; <span class="self">Self</span> {
		<span class="ident"><span class="self">Self</span>::new</span>(<span class="ident">addr</span> <span class="kw">as</span> <span class="ident">usize</span>)
	}
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">Debug</span> <span class="kw">for</span> <span class="ident">Address</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span>
{
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">fmt</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Formatter</span>) -&gt; <span class="ident">fmt::Result</span> {
		<span class="op">&lt;</span><span class="self">Self</span> <span class="kw">as</span> <span class="ident">Pointer</span><span class="op">&gt;</span><span class="ident">::fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">fmt</span>)
	}
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">Pointer</span> <span class="kw">for</span> <span class="ident">Address</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span>
{
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">fmt</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Formatter</span>) -&gt; <span class="ident">fmt::Result</span> {
		<span class="ident">Pointer::fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">to_const</span>(), <span class="ident">fmt</span>)
	}
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">Copy</span> <span class="kw">for</span> <span class="ident">Address</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span>
{
}

<span class="doccomment">/** Bit-precision slice pointer encoding.

Rust slices use a pointer/length encoding to represent regions of memory.
References to slices of data, `&amp;[T]`, have the ABI layout `(*const T, usize)`.

`BitPtr` encodes a base address, a first-bit index, and a length counter, into
the Rust slice reference layout using this structure, permitting `bitvec` to use
an opaque reference type in its implementation of Rust interfaces that require
references, rather than immediate value types.

# Layout

This structure is a more complex version of the `*const T`/`usize` tuple that
Rust uses to represent slices throughout the language. It breaks the pointer and
counter fundamentals into sub-field components. Rust does not have bitfield
syntax, so the below description of the structure layout is in C++.

```cpp
template &lt;typename T&gt;
struct BitPtr {
  uintptr_t ptr_head : __builtin_ctzll(alignof(T));
  uintptr_t ptr_addr : sizeof(uintptr_T) * 8 - __builtin_ctzll(alignof(T));

  size_t len_head : 3;
  size_t len_bits : sizeof(size_t) * 8 - 3;
};
```

This means that the `BitPtr&lt;T&gt;` has three *logical* fields, stored in four
segments across the two *structural* fields of the type. The widths and
placements of each segment are functions of the size of `*const T` and `usize`,
and of the alignment of the `T` referent buffer element type.

# Fields

This section describes the purpose, semantic meaning, and layout of the three
logical fields.

## Base Address

The address of the base element in a memory region is stored in all but the
lowest bits of the `ptr` field. An aligned pointer to `T` will always have its
lowest log&lt;sub&gt;2&lt;/sub&gt;(byte width) bits zeroed, so those bits can be used to
store other information, as long as they are erased before dereferencing the
address as a pointer to `T`.

## Head Bit Index

For any referent element type `T`, the selection of a single bit within the
element requires log&lt;sub&gt;2&lt;/sub&gt;(byte width) bits to select a byte within the
element `T`, and another three bits to select a bit within the selected byte.

|Type |Alignment|Trailing Zeros|Count Bits|
|:----|--------:|-------------:|---------:|
|`u8` |        1|             0|         3|
|`u16`|        2|             1|         4|
|`u32`|        4|             2|         5|
|`u64`|        8|             3|         6|

The index of the first live bit in the base element is split to have its three
least significant bits stored in the least significant edge of the `len` field,
and its remaining bits stored in the least significant edge of the `ptr` field.

## Length Counter

All but the lowest three bits of the `len` field are used to store a counter of
live bits in the referent region. When this is zero, the region is empty.
Because it is missing three bits, a `BitPtr` has only ⅛ of the index space of
a `usize` value.

# Significant Values

The following values represent significant instances of the `BitPtr` type.

## Null Slice

The fully-zeroed slot is not a valid member of the `BitPtr&lt;T&gt;` type; it is
reserved as the sentinel value for `Option::&lt;BitPtr&lt;T&gt;&gt;::None`.

## Canonical Empty Slice

All pointers with a `bits: 0` logical field are empty. Pointers used to maintain
ownership of heap buffers are not permitted to erase their `addr` field, but
unowning pointers may do so. When an unowning pointer becomes empty, it may
replace its `addr` with the `NonNull::&lt;T&gt;::dangling()` value.

All empty pointers are equivalent to each other.

### Uninhabited Slices

Any empty pointer with a non-`dangling()` base address is considered to be an
uninhabited region.

# Type Parameters

- `T`: The memory type of the referent region. `BitPtr&lt;T&gt;` is a refined `*[T]`
  slice pointer, and operates on memory in terms of the `T` type for access and
  pointer calculation.

# Safety

A `BitPtr` must never be constructed such that the element addressed by
`self.pointer().to_const().offset(self.elements())` causes an addition overflow.
This will be checked in `new()`.

It is difficult to cause an arithmetic overflow with pointer offsets, as most
targets divide the address space such that programs see a highest address of
`0x7FFF…`. This restriction is inherited from restrictions in the distribution
collection libraries, which have studied these problems extensively and are
reasonable sources of trustworthy plagiarism.

# Undefined Behavior

Values of this type are incompatible with slice pointers. Transmutation of these
values into any other type will result in an incorrect program, and permit the
program to begin illegal or undefined behaviors. This type may never be
manipulated in any way by user code outside of the APIs it offers to this crate;
it certainly may not be seen or observed by other crates.
**/</span>
<span class="attribute">#[<span class="ident">repr</span>(<span class="ident">C</span>)]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Eq</span>, <span class="ident">Hash</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">BitPtr</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span>
{
	<span class="doccomment">/// Two-element bitfield structure, holding pointer and head information.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This stores a pointer to the zeroth element of the slice, and the high</span>
	<span class="doccomment">/// bits of the head bit cursor. It is typed as a `NonNull&lt;u8&gt;` in order to</span>
	<span class="doccomment">/// provide null-value optimizations to `Option&lt;BitPtr&lt;T&gt;&gt;`, and because the</span>
	<span class="doccomment">/// presence of head-bit cursor information in the lowest bits means the</span>
	<span class="doccomment">/// bit pattern will not uphold alignment properties assumed by</span>
	<span class="doccomment">/// `NonNull&lt;T&gt;`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This field cannot be treated as an address of the zeroth byte of the</span>
	<span class="doccomment">/// slice domain, because the owning handle’s [`BitOrder`] implementation</span>
	<span class="doccomment">/// governs the bit pattern of the head cursor.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`BitOrder`]: ../order/trait.BitOrder.html</span>
	<span class="ident">ptr</span>: <span class="ident">NonNull</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>,
	<span class="doccomment">/// Two-element bitfield structure, holding bit-count and head-index</span>
	<span class="doccomment">/// information.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This stores the bit count in its highest bits and the low three bits of</span>
	<span class="doccomment">/// the head `BitIdx` in the lowest three bits.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`BitIdx`]: ../struct.BitIdx.html</span>
	<span class="ident">len</span>: <span class="ident">usize</span>,
	<span class="ident">_ty</span>: <span class="ident">PhantomData</span><span class="op">&lt;</span><span class="kw-2">*mut</span> <span class="ident">T</span><span class="op">&gt;</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">BitPtr</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span>
{
	<span class="doccomment">/// The canonical representation of a pointer to an empty region.</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const</span> <span class="ident">EMPTY</span>: <span class="self">Self</span> <span class="op">=</span> <span class="self">Self</span> {
		<span class="comment">/* Note: this must always construct the `T` dangling pointer, and then
		convert it into a pointer to `u8`. Creating `NonNull::dangling()`
		directly will always instantiate the `NonNull::&lt;u8&gt;::dangling()`
		pointer, which is VERY incorrect for any other `T` typarams.
		*/</span>
		<span class="ident">ptr</span>: <span class="kw">unsafe</span> {
			<span class="ident">NonNull::new_unchecked</span>(<span class="ident">NonNull</span>::<span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span><span class="ident">::dangling</span>().<span class="ident">as_ptr</span>() <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">u8</span>)
		},
		<span class="ident">len</span>: <span class="number">0</span>,
		<span class="ident">_ty</span>: <span class="ident">PhantomData</span>,
	};
	<span class="doccomment">/// The number of low bits of `self.len` required to hold the low bits of</span>
	<span class="doccomment">/// the head `BitIdx` cursor.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This is always `3`, until Rust tries to target an architecture that does</span>
	<span class="doccomment">/// not have 8-bit bytes.</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const</span> <span class="ident">LEN_HEAD_BITS</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">3</span>;
	<span class="doccomment">/// Marks the bits of `self.len` that hold part of the `head` logical field.</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const</span> <span class="ident">LEN_HEAD_MASK</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">0b0111</span>;
	<span class="doccomment">/// Marks the bits of `self.ptr` that hold the `addr` logical field.</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const</span> <span class="ident">PTR_ADDR_MASK</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="op">!</span><span class="number">0</span> <span class="op">&lt;</span><span class="op">&lt;</span> <span class="ident"><span class="self">Self</span>::PTR_HEAD_BITS</span>;
	<span class="doccomment">/// The number of low bits of `self.ptr` required to hold the high bits of</span>
	<span class="doccomment">/// the head `BitIdx` cursor.</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const</span> <span class="ident">PTR_HEAD_BITS</span>: <span class="ident">usize</span> <span class="op">=</span>
		<span class="ident">T::Mem::INDX</span> <span class="kw">as</span> <span class="ident">usize</span> <span class="op">-</span> <span class="ident"><span class="self">Self</span>::LEN_HEAD_BITS</span>;
	<span class="doccomment">/// Marks the bits of `self.ptr` that hold part of the `head` logical field.</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const</span> <span class="ident">PTR_HEAD_MASK</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="op">!</span><span class="ident"><span class="self">Self</span>::PTR_ADDR_MASK</span>;
	<span class="doccomment">/// The inclusive maximum number of bits that a `BitPtr` can cover.</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const</span> <span class="ident">REGION_MAX_BITS</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="op">!</span><span class="number">0</span> <span class="op">&gt;</span><span class="op">&gt;</span> <span class="ident"><span class="self">Self</span>::LEN_HEAD_BITS</span>;
	<span class="doccomment">/// The inclusive maximum number of elements that the region described by a</span>
	<span class="doccomment">/// `BitPtr` can cover in memory.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This is the number of elements required to store `MAX_BITS`, plus one</span>
	<span class="doccomment">/// because a region could start in the middle of its base element and thus</span>
	<span class="doccomment">/// push the final bits into a new element.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Since the region is ⅛th the bit span of a `usize` counter already, this</span>
	<span class="doccomment">/// number is guaranteed to be well below the limits of arithmetic or Rust’s</span>
	<span class="doccomment">/// own constraints on memory region handles.</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const</span> <span class="ident">REGION_MAX_ELTS</span>: <span class="ident">usize</span> <span class="op">=</span>
		<span class="ident"><span class="kw">crate</span>::mem::elts</span>::<span class="op">&lt;</span><span class="ident">T::Mem</span><span class="op">&gt;</span>(<span class="ident"><span class="self">Self</span>::REGION_MAX_BITS</span>) <span class="op">+</span> <span class="number">1</span>;

	<span class="doccomment">/// Constructs an empty `BitPtr` at a bare pointer.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `addr`: Some allocated address of a `T` element or region.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// A zero-length `BitPtr` at `addr`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Panics</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This function panics if `addr` is not well-aligned to `T`. All addresses</span>
	<span class="doccomment">/// received from the Rust allocation system are required to satisfy this</span>
	<span class="doccomment">/// constraint.</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">uninhabited</span>(<span class="ident">addr</span>: <span class="kw">impl</span> <span class="ident">Into</span><span class="op">&lt;</span><span class="ident">Address</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span><span class="op">&gt;</span>) -&gt; <span class="self">Self</span> {
		<span class="kw">let</span> <span class="ident">addr</span> <span class="op">=</span> <span class="ident">addr</span>.<span class="ident">into</span>();
		<span class="macro">assert!</span>(
			<span class="ident">addr</span>.<span class="ident">value</span>().<span class="ident">trailing_zeros</span>() <span class="kw">as</span> <span class="ident">usize</span> <span class="op">&gt;</span><span class="op">=</span> <span class="ident"><span class="self">Self</span>::PTR_HEAD_BITS</span>,
			<span class="string">&quot;Pointer {:p} does not satisfy minimum alignment requirements {}&quot;</span>,
			<span class="ident">addr</span>.<span class="ident">to_const</span>(),
			<span class="ident"><span class="self">Self</span>::PTR_HEAD_BITS</span>
		);
		<span class="self">Self</span> {
			<span class="ident">ptr</span>: <span class="kw">match</span> <span class="ident">NonNull::new</span>(<span class="ident">addr</span>.<span class="ident">to_mut</span>() <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">u8</span>) {
				<span class="prelude-val">Some</span>(<span class="ident">nn</span>) =&gt; <span class="ident">nn</span>,
				<span class="prelude-val">None</span> =&gt; <span class="kw">return</span> <span class="ident"><span class="self">Self</span>::EMPTY</span>,
			},
			<span class="ident">len</span>: <span class="number">0</span>,
			<span class="ident">_ty</span>: <span class="ident">PhantomData</span>,
		}
	}

	<span class="doccomment">/// Constructs a new `BitPtr` from its components.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `addr`: A well-aligned pointer to a storage element.</span>
	<span class="doccomment">/// - `head`: The bit index of the first live bit in the element under</span>
	<span class="doccomment">///   `*addr`.</span>
	<span class="doccomment">/// - `bits`: The number of live bits in the region the produced `BitPtr&lt;T&gt;`</span>
	<span class="doccomment">///   describes.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This returns `None` in the following cases:</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `addr` is the null pointer, or is not adequately aligned for `T`.</span>
	<span class="doccomment">/// - `bits` is greater than `Self::REGION_MAX_BITS`, and cannot be encoded</span>
	<span class="doccomment">///   into a `BitPtr`.</span>
	<span class="doccomment">/// - addr` is so high in the address space that the element slice wraps</span>
	<span class="doccomment">///   around the address space boundary.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Safety</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The caller must provide an `addr` pointer and a `bits` counter which</span>
	<span class="doccomment">/// describe a `[T]` region which is correctly aligned and validly allocated</span>
	<span class="doccomment">/// in the caller’s memory space. The caller is responsible for ensuring</span>
	<span class="doccomment">/// that the slice of memory the produced `BitPtr&lt;T&gt;` describes is all</span>
	<span class="doccomment">/// governable in the caller’s context.</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">new</span>(
		<span class="ident">addr</span>: <span class="kw">impl</span> <span class="ident">Into</span><span class="op">&lt;</span><span class="ident">Address</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span><span class="op">&gt;</span>,
		<span class="ident">head</span>: <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">T::Mem</span><span class="op">&gt;</span>,
		<span class="ident">bits</span>: <span class="ident">usize</span>,
	) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
		<span class="kw">let</span> <span class="ident">addr</span> <span class="op">=</span> <span class="ident">addr</span>.<span class="ident">into</span>();

		<span class="kw">if</span> <span class="ident">addr</span>.<span class="ident">to_const</span>().<span class="ident">is_null</span>()
			<span class="op">|</span><span class="op">|</span> (<span class="ident">addr</span>.<span class="ident">value</span>().<span class="ident">trailing_zeros</span>() <span class="kw">as</span> <span class="ident">usize</span>) <span class="op">&lt;</span> <span class="ident"><span class="self">Self</span>::PTR_HEAD_BITS</span>
			<span class="op">|</span><span class="op">|</span> <span class="ident">bits</span> <span class="op">&gt;</span> <span class="ident"><span class="self">Self</span>::REGION_MAX_BITS</span>
		{
			<span class="kw">return</span> <span class="prelude-val">None</span>;
		}

		<span class="kw">let</span> <span class="ident">elts</span> <span class="op">=</span> <span class="ident">head</span>.<span class="ident">span</span>(<span class="ident">bits</span>).<span class="number">0</span>;
		<span class="kw">let</span> <span class="ident">last</span> <span class="op">=</span> <span class="ident">addr</span>.<span class="ident">to_const</span>().<span class="ident">wrapping_add</span>(<span class="ident">elts</span>);
		<span class="kw">if</span> <span class="ident">last</span> <span class="op">&lt;</span> <span class="ident">addr</span>.<span class="ident">to_const</span>() {
			<span class="kw">return</span> <span class="prelude-val">None</span>;
		}

		<span class="prelude-val">Some</span>(<span class="kw">unsafe</span> { <span class="ident"><span class="self">Self</span>::new_unchecked</span>(<span class="ident">addr</span>, <span class="ident">head</span>, <span class="ident">bits</span>) })
	}

	<span class="doccomment">/// Creates a new `BitPtr&lt;T&gt;` from its components, without any validity</span>
	<span class="doccomment">/// checks.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Safety</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ***ABSOLUTELY NONE.*** This function *only* packs its arguments into the</span>
	<span class="doccomment">/// bit pattern of the `BitPtr&lt;T&gt;` type. It should only be used in contexts</span>
	<span class="doccomment">/// where a previously extant `BitPtr&lt;T&gt;` was constructed with ancestry</span>
	<span class="doccomment">/// known to have survived [`::new`], and any manipulations of its raw</span>
	<span class="doccomment">/// components are known to be valid for reconstruction.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// See [`::new`].</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// See [`::new`].</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`::new`]: #method.new</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">new_unchecked</span>(
		<span class="ident">addr</span>: <span class="kw">impl</span> <span class="ident">Into</span><span class="op">&lt;</span><span class="ident">Address</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span><span class="op">&gt;</span>,
		<span class="ident">head</span>: <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">T::Mem</span><span class="op">&gt;</span>,
		<span class="ident">bits</span>: <span class="ident">usize</span>,
	) -&gt; <span class="self">Self</span> {
		<span class="kw">let</span> (<span class="ident">addr</span>, <span class="ident">head</span>) <span class="op">=</span> (<span class="ident">addr</span>.<span class="ident">into</span>(), <span class="ident">head</span>.<span class="ident">value</span>() <span class="kw">as</span> <span class="ident">usize</span>);

		<span class="kw">let</span> <span class="ident">ptr_data</span> <span class="op">=</span> <span class="ident">addr</span>.<span class="ident">value</span>() <span class="op">&amp;</span> <span class="ident"><span class="self">Self</span>::PTR_ADDR_MASK</span>;
		<span class="kw">let</span> <span class="ident">ptr_head</span> <span class="op">=</span> <span class="ident">head</span> <span class="op">&gt;</span><span class="op">&gt;</span> <span class="ident"><span class="self">Self</span>::LEN_HEAD_BITS</span>;

		<span class="kw">let</span> <span class="ident">len_head</span> <span class="op">=</span> <span class="ident">head</span> <span class="op">&amp;</span> <span class="ident"><span class="self">Self</span>::LEN_HEAD_MASK</span>;
		<span class="kw">let</span> <span class="ident">len_bits</span> <span class="op">=</span> <span class="ident">bits</span> <span class="op">&lt;</span><span class="op">&lt;</span> <span class="ident"><span class="self">Self</span>::LEN_HEAD_BITS</span>;

		<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">Address::new</span>(<span class="ident">ptr_data</span> <span class="op">|</span> <span class="ident">ptr_head</span>);

		<span class="self">Self</span> {
			<span class="ident">ptr</span>: <span class="ident">NonNull::new_unchecked</span>(<span class="ident">ptr</span>.<span class="ident">to_mut</span>()),
			<span class="ident">len</span>: <span class="ident">len_bits</span> <span class="op">|</span> <span class="ident">len_head</span>,
			<span class="ident">_ty</span>: <span class="ident">PhantomData</span>,
		}
	}

	<span class="doccomment">/// Gets the base element address of the referent region.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The address of the starting element of the memory region. This address</span>
	<span class="doccomment">/// is weakly typed so that it can be cast by call sites to the most useful</span>
	<span class="doccomment">/// access type.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">pointer</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">Address</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
		<span class="ident">Address::new</span>(<span class="self">self</span>.<span class="ident">ptr</span>.<span class="ident">as_ptr</span>() <span class="kw">as</span> <span class="ident">usize</span> <span class="op">&amp;</span> <span class="ident"><span class="self">Self</span>::PTR_ADDR_MASK</span>)
	}

	<span class="doccomment">/// Overwrites the data pointer with a new address. This method does not</span>
	<span class="doccomment">/// perform safety checks on the new pointer.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;mut self`</span>
	<span class="doccomment">/// - `ptr`: The new address of the `BitPtr&lt;T&gt;`’s domain.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Safety</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// None. The invariants of `::new` must be checked at the caller.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">set_pointer</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">addr</span>: <span class="kw">impl</span> <span class="ident">Into</span><span class="op">&lt;</span><span class="ident">Address</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span><span class="op">&gt;</span>) {
		<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">addr</span> <span class="op">=</span> <span class="ident">addr</span>.<span class="ident">into</span>();
		<span class="kw">if</span> <span class="ident">addr</span>.<span class="ident">to_const</span>().<span class="ident">is_null</span>() {
			<span class="kw-2">*</span><span class="self">self</span> <span class="op">=</span> <span class="ident"><span class="self">Self</span>::EMPTY</span>;
			<span class="kw">return</span>;
		}
		<span class="ident">addr</span>.<span class="ident">addr</span> <span class="op">&amp;=</span> <span class="ident"><span class="self">Self</span>::PTR_ADDR_MASK</span>;
		<span class="ident">addr</span>.<span class="ident">addr</span> <span class="op">|</span><span class="op">=</span> <span class="self">self</span>.<span class="ident">ptr</span>.<span class="ident">as_ptr</span>() <span class="kw">as</span> <span class="ident">usize</span> <span class="op">&amp;</span> <span class="ident"><span class="self">Self</span>::PTR_HEAD_MASK</span>;
		<span class="self">self</span>.<span class="ident">ptr</span> <span class="op">=</span> <span class="ident">NonNull::new_unchecked</span>(<span class="ident">addr</span>.<span class="ident">to_mut</span>() <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">u8</span>);
	}

	<span class="doccomment">/// Gets the starting bit index of the referent region.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// A `BitIdx` of the first live bit in the element at the `self.pointer()`</span>
	<span class="doccomment">/// address.</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">head</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">T::Mem</span><span class="op">&gt;</span> {
		<span class="comment">//  Get the high part of the head counter out of the pointer.</span>
		<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">ptr</span>.<span class="ident">as_ptr</span>() <span class="kw">as</span> <span class="ident">usize</span>;
		<span class="kw">let</span> <span class="ident">ptr_head</span> <span class="op">=</span> (<span class="ident">ptr</span> <span class="op">&amp;</span> <span class="ident"><span class="self">Self</span>::PTR_HEAD_MASK</span>) <span class="op">&lt;</span><span class="op">&lt;</span> <span class="ident"><span class="self">Self</span>::LEN_HEAD_BITS</span>;
		<span class="comment">//  Get the low part of the head counter out of the length.</span>
		<span class="kw">let</span> <span class="ident">len_head</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">len</span> <span class="op">&amp;</span> <span class="ident"><span class="self">Self</span>::LEN_HEAD_MASK</span>;
		<span class="comment">//  Combine and mark as an index.</span>
		<span class="kw">unsafe</span> { <span class="ident">BitIdx::new_unchecked</span>((<span class="ident">ptr_head</span> <span class="op">|</span> <span class="ident">len_head</span>) <span class="kw">as</span> <span class="ident">u8</span>) }
	}

	<span class="doccomment">/// Write a new `head` value into the pointer, with no other effects.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;mut self`</span>
	<span class="doccomment">/// - `head`: A new starting index.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Effects</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// `head` is written into the `.head` logical field, without affecting</span>
	<span class="doccomment">/// `.addr` or `.bits`.</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">set_head</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">head</span>: <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">T::Mem</span><span class="op">&gt;</span>) {
		<span class="kw">let</span> <span class="ident">head</span> <span class="op">=</span> <span class="ident">head</span>.<span class="ident">value</span>() <span class="kw">as</span> <span class="ident">usize</span>;
		<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">ptr</span>.<span class="ident">as_ptr</span>() <span class="kw">as</span> <span class="ident">usize</span>;

		<span class="ident">ptr</span> <span class="op">&amp;=</span> <span class="ident"><span class="self">Self</span>::PTR_ADDR_MASK</span>;
		<span class="ident">ptr</span> <span class="op">|</span><span class="op">=</span> <span class="ident">head</span> <span class="op">&gt;</span><span class="op">&gt;</span> <span class="ident"><span class="self">Self</span>::LEN_HEAD_BITS</span>;
		<span class="self">self</span>.<span class="ident">ptr</span> <span class="op">=</span> <span class="ident">NonNull::new_unchecked</span>(<span class="ident">ptr</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">u8</span>);

		<span class="self">self</span>.<span class="ident">len</span> <span class="op">&amp;=</span> <span class="op">!</span><span class="ident"><span class="self">Self</span>::LEN_HEAD_MASK</span>;
		<span class="self">self</span>.<span class="ident">len</span> <span class="op">|</span><span class="op">=</span> <span class="ident">head</span> <span class="op">&amp;</span> <span class="ident"><span class="self">Self</span>::LEN_HEAD_MASK</span>;
	}

	<span class="doccomment">/// Gets the number of live bits in the referent region.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// A count of how many live bits the region pointer describes.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">len</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">usize</span> {
		<span class="self">self</span>.<span class="ident">len</span> <span class="op">&gt;</span><span class="op">&gt;</span> <span class="ident"><span class="self">Self</span>::LEN_HEAD_BITS</span>
	}

	<span class="doccomment">/// Sets the `.bits` logical member to a new value.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;mut self`</span>
	<span class="doccomment">/// - `len`: A new bit length. This must not be greater than</span>
	<span class="doccomment">///   `Self::REGION_MAX_BITS`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Effects</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The `new_len` value is written directly into the `.bits` logical field.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">set_len</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">new_len</span>: <span class="ident">usize</span>) {
		<span class="macro">debug_assert!</span>(
			<span class="ident">new_len</span> <span class="op">&lt;</span><span class="op">=</span> <span class="ident"><span class="self">Self</span>::REGION_MAX_BITS</span>,
			<span class="string">&quot;Length {} out of range&quot;</span>,
			<span class="ident">new_len</span>,
		);
		<span class="self">self</span>.<span class="ident">len</span> <span class="op">&amp;=</span> <span class="ident"><span class="self">Self</span>::LEN_HEAD_MASK</span>;
		<span class="self">self</span>.<span class="ident">len</span> <span class="op">|</span><span class="op">=</span> <span class="ident">new_len</span> <span class="op">&lt;</span><span class="op">&lt;</span> <span class="ident"><span class="self">Self</span>::LEN_HEAD_BITS</span>;
	}

	<span class="doccomment">/// Gets the three logical components of the pointer.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `.0`: The base address of the referent memory region.</span>
	<span class="doccomment">/// - `.1`: The index of the first live bit in the first element of the</span>
	<span class="doccomment">///   region.</span>
	<span class="doccomment">/// - `.2`: The number of live bits in the region.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">raw_parts</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; (<span class="ident">Address</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">T::Mem</span><span class="op">&gt;</span>, <span class="ident">usize</span>) {
		(<span class="self">self</span>.<span class="ident">pointer</span>(), <span class="self">self</span>.<span class="ident">head</span>(), <span class="self">self</span>.<span class="ident">len</span>())
	}

	<span class="doccomment">/// Computes the number of elements, starting at `self.pointer()`, that the</span>
	<span class="doccomment">/// region touches.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The count of all elements, starting at `self.pointer()`, that contain</span>
	<span class="doccomment">/// live bits included in the referent region.</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">elements</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">usize</span> {
		<span class="comment">//  Find the distance of the last bit from the base address.</span>
		<span class="kw">let</span> <span class="ident">total</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">len</span>() <span class="op">+</span> <span class="self">self</span>.<span class="ident">head</span>().<span class="ident">value</span>() <span class="kw">as</span> <span class="ident">usize</span>;
		<span class="comment">//  The element count is always the bit count divided by the bit width,</span>
		<span class="kw">let</span> <span class="ident">base</span> <span class="op">=</span> <span class="ident">total</span> <span class="op">&gt;</span><span class="op">&gt;</span> <span class="ident">T::Mem::INDX</span>;
		<span class="comment">//  plus whether any fractional element exists after the division.</span>
		<span class="kw">let</span> <span class="ident">tail</span> <span class="op">=</span> <span class="ident">total</span> <span class="kw">as</span> <span class="ident">u8</span> <span class="op">&amp;</span> <span class="ident">T::Mem::MASK</span>;
		<span class="ident">base</span> <span class="op">+</span> (<span class="ident">tail</span> <span class="op">!</span><span class="op">=</span> <span class="number">0</span>) <span class="kw">as</span> <span class="ident">usize</span>
	}

	<span class="doccomment">/// Computes the tail index for the first dead bit after the live bits.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// A `BitTail` that is the index of the first dead bit after the last live</span>
	<span class="doccomment">/// bit in the last element. This will almost always be in the range `1 ..=</span>
	<span class="doccomment">/// T::Mem::BITS`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// It will be zero only when `self` is empty.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">tail</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">BitTail</span><span class="op">&lt;</span><span class="ident">T::Mem</span><span class="op">&gt;</span> {
		<span class="kw">let</span> (<span class="ident">head</span>, <span class="ident">len</span>) <span class="op">=</span> (<span class="self">self</span>.<span class="ident">head</span>(), <span class="self">self</span>.<span class="ident">len</span>());

		<span class="kw">if</span> <span class="ident">head</span>.<span class="ident">value</span>() <span class="op">==</span> <span class="number">0</span> <span class="op">&amp;&amp;</span> <span class="ident">len</span> <span class="op">==</span> <span class="number">0</span> {
			<span class="kw">return</span> <span class="ident">BitTail::ZERO</span>;
		}

		<span class="comment">//  Compute the in-element tail index as the head plus the length,</span>
		<span class="comment">//  modulated by the element width.</span>
		<span class="kw">let</span> <span class="ident">tail</span> <span class="op">=</span> (<span class="ident">head</span>.<span class="ident">value</span>() <span class="kw">as</span> <span class="ident">usize</span> <span class="op">+</span> <span class="ident">len</span>) <span class="op">&amp;</span> <span class="ident">T::Mem::MASK</span> <span class="kw">as</span> <span class="ident">usize</span>;
		<span class="comment">/* If the tail is zero, wrap it to `T::Mem::BITS` as the maximal. This
		upshifts `1` (tail is zero) or `0` (tail is not), then sets the upshift
		on the rest of the tail, producing something in the range
		`1 ..= T::Mem::BITS`.
		*/</span>
		<span class="kw">unsafe</span> {
			<span class="ident">BitTail::new_unchecked</span>(
				(((<span class="ident">tail</span> <span class="op">==</span> <span class="number">0</span>) <span class="kw">as</span> <span class="ident">u8</span>) <span class="op">&lt;</span><span class="op">&lt;</span> <span class="ident">T::Mem::INDX</span>) <span class="op">|</span> <span class="ident">tail</span> <span class="kw">as</span> <span class="ident">u8</span>,
			)
		}
	}

	<span class="doccomment">/// Increments the `.head` logical field, rolling over into `.addr`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;mut self`</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Effects</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Increments `.head` by one. If the increment resulted in a rollover to</span>
	<span class="doccomment">/// `0`, then the `.addr` field is increased to the next `T::Mem` stepping.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">incr_head</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) {
		<span class="comment">//  Increment the cursor, permitting rollover to `T::Mem::BITS`.</span>
		<span class="kw">let</span> <span class="ident">head</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">head</span>().<span class="ident">value</span>() <span class="kw">as</span> <span class="ident">usize</span> <span class="op">+</span> <span class="number">1</span>;

		<span class="comment">//  Write the low bits into the `.len` field, then discard them.</span>
		<span class="self">self</span>.<span class="ident">len</span> <span class="op">&amp;=</span> <span class="op">!</span><span class="ident"><span class="self">Self</span>::LEN_HEAD_MASK</span>;
		<span class="self">self</span>.<span class="ident">len</span> <span class="op">|</span><span class="op">=</span> <span class="ident">head</span> <span class="op">&amp;</span> <span class="ident"><span class="self">Self</span>::LEN_HEAD_MASK</span>;
		<span class="kw">let</span> <span class="ident">head</span> <span class="op">=</span> <span class="ident">head</span> <span class="op">&gt;</span><span class="op">&gt;</span> <span class="ident"><span class="self">Self</span>::LEN_HEAD_BITS</span>;

		<span class="comment">//  Erase the high bits of `.head` from `.ptr`,</span>
		<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">ptr</span>.<span class="ident">as_ptr</span>() <span class="kw">as</span> <span class="ident">usize</span>;
		<span class="ident">ptr</span> <span class="op">&amp;=</span> <span class="ident"><span class="self">Self</span>::PTR_ADDR_MASK</span>;
		<span class="comment">/* Then numerically add the high bits of `.head` into the low bits of
		`.ptr`. If the head increment rolled over into a new element, this will
		have the effect of raising the `.addr` logical field to the next element
		address, in one instruction.
		*/</span>
		<span class="ident">ptr</span> <span class="op">+</span><span class="op">=</span> <span class="ident">head</span>;
		<span class="self">self</span>.<span class="ident">ptr</span> <span class="op">=</span> <span class="ident">NonNull::new_unchecked</span>(<span class="ident">ptr</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">u8</span>);
	}

	<span class="doccomment">/// Views the referent memory region as a slice of aliased elements.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This view will cause UB if it is used simultaneously with views of the</span>
	<span class="doccomment">/// referent region that assume full immutability of referent data.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// A slice handle over all memory elements this pointer describes.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Safety</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// `T` will be marked as `::Alias` where necessary by `BitSlice`, and so</span>
	<span class="doccomment">/// this pointer already contains the aliasing information it needs to be</span>
	<span class="doccomment">/// safe.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">as_aliased_slice</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> [<span class="ident">T::Alias</span>] {
		<span class="kw">unsafe</span> {
			<span class="ident">slice::from_raw_parts</span>(<span class="self">self</span>.<span class="ident">pointer</span>().<span class="ident">to_alias</span>(), <span class="self">self</span>.<span class="ident">elements</span>())
		}
	}

	<span class="doccomment">/// Reads a bit some distance away from `self`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Type Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `O`: A bit ordering.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">/// - `index`: The bit distance away from `self` at which to read.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The value of the bit `index` bits away from `self.head()`, according to</span>
	<span class="doccomment">/// the `O` ordering.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">read</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">index</span>: <span class="ident">usize</span>) -&gt; <span class="ident">bool</span>
	<span class="kw">where</span> <span class="ident">O</span>: <span class="ident">BitOrder</span> {
		<span class="kw">let</span> (<span class="ident">elt</span>, <span class="ident">bit</span>) <span class="op">=</span> <span class="self">self</span>.<span class="ident">head</span>().<span class="ident">offset</span>(<span class="ident">index</span> <span class="kw">as</span> <span class="ident">isize</span>);
		<span class="kw">let</span> <span class="ident">base</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">pointer</span>().<span class="ident">to_const</span>();
		(<span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">base</span>.<span class="ident">offset</span>(<span class="ident">elt</span>)).<span class="ident">get_bit</span>::<span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>(<span class="ident">bit</span>)
	}

	<span class="doccomment">/// Writes a bit some distance away from `self`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Type Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `O`: A bit ordering.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`: The `self` pointer must be describing a write-capable region.</span>
	<span class="doccomment">/// - `index`: The bit distance away from `self` at which to write,</span>
	<span class="doccomment">///   according to the `O` ordering.</span>
	<span class="doccomment">/// - `value`: The bit value to insert at `index`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Effects</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// `value` is written to the bit specified by `index`, relative to</span>
	<span class="doccomment">/// `self.head()` and `self.pointer()`.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">write</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">index</span>: <span class="ident">usize</span>, <span class="ident">value</span>: <span class="ident">bool</span>)
	<span class="kw">where</span> <span class="ident">O</span>: <span class="ident">BitOrder</span> {
		<span class="kw">let</span> (<span class="ident">elt</span>, <span class="ident">bit</span>) <span class="op">=</span> <span class="self">self</span>.<span class="ident">head</span>().<span class="ident">offset</span>(<span class="ident">index</span> <span class="kw">as</span> <span class="ident">isize</span>);
		<span class="kw">let</span> <span class="ident">base</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">pointer</span>().<span class="ident">to_access</span>();
		(<span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">base</span>.<span class="ident">offset</span>(<span class="ident">elt</span>)).<span class="ident">write_bit</span>::<span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>(<span class="ident">bit</span>, <span class="ident">value</span>);
	}

	<span class="doccomment">/// Produces the distance, in elements and bits, between two bit-pointers.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Undefined Behavior</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// It is undefined to calculate the distance between pointers that are not</span>
	<span class="doccomment">/// part of the same allocation region. This function is defined only when</span>
	<span class="doccomment">/// `self` and `other` are produced from the same region.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `self`</span>
	<span class="doccomment">/// - `other`: Another `BitPtr&lt;T&gt;`. This function is undefined if it is not</span>
	<span class="doccomment">///   produced from the same region as `self`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `.0`: The distance in elements between the first element of `self` and</span>
	<span class="doccomment">///   the first element of `other`. Negative if `other` is lower in memory</span>
	<span class="doccomment">///   than `self`; positive if `other` is higher.</span>
	<span class="doccomment">/// - `.1`: The distance in bits between the first bit of `self` and the</span>
	<span class="doccomment">///   first bit of `other`. Negative if `other`’s first bit is lower in its</span>
	<span class="doccomment">///   element than is `self`’s first bit; positive if `other`’s first bit is</span>
	<span class="doccomment">///   higher in its element than is `self`’s first bit.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Truth Tables</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Consider two adjacent bytes in memory. We will define four pairs of</span>
	<span class="doccomment">/// bit-pointers of width `1` at various points in this span in order to</span>
	<span class="doccomment">/// demonstrate the four possible states of difference.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```text</span>
	<span class="doccomment">///    [ 0 1 2 3 4 5 6 7 ] [ 8 9 a b c d e f ]</span>
	<span class="doccomment">/// 1.       A                       B</span>
	<span class="doccomment">/// 2.             A             B</span>
	<span class="doccomment">/// 3.           B           A</span>
	<span class="doccomment">/// 4.     B                             A</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// 1. The pointer `A` is in the lower element and `B` is in the higher. The</span>
	<span class="doccomment">///    first bit of `A` is lower in its element than the first bit of `B` is</span>
	<span class="doccomment">///    in its element. `A.ptr_diff(B)` thus produces positive element and</span>
	<span class="doccomment">///    bit distances: `(1, 2)`.</span>
	<span class="doccomment">/// 2. The pointer `A` is in the lower element and `B` is in the higher. The</span>
	<span class="doccomment">///    first bit of `A` is higher in its element than the first bit of `B`</span>
	<span class="doccomment">///    is in its element. `A.ptr_diff(B)` thus produces a positive element</span>
	<span class="doccomment">///    distance and a negative bit distance: `(1, -3)`.</span>
	<span class="doccomment">/// 3. The pointer `A` is in the higher element and `B` is in the lower. The</span>
	<span class="doccomment">///    first bit of `A` is lower in its element than the first bit of `B` is</span>
	<span class="doccomment">///    in its element. `A.ptr_diff(B)` thus produces a negative element</span>
	<span class="doccomment">///    distance and a positive bit distance: `(-1, 4)`.</span>
	<span class="doccomment">/// 4. The pointer `A` is in the higher element and `B` is in the lower. The</span>
	<span class="doccomment">///    first bit of `A` is higher in its element than the first bit of `B`</span>
	<span class="doccomment">///    is in its element. `A.ptr_diff(B)` thus produces negative element and</span>
	<span class="doccomment">///    bit distances: `(-1, -5)`.</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">ptr_diff</span>(<span class="self">self</span>, <span class="ident">other</span>: <span class="self">Self</span>) -&gt; (<span class="ident">isize</span>, <span class="ident">i8</span>) {
		<span class="kw">let</span> <span class="ident">self_ptr</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">pointer</span>();
		<span class="kw">let</span> <span class="ident">other_ptr</span> <span class="op">=</span> <span class="ident">other</span>.<span class="ident">pointer</span>();
		<span class="comment">//  FIXME(myrrlyn): `core::ptr::offset_from` stabilizes in 1.47.</span>
		<span class="comment">//  let elts = other_ptr.to_const().offset_from(self_ptr.to_const());</span>
		<span class="kw">let</span> <span class="ident">elts</span> <span class="op">=</span> <span class="ident">other_ptr</span>
		.<span class="ident">value</span>()
		.<span class="ident">wrapping_sub</span>(<span class="ident">self_ptr</span>.<span class="ident">value</span>())
			<span class="comment">//  Pointers are byte-addressed, so remember to divide the byte</span>
			<span class="comment">//  distance by the element width.</span>
			.<span class="ident">wrapping_div</span>(<span class="ident">core::mem::size_of</span>::<span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>()) <span class="kw">as</span> <span class="ident">isize</span>;
		<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">other</span>.<span class="ident">head</span>().<span class="ident">value</span>() <span class="kw">as</span> <span class="ident">i8</span> <span class="op">-</span> <span class="self">self</span>.<span class="ident">head</span>().<span class="ident">value</span>() <span class="kw">as</span> <span class="ident">i8</span>;
		(<span class="ident">elts</span>, <span class="ident">bits</span>)
	}

	<span class="doccomment">/// Typecasts a raw region pointer into a pointer structure.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">from_bitslice_ptr</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>(<span class="ident">raw</span>: <span class="kw-2">*const</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>) -&gt; <span class="self">Self</span>
	<span class="kw">where</span> <span class="ident">O</span>: <span class="ident">BitOrder</span> {
		<span class="kw">let</span> <span class="ident">slice_nn</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">NonNull::new</span>(<span class="ident">raw</span> <span class="kw">as</span> <span class="kw-2">*const</span> [()] <span class="kw">as</span> <span class="kw-2">*mut</span> [()]) {
			<span class="prelude-val">Some</span>(<span class="ident">r</span>) =&gt; <span class="ident">r</span>,
			<span class="prelude-val">None</span> =&gt; <span class="kw">return</span> <span class="ident"><span class="self">Self</span>::EMPTY</span>,
		};
		<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">dvl::nonnull_slice_to_base</span>(<span class="ident">slice_nn</span>).<span class="ident">cast</span>::<span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>();
		<span class="kw">let</span> <span class="ident">len</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">slice_nn</span>.<span class="ident">as_ref</span>() }.<span class="ident">len</span>();
		<span class="self">Self</span> {
			<span class="ident">ptr</span>,
			<span class="ident">len</span>,
			<span class="ident">_ty</span>: <span class="ident">PhantomData</span>,
		}
	}

	<span class="doccomment">/// Typecasts a raw region pointer into a pointer structure.</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">from_bitslice_ptr_mut</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>(<span class="ident">raw</span>: <span class="kw-2">*mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>) -&gt; <span class="self">Self</span>
	<span class="kw">where</span> <span class="ident">O</span>: <span class="ident">BitOrder</span> {
		<span class="ident"><span class="self">Self</span>::from_bitslice_ptr</span>(<span class="ident">raw</span> <span class="kw">as</span> <span class="kw-2">*const</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>)
	}

	<span class="doccomment">/// Type-casts the pointer structure into a raw region pointer.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">to_bitslice_ptr</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>(<span class="self">self</span>) -&gt; <span class="kw-2">*const</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>
	<span class="kw">where</span> <span class="ident">O</span>: <span class="ident">BitOrder</span> {
		<span class="ident">ptr::slice_from_raw_parts</span>(
			<span class="self">self</span>.<span class="ident">ptr</span>.<span class="ident">as_ptr</span>() <span class="kw">as</span> <span class="kw-2">*const</span> <span class="ident">u8</span> <span class="kw">as</span> <span class="kw-2">*const</span> (),
			<span class="self">self</span>.<span class="ident">len</span>,
		) <span class="kw">as</span> <span class="kw-2">*const</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>
	}

	<span class="doccomment">/// Typecasts the pointer structure into a raw mutable-region pointer.</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">to_bitslice_ptr_mut</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>(<span class="self">self</span>) -&gt; <span class="kw-2">*mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>
	<span class="kw">where</span> <span class="ident">O</span>: <span class="ident">BitOrder</span> {
		<span class="self">self</span>.<span class="ident">to_bitslice_ptr</span>::<span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>() <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>
	}

	<span class="doccomment">/// Typecasts the pointer structure into a region reference.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Safety</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This must only be used when the pointer refers to a region that is</span>
	<span class="doccomment">/// correctly initialized in the caller’s context. There must be no `&amp;mut</span>
	<span class="doccomment">/// BitSlice&lt;O, T&gt;` references to the referent region.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Lifetimes</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&#39;a`: The minimum lifetime of the referent region, as understood by</span>
	<span class="doccomment">///   the caller.</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">to_bitslice_ref</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">O</span><span class="op">&gt;</span>(<span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>
	<span class="kw">where</span> <span class="ident">O</span>: <span class="ident">BitOrder</span> {
		<span class="kw">unsafe</span> { <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="self">self</span>.<span class="ident">to_bitslice_ptr</span>::<span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>() }
	}

	<span class="doccomment">/// Typecasts the pointer structure into a mutable-region reference.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Safety</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This must only be used when the pointer refers to a region that is</span>
	<span class="doccomment">/// correctly initialized *and uniquely mutable* in the caller’s context.</span>
	<span class="doccomment">/// There must be no other references of any kind to the referent region.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Lifetimes</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&#39;a`: The minimum lifetime of the referent region, as understood by</span>
	<span class="doccomment">///   the caller.</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">to_bitslice_mut</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">O</span><span class="op">&gt;</span>(<span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="kw-2">mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>
	<span class="kw">where</span> <span class="ident">O</span>: <span class="ident">BitOrder</span> {
		<span class="kw">unsafe</span> { <span class="kw-2">&amp;mut</span> <span class="kw-2">*</span><span class="self">self</span>.<span class="ident">to_bitslice_ptr_mut</span>::<span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>() }
	}

	<span class="doccomment">/// Typecasts the pointer structure into a `NonNull&lt;BitSlice&gt;` pointer.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This function is used by the owning indirect handles, and does not yet</span>
	<span class="doccomment">/// have any purpose in non-`alloc` programs.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">to_nonnull</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>(<span class="self">self</span>) -&gt; <span class="ident">NonNull</span><span class="op">&lt;</span><span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span><span class="op">&gt;</span>
	<span class="kw">where</span>
		<span class="ident">O</span>: <span class="ident">BitOrder</span>,
		<span class="ident">T</span>: <span class="ident">BitStore</span>,
	{
		<span class="kw">unsafe</span> { <span class="ident">NonNull::new_unchecked</span>(<span class="self">self</span>.<span class="ident">to_bitslice_ptr_mut</span>()) }
	}

	<span class="doccomment">/// Renders the pointer structure into a formatter for use during</span>
	<span class="doccomment">/// higher-level type `Debug` implementations.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `self`</span>
	<span class="doccomment">/// - `fmt`: The formatter into which the pointer is written.</span>
	<span class="doccomment">/// - `name`: The suffix of the higher-level object rendering its pointer.</span>
	<span class="doccomment">///   The `Bit` prefix is applied to the object type name in this format.</span>
	<span class="doccomment">/// - `ord`: The name of a `BitOrder` type parameter, if any.</span>
	<span class="doccomment">/// - `fields`: Any additional fields in the object’s debuginfo to be</span>
	<span class="doccomment">///   rendered.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The result of formatting the pointer into the receiver.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Behavior</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This function writes `Bit{name}&lt;[{ord}, ]T&gt; {{ {fields} }}` into the</span>
	<span class="doccomment">/// `fmt` formatter, where `{fields}` includes the address, head index, and</span>
	<span class="doccomment">/// bit count of the pointer, as well as any additional fields provided by</span>
	<span class="doccomment">/// the caller.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Higher types in the crate should use this function to drive their</span>
	<span class="doccomment">/// `Debug` implementations, and then use `BitSlice`’s list formatters to</span>
	<span class="doccomment">/// display their contents if appropriate.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">render</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>(
		<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="self">self</span>,
		<span class="ident">fmt</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="kw-2">mut</span> <span class="ident">Formatter</span>,
		<span class="ident">name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">str</span>,
		<span class="ident">ord</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">str</span><span class="op">&gt;</span>,
		<span class="ident">fields</span>: <span class="kw">impl</span> <span class="ident">IntoIterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> (<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">str</span>, <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="kw">dyn</span> <span class="ident">Debug</span>)<span class="op">&gt;</span>,
	) -&gt; <span class="ident">fmt::Result</span> {
		<span class="macro">write!</span>(<span class="ident">fmt</span>, <span class="string">&quot;Bit{}&lt;&quot;</span>, <span class="ident">name</span>)<span class="question-mark">?</span>;
		<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">ord</span>) <span class="op">=</span> <span class="ident">ord</span> {
			<span class="macro">write!</span>(<span class="ident">fmt</span>, <span class="string">&quot;{}, &quot;</span>, <span class="ident">ord</span>)<span class="question-mark">?</span>;
		}
		<span class="macro">write!</span>(<span class="ident">fmt</span>, <span class="string">&quot;{}&gt;&quot;</span>, <span class="ident">any::type_name</span>::<span class="op">&lt;</span><span class="ident">T::Mem</span><span class="op">&gt;</span>())<span class="question-mark">?</span>;
		<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">builder</span> <span class="op">=</span> <span class="ident">fmt</span>.<span class="ident">debug_struct</span>(<span class="string">&quot;&quot;</span>);
		<span class="ident">builder</span>
			.<span class="ident">field</span>(<span class="string">&quot;addr&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">pointer</span>().<span class="ident">fmt_pointer</span>())
			.<span class="ident">field</span>(<span class="string">&quot;head&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">head</span>().<span class="ident">fmt_binary</span>())
			.<span class="ident">field</span>(<span class="string">&quot;bits&quot;</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">len</span>());
		<span class="kw">for</span> (<span class="ident">name</span>, <span class="ident">value</span>) <span class="kw">in</span> <span class="ident">fields</span> {
			<span class="ident">builder</span>.<span class="ident">field</span>(<span class="ident">name</span>, <span class="ident">value</span>);
		}
		<span class="ident">builder</span>.<span class="ident">finish</span>()
	}
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">Clone</span> <span class="kw">for</span> <span class="ident">BitPtr</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span>
{
	<span class="kw">fn</span> <span class="ident">clone</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="self">Self</span> {
		<span class="self">Self</span> { ..<span class="kw-2">*</span><span class="self">self</span> }
	}
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> <span class="ident">PartialEq</span><span class="op">&lt;</span><span class="ident">BitPtr</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">BitPtr</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
	<span class="ident">T</span>: <span class="ident">BitStore</span>,
	<span class="ident">U</span>: <span class="ident">BitStore</span>,
{
	<span class="kw">fn</span> <span class="ident">eq</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">other</span>: <span class="kw-2">&amp;</span><span class="ident">BitPtr</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>) -&gt; <span class="ident">bool</span> {
		<span class="kw">let</span> (<span class="ident">addr_a</span>, <span class="ident">head_a</span>, <span class="ident">bits_a</span>) <span class="op">=</span> <span class="self">self</span>.<span class="ident">raw_parts</span>();
		<span class="kw">let</span> (<span class="ident">addr_b</span>, <span class="ident">head_b</span>, <span class="ident">bits_b</span>) <span class="op">=</span> <span class="ident">other</span>.<span class="ident">raw_parts</span>();
		<span class="comment">//  Since ::BITS is an associated const, the compiler will automatically</span>
		<span class="comment">//  replace the entire function with `false` when the types don’t match.</span>
		<span class="ident">T::Mem::BITS</span> <span class="op">==</span> <span class="ident">U::Mem::BITS</span>
			<span class="op">&amp;&amp;</span> <span class="ident">addr_a</span>.<span class="ident">value</span>() <span class="op">==</span> <span class="ident">addr_b</span>.<span class="ident">value</span>()
			<span class="op">&amp;&amp;</span> <span class="ident">head_a</span>.<span class="ident">value</span>() <span class="op">==</span> <span class="ident">head_b</span>.<span class="ident">value</span>()
			<span class="op">&amp;&amp;</span> <span class="ident">bits_a</span> <span class="op">==</span> <span class="ident">bits_b</span>
	}
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">Default</span> <span class="kw">for</span> <span class="ident">BitPtr</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span>
{
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">fn</span> <span class="ident">default</span>() -&gt; <span class="self">Self</span> {
		<span class="ident"><span class="self">Self</span>::EMPTY</span>
	}
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">Debug</span> <span class="kw">for</span> <span class="ident">BitPtr</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span>
{
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">fmt</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Formatter</span>) -&gt; <span class="ident">fmt::Result</span> {
		<span class="ident">Pointer::fmt</span>(<span class="self">self</span>, <span class="ident">fmt</span>)
	}
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">Pointer</span> <span class="kw">for</span> <span class="ident">BitPtr</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span>
{
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">fmt</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Formatter</span>) -&gt; <span class="ident">fmt::Result</span> {
		<span class="self">self</span>.<span class="ident">render</span>(<span class="ident">fmt</span>, <span class="string">&quot;Ptr&quot;</span>, <span class="prelude-val">None</span>, <span class="prelude-val">None</span>)
	}
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">Copy</span> <span class="kw">for</span> <span class="ident">BitPtr</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span>
{
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">test</span>)]</span>
<span class="kw">mod</span> <span class="ident">tests</span> {
	<span class="kw">use</span> <span class="kw">crate</span>::{
		<span class="ident">bits</span>,
		<span class="ident">order::Msb0</span>,
	};

	<span class="attribute">#[<span class="ident">test</span>]</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
	<span class="kw">fn</span> <span class="ident">render</span>() {
		<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="ident">Msb0</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];

		<span class="kw">let</span> <span class="ident">render</span> <span class="op">=</span> <span class="macro">format!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">bits</span>.<span class="ident">bitptr</span>());
		<span class="macro">assert!</span>(<span class="ident">render</span>.<span class="ident">starts_with</span>(<span class="string">&quot;BitPtr&lt;u8&gt; { addr: 0x&quot;</span>));
		<span class="macro">assert!</span>(<span class="ident">render</span>.<span class="ident">ends_with</span>(<span class="string">&quot;, head: 000, bits: 4 }&quot;</span>));

		<span class="kw">let</span> <span class="ident">render</span> <span class="op">=</span> <span class="macro">format!</span>(<span class="string">&quot;{:#?}&quot;</span>, <span class="ident">bits</span>);
		<span class="macro">assert!</span>(<span class="ident">render</span>.<span class="ident">starts_with</span>(<span class="string">&quot;BitSlice&lt;bitvec::order::Msb0, u8&gt; {&quot;</span>));
		<span class="macro">assert!</span>(<span class="ident">render</span>.<span class="ident">ends_with</span>(<span class="string">&quot;} [\n    0b0100,\n]&quot;</span>), <span class="string">&quot;{}&quot;</span>, <span class="ident">render</span>);
	}

	<span class="attribute">#[<span class="ident">test</span>]</span>
	<span class="kw">fn</span> <span class="ident">ptr_diff</span>() {
		<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="ident">Msb0</span>, <span class="ident">u8</span>; <span class="number">0</span>; <span class="number">16</span>];

		<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">bits</span>[<span class="number">2</span> .. <span class="number">3</span>].<span class="ident">bitptr</span>();
		<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">bits</span>[<span class="number">12</span> .. <span class="number">13</span>].<span class="ident">bitptr</span>();
		<span class="macro">assert_eq!</span>(<span class="kw">unsafe</span> { <span class="ident">a</span>.<span class="ident">ptr_diff</span>(<span class="ident">b</span>) }, (<span class="number">1</span>, <span class="number">2</span>));

		<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">bits</span>[<span class="number">5</span> .. <span class="number">6</span>].<span class="ident">bitptr</span>();
		<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">bits</span>[<span class="number">10</span> .. <span class="number">11</span>].<span class="ident">bitptr</span>();
		<span class="macro">assert_eq!</span>(<span class="kw">unsafe</span> { <span class="ident">a</span>.<span class="ident">ptr_diff</span>(<span class="ident">b</span>) }, (<span class="number">1</span>, <span class="op">-</span><span class="number">3</span>));

		<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">bits</span>[<span class="number">8</span> .. <span class="number">9</span>].<span class="ident">bitptr</span>();
		<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">bits</span>[<span class="number">4</span> .. <span class="number">5</span>].<span class="ident">bitptr</span>();
		<span class="macro">assert_eq!</span>(<span class="kw">unsafe</span> { <span class="ident">a</span>.<span class="ident">ptr_diff</span>(<span class="ident">b</span>) }, (<span class="op">-</span><span class="number">1</span>, <span class="number">4</span>));

		<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">bits</span>[<span class="number">14</span> .. <span class="number">15</span>].<span class="ident">bitptr</span>();
		<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">bits</span>[<span class="number">1</span> .. <span class="number">2</span>].<span class="ident">bitptr</span>();
		<span class="macro">assert_eq!</span>(<span class="kw">unsafe</span> { <span class="ident">a</span>.<span class="ident">ptr_diff</span>(<span class="ident">b</span>) }, (<span class="op">-</span><span class="number">1</span>, <span class="op">-</span><span class="number">5</span>));
	}
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="bitvec" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.63.0 (4b91a6ea7 2022-08-08)" ></div>
</body></html>