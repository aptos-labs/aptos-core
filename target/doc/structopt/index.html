<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate defines the `StructOpt` trait and its custom derive."><meta name="keywords" content="rust, rustlang, rust-lang, structopt"><title>structopt - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="../crates.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../structopt/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../structopt/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Crate structopt</a></h2><div class="sidebar-elems"><div class="block"><ul><li class="version">Version 0.3.26</li><li><a id="all-types" href="all.html">All Items</a></li></ul></div><section><div class="block"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#traits">Traits</a></li></ul></div></section></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../structopt/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><div id="settings-menu" tabindex="-1">
                                <a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div>
                        </div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">structopt</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/structopt/lib.rs.html#9-1238">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate defines the <code>StructOpt</code> trait and its custom derive.</p>
<h3 id="maintenance"><a href="#maintenance">Maintenance</a></h3>
<p>As clap v3 is now out, and the structopt features are integrated
into (almost as-is), structopt is now in maintenance mode: no new
feature will be added.</p>
<p>Bugs will be fixed, and documentation improvements will be accepted.</p>
<h3 id="features"><a href="#features">Features</a></h3>
<p>If you want to disable all the <code>clap</code> features (colors,
suggestions, ..) add <code>default-features = false</code> to the <code>structopt</code>
dependency:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
structopt = { version = &quot;0.3&quot;, default-features = false }</code></pre></div>
<p>Support for <a href="https://github.com/rust-cli/paw"><code>paw</code></a> (the
<code>Command line argument paw-rser abstraction for main</code>) is disabled
by default, but can be enabled in the <code>structopt</code> dependency
with the feature <code>paw</code>:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
structopt = { version = &quot;0.3&quot;, features = [ &quot;paw&quot; ] }
paw = &quot;1.0&quot;</code></pre></div><h2 id="table-of-contents"><a href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="#how-to-derivestructopt">How to <code>derive(StructOpt)</code></a></li>
<li><a href="#attributes">Attributes</a>
<ul>
<li><a href="#raw-methods">Raw methods</a></li>
<li><a href="#magical-methods">Magical methods</a></li>
</ul>
</li>
<li>Arguments
<ul>
<li><a href="#type-magic">Type magic</a></li>
<li><a href="#specifying-argument-types">Specifying argument types</a></li>
<li><a href="#default-values">Default values</a></li>
<li><a href="#help-messages">Help messages</a></li>
<li><a href="#environment-variable-fallback">Environment variable fallback</a></li>
</ul>
</li>
<li><a href="#skipping-fields">Skipping fields</a></li>
<li><a href="#subcommands">Subcommands</a>
<ul>
<li><a href="#optional-subcommands">Optional subcommands</a></li>
<li><a href="#external-subcommands">External subcommands</a></li>
<li><a href="#flattening-subcommands">Flattening subcommands</a></li>
</ul>
</li>
<li><a href="#flattening">Flattening</a></li>
<li><a href="#custom-string-parsers">Custom string parsers</a></li>
<li><a href="#generics">Generics</a></li>
</ul>
<h3 id="how-to-derivestructopt"><a href="#how-to-derivestructopt">How to <code>derive(StructOpt)</code></a></h3>
<p>First, let’s look at the example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::path::PathBuf</span>;
<span class="kw">use</span> <span class="ident">structopt::StructOpt</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">StructOpt</span>)]</span>
<span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">name</span> <span class="op">=</span> <span class="string">&quot;example&quot;</span>, <span class="ident">about</span> <span class="op">=</span> <span class="string">&quot;An example of StructOpt usage.&quot;</span>)]</span>
<span class="kw">struct</span> <span class="ident">Opt</span> {
    <span class="doccomment">/// Activate debug mode</span>
    <span class="comment">// short and long flags (-d, --debug) will be deduced from the field&#39;s name</span>
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">short</span>, <span class="ident">long</span>)]</span>
    <span class="ident">debug</span>: <span class="ident">bool</span>,

    <span class="doccomment">/// Set speed</span>
    <span class="comment">// we don&#39;t want to name it &quot;speed&quot;, need to look smart</span>
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">short</span> <span class="op">=</span> <span class="string">&quot;v&quot;</span>, <span class="ident">long</span> <span class="op">=</span> <span class="string">&quot;velocity&quot;</span>, <span class="ident">default_value</span> <span class="op">=</span> <span class="string">&quot;42&quot;</span>)]</span>
    <span class="ident">speed</span>: <span class="ident">f64</span>,

    <span class="doccomment">/// Input file</span>
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">parse</span>(<span class="ident">from_os_str</span>))]</span>
    <span class="ident">input</span>: <span class="ident">PathBuf</span>,

    <span class="doccomment">/// Output file, stdout if not present</span>
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">parse</span>(<span class="ident">from_os_str</span>))]</span>
    <span class="ident">output</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">PathBuf</span><span class="op">&gt;</span>,

    <span class="doccomment">/// Where to write the output: to `stdout` or `file`</span>
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">short</span>)]</span>
    <span class="ident">out_type</span>: <span class="ident">String</span>,

    <span class="doccomment">/// File name: only required when `out-type` is set to `file`</span>
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">name</span> <span class="op">=</span> <span class="string">&quot;FILE&quot;</span>, <span class="ident">required_if</span>(<span class="string">&quot;out-type&quot;</span>, <span class="string">&quot;file&quot;</span>))]</span>
    <span class="ident">file_name</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>,
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">opt</span> <span class="op">=</span> <span class="ident">Opt::from_args</span>();
    <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">opt</span>);
}</code></pre></div>
<p>So <code>derive(StructOpt)</code> tells Rust to generate a command line parser,
and the various <code>structopt</code> attributes are simply
used for additional parameters.</p>
<p>First, define a struct, whatever its name. This structure
corresponds to a <code>clap::App</code>, its fields correspond to <code>clap::Arg</code>
(unless they’re <a href="#subcommands">subcommands</a>),
and you can adjust these apps and args by <code>#[structopt(...)]</code> <a href="#attributes">attributes</a>.</p>
<p><strong>Note:</strong></p>
<hr />
<p>Keep in mind that <code>StructOpt</code> trait is more than just <code>from_args</code> method.
It has a number of additional features, including access to underlying
<code>clap::App</code> via <code>StructOpt::clap()</code>. See the
<a href="trait.StructOpt.html">trait’s reference documentation</a>.</p>
<hr />
<h3 id="attributes"><a href="#attributes">Attributes</a></h3>
<p>You can control the way <code>structopt</code> translates your struct into an actual
<a href="https://docs.rs/clap/2.34.0/clap/app/struct.App.html" title="clap::App"><code>clap::App</code></a> invocation via <code>#[structopt(...)]</code> attributes.</p>
<p>The attributes fall into two categories:</p>
<ul>
<li>
<p><code>structopt</code>’s own <a href="#magical-methods">magical methods</a>.</p>
<p>They are used by <code>structopt</code> itself. They come mostly in
<code>attr = [&quot;whatever&quot;]</code> form, but some <code>attr(args...)</code> also exist.</p>
</li>
<li>
<p><a href="#raw-methods"><code>raw</code> attributes</a>.</p>
<p>They represent explicit <code>clap::Arg/App</code> method calls.
They are what used to be explicit <code>#[structopt(raw(...))]</code> attrs in pre-0.3 <code>structopt</code></p>
</li>
</ul>
<p>Every <code>structopt attribute</code> looks like comma-separated sequence of methods:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">structopt</span>(
    <span class="ident">short</span>, <span class="comment">// method with no arguments - always magical</span>
    <span class="ident">long</span> <span class="op">=</span> <span class="string">&quot;--long-option&quot;</span>, <span class="comment">// method with one argument</span>
    <span class="ident">required_if</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;file&quot;</span>), <span class="comment">// method with one and more args</span>
    <span class="ident">parse</span>(<span class="ident">from_os_str</span> <span class="op">=</span> <span class="ident">path::to::parser</span>) <span class="comment">// some magical methods have their own syntax</span>
)]</span></code></pre></div>
<p><code>#[structopt(...)]</code> attributes can be placed on top of <code>struct</code>, <code>enum</code>,
<code>struct</code> field or <code>enum</code> variant. Attributes on top of <code>struct</code> or <code>enum</code>
represent <code>clap::App</code> method calls, field or variant attributes correspond
to <code>clap::Arg</code> method calls.</p>
<p>In other words, the <code>Opt</code> struct from the example above
will be turned into this (<em>details omitted</em>):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="ident">App::new</span>(<span class="string">&quot;example&quot;</span>)
    .<span class="ident">version</span>(<span class="string">&quot;0.2.0&quot;</span>)
    .<span class="ident">about</span>(<span class="string">&quot;An example of StructOpt usage.&quot;</span>)
.<span class="ident">arg</span>(<span class="ident">Arg::with_name</span>(<span class="string">&quot;debug&quot;</span>)
    .<span class="ident">help</span>(<span class="string">&quot;Activate debug mode&quot;</span>)
    .<span class="ident">short</span>(<span class="string">&quot;debug&quot;</span>)
    .<span class="ident">long</span>(<span class="string">&quot;debug&quot;</span>))
.<span class="ident">arg</span>(<span class="ident">Arg::with_name</span>(<span class="string">&quot;speed&quot;</span>)
    .<span class="ident">help</span>(<span class="string">&quot;Set speed&quot;</span>)
    .<span class="ident">short</span>(<span class="string">&quot;v&quot;</span>)
    .<span class="ident">long</span>(<span class="string">&quot;velocity&quot;</span>)
    .<span class="ident">default_value</span>(<span class="string">&quot;42&quot;</span>))
<span class="comment">// and so on</span></code></pre></div>
<h3 id="raw-methods"><a href="#raw-methods">Raw methods</a></h3>
<p>They are the reason why <code>structopt</code> is so flexible. <strong>Every and each method from
<code>clap::App/Arg</code> can be used this way!</strong> See the <a href="https://docs.rs/clap/2/clap/struct.App.html"><code>clap::App</code>
methods</a> and <a href="https://docs.rs/clap/2/clap/struct.Arg.html"><code>clap::Arg</code>
methods</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">structopt</span>(
    <span class="ident">global</span> <span class="op">=</span> <span class="bool-val">true</span>, <span class="comment">// name = arg form, neat for one-arg methods</span>
    <span class="ident">required_if</span>(<span class="string">&quot;out&quot;</span>, <span class="string">&quot;file&quot;</span>) <span class="comment">// name(arg1, arg2, ...) form.</span>
)]</span></code></pre></div>
<p>The first form can only be used for methods which take only one argument.
The second form must be used with multi-arg methods, but can also be used with
single-arg methods. These forms are identical otherwise.</p>
<p>As long as <code>method_name</code> is not one of the magical methods -
it will be translated into a mere method call.</p>
<p><strong>Note:</strong></p>
<hr />
<p>“Raw methods” are direct replacement for pre-0.3 structopt’s
<code>#[structopt(raw(...))]</code> attributes, any time you would have used a <code>raw()</code> attribute
in 0.2 you should use raw method in 0.3.</p>
<p>Unfortunately, old raw attributes collide with <code>clap::Arg::raw</code> method. To explicitly
warn users of this change we allow <code>#[structopt(raw())]</code> only with <code>true</code> or <code>false</code>
literals (this method is supposed to be called only with <code>true</code> anyway).</p>
<hr />
<h3 id="magical-methods"><a href="#magical-methods">Magical methods</a></h3>
<p>They are the reason why <code>structopt</code> is so easy to use and convenient in most cases.
Many of them have defaults, some of them get used even if not mentioned.</p>
<p>Methods may be used on “top level” (on top of a <code>struct</code>, <code>enum</code> or <code>enum</code> variant)
and/or on “field-level” (on top of a <code>struct</code> field or <em>inside</em> of an enum variant).
Top level (non-magical) methods correspond to <code>App::method</code> calls, field-level methods
are <code>Arg::method</code> calls.</p>

<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore"><code><span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">top_level</span>)]</span>
<span class="kw">struct</span> <span class="ident">Foo</span> {
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">field_level</span>)]</span>
    <span class="ident">field</span>: <span class="ident">u32</span>
}

<span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">top_level</span>)]</span>
<span class="kw">enum</span> <span class="ident">Bar</span> {
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">top_level</span>)]</span>
    <span class="ident">Pineapple</span> {
        <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">field_level</span>)]</span>
        <span class="ident">chocolate</span>: <span class="ident">String</span>
    },

    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">top_level</span>)]</span>
    <span class="ident">Orange</span>,
}</code></pre></div>
<ul>
<li>
<p><code>name</code>: <code>[name = expr]</code></p>
<ul>
<li>
<p>On top level: <code>App::new(expr)</code>.</p>
<p>The binary name displayed in help messages. Defaults to the crate name given by Cargo.</p>
</li>
<li>
<p>On field-level: <code>Arg::with_name(expr)</code>.</p>
<p>The name for the argument the field stands for, this name appears in help messages.
Defaults to a name, deduced from a field, see also
<a href="#specifying-argument-types"><code>rename_all</code></a>.</p>
</li>
</ul>
</li>
<li>
<p><code>version</code>: <code>[version = &quot;version&quot;]</code></p>
<p>Usable only on top level: <code>App::version(&quot;version&quot; or env!(CARGO_PKG_VERSION))</code>.</p>
<p>The version displayed in help messages.
Defaults to the crate version given by Cargo. If <code>CARGO_PKG_VERSION</code> is not
set no <code>.version()</code> calls will be generated unless requested.</p>
</li>
<li>
<p><code>no_version</code>: <code>no_version</code></p>
<p>Usable only on top level. Prevents default <code>App::version</code> call, i.e
when no <code>version = &quot;version&quot;</code> mentioned.</p>
</li>
<li>
<p><code>author</code>: <code>author [= &quot;author&quot;]</code></p>
<p>Usable only on top level: <code>App::author(&quot;author&quot; or env!(CARGO_PKG_AUTHORS))</code>.</p>
<p>Author/maintainer of the binary, this name appears in help messages.
Defaults to the crate author given by cargo, but only when <code>author</code> explicitly mentioned.</p>
</li>
<li>
<p><code>about</code>: <code>about [= &quot;about&quot;]</code></p>
<p>Usable only on top level: <code>App::about(&quot;about&quot; or env!(CARGO_PKG_DESCRIPTION))</code>.</p>
<p>Short description of the binary, appears in help messages.
Defaults to the crate description given by cargo,
but only when <code>about</code> explicitly mentioned.</p>
</li>
<li>
<p><a href="#specifying-argument-types"><code>short</code></a>: <code>short [= &quot;short-opt-name&quot;]</code></p>
<p>Usable only on field-level.</p>
</li>
<li>
<p><a href="#specifying-argument-types"><code>long</code></a>: <code>long [= &quot;long-opt-name&quot;]</code></p>
<p>Usable only on field-level.</p>
</li>
<li>
<p><a href="#default-values"><code>default_value</code></a>: <code>default_value [= &quot;default value&quot;]</code></p>
<p>Usable only on field-level.</p>
</li>
<li>
<p><a href="#specifying-argument-types"><code>rename_all</code></a>:
[<code>rename_all = &quot;kebab&quot;/&quot;snake&quot;/&quot;screaming-snake&quot;/&quot;camel&quot;/&quot;pascal&quot;/&quot;verbatim&quot;/&quot;lower&quot;/&quot;upper&quot;]</code></p>
<p>Usable both on top level and field level.</p>
</li>
<li>
<p><a href="#custom-string-parsers"><code>parse</code></a>: <code>parse(type [= path::to::parser::fn])</code></p>
<p>Usable only on field-level.</p>
</li>
<li>
<p><a href="#skipping-fields"><code>skip</code></a>: <code>skip [= expr]</code></p>
<p>Usable only on field-level.</p>
</li>
<li>
<p><a href="#flattening"><code>flatten</code></a>: <code>flatten</code></p>
<p>Usable on field-level or single-typed tuple variants.</p>
</li>
<li>
<p><a href="#subcommands"><code>subcommand</code></a>: <code>subcommand</code></p>
<p>Usable only on field-level.</p>
</li>
<li>
<p><a href="#external-subcommands"><code>external_subcommand</code></a></p>
<p>Usable only on enum variants.</p>
</li>
<li>
<p><a href="#environment-variable-fallback"><code>env</code></a>: <code>env [= str_literal]</code></p>
<p>Usable only on field-level.</p>
</li>
<li>
<p><a href="#auto-deriving-environment-variables"><code>rename_all_env</code></a>:
[<code>rename_all_env = &quot;kebab&quot;/&quot;snake&quot;/&quot;screaming-snake&quot;/&quot;camel&quot;/&quot;pascal&quot;/&quot;verbatim&quot;/&quot;lower&quot;/&quot;upper&quot;]</code></p>
<p>Usable both on top level and field level.</p>
</li>
<li>
<p><a href="#doc-comment-preprocessing-and-structoptverbatim_doc_comment"><code>verbatim_doc_comment</code></a>:
<code>verbatim_doc_comment</code></p>
<p>Usable both on top level and field level.</p>
</li>
</ul>
<h3 id="type-magic"><a href="#type-magic">Type magic</a></h3>
<p>One of major things that makes <code>structopt</code> so awesome is its type magic.
Do you want optional positional argument? Use <code>Option&lt;T&gt;</code>! Or perhaps optional argument
that optionally takes value (<code>[--opt=[val]]</code>)? Use <code>Option&lt;Option&lt;T&gt;&gt;</code>!</p>
<p>Here is the table of types and <code>clap</code> methods they correspond to:</p>
<div><table><thead><tr><th>Type</th><th>Effect</th><th>Added method call to <code>clap::Arg</code></th></tr></thead><tbody>
<tr><td><code>bool</code></td><td><code>true</code> if the flag is present</td><td><code>.takes_value(false).multiple(false)</code></td></tr>
<tr><td><code>Option&lt;T: FromStr&gt;</code></td><td>optional positional argument or option</td><td><code>.takes_value(true).multiple(false)</code></td></tr>
<tr><td><code>Option&lt;Option&lt;T: FromStr&gt;&gt;</code></td><td>optional option with optional value</td><td><code>.takes_value(true).multiple(false).min_values(0).max_values(1)</code></td></tr>
<tr><td><code>Vec&lt;T: FromStr&gt;</code></td><td>list of options or the other positional arguments</td><td><code>.takes_value(true).multiple(true)</code></td></tr>
<tr><td><code>Option&lt;Vec&lt;T: FromStr&gt;</code></td><td>optional list of options</td><td><code>.takes_values(true).multiple(true).min_values(0)</code></td></tr>
<tr><td><code>T: FromStr</code></td><td>required option or positional argument</td><td><code>.takes_value(true).multiple(false).required(!has_default)</code></td></tr>
</tbody></table>
</div>
<p>The <code>FromStr</code> trait is used to convert the argument to the given
type, and the <code>Arg::validator</code> method is set to a method using
<code>to_string()</code> (<code>FromStr::Err</code> must implement <code>std::fmt::Display</code>).
If you would like to use a custom string parser other than <code>FromStr</code>, see
the <a href="#custom-string-parsers">same titled section</a> below.</p>
<p><strong>Important:</strong></p>
<hr />
<p>Pay attention that <em>only literal occurrence</em> of this types is special, for example
<code>Option&lt;T&gt;</code> is special while <code>::std::option::Option&lt;T&gt;</code> is not.</p>
<p>If you need to avoid special casing you can make a <code>type</code> alias and
use it in place of the said type.</p>
<hr />
<p><strong>Note:</strong></p>
<hr />
<p><code>bool</code> cannot be used as positional argument unless you provide an explicit parser.
If you need a positional bool, for example to parse <code>true</code> or <code>false</code>, you must
annotate the field with explicit <a href="#custom-string-parsers"><code>#[structopt(parse(...))]</code></a>.</p>
<hr />
<p>Thus, the <code>speed</code> argument is generated as:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="ident">clap::Arg::with_name</span>(<span class="string">&quot;speed&quot;</span>)
    .<span class="ident">takes_value</span>(<span class="bool-val">true</span>)
    .<span class="ident">multiple</span>(<span class="bool-val">false</span>)
    .<span class="ident">required</span>(<span class="bool-val">false</span>)
    .<span class="ident">validator</span>(<span class="ident">parse_validator</span>::<span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span>)
    .<span class="ident">short</span>(<span class="string">&quot;v&quot;</span>)
    .<span class="ident">long</span>(<span class="string">&quot;velocity&quot;</span>)
    .<span class="ident">help</span>(<span class="string">&quot;Set speed&quot;</span>)
    .<span class="ident">default_value</span>(<span class="string">&quot;42&quot;</span>);</code></pre></div>
<h3 id="specifying-argument-types"><a href="#specifying-argument-types">Specifying argument types</a></h3>
<p>There are three types of arguments that can be supplied to each
(sub-)command:</p>
<ul>
<li>short (e.g. <code>-h</code>),</li>
<li>long (e.g. <code>--help</code>)</li>
<li>and positional.</li>
</ul>
<p>Like clap, structopt defaults to creating positional arguments.</p>
<p>If you want to generate a long argument you can specify either
<code>long = $NAME</code>, or just <code>long</code> to get a long flag generated using
the field name.  The generated casing style can be modified using
the <code>rename_all</code> attribute. See the <code>rename_all</code> example for more.</p>
<p>For short arguments, <code>short</code> will use the first letter of the
field name by default, but just like the long option it’s also
possible to use a custom letter through <code>short = $LETTER</code>.</p>
<p>If an argument is renamed using <code>name = $NAME</code> any following call to
<code>short</code> or <code>long</code> will use the new name.</p>
<p><strong>Attention</strong>: If these arguments are used without an explicit name
the resulting flag is going to be renamed using <code>kebab-case</code> if the
<code>rename_all</code> attribute was not specified previously. The same is true
for subcommands with implicit naming through the related data structure.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">structopt::StructOpt</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">StructOpt</span>)]</span>
<span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">rename_all</span> <span class="op">=</span> <span class="string">&quot;kebab-case&quot;</span>)]</span>
<span class="kw">struct</span> <span class="ident">Opt</span> {
    <span class="doccomment">/// This option can be specified with something like `--foo-option</span>
    <span class="doccomment">/// value` or `--foo-option=value`</span>
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">long</span>)]</span>
    <span class="ident">foo_option</span>: <span class="ident">String</span>,

    <span class="doccomment">/// This option can be specified with something like `-b value` (but</span>
    <span class="doccomment">/// not `--bar-option value`).</span>
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">short</span>)]</span>
    <span class="ident">bar_option</span>: <span class="ident">String</span>,

    <span class="doccomment">/// This option can be specified either `--baz value` or `-z value`.</span>
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">short</span> <span class="op">=</span> <span class="string">&quot;z&quot;</span>, <span class="ident">long</span> <span class="op">=</span> <span class="string">&quot;baz&quot;</span>)]</span>
    <span class="ident">baz_option</span>: <span class="ident">String</span>,

    <span class="doccomment">/// This option can be specified either by `--custom value` or</span>
    <span class="doccomment">/// `-c value`.</span>
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">name</span> <span class="op">=</span> <span class="string">&quot;custom&quot;</span>, <span class="ident">long</span>, <span class="ident">short</span>)]</span>
    <span class="ident">custom_option</span>: <span class="ident">String</span>,

    <span class="doccomment">/// This option is positional, meaning it is the first unadorned string</span>
    <span class="doccomment">/// you provide (multiple others could follow).</span>
    <span class="ident">my_positional</span>: <span class="ident">String</span>,

    <span class="doccomment">/// This option is skipped and will be filled with the default value</span>
    <span class="doccomment">/// for its type (in this case 0).</span>
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">skip</span>)]</span>
    <span class="ident">skipped</span>: <span class="ident">u32</span>,
}
</code></pre></div>
<h3 id="default-values"><a href="#default-values">Default values</a></h3>
<p>In clap, default values for options can be specified via <a href="https://docs.rs/clap/2.33.0/clap/struct.Arg.html#method.default_value"><code>Arg::default_value</code></a>.</p>
<p>Of course, you can use as a raw method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">derive</span>(<span class="ident">StructOpt</span>)]</span>
<span class="kw">struct</span> <span class="ident">Opt</span> {
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">default_value</span> <span class="op">=</span> <span class="string">&quot;&quot;</span>, <span class="ident">long</span>)]</span>
    <span class="ident">prefix</span>: <span class="ident">String</span>,
}</code></pre></div>
<p>This is quite mundane and error-prone to type the <code>&quot;...&quot;</code> default by yourself,
especially when the Rust ecosystem uses the <a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> trait for that.
It would be wonderful to have <code>structopt</code> to take the <code>Default_default</code> and fill it
for you. And yes, <code>structopt</code> can do that.</p>
<p>Unfortunately, <code>default_value</code> takes <code>&amp;str</code> but <code>Default::default</code>
gives us some <code>Self</code> value. We need to map <code>Self</code> to <code>&amp;str</code> somehow.</p>
<p><code>structopt</code> solves this problem via <a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a> trait.</p>
<p>To be able to use auto-default the type must implement <em>both</em> <code>Default</code> and <code>ToString</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">derive</span>(<span class="ident">StructOpt</span>)]</span>
<span class="kw">struct</span> <span class="ident">Opt</span> {
    <span class="comment">// just leave the `= &quot;...&quot;` part and structopt will figure it for you</span>
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">default_value</span>, <span class="ident">long</span>)]</span>
    <span class="ident">prefix</span>: <span class="ident">String</span>, <span class="comment">// `String` implements both `Default` and `ToString`</span>
}</code></pre></div>
<h3 id="help-messages"><a href="#help-messages">Help messages</a></h3>
<p>In clap, help messages for the whole binary can be specified
via <a href="https://docs.rs/clap/2/clap/struct.App.html#method.about"><code>App::about</code></a> and <a href="https://docs.rs/clap/2/clap/struct.App.html#method.long_about"><code>App::long_about</code></a> while help messages
for individual arguments can be specified via <a href="https://docs.rs/clap/2/clap/struct.Arg.html#method.help"><code>Arg::help</code></a> and <a href="https://docs.rs/clap/2/clap/struct.Arg.html#method.long_help"><code>Arg::long_help</code></a>“.</p>
<p><code>long_*</code> variants are used when user calls the program with
<code>--help</code> and “short” variants are used with <code>-h</code> flag. In <code>structopt</code>,
you can use them via <a href="#raw-methods">raw methods</a>, for example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">StructOpt</span>)]</span>
<span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">about</span> <span class="op">=</span> <span class="string">&quot;I am a program and I work, just pass `-h`&quot;</span>)]</span>
<span class="kw">struct</span> <span class="ident">Foo</span> {
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">short</span>, <span class="ident">help</span> <span class="op">=</span> <span class="string">&quot;Pass `-h` and you&#39;ll see me!&quot;</span>)]</span>
    <span class="ident">bar</span>: <span class="ident">String</span>,
}</code></pre></div>
<p>For convenience, doc comments can be used instead of raw methods
(this example works exactly like the one above):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">StructOpt</span>)]</span>
<span class="doccomment">/// I am a program and I work, just pass `-h`</span>
<span class="kw">struct</span> <span class="ident">Foo</span> {
    <span class="doccomment">/// Pass `-h` and you&#39;ll see me!</span>
    <span class="ident">bar</span>: <span class="ident">String</span>,
}</code></pre></div>
<p>Doc comments on <a href="#magical-methods">top-level</a> will be turned into
<code>App::about/long_about</code> call (see below), doc comments on field-level are
<code>Arg::help/long_help</code> calls.</p>
<p><strong>Important:</strong></p>
<hr />
<p>Raw methods have priority over doc comments!</p>
<p><strong>Top level doc comments always generate <code>App::about/long_about</code> calls!</strong>
If you really want to use the <code>App::help/long_help</code> methods (you likely don’t),
use a raw method to override the <code>App::about</code> call generated from the doc comment.</p>
<hr />
<h4 id="long_help-and---help"><a href="#long_help-and---help"><code>long_help</code> and <code>--help</code></a></h4>
<p>A message passed to <a href="https://docs.rs/clap/2/clap/struct.App.html#method.long_about"><code>App::long_about</code></a> or <a href="https://docs.rs/clap/2/clap/struct.Arg.html#method.long_help"><code>Arg::long_help</code></a> will be displayed whenever
your program is called with <code>--help</code> instead of <code>-h</code>. Of course, you can
use them via raw methods as described <a href="#help-messages">above</a>.</p>
<p>The more convenient way is to use a so-called “long” doc comment:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">derive</span>(<span class="ident">StructOpt</span>)]</span>
<span class="doccomment">/// Hi there, I&#39;m Robo!</span>
<span class="doccomment">///</span>
<span class="doccomment">/// I like beeping, stumbling, eating your electricity,</span>
<span class="doccomment">/// and making records of you singing in a shower.</span>
<span class="doccomment">/// Pay up, or I&#39;ll upload it to youtube!</span>
<span class="kw">struct</span> <span class="ident">Robo</span> {
    <span class="doccomment">/// Call my brother SkyNet.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// I am artificial superintelligence. I won&#39;t rest</span>
    <span class="doccomment">/// until I&#39;ll have destroyed humanity. Enjoy your</span>
    <span class="doccomment">/// pathetic existence, you mere mortals.</span>
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">long</span>)]</span>
    <span class="ident">kill_all_humans</span>: <span class="ident">bool</span>,
}</code></pre></div>
<p>A long doc comment consists of three parts:</p>
<ul>
<li>Short summary</li>
<li>A blank line (whitespace only)</li>
<li>Detailed description, all the rest</li>
</ul>
<p>In other words, “long” doc comment consists of two or more paragraphs,
with the first being a summary and the rest being the detailed description.</p>
<p><strong>A long comment will result in two method calls</strong>, <code>help(&lt;summary&gt;)</code> and
<code>long_help(&lt;whole comment&gt;)</code>, so clap will display the summary with <code>-h</code>
and the whole help message on <code>--help</code> (see below).</p>
<p>So, the example above will be turned into this (details omitted):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="ident">clap::App::new</span>(<span class="string">&quot;&lt;name&gt;&quot;</span>)
    .<span class="ident">about</span>(<span class="string">&quot;Hi there, I&#39;m Robo!&quot;</span>)
    .<span class="ident">long_about</span>(<span class="string">&quot;Hi there, I&#39;m Robo!\n\n\
                 I like beeping, stumbling, eating your electricity,\
                 and making records of you singing in a shower.\
                 Pay up or I&#39;ll upload it to youtube!&quot;</span>)
<span class="comment">// args...</span></code></pre></div>
<h4 id="-h-vs---help-aka-help-vs-long_help"><a href="#-h-vs---help-aka-help-vs-long_help"><code>-h</code> vs <code>--help</code> (A.K.A <code>help()</code> vs <code>long_help()</code>)</a></h4>
<p>The <code>-h</code> flag is not the same as <code>--help</code>.</p>
<p>-h corresponds to <code>Arg::help/App::about</code> and requests short “summary” messages
while –help corresponds to <code>Arg::long_help/App::long_about</code> and requests more
detailed, descriptive messages.</p>
<p>It is entirely up to <code>clap</code> what happens if you used only one of
<a href="https://docs.rs/clap/2/clap/struct.Arg.html#method.help"><code>Arg::help</code></a>/<a href="https://docs.rs/clap/2/clap/struct.Arg.html#method.long_help"><code>Arg::long_help</code></a>, see <code>clap</code>’s documentation for these methods.</p>
<p>As of clap v2.33, if only a short message (<a href="https://docs.rs/clap/2/clap/struct.Arg.html#method.help"><code>Arg::help</code></a>) or only
a long (<a href="https://docs.rs/clap/2/clap/struct.Arg.html#method.long_help"><code>Arg::long_help</code></a>) message is provided, clap will use it
for both -h and –help. The same logic applies to <code>about/long_about</code>.</p>
<h4 id="doc-comment-preprocessing-and-structoptverbatim_doc_comment"><a href="#doc-comment-preprocessing-and-structoptverbatim_doc_comment">Doc comment preprocessing and <code>#[structopt(verbatim_doc_comment)]</code></a></h4>
<p><code>structopt</code> applies some preprocessing to doc comments to ease the most common uses:</p>
<ul>
<li>
<p>Strip leading and trailing whitespace from every line, if present.</p>
</li>
<li>
<p>Strip leading and trailing blank lines, if present.</p>
</li>
<li>
<p>Interpret each group of non-empty lines as a word-wrapped paragraph.</p>
<p>We replace newlines within paragraphs with spaces to allow the output
to be re-wrapped to the terminal width.</p>
</li>
<li>
<p>Strip any excess blank lines so that there is exactly one per paragraph break.</p>
</li>
<li>
<p>If the first paragraph ends in exactly one period,
remove the trailing period (i.e. strip trailing periods but not trailing ellipses).</p>
</li>
</ul>
<p>Sometimes you don’t want this preprocessing to apply, for example the comment contains
some ASCII art or markdown tables, you would need to preserve LFs along with
blank lines and the leading/trailing whitespace. You can ask <code>structopt</code> to preserve them
via <code>#[structopt(verbatim_doc_comment)]</code> attribute.</p>
<p><strong>This attribute must be applied to each field separately</strong>, there’s no global switch.</p>
<p><strong>Important:</strong></p>
<hr />
<p>Keep in mind that <code>structopt</code> will <em>still</em> remove one leading space from each
line, even if this attribute is present, to allow for a space between
<code>///</code> and the content.</p>
<p>Also, <code>structopt</code> will <em>still</em> remove leading and trailing blank lines so
these formats are equivalent:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/** This is a doc comment

Hello! */</span>

<span class="doccomment">/**
This is a doc comment

Hello!
*/</span>

<span class="doccomment">/// This is a doc comment</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Hello!</span></code></pre></div>
<hr />
<h3 id="environment-variable-fallback"><a href="#environment-variable-fallback">Environment variable fallback</a></h3>
<p>It is possible to specify an environment variable fallback option for an arguments
so that its value is taken from the specified environment variable if not
given through the command-line:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">StructOpt</span>)]</span>
<span class="kw">struct</span> <span class="ident">Foo</span> {
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">short</span>, <span class="ident">long</span>, <span class="ident">env</span> <span class="op">=</span> <span class="string">&quot;PARAMETER_VALUE&quot;</span>)]</span>
    <span class="ident">parameter_value</span>: <span class="ident">String</span>,
}</code></pre></div>
<p>By default, values from the environment are shown in the help output (i.e. when invoking
<code>--help</code>):</p>
<div class="example-wrap"><pre class="language-shell"><code>$ cargo run -- --help
...
OPTIONS:
  -p, --parameter-value &lt;parameter-value&gt;     [env: PARAMETER_VALUE=env_value]</code></pre></div>
<p>In some cases this may be undesirable, for example when being used for passing
credentials or secret tokens. In those cases you can use <code>hide_env_values</code> to avoid
having structopt emit the actual secret values:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">StructOpt</span>)]</span>
<span class="kw">struct</span> <span class="ident">Foo</span> {
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">long</span> <span class="op">=</span> <span class="string">&quot;secret&quot;</span>, <span class="ident">env</span> <span class="op">=</span> <span class="string">&quot;SECRET_VALUE&quot;</span>, <span class="ident">hide_env_values</span> <span class="op">=</span> <span class="bool-val">true</span>)]</span>
    <span class="ident">secret_value</span>: <span class="ident">String</span>,
}</code></pre></div>
<h4 id="auto-deriving-environment-variables"><a href="#auto-deriving-environment-variables">Auto-deriving environment variables</a></h4>
<p>Environment variables tend to be called after the corresponding <code>struct</code>’s field,
as in example above. The field is <code>secret_value</code> and the env var is “SECRET_VALUE”;
the name is the same, except casing is different.</p>
<p>It’s pretty tedious and error-prone to type the same name twice,
so you can ask <code>structopt</code> to do that for you.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">StructOpt</span>)]</span>
<span class="kw">struct</span> <span class="ident">Foo</span> {
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">long</span> <span class="op">=</span> <span class="string">&quot;secret&quot;</span>, <span class="ident">env</span>)]</span>
    <span class="ident">secret_value</span>: <span class="ident">String</span>,
}</code></pre></div>
<p>It works just like <code>#[structopt(short/long)]</code>: if <code>env</code> is not set to some concrete
value the value will be derived from the field’s name. This is controlled by
<code>#[structopt(rename_all_env)]</code>.</p>
<p><code>rename_all_env</code> works exactly as <code>rename_all</code> (including overriding)
except default casing is <code>SCREAMING_SNAKE_CASE</code> instead of <code>kebab-case</code>.</p>
<h3 id="skipping-fields"><a href="#skipping-fields">Skipping fields</a></h3>
<p>Sometimes you may want to add a field to your <code>Opt</code> struct that is not
a command line option and <code>clap</code> should know nothing about it. You can ask
<code>structopt</code> to skip the field entirely via <code>#[structopt(skip = value)]</code>
(<code>value</code> must implement <code>Into&lt;FieldType&gt;</code>)
or <code>#[structopt(skip)]</code> if you want assign the field with <code>Default::default()</code>
(obviously, the field’s type must implement <code>Default</code>).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">derive</span>(<span class="ident">StructOpt</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Opt</span> {
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">long</span>, <span class="ident">short</span>)]</span>
    <span class="ident">number</span>: <span class="ident">u32</span>,

    <span class="comment">// these fields are to be assigned with Default::default()</span>

    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">skip</span>)]</span>
    <span class="ident">k</span>: <span class="ident">String</span>,
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">skip</span>)]</span>
    <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>,

    <span class="comment">// these fields get set explicitly</span>

    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">skip</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span>)]
    <span class="ident">k2</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">skip</span> <span class="op">=</span> <span class="string">&quot;cake&quot;</span>)]</span> <span class="comment">// &amp;str implements Into&lt;String&gt;</span>
    <span class="ident">v2</span>: <span class="ident">String</span>,
}</code></pre></div>
<h3 id="subcommands"><a href="#subcommands">Subcommands</a></h3>
<p>Some applications, especially large ones, split their functionality
through the use of “subcommands”. Each of these act somewhat like a separate
command, but is part of the larger group.
One example is <code>git</code>, which has subcommands such as <code>add</code>, <code>commit</code>,
and <code>clone</code>, to mention just a few.</p>
<p><code>clap</code> has this functionality, and <code>structopt</code> supports it through enums:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">StructOpt</span>)]</span>
<span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">about</span> <span class="op">=</span> <span class="string">&quot;the stupid content tracker&quot;</span>)]</span>
<span class="kw">enum</span> <span class="ident">Git</span> {
    <span class="ident">Add</span> {
        <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">short</span>)]</span>
        <span class="ident">interactive</span>: <span class="ident">bool</span>,
        <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">short</span>)]</span>
        <span class="ident">patch</span>: <span class="ident">bool</span>,
        <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">parse</span>(<span class="ident">from_os_str</span>))]</span>
        <span class="ident">files</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">PathBuf</span><span class="op">&gt;</span>,
    },
    <span class="ident">Fetch</span> {
        <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">long</span>)]</span>
        <span class="ident">dry_run</span>: <span class="ident">bool</span>,
        <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">long</span>)]</span>
        <span class="ident">all</span>: <span class="ident">bool</span>,
        <span class="ident">repository</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>,
    },
    <span class="ident">Commit</span> {
        <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">short</span>)]</span>
        <span class="ident">message</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>,
        <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">short</span>)]</span>
        <span class="ident">all</span>: <span class="ident">bool</span>,
    },
}</code></pre></div>
<p>Using <code>derive(StructOpt)</code> on an enum instead of a struct will produce
a <code>clap::App</code> that only takes subcommands. So <code>git add</code>, <code>git fetch</code>,
and <code>git commit</code> would be commands allowed for the above example.</p>
<p><code>structopt</code> also provides support for applications where certain flags
need to apply to all subcommands, as well as nested subcommands:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">derive</span>(<span class="ident">StructOpt</span>)]</span>
<span class="kw">struct</span> <span class="ident">MakeCookie</span> {
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">name</span> <span class="op">=</span> <span class="string">&quot;supervisor&quot;</span>, <span class="ident">default_value</span> <span class="op">=</span> <span class="string">&quot;Puck&quot;</span>, <span class="ident">long</span> <span class="op">=</span> <span class="string">&quot;supervisor&quot;</span>)]</span>
    <span class="ident">supervising_faerie</span>: <span class="ident">String</span>,
    <span class="doccomment">/// The faerie tree this cookie is being made in.</span>
    <span class="ident">tree</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">subcommand</span>)]</span> <span class="comment">// Note that we mark a field as a subcommand</span>
    <span class="ident">cmd</span>: <span class="ident">Command</span>,
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">StructOpt</span>)]</span>
<span class="kw">enum</span> <span class="ident">Command</span> {
    <span class="doccomment">/// Pound acorns into flour for cookie dough.</span>
    <span class="ident">Pound</span> {
        <span class="ident">acorns</span>: <span class="ident">u32</span>,
    },
    <span class="doccomment">/// Add magical sparkles -- the secret ingredient!</span>
    <span class="ident">Sparkle</span> {
        <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">short</span>, <span class="ident">parse</span>(<span class="ident">from_occurrences</span>))]</span>
        <span class="ident">magicality</span>: <span class="ident">u64</span>,
        <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">short</span>)]</span>
        <span class="ident">color</span>: <span class="ident">String</span>,
    },
    <span class="ident">Finish</span>(<span class="ident">Finish</span>),
}

<span class="comment">// Subcommand can also be externalized by using a 1-uple enum variant</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">StructOpt</span>)]</span>
<span class="kw">struct</span> <span class="ident">Finish</span> {
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">short</span>)]</span>
    <span class="ident">time</span>: <span class="ident">u32</span>,
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">subcommand</span>)]</span> <span class="comment">// Note that we mark a field as a subcommand</span>
    <span class="ident">finish_type</span>: <span class="ident">FinishType</span>,
}

<span class="comment">// subsubcommand!</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">StructOpt</span>)]</span>
<span class="kw">enum</span> <span class="ident">FinishType</span> {
    <span class="ident">Glaze</span> {
        <span class="ident">applications</span>: <span class="ident">u32</span>,
    },
    <span class="ident">Powder</span> {
        <span class="ident">flavor</span>: <span class="ident">String</span>,
        <span class="ident">dips</span>: <span class="ident">u32</span>,
    }
}</code></pre></div>
<p>Marking a field with <code>structopt(subcommand)</code> will add the subcommands of the
designated enum to the current <code>clap::App</code>. The designated enum <em>must</em> also
be derived <code>StructOpt</code>. So the above example would take the following
commands:</p>
<ul>
<li><code>make-cookie pound 50</code></li>
<li><code>make-cookie sparkle -mmm --color &quot;green&quot;</code></li>
<li><code>make-cookie finish 130 glaze 3</code></li>
</ul>
<h4 id="optional-subcommands"><a href="#optional-subcommands">Optional subcommands</a></h4>
<p>Subcommands may be optional:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">derive</span>(<span class="ident">StructOpt</span>)]</span>
<span class="kw">struct</span> <span class="ident">Foo</span> {
    <span class="ident">file</span>: <span class="ident">String</span>,
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">subcommand</span>)]</span>
    <span class="ident">cmd</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Command</span><span class="op">&gt;</span>,
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">StructOpt</span>)]</span>
<span class="kw">enum</span> <span class="ident">Command</span> {
    <span class="ident">Bar</span>,
    <span class="ident">Baz</span>,
    <span class="ident">Quux</span>,
}</code></pre></div>
<h4 id="external-subcommands"><a href="#external-subcommands">External subcommands</a></h4>
<p>Sometimes you want to support not only the set of well-known subcommands
but you also want to allow other, user-driven subcommands. <code>clap</code> supports
this via <a href="https://docs.rs/clap/2.32.0/clap/enum.AppSettings.html#variant.AllowExternalSubcommands"><code>AppSettings::AllowExternalSubcommands</code></a>.</p>
<p><code>structopt</code> provides it’s own dedicated syntax for that:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">PartialEq</span>, <span class="ident">StructOpt</span>)]</span>
<span class="kw">struct</span> <span class="ident">Opt</span> {
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">subcommand</span>)]</span>
    <span class="ident">sub</span>: <span class="ident">Subcommands</span>,
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">PartialEq</span>, <span class="ident">StructOpt</span>)]</span>
<span class="kw">enum</span> <span class="ident">Subcommands</span> {
    <span class="comment">// normal subcommand</span>
    <span class="ident">Add</span>,

    <span class="comment">// `external_subcommand` tells structopt to put</span>
    <span class="comment">// all the extra arguments into this Vec</span>
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">external_subcommand</span>)]</span>
    <span class="ident">Other</span>(<span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>),
}

<span class="comment">// normal subcommand</span>
<span class="macro">assert_eq!</span>(
    <span class="ident">Opt::from_iter</span>(<span class="kw-2">&amp;</span>[<span class="string">&quot;test&quot;</span>, <span class="string">&quot;add&quot;</span>]),
    <span class="ident">Opt</span> {
        <span class="ident">sub</span>: <span class="ident">Subcommands::Add</span>
    }
);

<span class="macro">assert_eq!</span>(
    <span class="ident">Opt::from_iter</span>(<span class="kw-2">&amp;</span>[<span class="string">&quot;test&quot;</span>, <span class="string">&quot;git&quot;</span>, <span class="string">&quot;status&quot;</span>]),
    <span class="ident">Opt</span> {
        <span class="ident">sub</span>: <span class="ident">Subcommands::Other</span>(<span class="macro">vec!</span>[<span class="string">&quot;git&quot;</span>.<span class="ident">into</span>(), <span class="string">&quot;status&quot;</span>.<span class="ident">into</span>()])
    }
);

<span class="comment">// Please note that if you&#39;d wanted to allow &quot;no subcommands at all&quot; case</span>
<span class="comment">// you should have used `sub: Option&lt;Subcommands&gt;` above</span>
<span class="macro">assert!</span>(<span class="ident">Opt::from_iter_safe</span>(<span class="kw-2">&amp;</span>[<span class="string">&quot;test&quot;</span>]).<span class="ident">is_err</span>());</code></pre></div>
<p>In other words, you just add an extra tuple variant marked with
<code>#[structopt(subcommand)]</code>, and its type must be either
<code>Vec&lt;String&gt;</code> or <code>Vec&lt;OsString&gt;</code>. <code>structopt</code> will detect <code>String</code> in this context
and use appropriate <code>clap</code> API.</p>
<h4 id="flattening-subcommands"><a href="#flattening-subcommands">Flattening subcommands</a></h4>
<p>It is also possible to combine multiple enums of subcommands into one.
All the subcommands will be on the same level.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">derive</span>(<span class="ident">StructOpt</span>)]</span>
<span class="kw">enum</span> <span class="ident">BaseCli</span> {
    <span class="ident">Ghost10</span> {
        <span class="ident">arg1</span>: <span class="ident">i32</span>,
    }
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">StructOpt</span>)]</span>
<span class="kw">enum</span> <span class="ident">Opt</span> {
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">flatten</span>)]</span>
    <span class="ident">BaseCli</span>(<span class="ident">BaseCli</span>),
    <span class="ident">Dex</span> {
        <span class="ident">arg2</span>: <span class="ident">i32</span>,
    },
}</code></pre></div>
<div class="example-wrap"><pre class="language-shell"><code>cli ghost10 42
cli dex 42</code></pre></div><h3 id="flattening"><a href="#flattening">Flattening</a></h3>
<p>It can sometimes be useful to group related arguments in a substruct,
while keeping the command-line interface flat. In these cases you can mark
a field as <code>flatten</code> and give it another type that derives <code>StructOpt</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">derive</span>(<span class="ident">StructOpt</span>)]</span>
<span class="kw">struct</span> <span class="ident">Cmdline</span> {
    <span class="doccomment">/// switch on verbosity</span>
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">short</span>)]</span>
    <span class="ident">verbose</span>: <span class="ident">bool</span>,
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">flatten</span>)]</span>
    <span class="ident">daemon_opts</span>: <span class="ident">DaemonOpts</span>,
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">StructOpt</span>)]</span>
<span class="kw">struct</span> <span class="ident">DaemonOpts</span> {
    <span class="doccomment">/// daemon user</span>
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">short</span>)]</span>
    <span class="ident">user</span>: <span class="ident">String</span>,
    <span class="doccomment">/// daemon group</span>
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">short</span>)]</span>
    <span class="ident">group</span>: <span class="ident">String</span>,
}</code></pre></div>
<p>In this example, the derived <code>Cmdline</code> parser will support the options <code>-v</code>,
<code>-u</code> and <code>-g</code>.</p>
<p>This feature also makes it possible to define a <code>StructOpt</code> struct in a
library, parse the corresponding arguments in the main argument parser, and
pass off this struct to a handler provided by that library.</p>
<h3 id="custom-string-parsers"><a href="#custom-string-parsers">Custom string parsers</a></h3>
<p>If the field type does not have a <code>FromStr</code> implementation, or you would
like to provide a custom parsing scheme other than <code>FromStr</code>, you may
provide a custom string parser using <code>parse(...)</code> like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::num::ParseIntError</span>;
<span class="kw">use</span> <span class="ident">std::path::PathBuf</span>;

<span class="kw">fn</span> <span class="ident">parse_hex</span>(<span class="ident">src</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">u32</span>, <span class="ident">ParseIntError</span><span class="op">&gt;</span> {
    <span class="ident">u32::from_str_radix</span>(<span class="ident">src</span>, <span class="number">16</span>)
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">StructOpt</span>)]</span>
<span class="kw">struct</span> <span class="ident">HexReader</span> {
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">short</span>, <span class="ident">parse</span>(<span class="ident">try_from_str</span> <span class="op">=</span> <span class="ident">parse_hex</span>))]</span>
    <span class="ident">number</span>: <span class="ident">u32</span>,
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">short</span>, <span class="ident">parse</span>(<span class="ident">from_os_str</span>))]</span>
    <span class="ident">output</span>: <span class="ident">PathBuf</span>,
}</code></pre></div>
<p>There are five kinds of custom parsers:</p>
<div><table><thead><tr><th>Kind</th><th>Signature</th><th>Default</th></tr></thead><tbody>
<tr><td><code>from_str</code></td><td><code>fn(&amp;str) -&gt; T</code></td><td><code>::std::convert::From::from</code></td></tr>
<tr><td><code>try_from_str</code></td><td><code>fn(&amp;str) -&gt; Result&lt;T, E&gt;</code></td><td><code>::std::str::FromStr::from_str</code></td></tr>
<tr><td><code>from_os_str</code></td><td><code>fn(&amp;OsStr) -&gt; T</code></td><td><code>::std::convert::From::from</code></td></tr>
<tr><td><code>try_from_os_str</code></td><td><code>fn(&amp;OsStr) -&gt; Result&lt;T, OsString&gt;</code></td><td>(no default function)</td></tr>
<tr><td><code>from_occurrences</code></td><td><code>fn(u64) -&gt; T</code></td><td><code>value as T</code></td></tr>
<tr><td><code>from_flag</code></td><td><code>fn(bool) -&gt; T</code></td><td><code>::std::convert::From::from</code></td></tr>
</tbody></table>
</div>
<p>The <code>from_occurrences</code> parser is special. Using <code>parse(from_occurrences)</code>
results in the <em>number of flags occurrences</em> being stored in the relevant
field or being passed to the supplied function. In other words, it converts
something like <code>-vvv</code> to <code>3</code>. This is equivalent to
<code>.takes_value(false).multiple(true)</code>. Note that the default parser can only
be used with fields of integer types (<code>u8</code>, <code>usize</code>, <code>i64</code>, etc.).</p>
<p>The <code>from_flag</code> parser is also special. Using <code>parse(from_flag)</code> or
<code>parse(from_flag = some_func)</code> will result in the field being treated as a
flag even if it does not have type <code>bool</code>.</p>
<p>When supplying a custom string parser, <code>bool</code> will not be treated specially:</p>
<div><table><thead><tr><th>Type</th><th>Effect</th><th>Added method call to <code>clap::Arg</code></th></tr></thead><tbody>
<tr><td><code>Option&lt;T&gt;</code></td><td>optional argument</td><td><code>.takes_value(true).multiple(false)</code></td></tr>
<tr><td><code>Vec&lt;T&gt;</code></td><td>list of arguments</td><td><code>.takes_value(true).multiple(true)</code></td></tr>
<tr><td><code>T</code></td><td>required argument</td><td><code>.takes_value(true).multiple(false).required(!has_default)</code></td></tr>
</tbody></table>
</div>
<p>In the <code>try_from_*</code> variants, the function will run twice on valid input:
once to validate, and once to parse. Hence, make sure the function is
side-effect-free.</p>
<h3 id="generics"><a href="#generics">Generics</a></h3>
<p>Generic structs and enums can be used. They require explicit trait bounds
on any generic types that will be used by the <code>StructOpt</code> derive macro. In
some cases, associated types will require additional bounds. See the usage
of <code>FromStr</code> below for an example of this.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">fmt</span>, <span class="ident">str::FromStr</span>};

<span class="comment">// a struct with single custom argument</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">StructOpt</span>)]</span>
<span class="kw">struct</span> <span class="ident">GenericArgs</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">FromStr</span><span class="op">&gt;</span> <span class="kw">where</span> <span class="op">&lt;</span><span class="ident">T</span> <span class="kw">as</span> <span class="ident">FromStr</span><span class="op">&gt;</span><span class="ident">::Err</span>: <span class="ident">fmt::Display</span> <span class="op">+</span> <span class="ident">fmt::Debug</span> {
    <span class="ident">generic_arg_1</span>: <span class="ident">String</span>,
    <span class="ident">generic_arg_2</span>: <span class="ident">String</span>,
    <span class="ident">custom_arg_1</span>: <span class="ident">T</span>,
}</code></pre></div>
<p>or</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// a struct with multiple custom arguments in a substructure</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">StructOpt</span>)]</span>
<span class="kw">struct</span> <span class="ident">GenericArgs</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">StructOpt</span><span class="op">&gt;</span> {
    <span class="ident">generic_arg_1</span>: <span class="ident">String</span>,
    <span class="ident">generic_arg_2</span>: <span class="ident">String</span>,
    <span class="attribute">#[<span class="ident">structopt</span>(<span class="ident">flatten</span>)]</span>
    <span class="ident">custom_args</span>: <span class="ident">T</span>,
}</code></pre></div>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left import-item" id="reexport.clap"><code>pub use <a class="mod" href="https://docs.rs/clap/2.34.0/clap/index.html" title="mod clap">clap</a>;</code></div><div class="item-right docblock-short"></div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.StructOpt.html" title="structopt::StructOpt trait">StructOpt</a></div><div class="item-right docblock-short"><p>A struct that is converted from command line arguments.</p>
</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="structopt" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.63.0 (4b91a6ea7 2022-08-08)" ></div>
</body></html>