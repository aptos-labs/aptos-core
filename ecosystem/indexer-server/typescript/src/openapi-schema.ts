/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/": {
    get: operations["get_ledger_info"];
  };
  "/spec.html": {
    get: operations["get_spec_html"];
  };
  "/openapi.yaml": {
    get: operations["get_spec_yaml"];
  };
  "/tokens/{TokenId}": {
    /** Returns Token by Id */
    get: operations["getTokenById"];
  };
  "/token_metadata/{tokenId}": {
    /** Returns TokenMetaData by Id */
    get: operations["getTokenMetaDataById"];
  };
  "/token_metadata/byIds": {
    /** Returns TokenMetaData by Ids */
    post: operations["getTokenMetaDataByIds"];
  };
  "/tokens/byIds": {
    /** Returns Tokens by Ids */
    post: operations["getTokenByIds"];
  };
  "/ownerships/{ownershipId}": {
    /** Returns ownership by Id */
    get: operations["getOwnershipById"];
  };
  "/collections/{CollectionId}": {
    /** Returns collection by collection id */
    get: operations["getCollectionById"];
  };
  "/activities/byUser": {
    /** Returns activities by user */
    get: operations["getActivitiesByUser"];
  };
}

export interface components {
  schemas: {
    /** Response Error */
    AptosError: {
      code: number;
      message: string;
      aptos_ledger_version?: components["schemas"]["LedgerVersion"];
    };
    /**
     * uint64
     * Format: uint64
     * @description Unsigned int64 type value
     * @example 32425224034
     */
    Uint64: string;
    /**
     * Account Address
     * Format: address
     * @description Hex-encoded 16 bytes Aptos account address.
     *
     * Prefixed with `0x` and leading zeros are trimmed.
     *
     * See [doc](https://diem.github.io/move/address.html) for more details.
     *
     * @example 0xdd
     */
    Address: string;
    /**
     * Hex-encoded Bytes
     * Format: hex
     * @description All bytes data are represented as hex-encoded string prefixed with `0x` and fulfilled with
     * two hex digits per byte.
     *
     * Different with `Address` type, hex-encoded bytes should not trim any zeros.
     *
     * @example 0x88fbd33f54e1126269769780feb24480428179f552e2313fbe571b72e62a1ca1
     */
    HexEncodedBytes: string;
    /**
     * Timestamp in Seconds
     * Format: uint64
     * @description Timestamp in seconds, e.g. transaction expiration timestamp.
     *
     * @example 1635447454
     */
    TimestampSec: string;
    /**
     * Timestamp in Microseconds
     * Format: uint64
     * @description Timestamp in microseconds, e.g. ledger / block creation timestamp.
     *
     * @example 1632507671675208
     */
    TimestampUsec: string;
    /**
     * Ledger Version
     * Format: uint64
     * @description The version of the latest transaction in the ledger.
     *
     * @example 52635485
     */
    LedgerVersion: string;
    /**
     * Event Key
     * Format: hex
     * @description Event key is a global index for an event stream.
     *
     * It is hex-encoded BCS bytes of `EventHandle` `guid` field value, which is
     * a combination of a `uint64` creation number and account address
     * (without trimming leading zeros).
     *
     * For example, event key `0x00000000000000000000000000000000000000000a550c18`
     * is combined by the following 2 parts:
     *   1. `0000000000000000`: `uint64` representation of `0`.
     *   2. `0000000000000000000000000a550c18`: 16 bytes of account address.
     *
     * @example 0x00000000000000000000000000000000000000000a550c18
     */
    EventKey: string;
    /**
     * Event Sequence Number
     * Format: uint64
     * @description Event `sequence_number` is unique id of an event in an event stream.
     * Event `sequence_number` starts from 0 for each event key.
     *
     * @example 23
     */
    EventSequenceNumber: string;
    /** Ledger Information */
    LedgerInfo: {
      /**
       * @description The blockchain chain id.
       *
       * @example 4
       */
      chain_id: number;
      ledger_version: components["schemas"]["LedgerVersion"];
      ledger_timestamp: components["schemas"]["TimestampUsec"];
    };
    /**
     * Account
     * @description Core account resource, used for identifying account and transaction execution.
     * @example [object Object]
     */
    Account: {
      sequence_number: components["schemas"]["Uint64"];
      authentication_key: components["schemas"]["HexEncodedBytes"];
    };
    /**
     * Account Resource
     * @description Account resource is a Move struct value belongs to an account.
     * @example [object Object]
     */
    AccountResource: {
      type: components["schemas"]["MoveStructTagId"];
      /**
       * @description Account resource data is JSON representation of the Move struct `type`.
       *
       * Move struct field name and value are serialized as object property name and value.
       */
      data: { [key: string]: unknown };
    };
    /**
     * Move Type Tag ID
     * @description String representation of an on-chain Move type tag that is exposed in transaction payload.
     *
     * Values:
     *   - bool
     *   - u8
     *   - u64
     *   - u128
     *   - address
     *   - signer
     *   - vector: `vector<{non-reference MoveTypeId}>`
     *   - struct: `{address}::{module_name}::{struct_name}::<{generic types}>`
     *
     * Vector type value examples:
     *   * `vector<u8>`
     *   * `vector<vector<u64>>`
     *   * `vector<0x1::AptosAccount::Balance<0x1::XDX::XDX>>`
     *
     * Struct type value examples:
     *   * `0x1::Aptos::Aptos<0x1::XDX::XDX>`
     *   * `0x1::Abc::Abc<vector<u8>, vector<u64>>`
     *   * `0x1::AptosAccount::AccountOperationsCapability`
     *
     * Note:
     *   1. Empty chars should be ignored when comparing 2 struct tag ids.
     *   2. When used in an URL path, should be encoded by url-encoding (AKA percent-encoding).
     *
     * @example 0x1::XUS::XUS
     */
    MoveTypeTagId: string;
    /**
     * Move Type ID
     * @description String representation of an on-chain Move type identifier defined by the Move language.
     *
     * Values:
     *   - bool
     *   - u8
     *   - u64
     *   - u128
     *   - address
     *   - signer
     *   - vector: `vector<{non-reference MoveTypeId}>`
     *   - struct: `{address}::{module_name}::{struct_name}::<{generic types}>`
     *   - reference: immutable `&` and mutable `&mut` references.
     *   - generic_type_parameter: it is always start with `T` and following an index number,
     *     which is the position of the generic type parameter in the `struct` or
     *     `function` generic type parameters definition.
     *
     * Vector type value examples:
     *   * `vector<u8>`
     *   * `vector<vector<u64>>`
     *   * `vector<0x1::AptosAccount::Balance<0x1::XDX::XDX>>`
     *
     * Struct type value examples:
     *   * `0x1::Aptos::Aptos<0x1::XDX::XDX>`
     *   * `0x1::Abc::Abc<vector<u8>, vector<u64>>`
     *   * `0x1::AptosAccount::AccountOperationsCapability`
     *
     * Reference type value examples:
     *   * `&signer`
     *   * `&mut address`
     *   * `&mut vector<u8>`
     *
     * Generic type parameter value example, the following is `0x1::TransactionFee::TransactionFee` JSON representation:
     *
     *     {
     *         "name": "TransactionFee",
     *         "is_native": false,
     *         "abilities": ["key"],
     *         "generic_type_params": [
     *             {"constraints": [], "is_phantom": true}
     *         ],
     *         "fields": [
     *             { "name": "balance", "type": "0x1::Aptos::Aptos<T0>" },
     *             { "name": "preburn", "type": "0x1::Aptos::Preburn<T0>" }
     *         ]
     *     }
     *
     * It's Move source code:
     *
     *     module AptosFramework::TransactionFee {
     *         struct TransactionFee<phantom CoinType> has key {
     *             balance: Aptos<CoinType>,
     *             preburn: Preburn<CoinType>,
     *         }
     *     }
     *
     * The `T0` in the above JSON representation is the generic type place holder for
     * the `CoinType` in the Move source code.
     *
     * Note:
     *   1. Empty chars should be ignored when comparing 2 struct tag ids.
     *   2. When used in an URL path, should be encoded by url-encoding (AKA percent-encoding).
     *
     * @example 0x1::AptosAccount::Balance<0x1::XUS::XUS>
     */
    MoveTypeId: string;
    /**
     * Move Struct Tag ID
     * Format: move_type
     * @description String representation of an on-chain Move struct type.
     *
     * It is a combination of:
     *   1. `Move module address`, `module name` and `struct name` joined by `::`.
     *   2. `struct generic type parameters` joined by `, `.
     *
     * Examples:
     *   * `0x1::Aptos::Aptos<0x1::XDX::XDX>`
     *   * `0x1::Abc::Abc<vector<u8>, vector<u64>>`
     *   * `0x1::AptosAccount::AccountOperationsCapability`
     *
     * Note:
     *   1. Empty chars should be ignored when comparing 2 struct tag ids.
     *   2. When used in an URL path, should be encoded by url-encoding (AKA percent-encoding).
     *
     * See [doc](https://diem.github.io/move/structs-and-resources.html) for more details.
     *
     * @example 0x1::AptosAccount::Balance<0x1::XUS::XUS>
     */
    MoveStructTagId: string;
    /** Move Module */
    MoveModule: {
      bytecode: components["schemas"]["HexEncodedBytes"];
      abi?: components["schemas"]["MoveModuleABI"];
    };
    /**
     * Move Module ABI
     * @description Move Module ABI is JSON representation of Move module binary interface.
     */
    MoveModuleABI: {
      address: components["schemas"]["Address"];
      /** @example Aptos */
      name: string;
      friends: components["schemas"]["MoveModuleId"][];
      exposed_functions: components["schemas"]["MoveFunction"][];
      structs: components["schemas"]["MoveStruct"][];
    };
    /**
     * Move Struct
     * @example [object Object]
     */
    MoveStruct: {
      name: string;
      is_native: boolean;
      abilities: components["schemas"]["MoveAbility"][];
      generic_type_params: {
        constraints: components["schemas"]["MoveAbility"][];
        is_phantom: boolean;
      }[];
      fields: components["schemas"]["MoveStructField"][];
    };
    /**
     * Move Struct Field
     * @example [object Object]
     */
    MoveStructField: {
      name: string;
      type: components["schemas"]["MoveTypeId"];
    };
    /**
     * Move Function
     * @example [object Object]
     */
    MoveFunction: {
      /** @description Move function name */
      name: string;
      /** @enum {string} */
      visibility: "public" | "script" | "friend";
      generic_type_params: {
        constraints: components["schemas"]["MoveAbility"][];
      }[];
      params: components["schemas"]["MoveTypeId"][];
      return: components["schemas"]["MoveTypeId"][];
    };
    /**
     * Move Ability
     * @description Abilities are a typing feature in Move that control what actions are permissible for values of a given type.
     *
     * See [doc](https://diem.github.io/move/abilities.html) for more details.
     *
     * @example key
     * @enum {string}
     */
    MoveAbility: "copy" | "drop" | "store" | "key";
    /**
     * Move Module ID
     * @description Move module id is a string representation of Move module.
     *
     * Format: "{address}::{module name}"
     *
     * `address` should be hex-encoded 16 bytes account address
     * that is prefixed with `0x` and leading zeros are trimmed.
     *
     * Module name is case-sensitive.
     *
     * See [doc](https://diem.github.io/move/modules-and-scripts.html#modules) for more details.
     *
     * @example 0x1::Aptos
     */
    MoveModuleId: string;
    /** User Transaction Request */
    UserTransactionRequest: {
      sender: components["schemas"]["Address"];
      sequence_number: components["schemas"]["Uint64"];
      max_gas_amount: components["schemas"]["Uint64"];
      gas_unit_price: components["schemas"]["Uint64"];
      /** @example XDX */
      gas_currency_code: string;
      expiration_timestamp_secs: components["schemas"]["TimestampSec"];
      payload: components["schemas"]["TransactionPayload"];
    };
    /**
     * User Transaction Signature
     * @description This schema is used for appending `signature` field to another schema.
     */
    UserTransactionSignature: {
      signature: components["schemas"]["TransactionSignature"];
    };
    Transaction:
      | components["schemas"]["PendingTransaction"]
      | components["schemas"]["GenesisTransaction"]
      | components["schemas"]["UserTransaction"]
      | components["schemas"]["BlockMetadataTransaction"];
    /** Submit Transaction Request */
    SubmitTransactionRequest: components["schemas"]["UserTransactionRequest"] &
      components["schemas"]["UserTransactionSignature"];
    /** Pending Transaction */
    PendingTransaction: {
      /** @example pending_transaction */
      type: string;
      hash: components["schemas"]["HexEncodedBytes"];
    } & components["schemas"]["UserTransactionRequest"] &
      components["schemas"]["UserTransactionSignature"];
    /** On-chain Transaction */
    OnChainTransaction:
      | components["schemas"]["GenesisTransaction"]
      | components["schemas"]["UserTransaction"]
      | components["schemas"]["BlockMetadataTransaction"];
    /** On-chain transaction information */
    OnChainTransactionInfo: {
      version: components["schemas"]["Uint64"];
      hash: components["schemas"]["HexEncodedBytes"];
      state_root_hash: components["schemas"]["HexEncodedBytes"];
      event_root_hash: components["schemas"]["HexEncodedBytes"];
      gas_used: components["schemas"]["Uint64"];
      /**
       * @description Transaction execution result (success: true, failure: false).
       * See `vm_status` for human readable error message from Aptos VM.
       */
      success: boolean;
      /** @description Human readable transaction execution result message from Aptos VM. */
      vm_status: string;
      accumulator_root_hash: components["schemas"]["HexEncodedBytes"];
      changes: components["schemas"]["WriteSetChange"][];
    };
    /** User Transaction */
    UserTransaction: {
      /** @example user_transaction */
      type: string;
      events: components["schemas"]["Event"][];
      timestamp: components["schemas"]["TimestampUsec"];
    } & components["schemas"]["UserTransactionRequest"] &
      components["schemas"]["UserTransactionSignature"] &
      components["schemas"]["OnChainTransactionInfo"];
    /** Block Metadata Transaction */
    BlockMetadataTransaction: {
      /** @example block_metadata_transaction */
      type: string;
      id: components["schemas"]["HexEncodedBytes"];
      round: components["schemas"]["Uint64"];
      previous_block_votes: components["schemas"]["Address"][];
      proposer: components["schemas"]["Address"];
      timestamp: components["schemas"]["TimestampUsec"];
    } & components["schemas"]["OnChainTransactionInfo"];
    /** Genesis Transaction */
    GenesisTransaction: {
      /** @example genesis_transaction */
      type: string;
      events: components["schemas"]["Event"][];
      payload: components["schemas"]["WriteSetPayload"];
    } & components["schemas"]["OnChainTransactionInfo"];
    /** Transaction Payload */
    TransactionPayload:
      | components["schemas"]["ScriptFunctionPayload"]
      | components["schemas"]["ScriptPayload"]
      | components["schemas"]["ModuleBundlePayload"]
      | components["schemas"]["WriteSetPayload"];
    /**
     * Script Function Payload
     * @example [object Object]
     */
    ScriptFunctionPayload: {
      type: string;
      function: components["schemas"]["ScriptFunctionId"];
      /** @description Generic type arguments required by the script function. */
      type_arguments: components["schemas"]["MoveTypeTagId"][];
      /** @description The script function arguments. */
      arguments: components["schemas"]["MoveValue"][];
    };
    /**
     * Script Function ID
     * @description Script function id is string representation of a script function defined on-chain.
     *
     * Format: `{address}::{module name}::{function name}`
     *
     * Both `module name` and `function name` are case-sensitive.
     *
     * @example 0x1::PaymentScripts::peer_to_peer_with_metadata
     */
    ScriptFunctionId: string;
    /** Script Payload */
    ScriptPayload: {
      /** @example script_payload */
      type: string;
      code: components["schemas"]["MoveScript"];
      type_arguments: components["schemas"]["MoveTypeTagId"][];
      arguments: components["schemas"]["MoveValue"][];
    };
    /** Module Bundle Payload */
    ModuleBundlePayload: {
      /** @example module_bundle_payload */
      type: string;
      modules: components["schemas"]["MoveModule"][];
    };
    /** WriteSet Payload */
    WriteSetPayload: {
      /** @example write_set_payload */
      type: string;
      write_set: components["schemas"]["WriteSet"];
    };
    /** WriteSet */
    WriteSet:
      | components["schemas"]["ScriptWriteSet"]
      | components["schemas"]["DirectWriteSet"];
    /** Script WriteSet */
    ScriptWriteSet: {
      /** @example script_write_set */
      type: string;
      execute_as: components["schemas"]["Address"];
      script: components["schemas"]["Script"];
    };
    /** Direct WriteSet */
    DirectWriteSet: {
      /** @example direct_write_set */
      type: string;
      changes: components["schemas"]["WriteSetChange"][];
      events: components["schemas"]["Event"][];
    };
    WriteSetChange:
      | components["schemas"]["DeleteModule"]
      | components["schemas"]["DeleteResource"]
      | components["schemas"]["DeleteTableItem"]
      | components["schemas"]["WriteModule"]
      | components["schemas"]["WriteResource"]
      | components["schemas"]["WriteTableItem"];
    /** Delete Module */
    DeleteModule: {
      /** @example delete_module */
      type: string;
      state_key_hash: components["schemas"]["HexEncodedBytes"];
      address: components["schemas"]["Address"];
      module: components["schemas"]["MoveModuleId"];
    };
    /**
     * Delete Resource
     * @description Delete account resource change.
     */
    DeleteResource: {
      /** @example delete_resource */
      type: string;
      state_key_hash: components["schemas"]["HexEncodedBytes"];
      address: components["schemas"]["Address"];
      resource: components["schemas"]["MoveStructTagId"];
    };
    /**
     * Delete Table Item
     * @description Delete table item change.
     */
    DeleteTableItem: {
      /** @example delete_table_item */
      type: string;
      state_key_hash: components["schemas"]["HexEncodedBytes"];
      /** Table item deletion */
      data: {
        handle: components["schemas"]["HexEncodedBytes"];
        key: components["schemas"]["HexEncodedBytes"];
      };
    };
    /**
     * Write Module
     * @description Write move module
     */
    WriteModule: {
      /** @example write_module */
      type: string;
      state_key_hash: components["schemas"]["HexEncodedBytes"];
      address: components["schemas"]["Address"];
      data: components["schemas"]["MoveModule"];
    };
    /**
     * Write Resource
     * @description Write account resource
     */
    WriteResource: {
      /** @example write_resource */
      type: string;
      state_key_hash: components["schemas"]["HexEncodedBytes"];
      address: components["schemas"]["Address"];
      data: components["schemas"]["AccountResource"];
    };
    /**
     * Write Table Item
     * @description Write table item
     */
    WriteTableItem: {
      /** @example write_table_item */
      type: string;
      state_key_hash: components["schemas"]["HexEncodedBytes"];
      /** Table item write */
      data: {
        handle: components["schemas"]["HexEncodedBytes"];
        key: components["schemas"]["HexEncodedBytes"];
        value: components["schemas"]["HexEncodedBytes"];
      };
    };
    /** Script */
    Script: {
      code: components["schemas"]["MoveScript"];
      type_arguments: components["schemas"]["MoveTypeTagId"][];
      arguments: components["schemas"]["MoveValue"][];
    };
    /** Move Script */
    MoveScript: {
      bytecode: components["schemas"]["HexEncodedBytes"];
      abi?: components["schemas"]["MoveFunction"];
    };
    /**
     * Move Value
     * @description Move `bool` type value is serialized into `boolean`.
     *
     * Move `u8` type value is serialized into `integer`.
     *
     * Move `u64` and `u128` type value is serialized into `string`.
     *
     * Move `address` type value(16 bytes Aptos account address) is serialized into
     * hex-encoded string, which is prefixed with `0x` and leading zeros are trimmed.
     *
     * For example:
     *   * `0x1`
     *   * `0x1668f6be25668c1a17cd8caf6b8d2f25`
     *
     * Move `vector` type value is serialized into `array`, except `vector<u8>` which is
     * serialized into hex-encoded string with `0x` prefix.
     *
     * For example:
     *   * `vector<u64>{255, 255}` => `["255", "255"]`
     *   * `vector<u8>{255, 255}` => `0xffff`
     *
     * Move `struct` type value is serialized into `object` that looks like this (except some Move stdlib types, see the following section):
     *
     *   ```json
     *   {
     *     field1_name: field1_value,
     *     field2_name: field2_value,
     *     ......
     *   }
     *   ```
     *
     * For example:
     *   `{ "created": "0xa550c18", "role_id": "0" }`
     *
     * **Special serialization for Move stdlib types:**
     *
     * * [0x1::ASCII::String](https://github.com/aptos-labs/aptos-core/blob/main/language/move-stdlib/docs/ASCII.md) is serialized into `string`. For example, struct value `0x1::ASCII::String{bytes: b"hello world"}` is serialized as `"hello world"` in JSON.
     *
     * @example 3344000000
     */
    MoveValue: unknown;
    /**
     * Event
     * @description Event `key` and `sequence_number` are global identifier of the event.
     *
     * Event `sequence_number` starts from 0 for each event key.
     *
     * Event `type` is the type information of the event `data`, you can use the `type`
     * to decode the `data` JSON.
     *
     * @example [object Object]
     */
    Event: {
      key: components["schemas"]["EventKey"];
      sequence_number: components["schemas"]["EventSequenceNumber"];
      type: components["schemas"]["MoveTypeTagId"];
      data: components["schemas"]["MoveValue"];
    };
    /** Transaction Signature */
    TransactionSignature:
      | components["schemas"]["Ed25519Signature"]
      | components["schemas"]["MultiEd25519Signature"]
      | components["schemas"]["MultiAgentSignature"];
    /**
     * Ed25519 Signature
     * @description Please refer to https://github.com/aptos-labs/aptos-core/tree/main/specifications/crypto#signature-and-verification for
     * more details.
     */
    Ed25519Signature: {
      /** @example ed25519_signature */
      type: string;
      public_key: components["schemas"]["HexEncodedBytes"];
      signature: components["schemas"]["HexEncodedBytes"];
    };
    /**
     * Multi-ed25519 Signature
     * @description Multi ed25519 signature, please refer to https://github.com/aptos-labs/aptos-core/tree/main/specifications/crypto#multi-signatures for more details.
     */
    MultiEd25519Signature: {
      /** @example multi_ed25519_signature */
      type: string;
      /** @description all public keys of the sender account */
      public_keys: components["schemas"]["HexEncodedBytes"][];
      /** @description signatures created based on the `threshold` */
      signatures: components["schemas"]["HexEncodedBytes"][];
      /** @description The threshold of the multi ed25519 account key. */
      threshold: number;
      bitmap: components["schemas"]["HexEncodedBytes"];
    };
    /**
     * Multi-agent Signature
     * @description Multi agent signature, please refer to TBD.
     */
    MultiAgentSignature: {
      /** @example multi_agent_signature */
      type: string;
      sender: components["schemas"]["AccountSignature"];
      secondary_signer_addresses: components["schemas"]["Address"][];
      secondary_signers: components["schemas"]["AccountSignature"][];
    };
    /** Account Signature */
    AccountSignature:
      | components["schemas"]["Ed25519Signature"]
      | components["schemas"]["MultiEd25519Signature"];
    /** Table item request */
    TableItemRequest: {
      key_type: components["schemas"]["MoveTypeId"];
      value_type: components["schemas"]["MoveTypeId"];
      key: components["schemas"]["MoveValue"];
    };
    /**
     * token Id
     * Format: string
     * @description token id is the unique identifier of a token. It consists of 3 parts joined with "::". The 3 parts are creator account address, collection name and token name
     * @example 0x1::APE::LASER_APE
     */
    TokenId: string;
    TokenIds: {
      /** @description List of token Ids */
      ids?: components["schemas"]["TokenId"][];
    };
    Royalty: {
      account?: components["schemas"]["Address"];
      value?: number;
    };
    Royalties: {
      royalties?: components["schemas"]["Royalty"][];
    };
    /** Tokens */
    Tokens: {
      tokens?: components["schemas"]["Token"][];
    };
    /**
     * Token
     * @description Aptos Token data
     */
    Token: {
      id?: components["schemas"]["TokenId"];
      contract?: components["schemas"]["MoveModuleId"];
      creator?: components["schemas"]["Address"];
      supply?: number;
      owner?: components["schemas"]["Address"];
      royalties?: components["schemas"]["Royalties"];
      deleted?: boolean;
      /** @description The max number of this token */
      max?: number;
    };
    /**
     * Colelction Id
     * @description A Id of a collection
     * @example 0x1::my_awesome_collection
     */
    CollectionId: string;
    /**
     * NFT collection
     * @description A collection of tokens
     */
    Collection: {
      id?: components["schemas"]["CollectionId"];
      name?: string;
      owner?: components["schemas"]["Address"];
      ceator?: components["schemas"]["Address"];
      maxSupply?: number;
      /**
       * @description the number of tokens in this collection
       * @example 1
       */
      count?: number;
      description?: string;
      uri?: string;
    };
    /** @description the ownership Id is the  "TokenID::Owner" */
    OwnershipId: string;
    /** @enum {string} */
    OwnershipSource: "MINT" | "TRANSFER";
    Ownership: {
      id?: components["schemas"]["OwnershipId"];
      tokenId?: components["schemas"]["TokenId"];
      contract?: components["schemas"]["MoveModuleId"];
      collection?: components["schemas"]["CollectionId"];
      owner?: components["schemas"]["Address"];
      /** @description the number of the tokens in this ownership */
      value?: number;
      source?: components["schemas"]["OwnershipSource"];
      /** Format: date-time */
      createdAt?: string;
      creator?: components["schemas"]["Address"];
    };
    /** Ownerships */
    Ownerships: {
      ownership?: components["schemas"]["Ownership"][];
    };
    MintActivity: {
      /** @enum {string} */
      "@type"?: "MINT";
      creator?: components["schemas"]["Address"];
      contract?: components["schemas"]["MoveModuleId"];
      tokenId?: components["schemas"]["TokenId"];
      value?: number;
      transactionHash?: components["schemas"]["HexEncodedBytes"];
    };
    ActivityId: components["schemas"]["EventKey"];
    /** @enum {string} */
    UserActivityType:
      | "TRANSFER_FROM"
      | "TRANSFER_TO"
      | "MINT"
      | "BURN"
      | "MAKE_BID"
      | "GET_BID"
      | "LIST"
      | "BUY"
      | "SELL"
      | "CANCEL_LIST"
      | "CANCEL_BID"
      | "AUCTION_BID"
      | "AUCTION_CREATED"
      | "AUCTION_CANCEL"
      | "AUCTION_FINISHED"
      | "AUCTION_STARTED"
      | "AUCTION_ENDED";
    Activity: components["schemas"]["MintActivity"] & {
      id?: components["schemas"]["ActivityId"];
      /** Format: date-time */
      date?: string;
      /** Format: date-time */
      lastUpdatedAt?: string;
    };
    Activities: {
      ownership?: components["schemas"]["Activity"][];
    };
    /** @enum {string} */
    ActivitySort: "LATEST_FIRST" | "EARLIEST_FIRST";
    TokenMetaData: {
      /** @description the name of the collection */
      collection?: string;
      maxium?: number;
      uri?: string;
      /** @description Name of the NFT item */
      name?: string;
      /** @description Description of the NFT item */
      description?: string;
      /** @description Attributes of the NFT item */
      attributes?: components["schemas"]["TokenMetaAttribute"][];
      /** @description NFT content information */
      content?: components["schemas"]["MetaContent"][];
      raw?: string;
    };
    TokenMetaAttribute: {
      key: string;
      value?: string;
      type?: string;
      format?: string;
    };
    MetaContent: (
      | components["schemas"]["ImageContent"]
      | components["schemas"]["VideoContent"]
      | components["schemas"]["AudioContent"]
      | components["schemas"]["Model3dContent"]
      | components["schemas"]["HtmlContent"]
    ) & {
      url: string;
      /** @enum {string} */
      representation: "PREVIEW" | "BIG" | "ORIGINAL";
      /** @example image/png */
      mimeType?: string;
      /** Format: int64 */
      size?: number;
    };
    ImageContent: {
      /** @enum {string} */
      "@type"?: "IMAGE";
      width?: number;
      height?: number;
    };
    VideoContent: {
      /** @enum {string} */
      "@type"?: "VIDEO";
      width?: number;
      height?: number;
    };
    AudioContent: {
      /** @enum {string} */
      "@type"?: "AUDIO";
    };
    Model3dContent: {
      /** @enum {string} */
      "@type"?: "MODEL_3D";
    };
    HtmlContent: {
      /** @enum {string} */
      "@type"?: "HTML";
    };
  };
  responses: {
    /**
     * Bad request due to a client error: invalid request headers, parameters or body.
     * Client should not retry the request without modification.
     */
    400: {
      content: {
        "application/json": components["schemas"]["AptosError"];
      };
    };
    /**
     * Resource or data not found.
     * Client may retry the request if it is waiting for transaction execution or ledger synchronization.
     */
    404: {
      content: {
        "application/json": components["schemas"]["AptosError"];
      };
    };
    /** The request payload is too large. */
    413: {
      content: {
        "application/json": components["schemas"]["AptosError"];
      };
    };
    /** The request's content-type is not supported. */
    415: {
      content: {
        "application/json": components["schemas"]["AptosError"];
      };
    };
    /** Server internal error, caused by unexpected issues. */
    500: {
      content: {
        "application/json": components["schemas"]["AptosError"];
      };
    };
  };
  parameters: {
    AccountAddress: components["schemas"]["Address"];
    LedgerVersion: components["schemas"]["LedgerVersion"];
    /**
     * @description The start transaction version of the page. Default is the latest ledger version.
     * @example 1
     */
    StartVersion: number;
    /**
     * @description The max number of transactions should be returned for the page. Default is 25.
     * @example 25
     */
    Limit: number;
    /**
     * @description The start sequence number in the EVENT STREAM, defaulting to the latest event.
     * The events are returned in the reverse order of sequence numbers.
     */
    EventStart: number;
    /**
     * @description The number of events to be returned for the page default is 5
     * @example 25
     */
    EventLimit: number;
  };
}

export interface operations {
  get_ledger_info: {
    responses: {
      /** Returns the latest ledger information. */
      200: {
        content: {
          "application/json": components["schemas"]["LedgerInfo"];
        };
      };
      400: components["responses"]["400"];
      500: components["responses"]["500"];
    };
  };
  get_spec_html: {
    responses: {
      /** Returns OpenAPI specification html document. */
      200: unknown;
      /** Bad Request */
      400: unknown;
    };
  };
  get_spec_yaml: {
    responses: {
      /** Returns OpenAPI specification YAML document. */
      200: unknown;
      /** Bad Request */
      400: unknown;
    };
  };
  /** Returns Token by Id */
  getTokenById: {
    parameters: {
      path: {
        /** Token Id, has format `${address}:${collection_name}:${token_name}` */
        TokenId: components["schemas"]["TokenId"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["Token"];
        };
      };
      400: components["responses"]["400"];
      404: components["responses"]["404"];
      500: components["responses"]["500"];
    };
  };
  /** Returns TokenMetaData by Id */
  getTokenMetaDataById: {
    parameters: {
      path: {
        /** TokenId, has format `${address}:${collection_name}:${token_name}` */
        tokenId: components["schemas"]["TokenId"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["TokenMetaData"];
        };
      };
      400: components["responses"]["400"];
      404: components["responses"]["404"];
      500: components["responses"]["500"];
    };
  };
  /** Returns TokenMetaData by Ids */
  getTokenMetaDataByIds: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["TokenMetaData"];
        };
      };
      400: components["responses"]["400"];
      404: components["responses"]["404"];
      500: components["responses"]["500"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TokenIds"];
      };
    };
  };
  /** Returns Tokens by Ids */
  getTokenByIds: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["Tokens"];
        };
      };
      400: components["responses"]["400"];
      404: components["responses"]["404"];
      500: components["responses"]["500"];
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TokenIds"];
      };
    };
  };
  /** Returns ownership by Id */
  getOwnershipById: {
    parameters: {
      path: {
        /** Ownership Id in format: '${blockchain}:${token}:${tokenId}:${owner}' */
        ownershipId: components["schemas"]["OwnershipId"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["Ownership"];
        };
      };
      400: components["responses"]["400"];
      404: components["responses"]["404"];
      500: components["responses"]["500"];
    };
  };
  /** Returns collection by collection id */
  getCollectionById: {
    parameters: {
      path: {
        /** Id of the collection */
        CollectionId: components["schemas"]["CollectionId"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["Collection"];
        };
      };
      400: components["responses"]["400"];
      404: components["responses"]["404"];
      500: components["responses"]["500"];
    };
  };
  /** Returns activities by user */
  getActivitiesByUser: {
    parameters: {
      query: {
        /** Activity type */
        type: components["schemas"]["UserActivityType"][];
        /** Addresses of the users */
        user: components["schemas"]["Address"][];
        /** Lower time border of data */
        from?: string;
        /** Upper time border of data */
        to?: string;
        /** The number of items to return */
        size?: number;
        /** Sorting by data update time */
        sort?: components["schemas"]["ActivitySort"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["Activities"];
        };
      };
      400: components["responses"]["400"];
      500: components["responses"]["500"];
    };
  };
}

export interface external {}
