#!/usr/bin/env python3

import json
from typing import List
import click
import sys
import time

from test_framework.shell import LocalShell, Shell
from test_framework.git import Git
from test_framework.logging import log, init_logging

APTOS_CORE_REPO = "https://github.com/aptos-labs/aptos-core.git"
DOCKER_RUST_BUILD_WORKFLOW_NAME = "workflow-run-docker-rust-build.yaml"
EXP_GIT_BRANCH_PREFIX = "exp/"
WORKFLOW_WATCH_INTERVAL_SECS = 10  # refresh every 10s
WORKFLOW_WATCH_TIMEOUT_SECS = 30 * 60  # 30 min build timeout


def try_push_new_branch(git: Git, current_branch: str, new_branch: str) -> None:
    if git.branch_exists(new_branch):
        log.info("Branch %s already exists. Overriding its local state.", new_branch)
        git.run(["branch", "-D", new_branch]).unwrap()  # delete local branch

    # create a new branch and push it to the remote
    log.info("Creating branch %s", new_branch)
    git.run(["checkout", "-b", new_branch]).unwrap()
    log.info("Pushing branch %s", new_branch)
    git.run(["push", "-f", "origin", new_branch]).unwrap()

    log.info("Successfully created new branch %s", new_branch)

    git.run(["checkout", current_branch]).unwrap()  # switch back to the original branch


def get_gh_username(shell: Shell) -> str:
    ret = shell.run(["gh", "api", "user", "-q", ".login"])
    if ret.succeeded():
        return ret.unwrap().decode().strip()
    else:
        return ""


@click.group()
@click.option(
    "--log-metadata/--no-log-metadata",
    default=True,
)
def main(log_metadata: bool) -> None:
    init_logging(logger=log, print_metadata=log_metadata)


@main.command(help="Run a workflow on the aptos-core repo")
@click.option(
    "--features",
    multiple=True,
    default=[],
    help="Cargo features to enable",
)
@click.option(
    "--profile",
    default="release",
    help="Cargo profile to build",
)
@click.option(
    "--build-addl-testing-images",
    is_flag=True,
    help="Build additional testing images",
)
@click.option(
    "--tail",
    is_flag=True,
    help="Tail the logs of the scheduled workflow",
)
@click.option(
    "--dry-run",
    is_flag=True,
    help="Dry run",
)
def run(
    features: List[str],
    profile: str,
    build_addl_testing_images: bool,
    tail: bool,
    dry_run: bool,
) -> None:
    shell = LocalShell()
    git = Git(shell)

    current_git_branch = git.branch()
    new_exp_git_branch = (
        EXP_GIT_BRANCH_PREFIX + current_git_branch
    )  # the temporary branch to push to

    # ensure that the current git workspace is clean
    if not git.status():
        log.info("ERROR: uncommitted changes in git workspace")
        uncommitted_files = git.run(["status", "--porcelain"]).unwrap().decode().strip()
        log.info("Uncommitted files:\n%s", uncommitted_files)
        sys.exit(1)

    # create a new branch and push it to the remote
    try:
        try_push_new_branch(git, current_git_branch, new_exp_git_branch)
    except Exception as e:
        log.info("ERROR: Failed to create exp branch %s: %s", new_exp_git_branch, e)
        sys.exit(1)

    if not git.branch_matches_remote(APTOS_CORE_REPO, current_git_branch):
        log.info("ERROR: Not synced with remote. Please push to a remote branch")
        log.info(
            "%s (local) != %s (remote)",
            git.get_commit_hash(current_git_branch),
            git.resolve_remote_ref(APTOS_CORE_REPO, current_git_branch),
        )
        sys.exit(1)

    git_sha = git.get_commit_hash("HEAD")
    features = ",".join(features)
    profile = profile
    build_addl_testing_images = (  # make it a lower case string
        str(build_addl_testing_images).lower()
        if type(build_addl_testing_images) is bool
        else build_addl_testing_images
    )

    log.info("GIT_SHA: %s", git_sha)
    log.info("FEATURES: %s", features)
    log.info("PROFILE: %s", profile)
    log.info("BUILD_ADDL_TESTING_IMAGES: %s", build_addl_testing_images)

    gh_workflow_run_cmd = [
        "gh",
        "workflow",
        "run",
        DOCKER_RUST_BUILD_WORKFLOW_NAME,
        "--ref",
        new_exp_git_branch,
        "--field",
        f"GIT_SHA={git_sha}",
        "--field",
        f"FEATURES={features}",
        "--field",
        f"PROFILE={profile}",
        "--field",
        f"BUILD_ADDL_TESTING_IMAGES={build_addl_testing_images}",
    ]
    log.info("Running command: %s", " ".join(gh_workflow_run_cmd))
    if dry_run:
        log.info("Dry run. Exiting before running gh commands")
        sys.exit(0)
    gh_workflow_run_cmd_ret = shell.run(gh_workflow_run_cmd, stream_output=True)

    # delete the remote branch first after scheduling the workflow
    # the script must not exit before this point, otherwise we leave a dangling branch
    log.info("Deleting remote branch %s", new_exp_git_branch)
    git.run(["push", "origin", "--delete", new_exp_git_branch]).unwrap()

    # print URL to find the jobs
    if gh_workflow_run_cmd_ret.succeeded():
        log.info("Successfully triggered workflow")
    else:
        log.info("Failed to trigger workflow")
        sys.exit(1)

    # wait a while for GH API to update
    time.sleep(5)

    # get the workflow run ID
    gh_run_list_cmd = [
        "gh",
        "run",
        "list",
        "--workflow",
        DOCKER_RUST_BUILD_WORKFLOW_NAME,
        "--branch",
        new_exp_git_branch,
        "--limit",
        "1",
        "--json",
        "databaseId",
        "--jq",
        ".[0].databaseId",
    ]
    gh_run_list_cmd_ret = shell.run(gh_run_list_cmd)
    # get the URL
    if not gh_run_list_cmd_ret.succeeded():
        log.info("Failed to get workflow run ID")
        log.info(
            f"All workflow runs: https://github.com/aptos-labs/aptos-core/actions/workflows/{DOCKER_RUST_BUILD_WORKFLOW_NAME}"
        )
        sys.exit(1)
    workflow_run_id = gh_run_list_cmd_ret.unwrap().decode().strip()
    log.info(
        f"Workflow URL: https://github.com/aptos-labs/aptos-core/actions/runs/{workflow_run_id}"
    )

    if tail:
        iterations = WORKFLOW_WATCH_TIMEOUT_SECS // WORKFLOW_WATCH_INTERVAL_SECS
        for i in range(iterations):
            secs_remaining = (iterations - i) * WORKFLOW_WATCH_INTERVAL_SECS
            log.info(
                f"Checking workflow status: https://github.com/aptos-labs/aptos-core/actions/runs/{workflow_run_id} ({secs_remaining}s remaining)"
            )
            gh_run_view_cmd = [
                "gh",
                "run",
                "view",
                workflow_run_id,
                "--log",  # Exit with non-zero status if run fails
            ]
            gh_run_view_cmd_ret = shell.run(gh_run_view_cmd)
            if gh_run_view_cmd_ret.succeeded():
                log.info("Successfully ran workflow")
                log.info(f"To view the logs, run:\n\t$ {' '.join(gh_run_view_cmd)}")
                sys.exit(0)
            else:
                log.info("Waiting for workflow to complete...")
                time.sleep(WORKFLOW_WATCH_INTERVAL_SECS)


@main.command("list", help="List all authored workflows")
def list_exp():
    shell = LocalShell()
    username = get_gh_username(shell)
    gh_workflow_list_cmd = [
        "gh",
        "run",
        "list",
        "--json",
        "conclusion,createdAt,name,url",  # specific fields we care about
        "--workflow",
        DOCKER_RUST_BUILD_WORKFLOW_NAME,
        "--user",
        username,
    ]
    log.info("Running command: %s", " ".join(gh_workflow_list_cmd))
    gh_workflow_list_cmd_ret = shell.run(gh_workflow_list_cmd)
    list_out = json.dumps(
        json.loads(gh_workflow_list_cmd_ret.unwrap().decode()), indent=2
    )
    log.info("Output:\n%s", list_out)
    sys.exit(0)


if __name__ == "__main__":
    main()
