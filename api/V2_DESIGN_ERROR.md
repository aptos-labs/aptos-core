# V2 Design: Structured Error Model

> **Status: Implemented.** The final implementation follows this design closely with these additions:
>
> - **`RequestTimeout` error code** (HTTP 408) for the request timeout middleware
> - **`SseDisabled` error code** (HTTP 501) for when SSE is disabled
> - **`request_timeout()` constructor** on V2Error for timeout errors

## Overview

The v1 API uses Poem's macro-generated error types (`generate_error_response!`,
`generate_error_traits!`) that are tightly coupled to the Poem framework. The v2 API
introduces a framework-agnostic, machine-readable error model that works with Axum and
provides better client ergonomics.

---

## v1 Error Architecture (for reference)

### How v1 Errors Work

v1 defines error traits via `generate_error_traits!`:

```rust
generate_error_traits!(BadRequest, Gone, NotFound, Forbidden, PayloadTooLarge, Internal, InsufficientStorage, ServiceUnavailable);
```

This generates traits like `InternalError`, `NotFoundError`, etc., each with methods like:
- `internal_with_code(err, code, ledger_info)` -> constructs error with status + headers
- `not_found_with_code(err, code, ledger_info)` -> constructs 404 with headers

Concrete error types are generated via `generate_error_response!`:

```rust
generate_error_response!(BasicErrorWith404, (400, BadRequest), (403, Forbidden), (404, NotFound), (410, Gone), (500, Internal), (503, ServiceUnavailable));
```

This generates a Poem `ApiResponse` enum with variants for each status code, each carrying
`AptosError` as JSON payload plus 8 header values (chain_id, version, etc.).

### Problems with v1 Approach

1. **Framework lock-in**: Error traits depend on `poem_openapi::ApiResponse` derive
2. **Generic proliferation**: Every function is generic over `E: InternalError + NotFoundError + ...`
3. **Header-based metadata**: v1 errors embed ledger info in `X-Aptos-*` headers, which is awkward for clients and mixes concerns (an error about a missing resource shouldn't also report ledger state)
4. **Flat error codes**: `AptosErrorCode` is a flat enum without hierarchy
5. **No request ID**: Errors don't carry a request ID for correlation
6. **Macro complexity**: The `generate_error_response!` macro is ~300 lines of complex code

---

## v2 Error Design

### Key Principle: No Ledger Metadata in Errors

v2 error responses contain **only error-related information**. They do NOT include:

- `X-Aptos-*` response headers (v2 never sets these on any response, success or error)
- A `ledger` field in the error JSON body
- Any chain state metadata (version, epoch, block height, etc.)

If a client needs current ledger state after encountering an error, it should call
`GET /v2/info`. This separation of concerns keeps error responses focused and lightweight.

The only custom header on v2 error responses is `X-Request-Id`, which is set by
middleware on ALL responses (success and error) for request correlation.

### V2Error Struct

```rust
// api/src/v2/error.rs

use axum::http::StatusCode;
use axum::response::{IntoResponse, Response};
use axum::Json;
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

/// The standard error response for all v2 API endpoints.
///
/// Returned as a JSON body with an appropriate HTTP status code.
///
/// Example:
/// ```json
/// {
///     "code": "RESOURCE_NOT_FOUND",
///     "message": "Resource 0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin> not found at 0x1",
///     "request_id": "req_abc123",
///     "details": {
///         "address": "0x1",
///         "resource_type": "0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>",
///         "ledger_version": 12345
///     }
/// }
/// ```
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
pub struct V2Error {
    /// Machine-readable error code. Clients should switch on this field.
    pub code: ErrorCode,

    /// Human-readable error description. May change between versions;
    /// clients should NOT parse this string programmatically.
    pub message: String,

    /// Request ID for log correlation. Echoed from the X-Request-Id
    /// header if provided by the client, or generated by the server.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,

    /// Additional structured details specific to the error type.
    /// The schema depends on the error code.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub details: Option<serde_json::Value>,

    /// VM status code, if the error originated from Move VM execution.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vm_status_code: Option<u64>,

    /// The HTTP status code. Not serialized into the JSON body
    /// (it's the HTTP response status), but used internally.
    #[serde(skip)]
    http_status: StatusCode,
}
```

### ErrorCode Enum

```rust
/// Machine-readable error codes for the v2 API.
///
/// These are stable across versions. New codes may be added, but existing
/// codes will not be removed or change meaning.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, ToSchema)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum ErrorCode {
    // --- General errors ---

    /// An unexpected internal error occurred. Retry may help.
    InternalError,
    /// The request was malformed or contained invalid parameters.
    InvalidInput,
    /// The requested resource or entity was not found.
    NotFound,
    /// The requested data has been pruned and is no longer available.
    Gone,
    /// The request is forbidden by server configuration.
    Forbidden,
    /// The server is temporarily unavailable (e.g., during startup).
    ServiceUnavailable,
    /// The request was rate-limited. Retry after backoff.
    RateLimited,
    /// The request body exceeds the maximum allowed size.
    PayloadTooLarge,

    // --- BCS-specific ---

    /// The BCS version envelope has an unrecognized version discriminant.
    InvalidBcsVersion,
    /// The BCS payload failed to deserialize.
    InvalidBcsPayload,

    // --- Resource/state errors ---

    /// The requested account was not found at the given ledger version.
    AccountNotFound,
    /// The requested resource was not found at the given address and version.
    ResourceNotFound,
    /// The requested module was not found.
    ModuleNotFound,
    /// The requested table item was not found.
    TableItemNotFound,
    /// The requested state value was not found.
    StateValueNotFound,

    // --- Version/block errors ---

    /// The requested ledger version is in the future (not yet committed).
    VersionNotFound,
    /// The requested ledger version has been pruned.
    VersionPruned,
    /// The requested block was not found.
    BlockNotFound,
    /// The requested block has been pruned.
    BlockPruned,

    // --- Transaction errors ---

    /// The requested transaction was not found.
    TransactionNotFound,
    /// The submitted transaction was rejected by the mempool.
    MempoolRejected,
    /// The mempool is full and cannot accept new transactions.
    MempoolFull,
    /// Transaction simulation failed.
    SimulationFailed,

    // --- View function errors ---

    /// A view function execution failed.
    ViewFunctionFailed,
    /// The requested view function is blocked by server configuration.
    ViewFunctionForbidden,

    // --- Batch errors ---

    /// The batch request exceeds the maximum allowed size.
    BatchTooLarge,
    /// An individual request within a batch failed.
    BatchRequestFailed,
    /// Unknown method in a batch JSON-RPC request.
    MethodNotFound,

    // --- WebSocket errors ---

    /// WebSocket support is disabled on this node.
    WebSocketDisabled,
    /// Maximum WebSocket connections reached.
    WebSocketConnectionLimitReached,
    /// Maximum subscriptions per connection reached.
    WebSocketSubscriptionLimitReached,

    // --- Gas estimation ---

    /// Gas estimation failed.
    GasEstimationFailed,

    // --- Timeout ---

    /// The request exceeded the configured timeout.
    RequestTimeout,

    // --- SSE ---

    /// Server-Sent Events support is disabled on this node.
    SseDisabled,
}
```

### HTTP Status Code Mapping

```rust
impl ErrorCode {
    /// Map each error code to its HTTP status code.
    pub fn http_status(&self) -> StatusCode {
        match self {
            // 400 Bad Request
            ErrorCode::InvalidInput
            | ErrorCode::InvalidBcsVersion
            | ErrorCode::InvalidBcsPayload
            | ErrorCode::ViewFunctionFailed
            | ErrorCode::SimulationFailed
            | ErrorCode::BatchTooLarge
            | ErrorCode::MethodNotFound => StatusCode::BAD_REQUEST,

            // 403 Forbidden
            ErrorCode::Forbidden
            | ErrorCode::ViewFunctionForbidden => StatusCode::FORBIDDEN,

            // 404 Not Found
            ErrorCode::NotFound
            | ErrorCode::AccountNotFound
            | ErrorCode::ResourceNotFound
            | ErrorCode::ModuleNotFound
            | ErrorCode::TableItemNotFound
            | ErrorCode::StateValueNotFound
            | ErrorCode::VersionNotFound
            | ErrorCode::BlockNotFound
            | ErrorCode::TransactionNotFound => StatusCode::NOT_FOUND,

            // 410 Gone (pruned)
            ErrorCode::Gone
            | ErrorCode::VersionPruned
            | ErrorCode::BlockPruned => StatusCode::GONE,

            // 413 Payload Too Large
            ErrorCode::PayloadTooLarge => StatusCode::PAYLOAD_TOO_LARGE,

            // 422 Unprocessable Entity (mempool rejection)
            ErrorCode::MempoolRejected => StatusCode::UNPROCESSABLE_ENTITY,

            // 429 Too Many Requests
            ErrorCode::RateLimited
            | ErrorCode::WebSocketConnectionLimitReached
            | ErrorCode::WebSocketSubscriptionLimitReached => StatusCode::TOO_MANY_REQUESTS,

            // 500 Internal Server Error
            ErrorCode::InternalError
            | ErrorCode::GasEstimationFailed
            | ErrorCode::BatchRequestFailed => StatusCode::INTERNAL_SERVER_ERROR,

            // 503 Service Unavailable
            ErrorCode::ServiceUnavailable
            | ErrorCode::MempoolFull => StatusCode::SERVICE_UNAVAILABLE,

            // Disabled features
            ErrorCode::WebSocketDisabled => StatusCode::NOT_IMPLEMENTED,
        }
    }
}
```

---

## Constructor Methods

```rust
impl V2Error {
    /// Create an internal server error.
    pub fn internal<E: std::fmt::Display>(err: E) -> Self {
        Self {
            code: ErrorCode::InternalError,
            message: err.to_string(),
            request_id: None,
            details: None,
            vm_status_code: None,
            http_status: StatusCode::INTERNAL_SERVER_ERROR,
        }
    }

    /// Create a bad request error.
    pub fn bad_request<M: Into<String>>(code: ErrorCode, message: M) -> Self {
        let message = message.into();
        Self {
            http_status: code.http_status(),
            code,
            message,
            request_id: None,
            details: None,
            vm_status_code: None,
        }
    }

    /// Create a not-found error.
    pub fn not_found<M: Into<String>>(code: ErrorCode, message: M) -> Self {
        Self {
            http_status: code.http_status(),
            code,
            message: message.into(),
            request_id: None,
            details: None,
            vm_status_code: None,
        }
    }

    /// Create a gone (pruned) error.
    pub fn gone<M: Into<String>>(code: ErrorCode, message: M) -> Self {
        Self {
            http_status: code.http_status(),
            code,
            message: message.into(),
            request_id: None,
            details: None,
            vm_status_code: None,
        }
    }

    /// Create a forbidden error.
    pub fn forbidden<M: Into<String>>(code: ErrorCode, message: M) -> Self {
        Self {
            http_status: code.http_status(),
            code,
            message: message.into(),
            request_id: None,
            details: None,
            vm_status_code: None,
        }
    }

    /// Create a rate-limited error.
    pub fn rate_limited<M: Into<String>>(message: M) -> Self {
        Self {
            code: ErrorCode::RateLimited,
            message: message.into(),
            http_status: StatusCode::TOO_MANY_REQUESTS,
            request_id: None,
            details: None,
            vm_status_code: None,
        }
    }

    /// Attach a request ID (from X-Request-Id header or generated).
    pub fn with_request_id(mut self, id: String) -> Self {
        self.request_id = Some(id);
        self
    }

    /// Attach additional details.
    pub fn with_details(mut self, details: serde_json::Value) -> Self {
        self.details = Some(details);
        self
    }

    /// Attach a VM status code.
    pub fn with_vm_status(mut self, code: u64) -> Self {
        self.vm_status_code = Some(code);
        self
    }

    /// Get the HTTP status code for this error.
    pub fn http_status(&self) -> StatusCode {
        self.http_status
    }

    /// Convert from a mempool status to a V2Error.
    pub fn from_mempool_status(code: MempoolStatusCode, message: &str) -> Self {
        match code {
            MempoolStatusCode::Accepted => unreachable!("Accepted is not an error"),
            MempoolStatusCode::MempoolIsFull => Self {
                code: ErrorCode::MempoolFull,
                message: message.to_string(),
                http_status: StatusCode::SERVICE_UNAVAILABLE,
                request_id: None,
                details: None,
                vm_status_code: None,
            },
            _ => Self {
                code: ErrorCode::MempoolRejected,
                message: message.to_string(),
                http_status: StatusCode::UNPROCESSABLE_ENTITY,
                request_id: None,
                details: None,
                vm_status_code: None,
            },
        }
    }
}
```

---

## Axum Integration

### IntoResponse Implementation

```rust
impl IntoResponse for V2Error {
    fn into_response(self) -> Response {
        let status = self.http_status;
        let body = Json(self);
        (status, body).into_response()
    }
}
```

This lets handlers return `Result<Json<T>, V2Error>` directly:

```rust
async fn my_handler(State(ctx): State<V2Context>) -> Result<Json<Foo>, V2Error> {
    let data = do_something().map_err(V2Error::internal)?;
    Ok(Json(data))
}
```

### From Implementations

```rust
// Convert anyhow::Error to V2Error
impl From<anyhow::Error> for V2Error {
    fn from(err: anyhow::Error) -> Self {
        V2Error::internal(err)
    }
}

// Display and Error traits for std compatibility
impl std::fmt::Display for V2Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "[{:?}] {}", self.code, self.message)
    }
}

impl std::error::Error for V2Error {}
```

---

## Request ID Middleware

To automatically populate `request_id` on errors, we use an Axum middleware:

```rust
// api/src/v2/middleware/request_id.rs

use axum::{
    extract::Request,
    middleware::Next,
    response::Response,
    http::HeaderValue,
};
use uuid::Uuid;

pub async fn request_id_middleware(
    mut request: Request,
    next: Next,
) -> Response {
    // Extract or generate request ID
    let request_id = request
        .headers()
        .get("x-request-id")
        .and_then(|v| v.to_str().ok())
        .map(|s| s.to_string())
        .unwrap_or_else(|| Uuid::new_v4().to_string());

    // Store in request extensions for handlers to access
    request.extensions_mut().insert(RequestId(request_id.clone()));

    let mut response = next.run(request).await;

    // Echo request ID in response headers
    if let Ok(val) = HeaderValue::from_str(&request_id) {
        response.headers_mut().insert("x-request-id", val);
    }

    response
}

#[derive(Clone)]
pub struct RequestId(pub String);
```

Handlers can then access the request ID:

```rust
async fn my_handler(
    State(ctx): State<V2Context>,
    request_id: Option<Extension<RequestId>>,
) -> Result<Json<T>, V2Error> {
    let result = do_something();
    result.map_err(|e| {
        let mut err = V2Error::internal(e);
        if let Some(Extension(RequestId(id))) = request_id {
            err = err.with_request_id(id);
        }
        err
    })
}
```

---

## Example Error Responses

### Resource Not Found (404)

```json
HTTP/1.1 404 Not Found
Content-Type: application/json
X-Request-Id: req_abc123

{
    "code": "RESOURCE_NOT_FOUND",
    "message": "Resource 0x1::coin::CoinStore<0x1::fake::Coin> not found at 0x1 at ledger version 12345",
    "request_id": "req_abc123",
    "details": {
        "address": "0x1",
        "resource_type": "0x1::coin::CoinStore<0x1::fake::Coin>",
        "ledger_version": 12345
    }
}
```

### View Function Failed (400)

```json
HTTP/1.1 400 Bad Request
Content-Type: application/json
X-Request-Id: req_def456

{
    "code": "VIEW_FUNCTION_FAILED",
    "message": "Move abort in 0x1::coin::balance: ECOIN_STORE_NOT_PUBLISHED (code 0x60006)",
    "request_id": "req_def456",
    "vm_status_code": 393222,
    "details": {
        "function": "0x1::coin::balance",
        "abort_code": "0x60006"
    }
}
```

### Version Pruned (410)

```json
HTTP/1.1 410 Gone
Content-Type: application/json

{
    "code": "VERSION_PRUNED",
    "message": "Ledger version 100 has been pruned. Oldest available version is 50000.",
    "details": {
        "requested_version": 100,
        "oldest_available_version": 50000
    }
}
```

### Mempool Rejected (422)

```json
HTTP/1.1 422 Unprocessable Entity
Content-Type: application/json

{
    "code": "MEMPOOL_REJECTED",
    "message": "Transaction rejected: sequence number too old",
    "vm_status_code": 3,
    "details": {
        "mempool_status": "VmError",
        "vm_status": "SEQUENCE_NUMBER_TOO_OLD"
    }
}
```

### Batch Too Large (400)

```json
HTTP/1.1 400 Bad Request
Content-Type: application/json

{
    "code": "BATCH_TOO_LARGE",
    "message": "Batch size 50 exceeds maximum of 20",
    "details": {
        "batch_size": 50,
        "max_batch_size": 20
    }
}
```

### Internal Error (500)

```json
HTTP/1.1 500 Internal Server Error
Content-Type: application/json

{
    "code": "INTERNAL_ERROR",
    "message": "Failed to read from database",
    "request_id": "req_xyz789"
}
```
