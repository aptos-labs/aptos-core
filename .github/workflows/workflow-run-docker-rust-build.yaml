name: "*run Docker rust build reusable workflow"

on:
  workflow_call:
    inputs:
      GIT_SHA:
        required: true
        type: string
        description: The git SHA1 to build. If not specified, the latest commit on the triggering branch will be built
      TARGET_CACHE_ID:
        required: true
        type: string
        description: ID of the docker cache to use for the build
      FEATURES:
        required: false
        type: string
        description: The cargo features to build. If not specified, none will be built other than those specified in cargo config
      PROFILE:
        default: release
        required: false
        type: string
        description: The cargo profile to build. If not specified, the default release profile will be used
      BUILD_ADDL_TESTING_IMAGES:
        default: false
        required: false
        type: boolean
        description: Whether to build additional testing images. If not specified, only the base release images will be built
      TARGET_REGISTRY:
        default: gcp
        required: false
        type: string
        description: The target docker registry to push to

  workflow_dispatch:
    inputs:
      GIT_SHA:
        required: true
        type: string
        description: The git SHA1 to build. If not specified, the latest commit on the triggering branch will be built
      FEATURES:
        required: false
        type: string
        description: The cargo features to build. If not specified, none will be built other than those specified in cargo config
      PROFILE:
        default: release
        required: false
        type: string
        description: The cargo profile to build. If not specified, the default release profile will be used
      BUILD_ADDL_TESTING_IMAGES:
        default: false
        required: false
        type: boolean
        description: Whether to build additional testing images. If not specified, only the base release images will be built
      TARGET_REGISTRY:
        default: gcp
        required: false
        type: string
        description: The target docker registry to push to

env:
  GIT_SHA: ${{ inputs.GIT_SHA }}
  TARGET_CACHE_ID: ${{ inputs.TARGET_CACHE_ID || inputs.GIT_SHA }} # on workflow_dispatch, the build is one-off, so use the git sha as the cache id instead of another key
  PROFILE: ${{ inputs.PROFILE }}
  FEATURES: ${{ inputs.FEATURES }}
  BUILD_ADDL_TESTING_IMAGES: ${{ inputs.BUILD_ADDL_TESTING_IMAGES }}
  AWS_ECR_ACCOUNT_NUM: ${{ secrets.ENV_ECR_AWS_ACCOUNT_NUM }}
  GCP_DOCKER_ARTIFACT_REPO: ${{ vars.GCP_DOCKER_ARTIFACT_REPO }}
  TARGET_REGISTRY: ${{ inputs.TARGET_REGISTRY }}
  GCP_DOCKER_BUILD_LOCK_BUCKET: "aptos-docker-build-lock-bucket"

permissions:
  contents: read
  id-token: write #required for GCP Workload Identity federation which we use to login into Google Artifact Registry

jobs:
  pre-build-validation:
    outputs: 
      image-exist: ${{ steps.check-images.outputs.image-exist }}
      lock-exist: ${{ steps.check-lock.outputs.lock-exist }}
    runs-on: runs-on,cpu=8,family=c7,image=aptos-ubuntu-x64,run-id=${{ github.run_id }},spot=co,disk=small
    steps:       
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.GIT_SHA }}

      - name: Check if docker images already exist
        id: check-images
        uses: aptos-labs/aptos-core/.github/actions/wait-images-ci@main
        continue-on-error: true
        with:
          GIT_SHA: ${{ env.GIT_SHA }}
          GCP_DOCKER_ARTIFACT_REPO: ${{ env.GCP_DOCKER_ARTIFACT_REPO }}
          WAIT_FOR_IMAGE_SECONDS: 1

      - name: Set output
        id: set-output
        depends-on: check-images
        run: |
          if [ "${{ steps.check-images.outcome }}" = "success" ]; then
            echo "image-exist=true" >> $GITHUB_OUTPUT
          else
            echo "image-exist=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Check Docker Build Lock File
        id: check-lock
        if: steps.check-images.outcome == 'failure'
        continue-on-error: true
        run:  |
          set +e
          gcloud storage ls gs://${{ env.GCP_DOCKER_BUILD_LOCK_BUCKET }}/${{ env.GIT_SHA }}.txt
          if [ $? -eq 0 ]; then
            echo "Lock file exists: Current workflow building: "
            gcloud storage cat gs://${{ env.GCP_DOCKER_BUILD_LOCK_BUCKET }}/${{ env.GIT_SHA }}.txt
            echo "lock-exist=true" >> $GITHUB_OUTPUT
          else
            echo "Lock file does not exist"
            echo "lock-exist=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Lock Build
        if: steps.check-images.outcome == 'failure' && steps.check-lock.outputs.lock-exist == 'false'
        run: | 
          echo "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}" > ${GIT_SHA}.txt
          gcloud storage cp ${GIT_SHA}.txt gs://${GCP_DOCKER_BUILD_LOCK_BUCKET}/${GIT_SHA}.txt
          echo "Docker Build locked"

  rust-all:
    runs-on: runs-on,cpu=64,family=c7,image=aptos-ubuntu-x64,run-id=${{ github.run_id }},spot=co,disk=large
    needs: pre-build-validation
    if: needs.pre-build-validation.outputs.image-exist == 'false' && needs.pre-build-validation.outputs.lock-exist == 'false'
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.GIT_SHA }}

      - name: Setup Runs On Cache for Docker
        uses: runs-on/cache@v4
        with:
          path: |
            /home/runner/docker-cache.tzst
          key: docker-buildkit-cache-${{ env.PROFILE }}-${{ env.FEATURES }}${{ hashFiles('Cargo.lock') }}

      - name: Untar cache if present
        run: |
          if [ -f /home/runner/docker-cache.tzst ]; then
            sudo systemctl stop docker
            sudo tar --posix -xf /home/runner/docker-cache.tzst -P -C /var/lib/docker --use-compress-program zstdmt .
            sudo systemctl start docker
          fi          

      - uses: aptos-labs/aptos-core/.github/actions/docker-setup@main
        with:
          GCP_WORKLOAD_IDENTITY_PROVIDER: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          GCP_SERVICE_ACCOUNT_EMAIL: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DOCKER_ARTIFACT_REPO: ${{ secrets.AWS_DOCKER_ARTIFACT_REPO }}
          GIT_CREDENTIALS: ${{ secrets.GIT_CREDENTIALS }}

      - name: Build and Push Rust images
        run: docker/builder/docker-bake-rust-all.sh
        env:
          PROFILE: ${{ env.PROFILE }}
          FEATURES: ${{ env.FEATURES }}
          BUILD_ADDL_TESTING_IMAGES: ${{ env.BUILD_ADDL_TESTING_IMAGES }}
          GIT_CREDENTIALS: ${{ secrets.GIT_CREDENTIALS }}
          TARGET_REGISTRY: ${{ env.TARGET_REGISTRY }}
      
      - name: Prepare Docker for Caching
        run: |
          if [ ! -f /home/runner/docker-cache.tzst ]; then
            sudo systemctl stop docker
            sudo tar --posix -cf /home/runner/docker-cache.tzst -P -C /var/lib/docker --use-compress-program zstdmt .
          fi
      
      - name: Post-run Lock Cleanup 
        if: always()
        run: | 
          gcloud storage rm gs://${GCP_DOCKER_BUILD_LOCK_BUCKET}/${GIT_SHA}.txt || true
          echo "Docker Build unlocked"

