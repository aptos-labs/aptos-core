## IMPORTANT NOTE TO EDITORS OF THIS FILE ##

## Note that when you create a PR the jobs in this file are triggered off the `pull_request_target` event instead of `pull_request` event.
## This is because the `pull_request` event makes secrets only available to PRs from branches, not from forks, and some of these jobs require secrets.
## So with `pull_request_target` we're making secrets available to fork-based PRs too.
## Using `pull_request_target" has a side effect, which is that the workflow execution will be driven by the state of the <workflow>.yaml on the `main` (=target) branch, even if you edited the <workflow>.yaml in your PR.
## So when you for example add a new job here, you won't see that job appear in the PR itself. It will only become effective once you merge the PR to main.
## Therefore, if you want to add a new job here and want to test it's functionality prior to a merge to main, you have to to _temporarily_ change the trigger event from `pull_request_target` to `pull_request`.

## Additionally, because `pull_request_target` gets secrets injected for forked PRs we use `https://github.com/sushichop/action-repository-permission`
## to ensure these jobs are only executed when a repo member with "write" permission has triggered the workflow (directly through a push or indirectly by applying a label or enabling auto_merge).

name: "Build+Push Images"
on: # build on main branch OR when a PR is labeled with `CICD:build-images`
  # Allow us to run this specific workflow without a PR
  workflow_dispatch:
  pull_request:
    types: [labeled, opened, synchronize, reopened, auto_merge_enabled]
  push:
    branches:
      - main
      - auto
      - canary
      - devnet
      - testnet

# cancel redundant builds
concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.ref }}-test
  cancel-in-progress: true

env:
  GCP_DOCKER_ARTIFACT_REPO: ${{ secrets.GCP_DOCKER_ARTIFACT_REPO }}
  AWS_ECR_ACCOUNT_NUM: ${{ secrets.ENV_ECR_AWS_ACCOUNT_NUM }}
  # In case of pull_request events by default github actions merges main into the PR branch and then runs the tests etc
  # on the prospective merge result instead of only on the tip of the PR.
  # We want to avoid this in case of docker image builds on PRs since want more predictable images then correspond to the code state a developer pushed from local.
  # Therefore we build the images with the head of the PR branch instead of the prospective merge result.
  # Safety-wise the merge queue (bors/kodiak or whatever we use) will retest the PR branch merged with the base branch anyways.
  # In case of push events, this hack is a noop as we default to `github.sha`.
  # For more info also see https://github.com/actions/checkout#checkout-pull-request-head-commit-instead-of-merge-commit
  GIT_SHA: ${{ github.event.pull_request.head.sha || github.sha }}

permissions:
  contents: read
  id-token: write #required for GCP Workload Identity federation which we use to login into Google Artifact Registry
  issues: write
  pull-requests: write

# Note on the job-level `if` conditions:
# This workflow is designed such that:
# 1. Run ALL jobs when a 'push', 'workflow_dispatch' triggered the workflow or on 'pull_request's which have set auto_merge=true or have the label "CICD:run-e2e-tests".
# 2. Run ONLY the docker image building jobs on PRs with the "CICD:build-images" label.
# 3. Run NOTHING when neither 1. or 2.'s conditions are satisfied.
jobs:
  permission-check:
    if: |
      github.event_name == 'push' ||
      github.event_name == 'workflow_dispatch' ||
      contains(github.event.pull_request.labels.*.name, 'CICD:build-images') ||
      contains(github.event.pull_request.labels.*.name, 'CICD:run-e2e-tests') ||
      github.event.pull_request.auto_merge != null
    runs-on: ubuntu-latest
    steps:
      - name: Check repository permission for user which triggered workflow
        uses: sushichop/action-repository-permission@13d208f5ae7a6a3fc0e5a7c2502c214983f0241c
        with:
          required-permission: write
          comment-not-permitted: Sorry, you don't have permission to trigger this workflow.

  rust-images:
    # trigger only for push events (on protected branches as defined above) OR on PR events with the "CICD:build-images" label.
    # needs: permission-check
    # strategy:
    #   matrix:
    #     IMAGE_TARGET: [test]

    runs-on: high-perf-docker
    steps:
      - uses: actions/checkout@v3
        with:
          ref: ${{ env.GIT_SHA }}

      - uses: ./.github/actions/gar-auth
        with:
          GCP_WORKLOAD_IDENTITY_PROVIDER: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          GCP_SERVICE_ACCOUNT_EMAIL: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}

      # - name: Login to ECR
      #   uses: docker/login-action@v2
      #   with:
      #     registry: ${{ secrets.ENV_ECR_AWS_ACCOUNT_NUM }}.dkr.ecr.us-west-2.amazonaws.com
      #     username: ${{ secrets.AWS_ACCESS_KEY_ID }}
      #     password: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      # - uses: ./.github/actions/docker-buildx-setup

      - run: |
          docker run \
            -e GOOGLE_APPLICATION_CREDENTIALS=/kaniko/config.json \
            -v $(pwd):/workspace \
            -v ${{ env.GOOGLE_APPLICATION_CREDENTIALS }}:/kaniko/config.json:ro \
            gcr.io/kaniko-project/executor:latest \
            --dockerfile /workspace/docker/rust-all.Dockerfile \
            --cache=true \
            --build-arg "IMAGE_TARGET=test" \
            --use-new-run \
            --reproducible \
            --skip-unused-stages \
            --destination "${{ secrets.GCP_DOCKER_ARTIFACT_REPO }}/build-with-kaniko/forge:${{ env.GIT_SHA }}" \
            --context dir:///workspace/ \
            --target=forge

      - run: |
          docker run \
            -e GOOGLE_APPLICATION_CREDENTIALS=/kaniko/config.json \
            -v $(pwd):/workspace \
            -v ${{ env.GOOGLE_APPLICATION_CREDENTIALS }}:/kaniko/config.json:ro \
            gcr.io/kaniko-project/executor:latest \
            --dockerfile /workspace/docker/rust-all.Dockerfile \
            --cache=true \
            --build-arg "IMAGE_TARGET=test" \
            --use-new-run \
            --reproducible \
            --skip-unused-stages \
            --destination "${{ secrets.GCP_DOCKER_ARTIFACT_REPO }}/build-with-kaniko/txn-emitter:${{ env.GIT_SHA }}" \
            --context dir:///workspace/ \
            --target=txn-emitter
      # - uses: int128/kaniko-action@v1
      #   env:
      #     GOOGLE_APPLICATION_CREDENTIALS: /kaniko/config.json
      #   with:
      #     push: true
      #     tags: ${{ secrets.GCP_DOCKER_ARTIFACT_REPO }}/build-with-kaniko/forge:${{ env.GIT_SHA }}
      #     file: docker/rust-all.Dockerfile
      #     target: forge
      #     cache: true
      #     cache-repository: ${{ secrets.GCP_DOCKER_ARTIFACT_REPO }}/kaniko-cache

  sdk-integration-test:
    needs: rust-images
    if: |
      github.event_name == 'push' ||
      github.event_name == 'workflow_dispatch' ||
      contains(github.event.pull_request.labels.*.name, 'CICD:run-e2e-tests') ||
      github.event.pull_request.auto_merge != null
    uses: ./.github/workflows/sdk-integration-test.yaml
    secrets: inherit
    with:
      GIT_SHA: ${{ github.event.pull_request.head.sha || github.sha }}

  forge-e2e-test:
    needs: rust-images
    if: |
      github.event_name == 'push' ||
      github.event_name == 'workflow_dispatch' ||
      contains(github.event.pull_request.labels.*.name, 'CICD:run-e2e-tests') ||
      github.event.pull_request.auto_merge != null
    uses: ./.github/workflows/run-forge.yaml
    secrets: inherit
    with:
      GIT_SHA: ${{ github.event.pull_request.head.sha || github.sha }}
      merge_or_canary: ${{ github.event.pull_request.auto_merge != null && 'merge' || 'canary' }}

  community-platform:
    needs: permission-check
    runs-on: high-perf-docker
    steps:
      - uses: actions/checkout@v3
        with:
          ref: ${{ env.GIT_SHA }}

      - uses: ./.github/actions/gar-auth
        with:
          GCP_WORKLOAD_IDENTITY_PROVIDER: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          GCP_SERVICE_ACCOUNT_EMAIL: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}

      - name: Login to ECR
        uses: docker/login-action@v2
        with:
          registry: ${{ secrets.ENV_ECR_AWS_ACCOUNT_NUM }}.dkr.ecr.us-west-2.amazonaws.com
          username: ${{ secrets.AWS_ACCESS_KEY_ID }}
          password: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - uses: ./.github/actions/docker-buildx-setup

      - name: Build and Push Community Platform image
        env:
          GIT_BRANCH: ${{ github.head_ref }}
        run: |
          cd ecosystem/platform/server
          docker buildx bake --progress=plain --push -f ./docker-bake.hcl

  indexer-server:
    needs: permission-check
    runs-on: high-perf-docker
    steps:
      - uses: actions/checkout@v3
        with:
          ref: ${{ env.GIT_SHA }}

      - uses: ./.github/actions/gar-auth
        with:
          GCP_WORKLOAD_IDENTITY_PROVIDER: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          GCP_SERVICE_ACCOUNT_EMAIL: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}

      - name: Login to ECR
        uses: docker/login-action@v2
        with:
          registry: ${{ secrets.ENV_ECR_AWS_ACCOUNT_NUM }}.dkr.ecr.us-west-2.amazonaws.com
          username: ${{ secrets.AWS_ACCESS_KEY_ID }}
          password: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - uses: ./.github/actions/docker-buildx-setup

      - name: Build and Push Indexer Server image
        env:
          GIT_BRANCH: ${{ github.head_ref }}
        run: |
          cd ecosystem/indexer-server
          docker buildx bake --progress=plain --push -f ./docker-bake.hcl
