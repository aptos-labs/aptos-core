
\Section{Move and the Prover}

Move was developed for the Diem blockchain \cite{DIEM}, but its design is not
specific to blockchains.  A Move execution consists of a sequence of updates
evolving a \emph{global persistent memory state}, which we just call the
\emph{(global) memory}.  Updates are executed in a \emph{transactional} style.

The global memory is organized as a collection of resources, described by Move
structures (data types). A resource in memory is indexed by a pair of a type
(possibly instantiated) and an address (for example the address of a user
account). For instance, the expression |exists<Coin<USD>>(addr)| will be true if
there is a value of type |Coin<USD>| stored at |addr|. As seen in this example,
Move uses type generics, and working with generic functions and types is rather
idiomatic for Move.  Notice that account addresses are not just arbitrary values
but have a specific role in Move's programming methodology related to access
control via the builtin type of \emph{signers}, as will be discussed later.

A Move application consists of a set of \emph{transaction scripts}. Each of
those script defines a Move function with input parameters but no output
parameters.  This function updates the global memory, including emitting
events. The execution of this function can fail via a well-defined abort
mechanism, in which case the memory stays unmodified. An environment emits a
sequence of calls to such scripts, thereby evolving the memory.

% A transaction script is written in Move as an imperative function which can read
% and write the global memory. Move uses a specific style of
% imperative programming based on \emph{borrow semantics} \cite{BORROW_SEM}, as
% popularized in the programming language Rust \cite{RUST,RUST_TYPES}. For the
% verification problem borrow semantics is very important.  While allowing
% references into structured data, those are guaranteed to be safe by the
% \emph{borrow checker} \cite{BORROW_CHECKER}, which is run during bytecode
% loading time, and which verification can assume. Furthermore, the notorious hard
% verification problem of aliasing of references in the presence of mutation is
% eliminated.  Mutation always starts from a root location either in global memory
% or on the execution stack, and while a tree starting from this root is mutated,
% no other access can happen anywhere in the tree. Intuitively, borrow semantics
% allows to move a mutation 'cursor' down the tree, which follows linear typing
% discipline. Because of this property, mutable reference parameters to functions
% can be converted to input/output parameters, and verification of Move can avoid
% the traditionally hard problems caused by aliasing of mutable references.


\Paragraph{Programming in Move}

\begin{Figure}
\caption{\label{fig:AccountDef} Account Example Program}
\begin{MoveBox}
module Account {
  struct Account has key {
    balance: u64,
  }

  fun withdraw(account: address, amount: u64) acquires Account {
    let balance = &mut borrow_global_mut<Account>(account).balance;
    assert(*balance >= amount, Errors::limit_exceeded());
    *balance = *balance - amount;
  }

  fun deposit(account: address, amount: u64) acquires Account {
    let balance = &mut borrow_global_mut<Account>(account).balance;
    assert(*balance <= Limits::max_u64() - amount, Errors::limit_exceeded());
    *balance = *balance + amount;
  }

  public(script) fun transfer(from: &signer, to: address, amount: u64)
  acquires Account {
    assert(Signer::address_of(from) != to, Errors::invalid_argument());
    withdraw(Signer::address_of(from), amount);
    deposit(to, amount);
  }
}
\end{MoveBox}
\end{Figure}

\noindent In Move, one defines transactions via so-called \emph{script functions} which
take a set of parameters.  Those functions can call other functions. Script and
regular functions are encapsulated in \emph{modules}. Move modules are also the
place where structs are defined. An illustration of a Move contract is given in
Fig.~\ref{fig:AccountDef} (for a more complete description see the Move
Book~\cite{MOVE_LANG_DEF}). The example is a simple account which holds a
balance, defined in the script function |transfer|. Scripts get passed in so
called \emph{signers} which are tokens which represent an authorized account
address. The caller of the script -- an external program -- has ensured that the
owner of the signer account address has agreed to execute this script.  Notice
that in the code, the |assert| statement causes a Move transaction to abort
execution if the condition is not met.  Abortion can also happen implicitly; for
example, the expression |borrow_global_mut<T>(addr)| will abort if no resource
|T| exists at |addr|.


\Paragraph{Specifying in Move}

\begin{Figure}
\caption{\label{fig:AccountSpec} Account Example Specification}
\begin{MoveBox}
module Account {
  spec transfer {
    let from_addr = Signer::address_of(from);
    aborts_if from_addr == to;
    aborts_if bal(from_addr) < amount;
    aborts_if bal(to) + amount > Limits::max_u64();
    ensures bal(from_addr) == old(bal(from_addr)) - amount;
    ensures bal(to) == old(bal(to)) + amount;
  }

  spec fun bal(acc: address): u64 {
    global<Account>(acc).balance
  }

  invariant forall acc: address where exists<Account>(acc):
    bal(acc) >= AccountLimits::min_balance();

  invariant update forall acc: address where exists<Account>(acc):
    old(bal(acc)) - bal(acc) <= AccountLimits::max_decrease();
}
\end{MoveBox}
\end{Figure}

\noindent The specification language supports {\em Design By Contract}
\cite{DESIGN_BY_CONTRACT}. Developers can provide pre and post conditions for
functions, which include conditions over (mutable) parameters and global
memory. Developers can also provide invariants over data structures, as well as
the (state-dependent) content of the global memory. Universal and existential
quantification both over bounded domains (like the indices of a vector) as well
of unbounded domains (like all memory addresses, all integers, etc.)  are
supported. The latter makes the specification language very expressive, but also
renders the verification problem in theory undecidable (and in practice
dependent on heuristic decision procedures).

Fig.~\ref{fig:AccountSpec} illustrates the specification language by extending
the account example in Fig.~\ref{fig:AccountDef} (for the definition of the
specification language see \cite{MOVE_SPEC_LANG_DEF}). This adds the
specification of the |transfer| function, a helper function |bal| for use in
specs, and two global memory invariants. The first invariant states that a
balance can never drop underneath a certain minimum. The second invariant refers
to an update of global memory with pre and post state: the balance on an account
can never decrease in one step more than a certain amount.  Note that while the
Move programming language has only unsigned integers, the specification language
uses arbitrary precision signed integers, making it convenient to specify
something like |x + y <= limit|, without need to worry about overflow.

Specifications for the |withdraw| and |deposit| functions have been omitted in
this examples. \MVP supports omitting specs for non-recursive functions, in
which case they are treated as being inlined at caller site.

A discerning reader may have noted that the program in Fig.~\ref{fig:AccountDef}
does not actually satisfy the specification in Fig.~\ref{fig:AccountSpec}. This
will be discussed in the next section.

% The constructs we have seen so far are only a subset of the available features
% of the Move specification language. Notably, the language supports the following
% additional features:

% \begin{itemize}
% \item Function preconditions via the |requires|-clause.
% \item Data invariants for |struct| types, as a predicate over the field values.
% \item Means to abstract commonly used specification fragments in so-called
%   \emph{specification schemas} which can then be included in other specification
%   blocks.
% \end{itemize}

\Paragraph{Running the Prover}
\label{sec:RunningProver}

\MVP operates fully automated, quite similar to a type checker or linter, and is
expected to conclude in reasonable execution time, so it can be integrated in
the regular development workflow. Running \MVP on the |module Account| produces
multiple errors. The first is this one:

\begin{MoveDiag}
error: abort not covered by any of the `aborts_if` clauses
   -- account.move:24:3
   |
13 |       let balance = &mut borrow_global_mut<Account>(account).balance;
   |                          ----------------- abort happened here
   |
   =     at account.move:18: transfer
   =         from = signer{0x18be}
   =         to = 0x18bf
   =         amount = 147u8
   =     at ...
\end{MoveDiag}

\noindent \MVP detected that an implicit aborts condition is missing in the
specification of the |withdraw| function. It prints the context of the error, as
well as an \emph{execution trace} which lead to the error. Values of variable
assignments from the counterexample found by the SMT solver are printed together
with the execution trace. Logically, the counter example presents an instance of
assignments to variables such that program and specification disagree. In
general, \MVP attempts to produce diagnostics readable for Move developers
without the need of understanding any internals of the prover.

The next errors produced are about the memory invariants in
Fig.~\ref{fig:AccountSpec}. Both of them do not hold; we show only the first failure:

\begin{MoveDiag}
error: global memory invariant does not hold
   -- account.move:39:3
   |
39 |    invariant forall acc: address where exists<Account>(acc):
40 |      bal(acc) >= AccountLimits::min_balance();
   |
   =     at account.move:6: withdraw
   =         account = 0x0
   =         amount = 11u8
   =     at account.move:7: withdraw
   =         balance = &15u8
   =     at ...
\end{MoveDiag}

\noindent This happens because in the program in Fig.~\ref{fig:AccountDef}, we
did not made any attempt to respect the limits in |min_balance()| and
|max_decrease()|. We leave it open here (but covered it in
App.~\ref{sec:CorrectedAccount}) how to fix this problem, which requires
to add some more |assert| statements to the code and abort if the limits are not
met.

In reality, the programs and specifications \MVP deals with are significant larger than
in this example. For example, the conditions under which a transaction
in the Diem framework can abort typically has dozens of individual predicates,
stemming from other functions called by this transaction. Moreover, there are
hundreds of memory invariants specified, encoding access control and other
requirements for the Diem blockchain.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
