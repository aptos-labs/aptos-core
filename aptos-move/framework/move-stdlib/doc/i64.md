
<a id="0x1_i64"></a>

# Module `0x1::i64`

Implements the <code><a href="i64.md#0x1_i64">i64</a></code> type. The type name <code><a href="i64.md#0x1_i64">i64</a></code> is a shortcut for the <code><b>struct</b> <a href="i64.md#0x1_i64_I64">I64</a></code> defined in this module. One can use <code>+</code>, <code>-</code>, <code>==</code>, etc. with <code><a href="i64.md#0x1_i64">i64</a></code>, which are mapped to Move functions in this module.


-  [Struct `I64`](#0x1_i64_I64)
-  [Constants](#@Constants_0)
-  [Function `from`](#0x1_i64_from)
-  [Function `neg_from`](#0x1_i64_neg_from)
-  [Function `neg`](#0x1_i64_neg)
-  [Function `wrapping_add`](#0x1_i64_wrapping_add)
-  [Function `add`](#0x1_i64_add)
-  [Function `wrapping_sub`](#0x1_i64_wrapping_sub)
-  [Function `sub`](#0x1_i64_sub)
-  [Function `mul`](#0x1_i64_mul)
-  [Function `div`](#0x1_i64_div)
-  [Function `mod`](#0x1_i64_mod)
-  [Function `abs`](#0x1_i64_abs)
-  [Function `abs_u64`](#0x1_i64_abs_u64)
-  [Function `min`](#0x1_i64_min)
-  [Function `max`](#0x1_i64_max)
-  [Function `pow`](#0x1_i64_pow)
-  [Function `pack`](#0x1_i64_pack)
-  [Function `unpack`](#0x1_i64_unpack)
-  [Function `bits`](#0x1_i64_bits)
-  [Function `sign`](#0x1_i64_sign)
-  [Function `zero`](#0x1_i64_zero)
-  [Function `is_zero`](#0x1_i64_is_zero)
-  [Function `is_neg`](#0x1_i64_is_neg)
-  [Function `cmp`](#0x1_i64_cmp)
-  [Function `eq`](#0x1_i64_eq)
-  [Function `neq`](#0x1_i64_neq)
-  [Function `gt`](#0x1_i64_gt)
-  [Function `gte`](#0x1_i64_gte)
-  [Function `lt`](#0x1_i64_lt)
-  [Function `lte`](#0x1_i64_lte)
-  [Function `twos_complement`](#0x1_i64_twos_complement)
-  [Function `sign_internal`](#0x1_i64_sign_internal)


<pre><code></code></pre>



<a id="0x1_i64_I64"></a>

## Struct `I64`

Implementation of the <code><a href="i64.md#0x1_i64">i64</a></code> primitive type. Do not use this type directly, instead use <code><a href="i64.md#0x1_i64">i64</a></code>.


<pre><code><b>struct</b> <a href="i64.md#0x1_i64_I64">I64</a> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>bits: u64</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_0"></a>

## Constants


<a id="0x1_i64_MAX_U64"></a>

(1 << 64) - 1


<pre><code><b>const</b> <a href="i64.md#0x1_i64_MAX_U64">MAX_U64</a>: u64 = 18446744073709551615;
</code></pre>



<a id="0x1_i64_EDIVISION_BY_ZERO"></a>

Division by Zero is not allowed


<pre><code><b>const</b> <a href="i64.md#0x1_i64_EDIVISION_BY_ZERO">EDIVISION_BY_ZERO</a>: u64 = 2;
</code></pre>



<a id="0x1_i64_EOVERFLOW"></a>

Arithmetic operation resulted in overflow (value outside the range [-2^63, 2^63 - 1])


<pre><code><b>const</b> <a href="i64.md#0x1_i64_EOVERFLOW">EOVERFLOW</a>: u64 = 1;
</code></pre>



<a id="0x1_i64_EQ"></a>



<pre><code><b>const</b> <a href="i64.md#0x1_i64_EQ">EQ</a>: u8 = 1;
</code></pre>



<a id="0x1_i64_GT"></a>



<pre><code><b>const</b> <a href="i64.md#0x1_i64_GT">GT</a>: u8 = 2;
</code></pre>



<a id="0x1_i64_LT"></a>



<pre><code><b>const</b> <a href="i64.md#0x1_i64_LT">LT</a>: u8 = 0;
</code></pre>



<a id="0x1_i64_BITS_MAX_I64"></a>

max number that a I64 could represent = (0 followed by 63 1s) = (1 << 63) - 1


<pre><code><b>const</b> <a href="i64.md#0x1_i64_BITS_MAX_I64">BITS_MAX_I64</a>: u64 = 9223372036854775807;
</code></pre>



<a id="0x1_i64_BITS_MIN_I64"></a>

min number that a I64 could represent = (1 followed by 63 0s) = 1 << 63


<pre><code><b>const</b> <a href="i64.md#0x1_i64_BITS_MIN_I64">BITS_MIN_I64</a>: u64 = 9223372036854775808;
</code></pre>



<a id="0x1_i64_TWO_POW_64"></a>

1 << 64


<pre><code><b>const</b> <a href="i64.md#0x1_i64_TWO_POW_64">TWO_POW_64</a>: u128 = 18446744073709551616;
</code></pre>



<a id="0x1_i64_from"></a>

## Function `from`

Creates an I64 from a u64, asserting that it's not greater than the maximum positive value


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_from">from</a>(v: u64): <a href="i64.md#0x1_i64_I64">i64::I64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_from">from</a>(v: u64): <a href="i64.md#0x1_i64_I64">I64</a> {
    <b>assert</b>!(v &lt;= <a href="i64.md#0x1_i64_BITS_MAX_I64">BITS_MAX_I64</a>, <a href="i64.md#0x1_i64_EOVERFLOW">EOVERFLOW</a>);
    <a href="i64.md#0x1_i64_I64">I64</a> { bits: v }
}
</code></pre>



</details>

<a id="0x1_i64_neg_from"></a>

## Function `neg_from`

Creates a negative I64 from a u64, asserting that it's not greater than the minimum negative value


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_neg_from">neg_from</a>(v: u64): <a href="i64.md#0x1_i64_I64">i64::I64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_neg_from">neg_from</a>(v: u64): <a href="i64.md#0x1_i64_I64">I64</a> {
    <b>assert</b>!(v &lt;= <a href="i64.md#0x1_i64_BITS_MIN_I64">BITS_MIN_I64</a>, <a href="i64.md#0x1_i64_EOVERFLOW">EOVERFLOW</a>);
    <a href="i64.md#0x1_i64_I64">I64</a> { bits: <a href="i64.md#0x1_i64_twos_complement">twos_complement</a>(v) }
}
</code></pre>



</details>

<a id="0x1_i64_neg"></a>

## Function `neg`



<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_neg">neg</a>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>): <a href="i64.md#0x1_i64_I64">i64::I64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_neg">neg</a>(self: <a href="i64.md#0x1_i64_I64">I64</a>): <a href="i64.md#0x1_i64_I64">I64</a> {
    <b>if</b> (self.<a href="i64.md#0x1_i64_is_neg">is_neg</a>()) { self.<a href="i64.md#0x1_i64_abs">abs</a>() }
    <b>else</b> {
        <a href="i64.md#0x1_i64_neg_from">neg_from</a>(self.bits)
    }
}
</code></pre>



</details>

<a id="0x1_i64_wrapping_add"></a>

## Function `wrapping_add`

Performs wrapping addition on two I64 numbers


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_wrapping_add">wrapping_add</a>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>, num2: <a href="i64.md#0x1_i64_I64">i64::I64</a>): <a href="i64.md#0x1_i64_I64">i64::I64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_wrapping_add">wrapping_add</a>(self: <a href="i64.md#0x1_i64_I64">I64</a>, num2: <a href="i64.md#0x1_i64_I64">I64</a>): <a href="i64.md#0x1_i64_I64">I64</a> {
    <a href="i64.md#0x1_i64_I64">I64</a> { bits: (((self.bits <b>as</b> u128) + (num2.bits <b>as</b> u128)) % <a href="i64.md#0x1_i64_TWO_POW_64">TWO_POW_64</a> <b>as</b> u64) }
}
</code></pre>



</details>

<a id="0x1_i64_add"></a>

## Function `add`

Performs checked addition on two I64 numbers, abort on overflow


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_add">add</a>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>, num2: <a href="i64.md#0x1_i64_I64">i64::I64</a>): <a href="i64.md#0x1_i64_I64">i64::I64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_add">add</a>(self: <a href="i64.md#0x1_i64_I64">I64</a>, num2: <a href="i64.md#0x1_i64_I64">I64</a>): <a href="i64.md#0x1_i64_I64">I64</a> {
    <b>let</b> sum = self.<a href="i64.md#0x1_i64_wrapping_add">wrapping_add</a>(num2);
    // overflow only <b>if</b>: (1) postive + postive = negative, OR (2) negative + negative = positive
    <b>let</b> self_sign = self.<a href="i64.md#0x1_i64_sign_internal">sign_internal</a>();
    <b>let</b> overflow = self_sign == num2.<a href="i64.md#0x1_i64_sign_internal">sign_internal</a>() && self_sign != sum.<a href="i64.md#0x1_i64_sign_internal">sign_internal</a>();
    <b>assert</b>!(!overflow, <a href="i64.md#0x1_i64_EOVERFLOW">EOVERFLOW</a>);
    sum
}
</code></pre>



</details>

<a id="0x1_i64_wrapping_sub"></a>

## Function `wrapping_sub`

Performs wrapping subtraction on two I64 numbers


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_wrapping_sub">wrapping_sub</a>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>, num2: <a href="i64.md#0x1_i64_I64">i64::I64</a>): <a href="i64.md#0x1_i64_I64">i64::I64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_wrapping_sub">wrapping_sub</a>(self: <a href="i64.md#0x1_i64_I64">I64</a>, num2: <a href="i64.md#0x1_i64_I64">I64</a>): <a href="i64.md#0x1_i64_I64">I64</a> {
    self.<a href="i64.md#0x1_i64_wrapping_add">wrapping_add</a>(<a href="i64.md#0x1_i64_I64">I64</a> { bits: <a href="i64.md#0x1_i64_twos_complement">twos_complement</a>(num2.bits) })
}
</code></pre>



</details>

<a id="0x1_i64_sub"></a>

## Function `sub`

Performs checked subtraction on two I64 numbers, asserting on overflow


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_sub">sub</a>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>, num2: <a href="i64.md#0x1_i64_I64">i64::I64</a>): <a href="i64.md#0x1_i64_I64">i64::I64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_sub">sub</a>(self: <a href="i64.md#0x1_i64_I64">I64</a>, num2: <a href="i64.md#0x1_i64_I64">I64</a>): <a href="i64.md#0x1_i64_I64">I64</a> {
    <b>let</b> difference = self.<a href="i64.md#0x1_i64_wrapping_sub">wrapping_sub</a>(num2);
    // overflow only <b>if</b>: (1) positive - negative = negative, OR (2) negative - positive = positive
    <b>let</b> self_sign = self.<a href="i64.md#0x1_i64_sign_internal">sign_internal</a>();
    <b>let</b> overflow = self_sign != num2.<a href="i64.md#0x1_i64_sign_internal">sign_internal</a>() && self_sign != difference.<a href="i64.md#0x1_i64_sign_internal">sign_internal</a>();
    <b>assert</b>!(!overflow, <a href="i64.md#0x1_i64_EOVERFLOW">EOVERFLOW</a>);
    difference
}
</code></pre>



</details>

<a id="0x1_i64_mul"></a>

## Function `mul`

Performs multiplication on two I64 numbers


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_mul">mul</a>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>, num2: <a href="i64.md#0x1_i64_I64">i64::I64</a>): <a href="i64.md#0x1_i64_I64">i64::I64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_mul">mul</a>(self: <a href="i64.md#0x1_i64_I64">I64</a>, num2: <a href="i64.md#0x1_i64_I64">I64</a>): <a href="i64.md#0x1_i64_I64">I64</a> {
    <b>let</b> product = (self.<a href="i64.md#0x1_i64_abs_u64">abs_u64</a>() <b>as</b> u128) * (num2.<a href="i64.md#0x1_i64_abs_u64">abs_u64</a>() <b>as</b> u128);
    <b>if</b> (self.<a href="i64.md#0x1_i64_sign_internal">sign_internal</a>() != num2.<a href="i64.md#0x1_i64_sign_internal">sign_internal</a>()) {
        <b>assert</b>!(product &lt;= (<a href="i64.md#0x1_i64_BITS_MIN_I64">BITS_MIN_I64</a> <b>as</b> u128), <a href="i64.md#0x1_i64_EOVERFLOW">EOVERFLOW</a>);
        <a href="i64.md#0x1_i64_neg_from">neg_from</a>((product <b>as</b> u64))
    } <b>else</b> {
        <b>assert</b>!(product &lt;= (<a href="i64.md#0x1_i64_BITS_MAX_I64">BITS_MAX_I64</a> <b>as</b> u128), <a href="i64.md#0x1_i64_EOVERFLOW">EOVERFLOW</a>);
        <a href="i64.md#0x1_i64_from">from</a>((product <b>as</b> u64))
    }
}
</code></pre>



</details>

<a id="0x1_i64_div"></a>

## Function `div`

Performs division on two I64 numbers
Note that we mimic the behavior of solidity int division that it rounds towards 0 rather than rounds down
- rounds towards 0: (-4) / 3 = -(4 / 3) = -1 (remainder = -1)
- rounds down: (-4) / 3 = -2 (remainder = 2)


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_div">div</a>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>, num2: <a href="i64.md#0x1_i64_I64">i64::I64</a>): <a href="i64.md#0x1_i64_I64">i64::I64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_div">div</a>(self: <a href="i64.md#0x1_i64_I64">I64</a>, num2: <a href="i64.md#0x1_i64_I64">I64</a>): <a href="i64.md#0x1_i64_I64">I64</a> {
    <b>assert</b>!(!num2.<a href="i64.md#0x1_i64_is_zero">is_zero</a>(), <a href="i64.md#0x1_i64_EDIVISION_BY_ZERO">EDIVISION_BY_ZERO</a>);
    <b>let</b> result = self.<a href="i64.md#0x1_i64_abs_u64">abs_u64</a>() / num2.<a href="i64.md#0x1_i64_abs_u64">abs_u64</a>();
    <b>if</b> (self.<a href="i64.md#0x1_i64_sign_internal">sign_internal</a>() != num2.<a href="i64.md#0x1_i64_sign_internal">sign_internal</a>()) <a href="i64.md#0x1_i64_neg_from">neg_from</a>(result)
    <b>else</b> <a href="i64.md#0x1_i64_from">from</a>(result)
}
</code></pre>



</details>

<a id="0x1_i64_mod"></a>

## Function `mod`

Performs modulo on two I64 numbers
a mod b = a - b * (a / b)


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_mod">mod</a>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>, num2: <a href="i64.md#0x1_i64_I64">i64::I64</a>): <a href="i64.md#0x1_i64_I64">i64::I64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_mod">mod</a>(self: <a href="i64.md#0x1_i64_I64">I64</a>, num2: <a href="i64.md#0x1_i64_I64">I64</a>): <a href="i64.md#0x1_i64_I64">I64</a> {
    <b>let</b> quotient = self.<a href="i64.md#0x1_i64_div">div</a>(num2);
    self.<a href="i64.md#0x1_i64_sub">sub</a>(num2.<a href="i64.md#0x1_i64_mul">mul</a>(quotient))
}
</code></pre>



</details>

<a id="0x1_i64_abs"></a>

## Function `abs`

Returns the absolute value of an I64 number


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_abs">abs</a>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>): <a href="i64.md#0x1_i64_I64">i64::I64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_abs">abs</a>(self: <a href="i64.md#0x1_i64_I64">I64</a>): <a href="i64.md#0x1_i64_I64">I64</a> {
    <b>let</b> bits = <b>if</b> (self.<a href="i64.md#0x1_i64_sign_internal">sign_internal</a>() == 0) { self.bits }
    <b>else</b> {
        <b>assert</b>!(self.bits &gt; <a href="i64.md#0x1_i64_BITS_MIN_I64">BITS_MIN_I64</a>, <a href="i64.md#0x1_i64_EOVERFLOW">EOVERFLOW</a>);
        <a href="i64.md#0x1_i64_twos_complement">twos_complement</a>(self.bits)
    };
    <a href="i64.md#0x1_i64_I64">I64</a> { bits }
}
</code></pre>



</details>

<a id="0x1_i64_abs_u64"></a>

## Function `abs_u64`

Returns the absolute value of an I64 number as a u64


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_abs_u64">abs_u64</a>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_abs_u64">abs_u64</a>(self: <a href="i64.md#0x1_i64_I64">I64</a>): u64 {
    <b>if</b> (self.<a href="i64.md#0x1_i64_sign_internal">sign_internal</a>() == 0) self.bits
    <b>else</b> <a href="i64.md#0x1_i64_twos_complement">twos_complement</a>(self.bits)
}
</code></pre>



</details>

<a id="0x1_i64_min"></a>

## Function `min`

Returns the minimum of two I64 numbers


<pre><code><b>public</b> <b>fun</b> <b>min</b>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>, b: <a href="i64.md#0x1_i64_I64">i64::I64</a>): <a href="i64.md#0x1_i64_I64">i64::I64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <b>min</b>(self: <a href="i64.md#0x1_i64_I64">I64</a>, b: <a href="i64.md#0x1_i64_I64">I64</a>): <a href="i64.md#0x1_i64_I64">I64</a> {
    <b>if</b> (self.<a href="i64.md#0x1_i64_lt">lt</a>(b)) self <b>else</b> b
}
</code></pre>



</details>

<a id="0x1_i64_max"></a>

## Function `max`

Returns the maximum of two I64 numbers


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_max">max</a>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>, b: <a href="i64.md#0x1_i64_I64">i64::I64</a>): <a href="i64.md#0x1_i64_I64">i64::I64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_max">max</a>(self: <a href="i64.md#0x1_i64_I64">I64</a>, b: <a href="i64.md#0x1_i64_I64">I64</a>): <a href="i64.md#0x1_i64_I64">I64</a> {
    <b>if</b> (self.<a href="i64.md#0x1_i64_gt">gt</a>(b)) self <b>else</b> b
}
</code></pre>



</details>

<a id="0x1_i64_pow"></a>

## Function `pow`

Raises an I64 number to a u64 power


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_pow">pow</a>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>, exponent: u64): <a href="i64.md#0x1_i64_I64">i64::I64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_pow">pow</a>(self: <a href="i64.md#0x1_i64_I64">I64</a>, exponent: u64): <a href="i64.md#0x1_i64_I64">I64</a> {
    <b>if</b> (exponent == 0) {
        <b>return</b> <a href="i64.md#0x1_i64_from">from</a>(1)
    };
    <b>let</b> result = <a href="i64.md#0x1_i64_from">from</a>(1);
    <b>while</b> (exponent &gt; 0)  {
        <b>if</b> (exponent % 2 == 1) {
            result = result.<a href="i64.md#0x1_i64_mul">mul</a>(self);
        };
        self = self.<a href="i64.md#0x1_i64_mul">mul</a>(self);
        exponent /= 2;
    };
    result
}
</code></pre>



</details>

<a id="0x1_i64_pack"></a>

## Function `pack`

Creates an I64 from a u64 without any checks


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_pack">pack</a>(v: u64): <a href="i64.md#0x1_i64_I64">i64::I64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_pack">pack</a>(v: u64): <a href="i64.md#0x1_i64_I64">I64</a> {
    <a href="i64.md#0x1_i64_I64">I64</a> { bits: v }
}
</code></pre>



</details>

<a id="0x1_i64_unpack"></a>

## Function `unpack`

Destroys an I64 and returns its internal bits


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_unpack">unpack</a>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_unpack">unpack</a>(self: <a href="i64.md#0x1_i64_I64">I64</a>): u64 {
    self.bits
}
</code></pre>



</details>

<a id="0x1_i64_bits"></a>

## Function `bits`

Get internal bits of I64


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_bits">bits</a>(self: &<a href="i64.md#0x1_i64_I64">i64::I64</a>): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_bits">bits</a>(self: &<a href="i64.md#0x1_i64_I64">I64</a>): u64 {
    self.bits
}
</code></pre>



</details>

<a id="0x1_i64_sign"></a>

## Function `sign`

Returns the sign of an I64 number (0 for positive, 1 for negative)


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_sign">sign</a>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>): u8
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_sign">sign</a>(self: <a href="i64.md#0x1_i64_I64">I64</a>): u8 {
    self.<a href="i64.md#0x1_i64_sign_internal">sign_internal</a>()
}
</code></pre>



</details>

<a id="0x1_i64_zero"></a>

## Function `zero`

Creates and returns an I64 representing zero


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_zero">zero</a>(): <a href="i64.md#0x1_i64_I64">i64::I64</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_zero">zero</a>(): <a href="i64.md#0x1_i64_I64">I64</a> {
    <a href="i64.md#0x1_i64_I64">I64</a> { bits: 0 }
}
</code></pre>



</details>

<a id="0x1_i64_is_zero"></a>

## Function `is_zero`

Checks if an I64 number is zero


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_is_zero">is_zero</a>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_is_zero">is_zero</a>(self: <a href="i64.md#0x1_i64_I64">I64</a>): bool {
    self.bits == 0
}
</code></pre>



</details>

<a id="0x1_i64_is_neg"></a>

## Function `is_neg`

Checks if an I64 number is negative


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_is_neg">is_neg</a>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_is_neg">is_neg</a>(self: <a href="i64.md#0x1_i64_I64">I64</a>): bool {
    self.<a href="i64.md#0x1_i64_sign_internal">sign_internal</a>() == 1
}
</code></pre>



</details>

<a id="0x1_i64_cmp"></a>

## Function `cmp`

Compares two I64 numbers, returning LT, EQ, or GT


<pre><code><b>public</b> <b>fun</b> <a href="cmp.md#0x1_cmp">cmp</a>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>, num2: <a href="i64.md#0x1_i64_I64">i64::I64</a>): u8
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="cmp.md#0x1_cmp">cmp</a>(self: <a href="i64.md#0x1_i64_I64">I64</a>, num2: <a href="i64.md#0x1_i64_I64">I64</a>): u8 {
    <b>let</b> sign1 = self.<a href="i64.md#0x1_i64_sign_internal">sign_internal</a>();
    <b>let</b> sign2 = num2.<a href="i64.md#0x1_i64_sign_internal">sign_internal</a>();

    <b>if</b> (sign1 &gt; sign2) {
        <a href="i64.md#0x1_i64_LT">LT</a>
    } <b>else</b> <b>if</b> (sign1 &lt; sign2) {
        <a href="i64.md#0x1_i64_GT">GT</a>
    } <b>else</b> <b>if</b> (self.bits &gt; num2.bits) {
        <a href="i64.md#0x1_i64_GT">GT</a>
    } <b>else</b> <b>if</b> (self.<a href="i64.md#0x1_i64_bits">bits</a> &lt; num2.bits)  {
        <a href="i64.md#0x1_i64_LT">LT</a>
    } <b>else</b> {
        <a href="i64.md#0x1_i64_EQ">EQ</a>
    }
}
</code></pre>



</details>

<a id="0x1_i64_eq"></a>

## Function `eq`

Checks if two I64 numbers are equal


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_eq">eq</a>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>, num2: <a href="i64.md#0x1_i64_I64">i64::I64</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_eq">eq</a>(self: <a href="i64.md#0x1_i64_I64">I64</a>, num2: <a href="i64.md#0x1_i64_I64">I64</a>): bool {
    self.bits == num2.bits
}
</code></pre>



</details>

<a id="0x1_i64_neq"></a>

## Function `neq`

Checks if two I64 numbers are not equal


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_neq">neq</a>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>, num2: <a href="i64.md#0x1_i64_I64">i64::I64</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_neq">neq</a>(self: <a href="i64.md#0x1_i64_I64">I64</a>, num2: <a href="i64.md#0x1_i64_I64">I64</a>): bool {
    self.bits != num2.bits
}
</code></pre>



</details>

<a id="0x1_i64_gt"></a>

## Function `gt`

Checks if the first I64 number is greater than the second


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_gt">gt</a>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>, num2: <a href="i64.md#0x1_i64_I64">i64::I64</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_gt">gt</a>(self: <a href="i64.md#0x1_i64_I64">I64</a>, num2: <a href="i64.md#0x1_i64_I64">I64</a>): bool {
    self.<a href="cmp.md#0x1_cmp">cmp</a>(num2) == <a href="i64.md#0x1_i64_GT">GT</a>
}
</code></pre>



</details>

<a id="0x1_i64_gte"></a>

## Function `gte`

Checks if the first I64 number is greater than or equal to the second


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_gte">gte</a>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>, num2: <a href="i64.md#0x1_i64_I64">i64::I64</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_gte">gte</a>(self: <a href="i64.md#0x1_i64_I64">I64</a>, num2: <a href="i64.md#0x1_i64_I64">I64</a>): bool {
    self.<a href="cmp.md#0x1_cmp">cmp</a>(num2) &gt;= <a href="i64.md#0x1_i64_EQ">EQ</a>
}
</code></pre>



</details>

<a id="0x1_i64_lt"></a>

## Function `lt`

Checks if the first I64 number is less than the second


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_lt">lt</a>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>, num2: <a href="i64.md#0x1_i64_I64">i64::I64</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_lt">lt</a>(self: <a href="i64.md#0x1_i64_I64">I64</a>, num2: <a href="i64.md#0x1_i64_I64">I64</a>): bool {
    self.<a href="cmp.md#0x1_cmp">cmp</a>(num2) == <a href="i64.md#0x1_i64_LT">LT</a>
}
</code></pre>



</details>

<a id="0x1_i64_lte"></a>

## Function `lte`

Checks if the first I64 number is less than or equal to the second


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_lte">lte</a>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>, num2: <a href="i64.md#0x1_i64_I64">i64::I64</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i64.md#0x1_i64_lte">lte</a>(self: <a href="i64.md#0x1_i64_I64">I64</a>, num2: <a href="i64.md#0x1_i64_I64">I64</a>): bool {
    self.<a href="cmp.md#0x1_cmp">cmp</a>(num2) &lt;= <a href="i64.md#0x1_i64_EQ">EQ</a>
}
</code></pre>



</details>

<a id="0x1_i64_twos_complement"></a>

## Function `twos_complement`

Two's complement in order to dervie negative representation of bits
It is overflow-proof because we hardcode 2's complement of 0 to be 0
Which is fine for our specific use case


<pre><code><b>fun</b> <a href="i64.md#0x1_i64_twos_complement">twos_complement</a>(v: u64): u64
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>inline <b>fun</b> <a href="i64.md#0x1_i64_twos_complement">twos_complement</a>(v: u64): u64 {
    <b>if</b> (v == 0) 0 <b>else</b> <a href="i64.md#0x1_i64_MAX_U64">MAX_U64</a> - v + 1
}
</code></pre>



</details>

<a id="0x1_i64_sign_internal"></a>

## Function `sign_internal`

Returns the sign of an I64 number (0 for positive, 1 for negative)


<pre><code><b>fun</b> <a href="i64.md#0x1_i64_sign_internal">sign_internal</a>(self: <a href="i64.md#0x1_i64_I64">i64::I64</a>): u8
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>inline <b>fun</b> <a href="i64.md#0x1_i64_sign_internal">sign_internal</a>(self: <a href="i64.md#0x1_i64_I64">I64</a>): u8 {
    ((self.bits / <a href="i64.md#0x1_i64_BITS_MIN_I64">BITS_MIN_I64</a>) <b>as</b> u8)
}
</code></pre>



</details>


[move-book]: https://aptos.dev/move/book/SUMMARY
