
<a id="0x1_i128"></a>

# Module `0x1::i128`

Implements the <code><a href="i128.md#0x1_i128">i128</a></code> type. The type name <code><a href="i128.md#0x1_i128">i128</a></code> is a shortcut for the <code><b>struct</b> <a href="i128.md#0x1_i128_I128">I128</a></code> defined in this module. One can use <code>+</code>, <code>-</code>, <code>==</code>, etc. with <code><a href="i128.md#0x1_i128">i128</a></code>, which are mapped to Move functions in this module.


-  [Struct `I128`](#0x1_i128_I128)
-  [Constants](#@Constants_0)
-  [Function `from`](#0x1_i128_from)
-  [Function `neg_from`](#0x1_i128_neg_from)
-  [Function `neg`](#0x1_i128_neg)
-  [Function `wrapping_add`](#0x1_i128_wrapping_add)
-  [Function `add`](#0x1_i128_add)
-  [Function `wrapping_sub`](#0x1_i128_wrapping_sub)
-  [Function `sub`](#0x1_i128_sub)
-  [Function `mul`](#0x1_i128_mul)
-  [Function `div`](#0x1_i128_div)
-  [Function `mod`](#0x1_i128_mod)
-  [Function `abs`](#0x1_i128_abs)
-  [Function `abs_u128`](#0x1_i128_abs_u128)
-  [Function `min`](#0x1_i128_min)
-  [Function `max`](#0x1_i128_max)
-  [Function `pow`](#0x1_i128_pow)
-  [Function `pack`](#0x1_i128_pack)
-  [Function `unpack`](#0x1_i128_unpack)
-  [Function `bits`](#0x1_i128_bits)
-  [Function `sign`](#0x1_i128_sign)
-  [Function `zero`](#0x1_i128_zero)
-  [Function `is_zero`](#0x1_i128_is_zero)
-  [Function `is_neg`](#0x1_i128_is_neg)
-  [Function `cmp`](#0x1_i128_cmp)
-  [Function `eq`](#0x1_i128_eq)
-  [Function `neq`](#0x1_i128_neq)
-  [Function `gt`](#0x1_i128_gt)
-  [Function `gte`](#0x1_i128_gte)
-  [Function `lt`](#0x1_i128_lt)
-  [Function `lte`](#0x1_i128_lte)
-  [Function `twos_complement`](#0x1_i128_twos_complement)
-  [Function `sign_internal`](#0x1_i128_sign_internal)


<pre><code></code></pre>



<a id="0x1_i128_I128"></a>

## Struct `I128`

Implementation of the <code><a href="i128.md#0x1_i128">i128</a></code> primitive type. Do not use this type directly, instead use <code><a href="i128.md#0x1_i128">i128</a></code>.


<pre><code><b>struct</b> <a href="i128.md#0x1_i128_I128">I128</a> <b>has</b> <b>copy</b>, drop, store
</code></pre>



<details>
<summary>Fields</summary>


<dl>
<dt>
<code>bits: u128</code>
</dt>
<dd>

</dd>
</dl>


</details>

<a id="@Constants_0"></a>

## Constants


<a id="0x1_i128_MAX_U128"></a>

(1 << 128) - 1


<pre><code><b>const</b> <a href="i128.md#0x1_i128_MAX_U128">MAX_U128</a>: u128 = 340282366920938463463374607431768211455;
</code></pre>



<a id="0x1_i128_EDIVISION_BY_ZERO"></a>

Division by Zero is not allowed


<pre><code><b>const</b> <a href="i128.md#0x1_i128_EDIVISION_BY_ZERO">EDIVISION_BY_ZERO</a>: u64 = 2;
</code></pre>



<a id="0x1_i128_BITS_MAX_I128"></a>

max number that a I128 could represent = (0 followed by 127 1s) = (1 << 127) - 1


<pre><code><b>const</b> <a href="i128.md#0x1_i128_BITS_MAX_I128">BITS_MAX_I128</a>: u128 = 170141183460469231731687303715884105727;
</code></pre>



<a id="0x1_i128_BITS_MIN_I128"></a>

min number that a I128 could represent = (1 followed by 127 0s) = 1 << 127


<pre><code><b>const</b> <a href="i128.md#0x1_i128_BITS_MIN_I128">BITS_MIN_I128</a>: u128 = 170141183460469231731687303715884105728;
</code></pre>



<a id="0x1_i128_EOVERFLOW"></a>

Arithmetic operation resulted in overflow (value outside the range [-2^127, 2^127 - 1])


<pre><code><b>const</b> <a href="i128.md#0x1_i128_EOVERFLOW">EOVERFLOW</a>: u64 = 1;
</code></pre>



<a id="0x1_i128_EQ"></a>



<pre><code><b>const</b> <a href="i128.md#0x1_i128_EQ">EQ</a>: u8 = 1;
</code></pre>



<a id="0x1_i128_GT"></a>



<pre><code><b>const</b> <a href="i128.md#0x1_i128_GT">GT</a>: u8 = 2;
</code></pre>



<a id="0x1_i128_LT"></a>



<pre><code><b>const</b> <a href="i128.md#0x1_i128_LT">LT</a>: u8 = 0;
</code></pre>



<a id="0x1_i128_TWO_POW_128"></a>

1 << 128


<pre><code><b>const</b> <a href="i128.md#0x1_i128_TWO_POW_128">TWO_POW_128</a>: u256 = 340282366920938463463374607431768211456;
</code></pre>



<a id="0x1_i128_from"></a>

## Function `from`

Creates an I128 from a u128, asserting that it's not greater than the maximum positive value


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_from">from</a>(v: u128): <a href="i128.md#0x1_i128_I128">i128::I128</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_from">from</a>(v: u128): <a href="i128.md#0x1_i128_I128">I128</a> {
    <b>assert</b>!(v &lt;= <a href="i128.md#0x1_i128_BITS_MAX_I128">BITS_MAX_I128</a>, <a href="i128.md#0x1_i128_EOVERFLOW">EOVERFLOW</a>);
    <a href="i128.md#0x1_i128_I128">I128</a> { bits: v }
}
</code></pre>



</details>

<a id="0x1_i128_neg_from"></a>

## Function `neg_from`

Creates a negative I128 from a u128, asserting that it's not greater than the minimum negative value


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_neg_from">neg_from</a>(v: u128): <a href="i128.md#0x1_i128_I128">i128::I128</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_neg_from">neg_from</a>(v: u128): <a href="i128.md#0x1_i128_I128">I128</a> {
    <b>assert</b>!(v &lt;= <a href="i128.md#0x1_i128_BITS_MIN_I128">BITS_MIN_I128</a>, <a href="i128.md#0x1_i128_EOVERFLOW">EOVERFLOW</a>);
    <a href="i128.md#0x1_i128_I128">I128</a> { bits: <a href="i128.md#0x1_i128_twos_complement">twos_complement</a>(v) }
}
</code></pre>



</details>

<a id="0x1_i128_neg"></a>

## Function `neg`



<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_neg">neg</a>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>): <a href="i128.md#0x1_i128_I128">i128::I128</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_neg">neg</a>(self: <a href="i128.md#0x1_i128_I128">I128</a>): <a href="i128.md#0x1_i128_I128">I128</a> {
    <b>if</b> (self.<a href="i128.md#0x1_i128_is_neg">is_neg</a>()) { self.<a href="i128.md#0x1_i128_abs">abs</a>() }
    <b>else</b> {
        <a href="i128.md#0x1_i128_neg_from">neg_from</a>(self.bits)
    }
}
</code></pre>



</details>

<a id="0x1_i128_wrapping_add"></a>

## Function `wrapping_add`

Performs wrapping addition on two I128 numbers


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_wrapping_add">wrapping_add</a>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>, num2: <a href="i128.md#0x1_i128_I128">i128::I128</a>): <a href="i128.md#0x1_i128_I128">i128::I128</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_wrapping_add">wrapping_add</a>(self: <a href="i128.md#0x1_i128_I128">I128</a>, num2: <a href="i128.md#0x1_i128_I128">I128</a>): <a href="i128.md#0x1_i128_I128">I128</a> {
    <a href="i128.md#0x1_i128_I128">I128</a> { bits: (((self.bits <b>as</b> u256) + (num2.bits <b>as</b> u256)) % <a href="i128.md#0x1_i128_TWO_POW_128">TWO_POW_128</a> <b>as</b> u128) }
}
</code></pre>



</details>

<a id="0x1_i128_add"></a>

## Function `add`

Performs checked addition on two I128 numbers, abort on overflow


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_add">add</a>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>, num2: <a href="i128.md#0x1_i128_I128">i128::I128</a>): <a href="i128.md#0x1_i128_I128">i128::I128</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_add">add</a>(self: <a href="i128.md#0x1_i128_I128">I128</a>, num2: <a href="i128.md#0x1_i128_I128">I128</a>): <a href="i128.md#0x1_i128_I128">I128</a> {
    <b>let</b> sum = self.<a href="i128.md#0x1_i128_wrapping_add">wrapping_add</a>(num2);
    // overflow only <b>if</b>: (1) postive + postive = negative, OR (2) negative + negative = positive
    <b>let</b> self_sign = self.<a href="i128.md#0x1_i128_sign_internal">sign_internal</a>();
    <b>let</b> overflow = self_sign == num2.<a href="i128.md#0x1_i128_sign">sign</a>() && self_sign != sum.<a href="i128.md#0x1_i128_sign">sign</a>();
    <b>assert</b>!(!overflow, <a href="i128.md#0x1_i128_EOVERFLOW">EOVERFLOW</a>);
    sum
}
</code></pre>



</details>

<a id="0x1_i128_wrapping_sub"></a>

## Function `wrapping_sub`

Performs wrapping subtraction on two I128 numbers


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_wrapping_sub">wrapping_sub</a>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>, num2: <a href="i128.md#0x1_i128_I128">i128::I128</a>): <a href="i128.md#0x1_i128_I128">i128::I128</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_wrapping_sub">wrapping_sub</a>(self: <a href="i128.md#0x1_i128_I128">I128</a>, num2: <a href="i128.md#0x1_i128_I128">I128</a>): <a href="i128.md#0x1_i128_I128">I128</a> {
    self.<a href="i128.md#0x1_i128_wrapping_add">wrapping_add</a>(<a href="i128.md#0x1_i128_I128">I128</a> { bits: <a href="i128.md#0x1_i128_twos_complement">twos_complement</a>(num2.bits) })
}
</code></pre>



</details>

<a id="0x1_i128_sub"></a>

## Function `sub`

Performs checked subtraction on two I128 numbers, asserting on overflow


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_sub">sub</a>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>, num2: <a href="i128.md#0x1_i128_I128">i128::I128</a>): <a href="i128.md#0x1_i128_I128">i128::I128</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_sub">sub</a>(self: <a href="i128.md#0x1_i128_I128">I128</a>, num2: <a href="i128.md#0x1_i128_I128">I128</a>): <a href="i128.md#0x1_i128_I128">I128</a> {
    <b>let</b> difference = self.<a href="i128.md#0x1_i128_wrapping_sub">wrapping_sub</a>(num2);
    // overflow only <b>if</b>: (1) positive - negative = negative, OR (2) negative - positive = positive
    <b>let</b> self_sign = self.<a href="i128.md#0x1_i128_sign_internal">sign_internal</a>();
    <b>let</b> overflow = self_sign != num2.<a href="i128.md#0x1_i128_sign_internal">sign_internal</a>() && self_sign != difference.<a href="i128.md#0x1_i128_sign_internal">sign_internal</a>();
    <b>assert</b>!(!overflow, <a href="i128.md#0x1_i128_EOVERFLOW">EOVERFLOW</a>);
    difference
}
</code></pre>



</details>

<a id="0x1_i128_mul"></a>

## Function `mul`

Performs multiplication on two I128 numbers


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_mul">mul</a>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>, num2: <a href="i128.md#0x1_i128_I128">i128::I128</a>): <a href="i128.md#0x1_i128_I128">i128::I128</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_mul">mul</a>(self: <a href="i128.md#0x1_i128_I128">I128</a>, num2: <a href="i128.md#0x1_i128_I128">I128</a>): <a href="i128.md#0x1_i128_I128">I128</a> {
    <b>let</b> product = (self.<a href="i128.md#0x1_i128_abs_u128">abs_u128</a>() <b>as</b> u256) * (num2.<a href="i128.md#0x1_i128_abs_u128">abs_u128</a>() <b>as</b> u256);
    <b>if</b> (self.<a href="i128.md#0x1_i128_sign_internal">sign_internal</a>() != num2.<a href="i128.md#0x1_i128_sign_internal">sign_internal</a>()) {
        <b>assert</b>!(product &lt;= (<a href="i128.md#0x1_i128_BITS_MIN_I128">BITS_MIN_I128</a> <b>as</b> u256), <a href="i128.md#0x1_i128_EOVERFLOW">EOVERFLOW</a>);
        <a href="i128.md#0x1_i128_neg_from">neg_from</a>((product <b>as</b> u128))
    } <b>else</b> {
        <b>assert</b>!(product &lt;= (<a href="i128.md#0x1_i128_BITS_MAX_I128">BITS_MAX_I128</a> <b>as</b> u256), <a href="i128.md#0x1_i128_EOVERFLOW">EOVERFLOW</a>);
        <a href="i128.md#0x1_i128_from">from</a>((product <b>as</b> u128))
    }
}
</code></pre>



</details>

<a id="0x1_i128_div"></a>

## Function `div`

Performs division on two I128 numbers
Note that we mimic the behavior of solidity int division that it rounds towards 0 rather than rounds down
- rounds towards 0: (-4) / 3 = -(4 / 3) = -1 (remainder = -1)
- rounds down: (-4) / 3 = -2 (remainder = 2)


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_div">div</a>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>, num2: <a href="i128.md#0x1_i128_I128">i128::I128</a>): <a href="i128.md#0x1_i128_I128">i128::I128</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_div">div</a>(self: <a href="i128.md#0x1_i128_I128">I128</a>, num2: <a href="i128.md#0x1_i128_I128">I128</a>): <a href="i128.md#0x1_i128_I128">I128</a> {
    <b>assert</b>!(!num2.<a href="i128.md#0x1_i128_is_zero">is_zero</a>(), <a href="i128.md#0x1_i128_EDIVISION_BY_ZERO">EDIVISION_BY_ZERO</a>);
    <b>let</b> result = self.<a href="i128.md#0x1_i128_abs_u128">abs_u128</a>() / num2.<a href="i128.md#0x1_i128_abs_u128">abs_u128</a>();
    <b>if</b> (self.<a href="i128.md#0x1_i128_sign_internal">sign_internal</a>() != num2.<a href="i128.md#0x1_i128_sign_internal">sign_internal</a>()) <a href="i128.md#0x1_i128_neg_from">neg_from</a>(result)
    <b>else</b> <a href="i128.md#0x1_i128_from">from</a>(result)
}
</code></pre>



</details>

<a id="0x1_i128_mod"></a>

## Function `mod`

Performs modulo on two I128 numbers
a mod b = a - b * (a / b)


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_mod">mod</a>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>, num2: <a href="i128.md#0x1_i128_I128">i128::I128</a>): <a href="i128.md#0x1_i128_I128">i128::I128</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_mod">mod</a>(self: <a href="i128.md#0x1_i128_I128">I128</a>, num2: <a href="i128.md#0x1_i128_I128">I128</a>): <a href="i128.md#0x1_i128_I128">I128</a> {
    <b>let</b> quotient = self.<a href="i128.md#0x1_i128_div">div</a>(num2);
    self.<a href="i128.md#0x1_i128_sub">sub</a>(num2.<a href="i128.md#0x1_i128_mul">mul</a>(quotient))
}
</code></pre>



</details>

<a id="0x1_i128_abs"></a>

## Function `abs`

Returns the absolute value of an I128 number


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_abs">abs</a>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>): <a href="i128.md#0x1_i128_I128">i128::I128</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_abs">abs</a>(self: <a href="i128.md#0x1_i128_I128">I128</a>): <a href="i128.md#0x1_i128_I128">I128</a> {
    <b>let</b> bits = <b>if</b> (self.<a href="i128.md#0x1_i128_sign_internal">sign_internal</a>() == 0) { self.bits }
    <b>else</b> {
        <b>assert</b>!(self.bits &gt; <a href="i128.md#0x1_i128_BITS_MIN_I128">BITS_MIN_I128</a>, <a href="i128.md#0x1_i128_EOVERFLOW">EOVERFLOW</a>);
        <a href="i128.md#0x1_i128_twos_complement">twos_complement</a>(self.bits)
    };
    <a href="i128.md#0x1_i128_I128">I128</a> { bits }
}
</code></pre>



</details>

<a id="0x1_i128_abs_u128"></a>

## Function `abs_u128`

Returns the absolute value of an I128 number as a u128


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_abs_u128">abs_u128</a>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_abs_u128">abs_u128</a>(self: <a href="i128.md#0x1_i128_I128">I128</a>): u128 {
    <b>if</b> (self.<a href="i128.md#0x1_i128_sign_internal">sign_internal</a>() == 0) self.bits
    <b>else</b> <a href="i128.md#0x1_i128_twos_complement">twos_complement</a>(self.bits)
}
</code></pre>



</details>

<a id="0x1_i128_min"></a>

## Function `min`

Returns the minimum of two I128 numbers


<pre><code><b>public</b> <b>fun</b> <b>min</b>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>, b: <a href="i128.md#0x1_i128_I128">i128::I128</a>): <a href="i128.md#0x1_i128_I128">i128::I128</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <b>min</b>(self: <a href="i128.md#0x1_i128_I128">I128</a>, b: <a href="i128.md#0x1_i128_I128">I128</a>): <a href="i128.md#0x1_i128_I128">I128</a> {
    <b>if</b> (self.<a href="i128.md#0x1_i128_lt">lt</a>(b)) self <b>else</b> b
}
</code></pre>



</details>

<a id="0x1_i128_max"></a>

## Function `max`

Returns the maximum of two I128 numbers


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_max">max</a>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>, b: <a href="i128.md#0x1_i128_I128">i128::I128</a>): <a href="i128.md#0x1_i128_I128">i128::I128</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_max">max</a>(self: <a href="i128.md#0x1_i128_I128">I128</a>, b: <a href="i128.md#0x1_i128_I128">I128</a>): <a href="i128.md#0x1_i128_I128">I128</a> {
    <b>if</b> (self.<a href="i128.md#0x1_i128_gt">gt</a>(b)) self <b>else</b> b
}
</code></pre>



</details>

<a id="0x1_i128_pow"></a>

## Function `pow`

Raises an I128 number to a u64 power


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_pow">pow</a>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>, exponent: u64): <a href="i128.md#0x1_i128_I128">i128::I128</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_pow">pow</a>(self: <a href="i128.md#0x1_i128_I128">I128</a>, exponent: u64): <a href="i128.md#0x1_i128_I128">I128</a> {
    <b>if</b> (exponent == 0) {
        <b>return</b> <a href="i128.md#0x1_i128_from">from</a>(1)
    };
    <b>let</b> result = <a href="i128.md#0x1_i128_from">from</a>(1);
    <b>while</b> (exponent &gt; 0) {
        <b>if</b> (exponent % 2 == 1) {
            result = result.<a href="i128.md#0x1_i128_mul">mul</a>(self);
        };
        self = self.<a href="i128.md#0x1_i128_mul">mul</a>(self);
        exponent /= 2;
    };
    result
}
</code></pre>



</details>

<a id="0x1_i128_pack"></a>

## Function `pack`

Creates an I128 from a u128 without any checks


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_pack">pack</a>(v: u128): <a href="i128.md#0x1_i128_I128">i128::I128</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_pack">pack</a>(v: u128): <a href="i128.md#0x1_i128_I128">I128</a> {
    <a href="i128.md#0x1_i128_I128">I128</a> { bits: v }
}
</code></pre>



</details>

<a id="0x1_i128_unpack"></a>

## Function `unpack`

Destroys an I128 and returns its internal bits


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_unpack">unpack</a>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_unpack">unpack</a>(self: <a href="i128.md#0x1_i128_I128">I128</a>): u128 {
    self.bits
}
</code></pre>



</details>

<a id="0x1_i128_bits"></a>

## Function `bits`

Get internal bits of I128


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_bits">bits</a>(self: &<a href="i128.md#0x1_i128_I128">i128::I128</a>): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_bits">bits</a>(self: &<a href="i128.md#0x1_i128_I128">I128</a>): u128 {
    self.bits
}
</code></pre>



</details>

<a id="0x1_i128_sign"></a>

## Function `sign`

Returns the sign of an I128 number (0 for positive, 1 for negative)


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_sign">sign</a>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>): u8
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_sign">sign</a>(self: <a href="i128.md#0x1_i128_I128">I128</a>): u8 {
    self.<a href="i128.md#0x1_i128_sign_internal">sign_internal</a>()
}
</code></pre>



</details>

<a id="0x1_i128_zero"></a>

## Function `zero`

Creates and returns an I128 representing zero


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_zero">zero</a>(): <a href="i128.md#0x1_i128_I128">i128::I128</a>
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_zero">zero</a>(): <a href="i128.md#0x1_i128_I128">I128</a> {
    <a href="i128.md#0x1_i128_I128">I128</a> { bits: 0 }
}
</code></pre>



</details>

<a id="0x1_i128_is_zero"></a>

## Function `is_zero`

Checks if an I128 number is zero


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_is_zero">is_zero</a>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_is_zero">is_zero</a>(self: <a href="i128.md#0x1_i128_I128">I128</a>): bool {
    self.bits == 0
}
</code></pre>



</details>

<a id="0x1_i128_is_neg"></a>

## Function `is_neg`

Checks if an I128 number is negative


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_is_neg">is_neg</a>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_is_neg">is_neg</a>(self: <a href="i128.md#0x1_i128_I128">I128</a>): bool {
    self.<a href="i128.md#0x1_i128_sign_internal">sign_internal</a>() == 1
}
</code></pre>



</details>

<a id="0x1_i128_cmp"></a>

## Function `cmp`

Compares two I128 numbers, returning LT, EQ, or GT


<pre><code><b>public</b> <b>fun</b> <a href="cmp.md#0x1_cmp">cmp</a>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>, num2: <a href="i128.md#0x1_i128_I128">i128::I128</a>): u8
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="cmp.md#0x1_cmp">cmp</a>(self: <a href="i128.md#0x1_i128_I128">I128</a>, num2: <a href="i128.md#0x1_i128_I128">I128</a>): u8 {
    <b>let</b> sign1 = self.<a href="i128.md#0x1_i128_sign_internal">sign_internal</a>();
    <b>let</b> sign2 = num2.<a href="i128.md#0x1_i128_sign_internal">sign_internal</a>();

    <b>if</b> (sign1 &gt; sign2) {
        <a href="i128.md#0x1_i128_LT">LT</a>
    } <b>else</b> <b>if</b> (sign1 &lt; sign2) {
        <a href="i128.md#0x1_i128_GT">GT</a>
    } <b>else</b> <b>if</b> (self.bits &gt; num2.bits) {
        <a href="i128.md#0x1_i128_GT">GT</a>
    } <b>else</b> <b>if</b> (self.<a href="i128.md#0x1_i128_bits">bits</a> &lt; num2.bits) {
        <a href="i128.md#0x1_i128_LT">LT</a>
    } <b>else</b> {
        <a href="i128.md#0x1_i128_EQ">EQ</a>
    }
}
</code></pre>



</details>

<a id="0x1_i128_eq"></a>

## Function `eq`

Checks if two I128 numbers are equal


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_eq">eq</a>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>, num2: <a href="i128.md#0x1_i128_I128">i128::I128</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_eq">eq</a>(self: <a href="i128.md#0x1_i128_I128">I128</a>, num2: <a href="i128.md#0x1_i128_I128">I128</a>): bool {
    self.bits == num2.bits
}
</code></pre>



</details>

<a id="0x1_i128_neq"></a>

## Function `neq`

Checks if two I128 numbers are not equal


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_neq">neq</a>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>, num2: <a href="i128.md#0x1_i128_I128">i128::I128</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_neq">neq</a>(self: <a href="i128.md#0x1_i128_I128">I128</a>, num2: <a href="i128.md#0x1_i128_I128">I128</a>): bool {
    self.bits != num2.bits
}
</code></pre>



</details>

<a id="0x1_i128_gt"></a>

## Function `gt`

Checks if the first I128 number is greater than the second


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_gt">gt</a>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>, num2: <a href="i128.md#0x1_i128_I128">i128::I128</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_gt">gt</a>(self: <a href="i128.md#0x1_i128_I128">I128</a>, num2: <a href="i128.md#0x1_i128_I128">I128</a>): bool {
    self.<a href="cmp.md#0x1_cmp">cmp</a>(num2) == <a href="i128.md#0x1_i128_GT">GT</a>
}
</code></pre>



</details>

<a id="0x1_i128_gte"></a>

## Function `gte`

Checks if the first I128 number is greater than or equal to the second


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_gte">gte</a>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>, num2: <a href="i128.md#0x1_i128_I128">i128::I128</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_gte">gte</a>(self: <a href="i128.md#0x1_i128_I128">I128</a>, num2: <a href="i128.md#0x1_i128_I128">I128</a>): bool {
    self.<a href="cmp.md#0x1_cmp">cmp</a>(num2) &gt;= <a href="i128.md#0x1_i128_EQ">EQ</a>
}
</code></pre>



</details>

<a id="0x1_i128_lt"></a>

## Function `lt`

Checks if the first I128 number is less than the second


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_lt">lt</a>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>, num2: <a href="i128.md#0x1_i128_I128">i128::I128</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_lt">lt</a>(self: <a href="i128.md#0x1_i128_I128">I128</a>, num2: <a href="i128.md#0x1_i128_I128">I128</a>): bool {
    self.<a href="cmp.md#0x1_cmp">cmp</a>(num2) == <a href="i128.md#0x1_i128_LT">LT</a>
}
</code></pre>



</details>

<a id="0x1_i128_lte"></a>

## Function `lte`

Checks if the first I128 number is less than or equal to the second


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_lte">lte</a>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>, num2: <a href="i128.md#0x1_i128_I128">i128::I128</a>): bool
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code><b>public</b> <b>fun</b> <a href="i128.md#0x1_i128_lte">lte</a>(self: <a href="i128.md#0x1_i128_I128">I128</a>, num2: <a href="i128.md#0x1_i128_I128">I128</a>): bool {
    self.<a href="cmp.md#0x1_cmp">cmp</a>(num2) &lt;= <a href="i128.md#0x1_i128_EQ">EQ</a>
}
</code></pre>



</details>

<a id="0x1_i128_twos_complement"></a>

## Function `twos_complement`

Two's complement in order to dervie negative representation of bits
It is overflow-proof because we hardcode 2's complement of 0 to be 0
Which is fine for our specific use case


<pre><code><b>fun</b> <a href="i128.md#0x1_i128_twos_complement">twos_complement</a>(v: u128): u128
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>inline <b>fun</b> <a href="i128.md#0x1_i128_twos_complement">twos_complement</a>(v: u128): u128 {
    <b>if</b> (v == 0) 0 <b>else</b> <a href="i128.md#0x1_i128_MAX_U128">MAX_U128</a> - v + 1
}
</code></pre>



</details>

<a id="0x1_i128_sign_internal"></a>

## Function `sign_internal`

Returns the sign of an I128 number (0 for positive, 1 for negative)


<pre><code><b>fun</b> <a href="i128.md#0x1_i128_sign_internal">sign_internal</a>(self: <a href="i128.md#0x1_i128_I128">i128::I128</a>): u8
</code></pre>



<details>
<summary>Implementation</summary>


<pre><code>inline <b>fun</b> <a href="i128.md#0x1_i128_sign_internal">sign_internal</a>(self: <a href="i128.md#0x1_i128_I128">I128</a>): u8 {
    ((self.bits / <a href="i128.md#0x1_i128_BITS_MIN_I128">BITS_MIN_I128</a>) <b>as</b> u8)
}
</code></pre>



</details>


[move-book]: https://aptos.dev/move/book/SUMMARY
