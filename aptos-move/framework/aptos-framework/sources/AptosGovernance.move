/**
 * AptosGovernance represents the on-chain governance of the Aptos network. Voting power is calculated based on the
 * current epoch's voting power of the proposer or voter's backing stake pool. In addition, for it to count,
 * the stake pool's lockup needs to be at least as long as the proposal's duration.
 *
 * It provides the following flow:
 * 1. Proposers can create a proposal by calling AptosGovernance::create_proposal. The proposer's backing stake pool
 * needs to have the minimum proposer stake required. Off-chain components can subscribe to CreateProposalEvent to
 * track proposal creation and proposal ids.
 * 2. Voters can vote on a proposal. Their voting power is derived from the backing stake pool. Each stake pool can
 * only be used to vote on each proposal exactly once.
 *
 */
module AptosFramework::AptosGovernance {
    use Std::Errors;
    use Std::Event::{Self, EventHandle};
    use Std::Option;
    use Std::Signer;

    use AptosFramework::Coin;
    use AptosFramework::GovernanceProposal::{Self, GovernanceProposal};
    use AptosFramework::Stake;
    use AptosFramework::SystemAddresses;
    use AptosFramework::Table::{Self, Table};
    use AptosFramework::TestCoin::TestCoin;
    use AptosFramework::Timestamp;
    use AptosFramework::Voting;

    /// Error codes.
    const EINSUFFICIENT_PROPOSER_STAKE: u64 = 1;
    const ENOT_DELEGATED_VOTER: u64 = 2;
    const EINSUFFICIENT_STAKE_LOCKUP: u64 = 3;
    const EALREADY_VOTED: u64 = 4;

    /// Configurations of the AptosGovernance, set during Genesis and can be updated by the same process offered
    /// by this AptosGovernance module.
    struct GovernanceConfig has key {
        min_voting_threshold: u128,
        required_proposer_stake: u64,
        voting_period_secs: u64,
    }

    struct RecordKey has copy, drop, store {
        stake_pool: address,
        proposal_id: u64,
    }

    /// Records to track the proposals each stake pool has been used to vote on.
    struct VotingRecords has key {
        votes: Table<RecordKey, bool>
    }

    /// Events generated by interactions with the AptosGovernance module.
    struct GovernanceEvents has key {
        create_proposal_events: EventHandle<CreateProposalEvent>,
        update_config_events: EventHandle<UpdateConfigEvent>,
        vote_events: EventHandle<VoteEvent>,
    }

    /// Event emitted when a proposal is created.
    struct CreateProposalEvent has drop, store {
        proposer: address,
        stake_pool: address,
        proposal_id: u64,
        execution_hash: vector<u8>,
    }

    /// Event emitted when there's a vote on a proposa;
    struct VoteEvent has drop, store {
        proposal_id: u64,
        voter: address,
        stake_pool: address,
        num_votes: u64,
        should_pass: bool,
    }

    /// Event emitted when the governance configs are updated.
    struct UpdateConfigEvent has drop, store {
        min_voting_threshold: u128,
        required_proposer_stake: u64,
        voting_period_secs: u64,
    }

    /// Initializes the state for Aptos Governance. Can only be called during Genesis with a signer
    /// for the CoreFramework (0x1) account.
    public fun initialize(
        core_framework: &signer,
        min_voting_threshold: u128,
        required_proposer_stake: u64,
        voting_period_secs: u64,
    ) {
        SystemAddresses::assert_core_framework(core_framework);

        Voting::register<GovernanceProposal>(core_framework);
        move_to(core_framework, GovernanceConfig {
            voting_period_secs,
            min_voting_threshold,
            required_proposer_stake,
        });
        move_to(core_framework, GovernanceEvents {
            create_proposal_events: Event::new_event_handle<CreateProposalEvent>(core_framework),
            update_config_events: Event::new_event_handle<UpdateConfigEvent>(core_framework),
            vote_events: Event::new_event_handle<VoteEvent>(core_framework),
        });
        move_to(core_framework, VotingRecords {
            votes: Table::new(),
        });
    }

    /// Update the governance configurations. This can only be called as part of resolving a proposal in this same
    /// AptosGovernance.
    public fun update_governance_config(
        _proposal: GovernanceProposal,
        min_voting_threshold: u128,
        required_proposer_stake: u64,
        voting_period_secs: u64,
    ) acquires GovernanceConfig, GovernanceEvents {
        let governance_config = borrow_global_mut<GovernanceConfig>(@AptosFramework);
        governance_config.voting_period_secs = voting_period_secs;
        governance_config.min_voting_threshold = min_voting_threshold;
        governance_config.required_proposer_stake = required_proposer_stake;

        let events = borrow_global_mut<GovernanceEvents>(@AptosFramework);
        Event::emit_event<UpdateConfigEvent>(
            &mut events.update_config_events,
            UpdateConfigEvent {
                min_voting_threshold,
                required_proposer_stake,
                voting_period_secs
            },
        );
    }

    /// Create a proposal with the backing `stake_pool`.
    /// @param execution_hash Required. This is the hash of the resolution script. When the proposal is resolved,
    /// only the exact script with matching hash can be successfully executed.
    public(script) fun create_proposal(
        proposer: &signer,
        stake_pool: address,
        execution_hash: vector<u8>,
    ) acquires GovernanceConfig, GovernanceEvents {
        let proposer_address = Signer::address_of(proposer);
        assert!(Stake::is_delegated_voter(stake_pool, proposer_address), Errors::invalid_argument(ENOT_DELEGATED_VOTER));

        // The proposer's stake needs to be at least the required bond amount.
        let governance_config = borrow_global<GovernanceConfig>(@AptosFramework);
        let stake_balance = Stake::get_active_staked_balance(stake_pool);
        assert!(
            stake_balance >= governance_config.required_proposer_stake,
            Errors::invalid_argument(EINSUFFICIENT_PROPOSER_STAKE),
        );

        // The proposer's stake needs to be locked up at least as long as the proposal's voting period.
        let current_time = Timestamp::now_seconds();
        let proposal_expiration = current_time + governance_config.voting_period_secs;
        assert!(
            Stake::get_lockup_secs(stake_pool) >= proposal_expiration,
            Errors::invalid_argument(EINSUFFICIENT_STAKE_LOCKUP),
        );

        // We want to allow early resolution of proposals if more than 50% of the total supply of the network coins
        // has voted. This doesn't take into subsequent inflation/deflation (rewards are issued every epoch and gas fees
        // are burnt after every transaction), but inflation/delation is very unlikely to have a major impact on total
        // supply during the voting period.
        let total_voting_token_supply = Coin::supply<TestCoin>();
        let early_resolution_vote_threshold = Option::none<u128>();
        if (Option::is_some(&total_voting_token_supply)) {
            let total_supply = *Option::borrow(&total_voting_token_supply);
            // 50% + 1 to avoid rounding errors.
            early_resolution_vote_threshold = Option::some(total_supply / 2 + 1);
        };

        let proposal_id = Voting::create_proposal(
            @AptosFramework,
            GovernanceProposal::create_proposal(),
            Option::some(execution_hash),
            governance_config.min_voting_threshold,
            proposal_expiration,
            early_resolution_vote_threshold,
        );

        let events = borrow_global_mut<GovernanceEvents>(@AptosFramework);
        Event::emit_event<CreateProposalEvent>(
            &mut events.create_proposal_events,
            CreateProposalEvent {
                proposal_id,
                proposer: proposer_address,
                stake_pool,
                execution_hash,
            },
        );
    }

    /// Vote on proposal with `proposal_id` and voting power from `stake_pool`.
    public(script) fun vote(
        voter: &signer,
        stake_pool: address,
        proposal_id: u64,
        should_pass: bool,
    ) acquires GovernanceEvents, VotingRecords {
        let voter_address = Signer::address_of(voter);
        assert!(Stake::is_delegated_voter(stake_pool, voter_address), Errors::invalid_argument(ENOT_DELEGATED_VOTER));

        // The voter's stake needs to be locked up at least as long as the proposal's expiration.
        let proposal_expiration = Voting::get_proposal_expiration_secs<GovernanceProposal>(@AptosFramework, proposal_id);
        assert!(
            Stake::get_lockup_secs(stake_pool) >= proposal_expiration,
            Errors::invalid_argument(EINSUFFICIENT_STAKE_LOCKUP),
        );

        // Ensure the voter doesn't double vote.
        let voting_records = borrow_global_mut<VotingRecords>(@AptosFramework);
        let record_key = RecordKey {
            stake_pool,
            proposal_id,
        };
        assert!(
            !Table::contains(&voting_records.votes, record_key),
            Errors::invalid_argument(EALREADY_VOTED));
        Table::add(&mut voting_records.votes, record_key, true);

        // Voting power does not include pending_active or pending_inactive balances.
        // In general, the stake pool should not have pending_inactive balance if it still has lockup (requried to vote)
        // And if pending_active will be added to active in the next epoch.
        let voting_power = Stake::get_active_staked_balance(stake_pool);
        Voting::vote<GovernanceProposal>(
            &GovernanceProposal::create_proposal(),
            @AptosFramework,
            proposal_id,
            voting_power,
            should_pass,
        );

        let events = borrow_global_mut<GovernanceEvents>(@AptosFramework);
        Event::emit_event<VoteEvent>(
            &mut events.vote_events,
            VoteEvent {
                proposal_id,
                voter: voter_address,
                stake_pool,
                num_votes: voting_power,
                should_pass,
            },
        );
    }

    #[test(core_resources = @CoreResources, core_framework = @AptosFramework, proposer = @0x123, yes_voter = @0x234, no_voter = @345)]
    public(script) fun test_voting(
        core_resources: signer,
        core_framework: signer,
        proposer: signer,
        yes_voter: signer,
        no_voter: signer,
    ) acquires GovernanceConfig, GovernanceEvents, VotingRecords {
        setup_voting(
            &core_resources,
            &core_framework,
            &proposer,
            &yes_voter,
            &no_voter,
        );

        create_proposal(&proposer, Signer::address_of(&proposer), b"");
        vote(&yes_voter, Signer::address_of(&yes_voter), 0, true);
        vote(&no_voter, Signer::address_of(&no_voter), 0, false);

        // Once expiration time has passed, the proposal should be considered resolve now as there are more yes votes
        // than no.
        Timestamp::update_global_time_for_test(100001000000);
        let proposal_state = Voting::get_proposal_state<GovernanceProposal>(Signer::address_of(&core_framework), 0);
        assert!(proposal_state == 1, proposal_state);
    }

    #[test(core_resources = @CoreResources, core_framework = @AptosFramework, proposer = @0x123, voter_1 = @0x234, voter_2 = @345)]
    #[expected_failure(abort_code = 1031)]
    public(script) fun test_cannot_double_vote(
        core_resources: signer,
        core_framework: signer,
        proposer: signer,
        voter_1: signer,
        voter_2: signer,
    ) acquires GovernanceConfig, GovernanceEvents, VotingRecords {
        setup_voting(
            &core_resources,
            &core_framework,
            &proposer,
            &voter_1,
            &voter_2,
        );

        create_proposal(&proposer, Signer::address_of(&proposer), b"");

        // Double voting should throw an error.
        vote(&voter_1, Signer::address_of(&voter_1), 0, true);
        vote(&voter_1, Signer::address_of(&voter_1), 0, true);
    }

    #[test(core_resources = @CoreResources, core_framework = @AptosFramework, proposer = @0x123, voter_1 = @0x234, voter_2 = @345)]
    #[expected_failure(abort_code = 1031)]
    public(script) fun test_cannot_double_vote_with_different_voter_addresses(
        core_resources: signer,
        core_framework: signer,
        proposer: signer,
        voter_1: signer,
        voter_2: signer,
    ) acquires GovernanceConfig, GovernanceEvents, VotingRecords {
        setup_voting(
            &core_resources,
            &core_framework,
            &proposer,
            &voter_1,
            &voter_2,
        );

        create_proposal(&proposer, Signer::address_of(&proposer), b"");

        // Double voting should throw an error for 2 different voters if they still use the same stake pool.
        vote(&voter_1, Signer::address_of(&voter_1), 0, true);
        Stake::set_delegated_voter(&voter_1, Signer::address_of(&voter_2));
        vote(&voter_2, Signer::address_of(&voter_1), 0, true);
    }

    #[test_only]
    fun setup_voting(
        core_resources: &signer,
        core_framework: &signer,
        proposer: &signer,
        yes_voter: &signer,
        no_voter: &signer,
    ) {
        use Std::Vector;

        use AptosFramework::Coin;
        use AptosFramework::TestCoin::{Self, TestCoin};

        Timestamp::set_time_has_started_for_testing(core_resources);

        // Initialize the governance.
        initialize(core_framework, 10, 100, 1000);

        // Initialize the stake pools for proposer and voters.
        let active_validators = Vector::empty<address>();
        Vector::push_back(&mut active_validators, Signer::address_of(proposer));
        Vector::push_back(&mut active_validators, Signer::address_of(yes_voter));
        Vector::push_back(&mut active_validators, Signer::address_of(no_voter));
        Stake::create_validator_set(core_resources, active_validators);

        let (mint_cap, burn_cap) = TestCoin::initialize(core_framework, core_resources);
        let proposer_stake = Coin::mint(100, &mint_cap);
        let yes_voter_stake = Coin::mint(20, &mint_cap);
        let no_voter_stake = Coin::mint(10, &mint_cap);
        Stake::create_stake_pool(proposer, proposer_stake, 10000);
        Stake::create_stake_pool(yes_voter, yes_voter_stake, 10000);
        Stake::create_stake_pool(no_voter, no_voter_stake, 10000);
        Coin::destroy_mint_cap<TestCoin>(mint_cap);
        Coin::destroy_burn_cap<TestCoin>(burn_cap);
    }
}
